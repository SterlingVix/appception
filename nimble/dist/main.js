eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global require, define, window, brackets, navigator */\r\n\r\n/**\r\n * The boostrapping module for brackets. This module sets up the require \r\n * configuration and loads the brackets module.\r\n */\r\nrequire.config({\r\n    paths: {\r\n        "text"              : "thirdparty/text/text",\r\n        "i18n"              : "thirdparty/i18n/i18n",\r\n        \r\n        // The file system implementation. Change this value to use different \r\n        // implementations (e.g. cloud-based storage).\r\n        "fileSystemImpl"    : "filesystem/impls/makedrive/MakeDriveFileSystem"\r\n    }\r\n});\r\n\r\nif (window.location.search.indexOf("testEnvironment") > -1) {\r\n    require.config({\r\n        paths: {\r\n            "preferences/PreferencesImpl": "../test/TestPreferencesImpl"\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * hack for r.js optimization, move locale to another config call\r\n *\r\n * Use custom brackets property until CEF sets the correct navigator.language\r\n * NOTE: When we change to navigator.language here, we also should change to\r\n * navigator.language in ExtensionLoader (when making require contexts for each\r\n * extension).\r\n */\r\nrequire.config({\r\n    locale: window.localStorage.getItem("locale") || (typeof (brackets) !== "undefined" ? brackets.app.language : navigator.language)\r\n});\r\n\r\ndefine(\'main\',[\'require\'],function (require) {\r\n    "use strict";\r\n\r\n    // Load compatibility shims--these need to load early, be careful moving this\r\n    require(["utils/Compatibility"], function () {\r\n        // Load the brackets module. This is a self-running module that loads and runs the entire application.\r\n        require(["brackets"]);\r\n    });\r\n});\r\n\n//# sourceURL=/main.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\n/**\r\n * Compatibility shims for running Brackets in various environments, browsers.\r\n */\r\ndefine(\'utils/Compatibility\',[],function () {\r\n    "use strict";\r\n\r\n    // [IE10] String.prototype missing trimRight() and trimLeft()\r\n    if (!String.prototype.trimRight) {\r\n        String.prototype.trimRight = function () { return this.replace(/\\s+$/, ""); };\r\n    }\r\n    if (!String.prototype.trimLeft) {\r\n        String.prototype.trimLeft = function () { return this.replace(/^\\s+/, ""); };\r\n    }\r\n\r\n});\r\n\n//# sourceURL=/utils/Compatibility.js'),eval("/* ============================================================\r\n * bootstrap-dropdown.js v2.3.1\r\n * http://twitter.github.com/bootstrap/javascript.html#dropdowns\r\n * ============================================================\r\n * Copyright 2012 Twitter, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ============================================================ */\r\n\r\n\r\n!function ($) {\r\n\r\n  \"use strict\"; // jshint ;_;\r\n\r\n\r\n /* DROPDOWN CLASS DEFINITION\r\n  * ========================= */\r\n\r\n  var toggle = '[data-toggle=dropdown]'\r\n    , Dropdown = function (element) {\r\n        var $el = $(element).on('click.dropdown.data-api', this.toggle)\r\n        $('html').on('click.dropdown.data-api', function () {\r\n          $el.parent().removeClass('open')\r\n        })\r\n      }\r\n\r\n  Dropdown.prototype = {\r\n\r\n    constructor: Dropdown\r\n\r\n  , toggle: function (e) {\r\n      var $this = $(this)\r\n        , $parent\r\n        , isActive\r\n\r\n      if ($this.is('.disabled, :disabled')) return\r\n\r\n      $parent = getParent($this)\r\n\r\n      isActive = $parent.hasClass('open')\r\n\r\n      clearMenus()\r\n\r\n      if (!isActive) {\r\n        $parent.toggleClass('open')\r\n      }\r\n\r\n      $this.focus()\r\n\r\n      return false\r\n    }\r\n\r\n  , keydown: function (e) {\r\n      var $this\r\n        , $items\r\n        , $active\r\n        , $parent\r\n        , isActive\r\n        , index\r\n\r\n      if (!/(38|40|27)/.test(e.keyCode)) return\r\n\r\n      $this = $(this)\r\n\r\n      e.preventDefault()\r\n      e.stopPropagation()\r\n\r\n      if ($this.is('.disabled, :disabled')) return\r\n\r\n      $parent = getParent($this)\r\n\r\n      isActive = $parent.hasClass('open')\r\n\r\n      if (!isActive || (isActive && e.keyCode == 27)) {\r\n        if (e.which == 27) $parent.find(toggle).focus()\r\n        return $this.click()\r\n      }\r\n\r\n      $items = $('[role=menu] li:not(.divider):visible a', $parent)\r\n\r\n      if (!$items.length) return\r\n\r\n      index = $items.index($items.filter(':focus'))\r\n\r\n      if (e.keyCode == 38 && index > 0) index--                                        // up\r\n      if (e.keyCode == 40 && index < $items.length - 1) index++                        // down\r\n      if (!~index) index = 0\r\n\r\n      $items\r\n        .eq(index)\r\n        .focus()\r\n    }\r\n\r\n  }\r\n\r\n  function clearMenus() {\r\n    $(toggle).each(function () {\r\n      getParent($(this)).removeClass('open')\r\n    })\r\n  }\r\n\r\n  function getParent($this) {\r\n    var selector = $this.attr('data-target')\r\n      , $parent\r\n\r\n    if (!selector) {\r\n      selector = $this.attr('href')\r\n      selector = selector && /#/.test(selector) && selector.replace(/.*(?=#[^\\s]*$)/, '') //strip for ie7\r\n    }\r\n\r\n    $parent = selector && $(selector)\r\n\r\n    if (!$parent || !$parent.length) $parent = $this.parent()\r\n\r\n    return $parent\r\n  }\r\n\r\n\r\n  /* DROPDOWN PLUGIN DEFINITION\r\n   * ========================== */\r\n\r\n  var old = $.fn.dropdown\r\n\r\n  $.fn.dropdown = function (option) {\r\n    return this.each(function () {\r\n      var $this = $(this)\r\n        , data = $this.data('dropdown')\r\n      if (!data) $this.data('dropdown', (data = new Dropdown(this)))\r\n      if (typeof option == 'string') data[option].call($this)\r\n    })\r\n  }\r\n\r\n  $.fn.dropdown.Constructor = Dropdown\r\n\r\n\r\n /* DROPDOWN NO CONFLICT\r\n  * ==================== */\r\n\r\n  $.fn.dropdown.noConflict = function () {\r\n    $.fn.dropdown = old\r\n    return this\r\n  }\r\n\r\n\r\n  /* APPLY TO STANDARD DROPDOWN ELEMENTS\r\n   * =================================== */\r\n\r\n  $(document)\r\n    .on('click.dropdown.data-api', clearMenus)\r\n    .on('click.dropdown.data-api', '.dropdown form', function (e) { e.stopPropagation() })\r\n    .on('click.dropdown-menu', function (e) { e.stopPropagation() })\r\n    .on('click.dropdown.data-api'  , toggle, Dropdown.prototype.toggle)\r\n    .on('keydown.dropdown.data-api', toggle + ', [role=menu]' , Dropdown.prototype.keydown)\r\n\r\n}(window.jQuery);\r\n\n//# sourceURL=/widgets/bootstrap-dropdown.js"),define("widgets/bootstrap-dropdown",function(){}),eval("/* =========================================================\r\n * bootstrap-modal.js v2.3.1\r\n * http://twitter.github.com/bootstrap/javascript.html#modals\r\n * =========================================================\r\n * Copyright 2012 Twitter, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ========================================================= */\r\n\r\n\r\n!function ($) {\r\n\r\n  \"use strict\"; // jshint ;_;\r\n\r\n\r\n /* MODAL CLASS DEFINITION\r\n  * ====================== */\r\n\r\n  var Modal = function (element, options) {\r\n    this.options = options\r\n    this.$element = $(element)\r\n      .delegate('[data-dismiss=\"modal\"]', 'click.dismiss.modal', $.proxy(this.hide, this))\r\n    this.options.remote && this.$element.find('.modal-body').load(this.options.remote)\r\n  }\r\n\r\n  Modal.prototype = {\r\n\r\n      constructor: Modal\r\n\r\n    , toggle: function () {\r\n        return this[!this.isShown ? 'show' : 'hide']()\r\n      }\r\n\r\n    , show: function () {\r\n        var that = this\r\n          , e = $.Event('show')\r\n\r\n        this.$element.trigger(e)\r\n\r\n        if (this.isShown || e.isDefaultPrevented()) return\r\n\r\n        this.isShown = true\r\n\r\n        this.escape()\r\n\r\n        this.backdrop(function () {\r\n          var transition = $.support.transition && that.$element.hasClass('fade')\r\n\r\n          if (!that.$element.parent().length) {\r\n            that.$element.appendTo(this.options.selector) //don't move modals dom position\r\n          }\r\n\r\n          that.$element.show()\r\n\r\n          if (transition) {\r\n            that.$element[0].offsetWidth // force reflow\r\n          }\r\n\r\n          that.$element\r\n            .addClass('in')\r\n            .attr('aria-hidden', false)\r\n\r\n          that.enforceFocus()\r\n\r\n          transition ?\r\n            that.$element.one($.support.transition.end, function () { that.$element.focus().trigger('shown') }) :\r\n            that.$element.focus().trigger('shown')\r\n\r\n        })\r\n      }\r\n\r\n    , hide: function (e) {\r\n        e && e.preventDefault()\r\n\r\n        var that = this\r\n\r\n        e = $.Event('hide')\r\n\r\n        this.$element.trigger(e)\r\n\r\n        if (!this.isShown || e.isDefaultPrevented()) return\r\n\r\n        this.isShown = false\r\n\r\n        this.escape()\r\n\r\n        $(document).off('focusin.modal')\r\n\r\n        this.$element\r\n          .removeClass('in')\r\n          .attr('aria-hidden', true)\r\n\r\n        $.support.transition && this.$element.hasClass('fade') ?\r\n          this.hideWithTransition() :\r\n          this.hideModal()\r\n      }\r\n\r\n    , enforceFocus: function () {\r\n        var that = this\r\n        $(document).on('focusin.modal', function (e) {\r\n          if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {\r\n            that.$element.focus()\r\n          }\r\n        })\r\n      }\r\n\r\n    , escape: function () {\r\n        var that = this\r\n        if (this.isShown && this.options.keyboard) {\r\n          this.$element.on('keyup.dismiss.modal', function ( e ) {\r\n            e.which == 27 && that.hide()\r\n          })\r\n        } else if (!this.isShown) {\r\n          this.$element.off('keyup.dismiss.modal')\r\n        }\r\n      }\r\n\r\n    , hideWithTransition: function () {\r\n        var that = this\r\n          , timeout = setTimeout(function () {\r\n              that.$element.off($.support.transition.end)\r\n              that.hideModal()\r\n            }, 500)\r\n\r\n        this.$element.one($.support.transition.end, function () {\r\n          clearTimeout(timeout)\r\n          that.hideModal()\r\n        })\r\n      }\r\n\r\n    , hideModal: function () {\r\n        var that = this\r\n        this.$element.hide()\r\n        this.backdrop(function () {\r\n          that.removeBackdrop()\r\n          that.$element.trigger('hidden')\r\n        })\r\n      }\r\n\r\n    , removeBackdrop: function () {\r\n        this.$backdrop && this.$backdrop.remove()\r\n        this.$backdrop = null\r\n      }\r\n\r\n    , backdrop: function (callback) {\r\n        var that = this\r\n          , animate = this.$element.hasClass('fade') ? 'fade' : ''\r\n\r\n        if (this.isShown && this.options.backdrop) {\r\n          var doAnimate = $.support.transition && animate\r\n\r\n          this.$backdrop = $('<div class=\"modal-backdrop ' + animate + '\" />')\r\n            .appendTo(this.options.selector)\r\n\r\n          this.$backdrop.click(\r\n            this.options.backdrop == 'static' ?\r\n              $.proxy(this.$element[0].focus, this.$element[0])\r\n            : $.proxy(this.hide, this)\r\n          )\r\n\r\n          if (doAnimate) this.$backdrop[0].offsetWidth // force reflow\r\n\r\n          this.$backdrop.addClass('in')\r\n\r\n          if (!callback) return\r\n\r\n          doAnimate ?\r\n            this.$backdrop.one($.support.transition.end, callback) :\r\n            callback()\r\n\r\n        } else if (!this.isShown && this.$backdrop) {\r\n          this.$backdrop.removeClass('in')\r\n\r\n          $.support.transition && this.$element.hasClass('fade')?\r\n            this.$backdrop.one($.support.transition.end, callback) :\r\n            callback()\r\n\r\n        } else if (callback) {\r\n          callback()\r\n        }\r\n      }\r\n  }\r\n\r\n\r\n /* MODAL PLUGIN DEFINITION\r\n  * ======================= */\r\n\r\n  var old = $.fn.modal\r\n\r\n  $.fn.modal = function (option) {\r\n    return this.each(function () {\r\n      var $this = $(this)\r\n        , data = $this.data('modal')\r\n        , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)\r\n      if (!data) $this.data('modal', (data = new Modal(this, options)))\r\n      if (typeof option == 'string') data[option]()\r\n      else if (options.show) data.show()\r\n    })\r\n  }\r\n\r\n  $.fn.modal.defaults = {\r\n      backdrop: true\r\n    , keyboard: true\r\n    , show: true\r\n    , selector: \"body\"\r\n  }\r\n\r\n  $.fn.modal.Constructor = Modal\r\n\r\n\r\n /* MODAL NO CONFLICT\r\n  * ================= */\r\n\r\n  $.fn.modal.noConflict = function () {\r\n    $.fn.modal = old\r\n    return this\r\n  }\r\n\r\n\r\n /* MODAL DATA-API\r\n  * ============== */\r\n\r\n  $(document).on('click.modal.data-api', '[data-toggle=\"modal\"]', function (e) {\r\n    var $this = $(this)\r\n      , href = $this.attr('href')\r\n      , $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\\s]+$)/, ''))) //strip for ie7\r\n      , option = $target.data('modal') ? 'toggle' : $.extend({ remote:!/#/.test(href) && href }, $target.data(), $this.data())\r\n\r\n    e.preventDefault()\r\n\r\n    $target\r\n      .modal(option)\r\n      .one('hide', function () {\r\n        $this.focus()\r\n      })\r\n  })\r\n\r\n}(window.jQuery);\r\n\n//# sourceURL=/widgets/bootstrap-modal.js"),define("widgets/bootstrap-modal",function(){}),eval("/* ==========================================================\r\n * bootstrap-twipsy.js v1.4.0\r\n * http://twitter.github.com/bootstrap/javascript.html#twipsy\r\n * Adapted from the original jQuery.tipsy by Jason Frame\r\n * Adjusted for Brackets\r\n * ==========================================================\r\n * Copyright 2011 Twitter, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ========================================================== */\r\n\r\n\r\n!function( $ ) {\r\n\r\n  \"use strict\"\r\n\r\n  /***** [changed for Brackets] *****/\r\n  // Undefined until the focus state changed once\r\n  var _windowHasFocus;\r\n\r\n  $(window)\r\n    .focus(function _onWindowGainedFocus() {\r\n      _windowHasFocus = true;\r\n    })\r\n    .blur(function _onWindowLostFocus() {\r\n      _windowHasFocus = false;\r\n    });\r\n  /***** [/changed for Brackets] *****/\r\n\r\n /* CSS TRANSITION SUPPORT (https://gist.github.com/373874)\r\n  * ======================================================= */\r\n\r\n  var transitionEnd\r\n\r\n  $(document).ready(function () {\r\n\r\n    $.support.transition = (function () {\r\n\r\n      var transitionEnd = (function () {\r\n\r\n        var el = document.createElement('bootstrap')\r\n          , transEndEventNames = {\r\n               'WebkitTransition' : 'webkitTransitionEnd'\r\n            ,  'MozTransition'    : 'transitionend'\r\n            ,  'OTransition'      : 'oTransitionEnd'\r\n            ,  'msTransition'     : 'MSTransitionEnd'\r\n            ,  'transition'       : 'transitionend'\r\n            }\r\n          , name\r\n\r\n        for (name in transEndEventNames){\r\n          if (el.style[name] !== undefined) {\r\n            return transEndEventNames[name]\r\n          }\r\n        }\r\n\r\n      }())\r\n\r\n      return transitionEnd && {\r\n        end: transitionEnd\r\n      }\r\n\r\n    })()\r\n\r\n    // set CSS transition event type\r\n    if ( $.support.transition ) {\r\n      transitionEnd = $.support.transition.end\r\n    }\r\n\r\n  })\r\n\r\n\r\n /* TWIPSY PUBLIC CLASS DEFINITION\r\n  * ============================== */\r\n\r\n  var Twipsy = function ( element, options ) {\r\n    this.$element = $(element)\r\n    this.options = options\r\n    this.enabled = true\r\n    /***** [changed for Brackets] *****/\r\n    this.autoHideTimeout = null;\r\n    /***** [/changed for Brackets] *****/\r\n    this.fixTitle()\r\n  }\r\n\r\n  Twipsy.prototype = {\r\n\r\n    show: function() {\r\n      /***** [changed for Brackets: moved some variables to updatePosition()] *****/\r\n      var $tip\r\n        , that = this;\r\n      /***** [/changed for Brackets] *****/\r\n\r\n      if (this.hasContent() && this.enabled) {\r\n        $tip = this.tip()\r\n        this.setContent()\r\n\r\n        if (this.options.animate) {\r\n          $tip.addClass('fade')\r\n        }\r\n\r\n        $tip\r\n          .remove()\r\n          .css({ top: 0, left: 0, display: 'block' })\r\n          .prependTo(document.body)\r\n\r\n/***** [changed for Brackets] *****/\r\n        this.updatePosition();\r\n\r\n        $(window).off(\"resize\", this.resizeHandler);\r\n        this.resizeHandler = function(e) {\r\n          that.updatePosition();\r\n        };\r\n        $(window).on(\"resize\", this.resizeHandler);\r\n\r\n        if (this.options.autoHideDelay) {\r\n          var startAutoHide = function () {\r\n            window.clearTimeout(that.autoHideTimeout);\r\n            that.autoHideTimeout = window.setTimeout(function () {\r\n              that.hide();\r\n            }, that.options.autoHideDelay);\r\n          }\r\n          if (_windowHasFocus) {\r\n            startAutoHide();\r\n          } else {\r\n            $(window).one(\"focus\", startAutoHide);\r\n          }\r\n        }\r\n\r\n        $tip.addClass('in');\r\n      }\r\n    }\r\n\r\n  , updatePosition: function () {\r\n      var pos\r\n        , actualWidth\r\n        , actualHeight\r\n        , paddingLeft\r\n        , paddingRight\r\n        , surplusRight\r\n        , shiftArrow\r\n        , placement\r\n        , $tip\r\n        , $arrow\r\n        , tp\r\n        , that = this\r\n\r\n      $tip = this.tip()\r\n\r\n      pos = $.extend({}, this.$element.offset(), {\r\n        width: this.$element[0].offsetWidth\r\n      , height: this.$element[0].offsetHeight\r\n      })\r\n\r\n      paddingLeft  = parseInt(this.$element.css(\"padding-left\"),  10);\r\n      paddingRight = parseInt(this.$element.css(\"padding-right\"), 10);\r\n\r\n      pos.left += paddingLeft;\r\n      pos.width -= (paddingLeft + paddingRight);\r\n\r\n      actualWidth = $tip[0].offsetWidth\r\n      actualHeight = $tip[0].offsetHeight\r\n\r\n      placement = maybeCall(this.options.placement, this, [ $tip[0], this.$element[0] ])\r\n      // Add the placement class so the arrow's margin can be determined\r\n      $tip.addClass(placement)\r\n\r\n      switch (placement) {\r\n        case 'below':\r\n          tp = {top: pos.top + pos.height + this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2}\r\n          break\r\n        case 'above':\r\n          tp = {top: pos.top - actualHeight - this.options.offset, left: pos.left + pos.width / 2 - actualWidth / 2}\r\n          break\r\n        case 'left':\r\n          /***** [changed for Brackets] *****/\r\n          tp = {top: pos.top + pos.height + 20 - actualHeight, left: pos.left - actualWidth - this.options.offset}\r\n          break\r\n        case 'right':\r\n          /***** [changed for Brackets] *****/\r\n          tp = {top: pos.top + pos.height + 20 - actualHeight, left: pos.left + pos.width + this.options.offset}\r\n          break\r\n      }\r\n\r\n      shiftArrow = 0;\r\n\r\n      surplusRight = (tp.left + actualWidth - $(document.body).width());\r\n      if (surplusRight > 0) {\r\n        shiftArrow = surplusRight;\r\n        tp.left -= surplusRight;\r\n      } else if (tp.left < 0) {\r\n        shiftArrow = tp.left;\r\n        tp.left = 0;\r\n      }\r\n\r\n      if (surplusRight > 0) {\r\n        $arrow = $tip.find(\".tooltip-arrow\");\r\n        if (! this.defaultMargin) {\r\n          this.defaultMargin = parseInt($arrow.css(\"margin-left\"), 10);\r\n        }\r\n        $arrow.css(\"margin-left\", this.defaultMargin + shiftArrow);\r\n      }\r\n\r\n      $tip.css(tp);\r\n    }\r\n/***** [/changed for Brackets] *****/\r\n\r\n  , setContent: function () {\r\n      var $tip = this.tip()\r\n      $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](this.getTitle())\r\n      $tip[0].className = 'tooltip'\r\n    }\r\n\r\n  , hide: function() {\r\n      var that = this\r\n        , $tip = this.tip()\r\n\r\n      $tip.removeClass('in')\r\n\r\n      function removeElement () {\r\n        $tip.remove()\r\n      }\r\n\r\n      $.support.transition && this.$tip.hasClass('fade') ?\r\n        $tip.bind(transitionEnd, removeElement) :\r\n        removeElement()\r\n\r\n      /***** [changed for Brackets] *****/\r\n      window.clearTimeout(this.autoHideTimeout);\r\n      $(window).off(\"resize\", this.resizeHandler)\r\n      /***** [/changed for Brackets] *****/\r\n    }\r\n\r\n  , fixTitle: function() {\r\n      var $e = this.$element\r\n      if ($e.attr('title') || typeof($e.attr('data-original-title')) != 'string') {\r\n        $e.attr('data-original-title', $e.attr('title') || '').removeAttr('title')\r\n      }\r\n    }\r\n\r\n  , hasContent: function () {\r\n      return this.getTitle()\r\n    }\r\n\r\n  , getTitle: function() {\r\n      var title\r\n        , $e = this.$element\r\n        , o = this.options\r\n\r\n        this.fixTitle()\r\n\r\n        if (typeof o.title == 'string') {\r\n          title = $e.attr(o.title == 'title' ? 'data-original-title' : o.title)\r\n        } else if (typeof o.title == 'function') {\r\n          title = o.title.call($e[0])\r\n        }\r\n\r\n        title = ('' + title).replace(/(^\\s*|\\s*$)/, \"\")\r\n\r\n        return title || o.fallback\r\n    }\r\n\r\n  , tip: function() {\r\n      return this.$tip = this.$tip || $('<div class=\"tooltip\" />').html(this.options.template)\r\n    }\r\n\r\n  , validate: function() {\r\n      if (!this.$element[0].parentNode) {\r\n        this.hide()\r\n        this.$element = null\r\n        this.options = null\r\n      }\r\n    }\r\n\r\n  , enable: function() {\r\n      this.enabled = true\r\n    }\r\n\r\n  , disable: function() {\r\n      this.enabled = false\r\n    }\r\n\r\n  , toggleEnabled: function() {\r\n      this.enabled = !this.enabled\r\n    }\r\n\r\n  , toggle: function () {\r\n      this[this.tip().hasClass('in') ? 'hide' : 'show']()\r\n    }\r\n\r\n  }\r\n\r\n\r\n /* TWIPSY PRIVATE METHODS\r\n  * ====================== */\r\n\r\n   function maybeCall ( thing, ctx, args ) {\r\n     return typeof thing == 'function' ? thing.apply(ctx, args) : thing\r\n   }\r\n\r\n /* TWIPSY PLUGIN DEFINITION\r\n  * ======================== */\r\n\r\n  $.fn.twipsy = function (options) {\r\n    $.fn.twipsy.initWith.call(this, options, Twipsy, 'twipsy')\r\n    return this\r\n  }\r\n\r\n  $.fn.twipsy.initWith = function (options, Constructor, name) {\r\n    var twipsy\r\n      , binder\r\n      , eventIn\r\n      , eventOut\r\n\r\n    if (options === true) {\r\n      return this.data(name)\r\n    } else if (typeof options == 'string') {\r\n      twipsy = this.data(name)\r\n      if (twipsy) {\r\n        twipsy[options]()\r\n      }\r\n      return this\r\n    }\r\n\r\n    options = $.extend({}, $.fn[name].defaults, options)\r\n\r\n    function get(ele) {\r\n      var twipsy = $.data(ele, name)\r\n\r\n      if (!twipsy) {\r\n        twipsy = new Constructor(ele, $.fn.twipsy.elementOptions(ele, options))\r\n        $.data(ele, name, twipsy)\r\n      }\r\n\r\n      return twipsy\r\n    }\r\n\r\n    function enter() {\r\n      var twipsy = get(this)\r\n      twipsy.hoverState = 'in'\r\n\r\n      if (options.delayIn == 0) {\r\n        twipsy.show()\r\n      } else {\r\n        twipsy.fixTitle()\r\n        setTimeout(function() {\r\n          if (twipsy.hoverState == 'in') {\r\n            twipsy.show()\r\n          }\r\n        }, options.delayIn)\r\n      }\r\n    }\r\n\r\n    function leave() {\r\n      var twipsy = get(this)\r\n      twipsy.hoverState = 'out'\r\n      if (options.delayOut == 0) {\r\n        twipsy.hide()\r\n      } else {\r\n        setTimeout(function() {\r\n          if (twipsy.hoverState == 'out') {\r\n            twipsy.hide()\r\n          }\r\n        }, options.delayOut)\r\n      }\r\n    }\r\n\r\n    if (!options.live) {\r\n      this.each(function() {\r\n        get(this)\r\n      })\r\n    }\r\n\r\n    if (options.trigger != 'manual') {\r\n      binder   = options.live ? 'live' : 'bind'\r\n      eventIn  = options.trigger == 'hover' ? 'mouseenter' : 'focus'\r\n      eventOut = options.trigger == 'hover' ? 'mouseleave' : 'blur'\r\n      this[binder](eventIn, enter)[binder](eventOut, leave)\r\n    }\r\n\r\n    return this\r\n  }\r\n\r\n  $.fn.twipsy.Twipsy = Twipsy\r\n\r\n  $.fn.twipsy.defaults = {\r\n    animate: true\r\n  , delayIn: 0\r\n  , delayOut: 0\r\n  , fallback: ''\r\n  , placement: 'above'\r\n  , html: false\r\n  , live: false\r\n  , offset: 0\r\n  , title: 'title'\r\n  , trigger: 'hover'\r\n  , template: '<div class=\"tooltip-arrow\"></div><div class=\"tooltip-inner\"></div>'\r\n  }\r\n\r\n  $.fn.twipsy.rejectAttrOptions = [ 'title' ]\r\n\r\n  $.fn.twipsy.elementOptions = function(ele, options) {\r\n    var data = $(ele).data()\r\n      , rejects = $.fn.twipsy.rejectAttrOptions\r\n      , i = rejects.length\r\n\r\n    while (i--) {\r\n      delete data[rejects[i]]\r\n    }\r\n\r\n    return $.extend({}, options, data)\r\n  }\r\n\r\n}( window.jQuery || window.ender );\r\n\n//# sourceURL=/widgets/bootstrap-twipsy-mod.js"),define("widgets/bootstrap-twipsy-mod",function(){}),eval('// path-utils.js - version 0.1\r\n// Copyright (c) 2011, Kin Blas\r\n// All rights reserved.\r\n// \r\n// Redistribution and use in source and binary forms, with or without\r\n// modification, are permitted provided that the following conditions are met:\r\n//     * Redistributions of source code must retain the above copyright\r\n//       notice, this list of conditions and the following disclaimer.\r\n//     * Redistributions in binary form must reproduce the above copyright\r\n//       notice, this list of conditions and the following disclaimer in the\r\n//       documentation and/or other materials provided with the distribution.\r\n//     * Neither the name of the <organization> nor the\r\n//       names of its contributors may be used to endorse or promote products\r\n//       derived from this software without specific prior written permission.\r\n// \r\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND\r\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n\r\n(function(l){function m(a){return function(e){return b.parseUrl(e)[a]}}var b={urlParseRE:/^(((([^:\\/#\\?]+:)?(?:(\\/\\/)((?:(([^:@\\/#\\?]+)(?:\\:([^:@\\/#\\?]+))?)@)?(([^:\\/#\\?\\]\\[]+|\\[[^\\/\\]@#?]+\\])(?:\\:([0-9]+))?))?)?)?((\\/?(?:[^\\/\\?#]+\\/+)*)([^\\?#\\.]*(?:\\.[^\\?#\\.]+)*(\\.[^\\?#\\.]+)|[^\\?#]*)))?(\\?[^#]+)?)(#.*)?/,parsedUrlPropNames:"href,hrefNoHash,hrefNoSearch,domain,protocol,doubleSlash,authority,userinfo,username,password,host,hostname,port,pathname,directory,filename,filenameExtension,search,hash".split(","),\r\ndefaultPorts:{http:"80",https:"443",ftp:"20",ftps:"990"},parseUrl:function(a){if(a&&typeof a==="object")return a;var a=b.urlParseRE.exec(a||"")||[],e=b.parsedUrlPropNames,c=e.length,f={},d;for(d=0;d<c;d++)f[e[d]]=a[d]||"";return f},port:function(a){a=b.parseUrl(a);return a.port||b.defaultPorts[a.protocol]},isSameDomain:function(a,e){return b.parseUrl(a).domain===b.parseUrl(e).domain},isRelativeUrl:function(a){return b.parseUrl(a).protocol===""},isAbsoluteUrl:function(a){return b.parseUrl(a).protocol!==\r\n""},makePathAbsolute:function(a,e){if(a&&a.charAt(0)==="/")return a;for(var a=a||"",c=(e=e?e.replace(/^\\/|(\\/[^\\/]*|[^\\/]+)$/g,""):"")?e.split("/"):[],b=a.split("/"),d=0;d<b.length;d++){var j=b[d];switch(j){case ".":break;case "..":c.length&&c.pop();break;default:c.push(j)}}return"/"+c.join("/")},makePathRelative:function(a,b){for(var b=b?b.replace(/^\\/|\\/?[^\\/]*$/g,""):"",a=a?a.replace(/^\\//,""):"",c=b?b.split("/"):[],f=a.split("/"),d=[],j=c.length,g=false,i=0;i<j;i++)(g=g||f[0]!==c[i])?d.push(".."):\r\nf.shift();return d.concat(f).join("/")},makeUrlAbsolute:function(a,e){if(!b.isRelativeUrl(a))return a;var c=b.parseUrl(a),f=b.parseUrl(e),d=c.protocol||f.protocol,g=c.protocol?c.doubleSlash:c.doubleSlash||f.doubleSlash,h=c.authority||f.authority,i=c.pathname!=="",k=b.makePathAbsolute(c.pathname||f.filename,f.pathname);return d+g+h+k+(c.search||!i&&f.search||"")+c.hash}},g,h,k=b.parsedUrlPropNames,n=k.length;for(g=0;g<n;g++)h=k[g],b[h]||(b[h]=m(h));l.PathUtils=b})(window);\r\n\n//# sourceURL=/thirdparty/path-utils/path-utils.min.js'),define("thirdparty/path-utils/path-utils.min",function(){}),eval('/**\r\n * Smart Auto Complete plugin \r\n * \r\n * Copyright (c) 2011 Lakshan Perera (laktek.com)\r\n * Licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)  licenses.\r\n * \r\n*/\r\n\r\n/*\r\n Requirements: jQuery 1.5 or above\r\n\r\n  Usage:\r\n  $(target).smartAutoComplete({options})\r\n\r\n  Options:\r\n  minCharLimit: (integer) minimum characters user have to type before invoking the autocomplete (default: 1)\r\n  maxCharLimit: (integer) maximum characters user can type while invoking the autocomplete (default: null (unlimited))\r\n  maxResults: (integer) maximum number of results to return (default: null (unlimited))\r\n  delay: (integer) delay before autocomplete starts (default: 0)\r\n  disabled: (boolean) whether autocomplete disabled on the field (default: false)\r\n  forceSelect: (boolean) If set to true, field will be always filled with best matching result, without leaving the custom input.\r\n               Better to enable this option, if you want autocomplete field to behave similar to a HTML select field. (Check Example 2 in the demo)\r\n               (default: false)\r\n  typeAhead: (boolean) If set to true, it will offer the best matching result in grey within the field; that can be auto-completed by pressing the right arrow-key or enter.\r\n             This is similar to behaviour in Google Instant Search\'s query field (Check Example 3 in the demo) \r\n             (default: false)\r\n  source:  (string/array) you can supply an array with items or a string containing a URL to fetch items for the source\r\n           this is optional if you prefer to have your own filter method \r\n  filter: (function) define a custom function that would return matching items to the entered text (this will override the default filtering algorithm)\r\n          should return an array or a Deferred object (ajax call)\r\n          parameters available: term, source \r\n  resultFormatter: (function) the function you supply here will be called to format the output of an individual result.\r\n                   should return a string\r\n                   parameters available: result \r\n  resultsContainer: (selector) to which element(s) the result should be appended.\r\n  resultElement: (selector) references to the result elements collection (e.g. li, div.result) \r\n\r\n  Events:\r\n  keyIn: fires when user types into the field (parameters: query)\r\n  resultsReady: fires when the filter function returns (parameters: results)\r\n  showResults: fires when results are shown (parameters: results)\r\n  noResults: fires when filter returns an empty array\r\n  itemSelect: fires when user selects an item from the result list (paramters: item)\r\n  itemFocus: fires when user highlights an item with mouse or arrow keys (paramters: item)\r\n  itemUnfocus: fires when user moves out from an highlighted item (paramters: item)\r\n  lostFocus: fires when autocomplete field loses focus by user clicking outside of the field or focusing on another field. Also, this event is fired when a value is selected\r\n\r\n })\r\n*/\r\n\r\n(function($){\r\n  $.fn.smartAutoComplete = function(){    \r\n\r\n    if(arguments.length < 1){\r\n      // get the smart autocomplete object of the first element and return \r\n      var first_element = this[0];\r\n      return $(first_element).data("smart-autocomplete")\r\n    }\r\n\r\n    var default_filter_matcher = function(term, source, context){\r\n                                    var matcher = new RegExp(term.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, "\\\\$&"), "i" );\r\n\r\n                                    return $.grep(source, function(value) {\r\n                                      return matcher.test( value );\r\n                                    });\r\n\r\n                                 }\r\n\r\n    var default_options = {\r\n                            minCharLimit: 1, \r\n                            maxCharLimit: null, \r\n                            maxResults: null,\r\n                            delay: 0,\r\n                            disabled: false,\r\n                            forceSelect: false,\r\n                            typeAhead: false,\r\n                            resultElement: "li",\r\n                            resultFormatter: function(r){ return ("<li>" + r + "</li>"); },\r\n                            filter: function(term, source){    \r\n                              var context = this;\r\n                              var options = $(context).data("smart-autocomplete");\r\n                              \r\n\r\n                              //when source is an array\r\n                              if($.type(source) === "array") {\r\n                                // directly map\r\n                                var results = default_filter_matcher(term, source, context);\r\n                                return results; \r\n                              }\r\n                              //when source is a string\r\n                              else if($.type(source) === "string"){\r\n                                // treat the string as a URL endpoint\r\n                                // pass the query as \'term\'\r\n                                \r\n                                return $.Deferred(function(dfd){ \r\n                                  $.ajax({\r\n                                    url: source,\r\n                                    data: {"term": term},\r\n                                    dataType: "json"\r\n                                  }).done( function(data){\r\n                                    dfd.resolve( default_filter_matcher(term, data, context) );          \r\n                                  }); \r\n                                }).promise();\r\n                                \r\n                              }\r\n\r\n                            },\r\n\r\n                            alignResultsContainer: false,\r\n\r\n                            clearResults: function(){\r\n                              //remove type ahead field\r\n                              var type_ahead_field = $(this.context).prev(".smart_autocomplete_type_ahead_field");\r\n                              $(this.context).css({ background: type_ahead_field.css("background") });\r\n                              type_ahead_field.remove();\r\n                              \r\n                              //clear results div\r\n                              $(this.resultsContainer).html("");\r\n                            },\r\n\r\n                            setCurrentSelectionToContext: function(){\r\n                                if(this.rawResults.length > 0 && this.currentSelection >= 0)\r\n                                  $(this.context).val(this.rawResults[(this.currentSelection)]);\r\n                            },\r\n\r\n                            setItemSelected: function(val){\r\n                              this.itemSelected = val;\r\n                            },\r\n\r\n                            autocompleteFocused: false,\r\n\r\n                            setAutocompleteFocused: function(val){\r\n                              this.autocompleteFocused = val;\r\n                            }\r\n\r\n    };\r\n\r\n    //define the default events\r\n    $.event.special.keyIn = {\r\n      setup: function(){ return false; }, \r\n\r\n      _default: function(ev){\r\n        var context = ev.target;\r\n        var options = $(context).data("smart-autocomplete");\r\n        var source = options.source || null;\r\n        var filter = options.filter;\r\n        var maxChars = (options.maxCharLimit > 0 ?  options.maxCharLimit : Number.POSITIVE_INFINITY)\r\n\r\n        //event specific data\r\n        var query = ev.smartAutocompleteData.query;\r\n\r\n        if(options.disabled || (query.length > maxChars)){\r\n          $(context).trigger("lostFocus");\r\n          return false;\r\n        }\r\n\r\n        //set item selected property\r\n        options.setItemSelected(false);\r\n\r\n        //set autocomplete focused\r\n        options.setAutocompleteFocused(true);\r\n\r\n        //call the filter function with delay\r\n        setTimeout(function(){\r\n          $.when( filter.apply(options, [query, options.source]) ).done(function( results ){\r\n            //do the trimming\r\n            var trimmed_results = (options.maxResults > 0 ? results.splice(0, options.maxResults) : results);\r\n\r\n            $(context).trigger("resultsReady", [trimmed_results]);\r\n          });\r\n        }, options.delay);\r\n      }\r\n    };\r\n\r\n    $.event.special.resultsReady = {\r\n      setup: function(){ return false },\r\n\r\n      _default: function(ev){\r\n        var context = ev.target;\r\n        var options = $(context).data("smart-autocomplete");\r\n\r\n        //event specific data\r\n        var results = ev.smartAutocompleteData.results;\r\n\r\n        //exit if smart complete is disabled\r\n        if(options.disabled)\r\n          return false;\r\n\r\n        //clear all previous results \r\n        $(context).smartAutoComplete().clearResults();\r\n\r\n        //save the raw results\r\n        options.rawResults = results;\r\n\r\n        //fire the no match event and exit if no matching results\r\n        if(results.length < 1){\r\n          $(context).trigger("noResults");\r\n          return false\r\n        }\r\n\r\n        //call the results formatter function\r\n        var formatted_results = $.map(results, function(result){\r\n          return options.resultFormatter.apply(options, [result]);\r\n        });\r\n\r\n        var formatted_results_html = formatted_results.join("");\r\n\r\n        //append the results to the container\r\n        if(options.resultsContainer)\r\n          $(options.resultsContainer).append(formatted_results_html);\r\n\r\n        //trigger results ready event\r\n        $(context).trigger("showResults", [results]);\r\n      }             \r\n    };\r\n\r\n    $.event.special.showResults = {\r\n      setup: function(){ return false },\r\n\r\n      _default: function(ev){    \r\n        var context = ev.target;\r\n        var options = $(context).data("smart-autocomplete");\r\n        var results_container = $(options.resultsContainer);\r\n\r\n        //event specific data\r\n        var raw_results = ev.smartAutocompleteData.results; \r\n\r\n        //type ahead\r\n        if(options.typeAhead && (raw_results[0].substr(0, $(context).val().length) == $(context).val()) ){\r\n          var suggestion = raw_results[0]; //options.typeAheadExtractor($(context).val(), raw_results[0]); \r\n          \r\n          //add new typeAhead field\r\n          $(context).before("<input class=\'smart_autocomplete_type_ahead_field\' type=\'text\' autocomplete=\'off\' disabled=\'disabled\' value=\'" + suggestion + "\'/>");\r\n\r\n          $(context).css({\r\n            position: "relative",\r\n            zIndex: 2,\r\n            background: "transparent"\r\n          });\r\n\r\n          var typeAheadField = $(context).prev("input");\r\n          typeAheadField.css({\r\n            position: "absolute",\r\n            zIndex: 1,\r\n            overflow: "hidden",\r\n            background: $(context).css("background"),\r\n            borderColor: "transparent",\r\n            width: $(context).width(),\r\n            color: "silver"\r\n          });\r\n\r\n          //trigger item over for first item\r\n          options.currentSelection = 0;\r\n          if(results_container)\r\n            $(context).trigger("itemFocus", results_container.children()[options.currentSelection]);\r\n        }\r\n\r\n        //show the results container after aligning it with the field \r\n        if(results_container){\r\n          if(options.alignResultsContainer){\r\n            results_container.css({ \r\n                  position: "absolute",\r\n                  top: function(){ return $(context).offset().top + $(context).height(); }, \r\n                  left: function(){ return $(context).offset().left; }, \r\n                  width: function(){ return $(context).width(); }, \r\n                  zIndex: 1000\r\n            })\r\n          }  \r\n          results_container.show();\r\n        }\r\n\r\n      }\r\n    };\r\n\r\n    $.event.special.noResults = {\r\n      setup: function(){ return false },\r\n\r\n      _default: function(ev){    \r\n        var context = ev.target;\r\n        var options = $(context).data("smart-autocomplete");\r\n        var result_container = $(options.resultsContainer);\r\n\r\n        if(result_container){\r\n         //clear previous results\r\n         options.clearResults(); \r\n        }\r\n\r\n      }\r\n    };\r\n\r\n    $.event.special.itemSelect = { \r\n      setup: function(){ return false },\r\n\r\n      _default: function(ev){    \r\n        var context = ev.target;\r\n        var options = $(context).data("smart-autocomplete");\r\n\r\n        //event specific data\r\n        var selected_item = ev.smartAutocompleteData.item;\r\n\r\n        //get the text from selected item\r\n        var selected_value = $(selected_item).text() || $(selected_item).val();\r\n        //set it as the value of the autocomplete field\r\n        $(context).val(selected_value); \r\n\r\n        //set item selected property\r\n        options.setItemSelected(true);\r\n\r\n        //set number of current chars in field \r\n        options.originalCharCount = $(context).val().length;\r\n        \r\n        //trigger lost focus\r\n        $(context).trigger(\'lostFocus\');\r\n      }\r\n    };\r\n\r\n    $.event.special.itemFocus = {\r\n      setup: function(){ return false },\r\n\r\n      _default: function(ev){    \r\n\r\n        //event specific data\r\n        var item = ev.smartAutocompleteData.item;\r\n\r\n        $(item).addClass("smart_autocomplete_highlight");\r\n      }\r\n    };\r\n\r\n    $.event.special.itemUnfocus = { \r\n      setup: function(){ return false },\r\n\r\n      _default: function(ev){    \r\n\r\n        //event specific data\r\n        var item = ev.smartAutocompleteData.item;\r\n\r\n        $(item).removeClass("smart_autocomplete_highlight");\r\n      }\r\n    }\r\n\r\n    $.event.special.lostFocus = {\r\n      setup: function(){ return false },\r\n\r\n      _default: function(ev){    \r\n        var context = ev.target;\r\n        var options = $(context).data("smart-autocomplete");\r\n\r\n        //if force select is selected and no item is selected, clear currently entered text \r\n        if(options.forceSelect && !options.itemSelected)\r\n          $(options.context).val("");\r\n\r\n        //unset autocomplete focused\r\n        options.setAutocompleteFocused(false);\r\n\r\n        //clear results\r\n        options.clearResults(); \r\n\r\n        //hide the results container\r\n        if(options.resultsContainer)\r\n          $(options.resultsContainer).hide();\r\n\r\n        //set current selection to null\r\n        options.currentSelection = null;\r\n      }\r\n    };\r\n\r\n    var passed_options = arguments[0];\r\n\r\n    return this.each(function(i) { \r\n      //set the options\r\n      var options = $.extend(default_options, $(this).data("smart-autocomplete"), passed_options);\r\n      //set the context\r\n      options["context"] = this;\r\n\r\n      //if a result container is not defined\r\n      if($.type(options.resultsContainer) === "undefined" ){\r\n        //define the default result container if it is already not defined\r\n        var default_container = $("<ul class=\'smart_autocomplete_container\' style=\'display:none\'></ul>");\r\n        default_container.appendTo("body");\r\n\r\n        options.resultsContainer = default_container;\r\n        options.alignResultsContainer = true;\r\n      }\r\n\r\n      $(this).data("smart-autocomplete", options);\r\n\r\n      // bind user events\r\n      // Brackets monkeypatch: revert this to keyup because keydown breaks Quick Open\r\n      $(this).on("keyup", function(ev){\r\n        //get the options\r\n        var options = $(this).data("smart-autocomplete");\r\n\r\n        //up arrow\r\n        if(ev.keyCode === 38){\r\n\r\n          if(options.resultsContainer){\r\n            var current_selection = options.currentSelection || 0;\r\n            var result_suggestions = $(options.resultsContainer).children();\r\n\r\n            if(current_selection > 0) {\r\n              $(options.context).trigger("itemUnfocus", result_suggestions[current_selection] );\r\n              current_selection--;\r\n            } else if((current_selection-1) < 0) {\r\n              $(options.context).trigger("itemUnfocus", result_suggestions[current_selection] );\r\n              current_selection = result_suggestions.length-1;\r\n            }\r\n\r\n            options.currentSelection = current_selection;\r\n\r\n            $(options.context).trigger("itemFocus", [ result_suggestions[current_selection] ] );\r\n          }\r\n        }\r\n\r\n        //down arrow\r\n        else if(ev.keyCode === 40){\r\n\r\n          if(options.resultsContainer && options.resultsContainer.is(\':visible\')){\r\n            var current_selection = options.currentSelection;\r\n            var result_suggestions = $(options.resultsContainer).children();\r\n\r\n            if(current_selection >= 0)\r\n              $(options.context).trigger("itemUnfocus", result_suggestions[current_selection] );\r\n\r\n            if(isNaN(current_selection) || null == current_selection || (++current_selection >= result_suggestions.length) )\r\n              current_selection = 0;\r\n\r\n            options["currentSelection"] = current_selection;\r\n\r\n            $(options.context).trigger("itemFocus", [ result_suggestions[current_selection] ] );\r\n          }\r\n          //trigger keyIn event on down key\r\n          else {\r\n            $(options.context).trigger("keyIn", [$(this).val()]); \r\n          }\r\n          \r\n        }\r\n\r\n        //right arrow & enter key\r\n        else if(ev.keyCode === 39 || ev.keyCode === 13){\r\n          var type_ahead_field = $(options.context).prev(".smart_autocomplete_type_ahead_field");\r\n          if(options.resultsContainer && $(options.resultsContainer).is(\':visible\')){\r\n            var current_selection = options.currentSelection;\r\n            var result_suggestions = $(options.resultsContainer).children();\r\n\r\n            $(options.context).trigger("itemSelect", [ result_suggestions[current_selection] ] );\r\n          }\r\n          else if(options.typeAhead && type_ahead_field.is(":visible"))\r\n            $(options.context).trigger("itemSelect", [ type_ahead_field ] );\r\n\r\n          return false;\r\n        }\r\n\r\n        else if(ev.keyCode !== 255) {\r\n         var current_char_count = $(options.context).val().length;\r\n         //check whether the string has modified\r\n         if(options.originalCharCount == current_char_count)\r\n           return;\r\n\r\n         //check minimum and maximum number of characters are typed\r\n         if(current_char_count >= options.minCharLimit){\r\n          $(options.context).trigger("keyIn", [$(this).val()]); \r\n         }\r\n         else{\r\n            if(options.autocompleteFocused){ \r\n              options.currentSelection = null;\r\n              $(options.context).trigger("lostFocus");\r\n            }\r\n         }\r\n\r\n        }\r\n      });\r\n\r\n      $(this).focus(function(){\r\n        //if the field is in a form capture the return key event \r\n        $(this).closest("form").bind("keydown.block_for_smart_autocomplete", function(ev){\r\n          var type_ahead_field = $(options.context).prev(".smart_autocomplete_type_ahead_field");\r\n          if(ev.keyCode === 13){\r\n            if(options.resultsContainer && $(options.resultsContainer).is(":visible")){\r\n              var current_selection = options.currentSelection;\r\n              var result_suggestions = $(options.resultsContainer).children();\r\n\r\n              $(options.context).trigger("itemSelect", [ result_suggestions[current_selection] ] );\r\n              return false;\r\n            }\r\n            else if(options.typeAhead && type_ahead_field.is(":visible") ){\r\n              $(options.context).trigger("itemSelect", [ type_ahead_field ] );\r\n              return false;\r\n            }\r\n          }\r\n        });\r\n\r\n        if(options.forceSelect){\r\n          $(this).select(); \r\n        }\r\n      });\r\n\r\n      //check for loosing focus on smart complete field and results container\r\n      //$(this).blur(function(ev){\r\n      $(document).bind("focusin click", function(ev){\r\n        if(options.autocompleteFocused){ \r\n          var elemIsParent = $.contains(options.resultsContainer[0], ev.target);\r\n          if(ev.target == options.resultsContainer[0] || ev.target == options.context || elemIsParent) return\r\n\r\n          $(options.context).closest("form").unbind("keydown.block_for_smart_autocomplete");\r\n          $(options.context).trigger("lostFocus");\r\n        }\r\n      });\r\n\r\n      // Brackets monkeypatch: don\'t trigger item focus/unfocus events on mouseenter/mouseleave, since we don\'t\r\n      // want to select an item just by mousing over it. We just want an ordinary hover highlight, which we apply\r\n      // through CSS directly.\r\n/*\r\n      //bind events to results container\r\n      $(options.resultsContainer).delegate(options.resultElement, "mouseenter.smart_autocomplete", function(){\r\n        var old_selection = options.currentSelection || 0;\r\n        var result_suggestions = $(options.resultsContainer).children();\r\n\r\n        options["currentSelection"] = $(this).prevAll().length;\r\n        \r\n        if (old_selection != options.currentSelection) {\r\n          $(options.context).trigger("itemUnfocus", result_suggestions[old_selection]);\r\n        }\r\n\r\n        $(options.context).trigger("itemFocus", [this] );\r\n          \r\n      });\r\n\r\n      $(options.resultsContainer).delegate(options.resultElement, "mouseleave.smart_autocomplete", function(){\r\n        $(options.context).trigger("itemUnfocus", [this] );\r\n      });\r\n*/\r\n\r\n      $(options.resultsContainer).delegate(options.resultElement, "mousedown.smart_autocomplete", function(){\r\n        $(options.context).trigger("itemSelect", [this]);\r\n        return false\r\n      });\r\n\r\n      //bind plugin specific events\r\n      $(this).bind({\r\n        keyIn: function(ev, query){ ev.smartAutocompleteData  = {"query": query }; },\r\n        resultsReady: function(ev, results){ ev.smartAutocompleteData  = {"results": results }; }, \r\n        showResults: function(ev, results){ ev.smartAutocompleteData = {"results": results } },\r\n        noResults: function(){},\r\n        lostFocus: function(){},\r\n        itemSelect: function(ev, item){ ev.smartAutocompleteData = {"item": item }; },\r\n        itemFocus: function(ev, item){ ev.smartAutocompleteData = {"item": item }; },\r\n        itemUnfocus: function(ev, item){ ev.smartAutocompleteData = {"item": item }; }\r\n      });\r\n    });\r\n      \r\n  }\r\n})(jQuery);\r\n\n//# sourceURL=/thirdparty/smart-auto-complete-local/jquery.smart_autocomplete.js'),define("thirdparty/smart-auto-complete-local/jquery.smart_autocomplete",function(){}),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// This is CodeMirror (http://codemirror.net), a code editor\r\n// implemented in JavaScript on top of the browser\'s DOM.\r\n//\r\n// You can find some technical background for some of the code below\r\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    module.exports = mod();\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    return define(\'thirdparty/CodeMirror2/lib/codemirror\',[], mod);\r\n  else // Plain browser env\r\n    this.CodeMirror = mod();\r\n})(function() {\r\n  "use strict";\r\n\r\n  // BROWSER SNIFFING\r\n\r\n  // Kludges for bugs and behavior differences that can\'t be feature\r\n  // detected are enabled based on userAgent etc sniffing.\r\n\r\n  var gecko = /gecko\\/\\d/i.test(navigator.userAgent);\r\n  // ie_uptoN means Internet Explorer version N or lower\r\n  var ie_upto10 = /MSIE \\d/.test(navigator.userAgent);\r\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent);\r\n  var ie = ie_upto10 || ie_11up;\r\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : ie_11up[1]);\r\n  var webkit = /WebKit\\//.test(navigator.userAgent);\r\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(navigator.userAgent);\r\n  var chrome = /Chrome\\//.test(navigator.userAgent);\r\n  var presto = /Opera\\//.test(navigator.userAgent);\r\n  var safari = /Apple Computer/.test(navigator.vendor);\r\n  var khtml = /KHTML\\//.test(navigator.userAgent);\r\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(navigator.userAgent);\r\n  var phantom = /PhantomJS/.test(navigator.userAgent);\r\n\r\n  var ios = /AppleWebKit/.test(navigator.userAgent) && /Mobile\\/\\w+/.test(navigator.userAgent);\r\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\r\n  var mobile = ios || /Android|webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(navigator.userAgent);\r\n  var mac = ios || /Mac/.test(navigator.platform);\r\n  var windows = /win/i.test(navigator.platform);\r\n\r\n  var presto_version = presto && navigator.userAgent.match(/Version\\/(\\d*\\.\\d*)/);\r\n  if (presto_version) presto_version = Number(presto_version[1]);\r\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\r\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\r\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\r\n  var captureRightClick = gecko || (ie && ie_version >= 9);\r\n\r\n  // Optimize some code when these features are not used.\r\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\r\n\r\n  // EDITOR CONSTRUCTOR\r\n\r\n  // A CodeMirror instance represents an editor. This is the object\r\n  // that user code is usually dealing with.\r\n\r\n  function CodeMirror(place, options) {\r\n    if (!(this instanceof CodeMirror)) return new CodeMirror(place, options);\r\n\r\n    this.options = options = options || {};\r\n    // Determine effective options based on given values and defaults.\r\n    copyObj(defaults, options, false);\r\n    setGuttersForLineNumbers(options);\r\n\r\n    var doc = options.value;\r\n    if (typeof doc == "string") doc = new Doc(doc, options.mode);\r\n    this.doc = doc;\r\n\r\n    var display = this.display = new Display(place, doc);\r\n    display.wrapper.CodeMirror = this;\r\n    updateGutters(this);\r\n    themeChanged(this);\r\n    if (options.lineWrapping)\r\n      this.display.wrapper.className += " CodeMirror-wrap";\r\n    if (options.autofocus && !mobile) focusInput(this);\r\n\r\n    this.state = {\r\n      keyMaps: [],  // stores maps added by addKeyMap\r\n      overlays: [], // highlighting overlays, as added by addOverlay\r\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\r\n      overwrite: false, focused: false,\r\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\r\n      pasteIncoming: false, cutIncoming: false, // help recognize paste/cut edits in readInput\r\n      draggingText: false,\r\n      highlight: new Delayed() // stores highlight worker timeout\r\n    };\r\n\r\n    // Override magic textarea content restore that IE sometimes does\r\n    // on our hidden textarea on reload\r\n    if (ie && ie_version < 11) setTimeout(bind(resetInput, this, true), 20);\r\n\r\n    registerEventHandlers(this);\r\n    ensureGlobalHandlers();\r\n\r\n    var cm = this;\r\n    runInOp(this, function() {\r\n      cm.curOp.forceUpdate = true;\r\n      attachDoc(cm, doc);\r\n\r\n      if ((options.autofocus && !mobile) || activeElt() == display.input)\r\n        setTimeout(bind(onFocus, cm), 20);\r\n      else\r\n        onBlur(cm);\r\n\r\n      for (var opt in optionHandlers) if (optionHandlers.hasOwnProperty(opt))\r\n        optionHandlers[opt](cm, options[opt], Init);\r\n      maybeUpdateLineNumberWidth(cm);\r\n      for (var i = 0; i < initHooks.length; ++i) initHooks[i](cm);\r\n    });\r\n  }\r\n\r\n  // DISPLAY CONSTRUCTOR\r\n\r\n  // The display handles the DOM integration, both for input reading\r\n  // and content drawing. It holds references to DOM nodes and\r\n  // display-related state.\r\n\r\n  function Display(place, doc) {\r\n    var d = this;\r\n\r\n    // The semihidden textarea that is focused when the editor is\r\n    // focused, and receives input.\r\n    var input = d.input = elt("textarea", null, null, "position: absolute; padding: 0; width: 1px; height: 1em; outline: none");\r\n    // The textarea is kept positioned near the cursor to prevent the\r\n    // fact that it\'ll be scrolled into view on input from scrolling\r\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\r\n    // very slow. So make the area wide instead.\r\n    if (webkit) input.style.width = "1000px";\r\n    else input.setAttribute("wrap", "off");\r\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\r\n    if (ios) input.style.border = "1px solid black";\r\n    input.setAttribute("autocorrect", "off"); input.setAttribute("autocapitalize", "off"); input.setAttribute("spellcheck", "false");\r\n\r\n    // Wraps and hides input textarea\r\n    d.inputDiv = elt("div", [input], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");\r\n    // The fake scrollbar elements.\r\n    d.scrollbarH = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");\r\n    d.scrollbarV = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");\r\n    // Covers bottom-right square when both scrollbars are present.\r\n    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");\r\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\r\n    // and h scrollbar is present.\r\n    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");\r\n    // Will contain the actual code, positioned to cover the viewport.\r\n    d.lineDiv = elt("div", null, "CodeMirror-code");\r\n    // Elements are added to these to represent selection and cursors.\r\n    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");\r\n    d.cursorDiv = elt("div", null, "CodeMirror-cursors");\r\n    // A visibility: hidden element used to find the size of things.\r\n    d.measure = elt("div", null, "CodeMirror-measure");\r\n    // When lines outside of the viewport are measured, they are drawn in this.\r\n    d.lineMeasure = elt("div", null, "CodeMirror-measure");\r\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\r\n    d.lineSpace = elt("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\r\n                      null, "position: relative; outline: none");\r\n    // Moved around its parent to cover visible view.\r\n    d.mover = elt("div", [elt("div", [d.lineSpace], "CodeMirror-lines")], null, "position: relative");\r\n    // Set to the height of the document, allowing scrolling.\r\n    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");\r\n    // Behavior of elts with overflow: auto and padding is\r\n    // inconsistent across browsers. This is used to ensure the\r\n    // scrollable area is big enough.\r\n    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerCutOff + "px; width: 1px;");\r\n    // Will contain the gutters, if any.\r\n    d.gutters = elt("div", null, "CodeMirror-gutters");\r\n    d.lineGutter = null;\r\n    // Actual scrollable element.\r\n    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");\r\n    d.scroller.setAttribute("tabIndex", "-1");\r\n    // The element in which the editor lives.\r\n    d.wrapper = elt("div", [d.inputDiv, d.scrollbarH, d.scrollbarV,\r\n                            d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");\r\n\r\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\r\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\r\n    // Needed to hide big blue blinking cursor on Mobile Safari\r\n    if (ios) input.style.width = "0px";\r\n    if (!webkit) d.scroller.draggable = true;\r\n    // Needed to handle Tab key in KHTML\r\n    if (khtml) { d.inputDiv.style.height = "1px"; d.inputDiv.style.position = "absolute"; }\r\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\r\n    if (ie && ie_version < 8) d.scrollbarH.style.minHeight = d.scrollbarV.style.minWidth = "18px";\r\n\r\n    if (place.appendChild) place.appendChild(d.wrapper);\r\n    else place(d.wrapper);\r\n\r\n    // Current rendered range (may be bigger than the view window).\r\n    d.viewFrom = d.viewTo = doc.first;\r\n    // Information about the rendered lines.\r\n    d.view = [];\r\n    // Holds info about a single rendered line when it was rendered\r\n    // for measurement, while not in view.\r\n    d.externalMeasured = null;\r\n    // Empty space (in pixels) above the view\r\n    d.viewOffset = 0;\r\n    d.lastSizeC = 0;\r\n    d.updateLineNumbers = null;\r\n\r\n    // Used to only resize the line number gutter when necessary (when\r\n    // the amount of lines crosses a boundary that makes its width change)\r\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\r\n    // See readInput and resetInput\r\n    d.prevInput = "";\r\n    // Set to true when a non-horizontal-scrolling line widget is\r\n    // added. As an optimization, line widget aligning is skipped when\r\n    // this is false.\r\n    d.alignWidgets = false;\r\n    // Flag that indicates whether we expect input to appear real soon\r\n    // now (after some event like \'keypress\' or \'input\') and are\r\n    // polling intensively.\r\n    d.pollingFast = false;\r\n    // Self-resetting timeout for the poller\r\n    d.poll = new Delayed();\r\n\r\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\r\n\r\n    // Tracks when resetInput has punted to just putting a short\r\n    // string into the textarea instead of the full selection.\r\n    d.inaccurateSelection = false;\r\n\r\n    // Tracks the maximum line length so that the horizontal scrollbar\r\n    // can be kept static when scrolling.\r\n    d.maxLine = null;\r\n    d.maxLineLength = 0;\r\n    d.maxLineChanged = false;\r\n\r\n    // Used for measuring wheel scrolling granularity\r\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\r\n\r\n    // True when shift is held down.\r\n    d.shift = false;\r\n\r\n    // Used to track whether anything happened since the context menu\r\n    // was opened.\r\n    d.selForContextMenu = null;\r\n  }\r\n\r\n  // STATE UPDATES\r\n\r\n  // Used to get the editor into a consistent state again when options change.\r\n\r\n  function loadMode(cm) {\r\n    cm.doc.mode = CodeMirror.getMode(cm.options, cm.doc.modeOption);\r\n    resetModeState(cm);\r\n  }\r\n\r\n  function resetModeState(cm) {\r\n    cm.doc.iter(function(line) {\r\n      if (line.stateAfter) line.stateAfter = null;\r\n      if (line.styles) line.styles = null;\r\n    });\r\n    cm.doc.frontier = cm.doc.first;\r\n    startWorker(cm, 100);\r\n    cm.state.modeGen++;\r\n    if (cm.curOp) regChange(cm);\r\n  }\r\n\r\n  function wrappingChanged(cm) {\r\n    if (cm.options.lineWrapping) {\r\n      addClass(cm.display.wrapper, "CodeMirror-wrap");\r\n      cm.display.sizer.style.minWidth = "";\r\n    } else {\r\n      rmClass(cm.display.wrapper, "CodeMirror-wrap");\r\n      findMaxLine(cm);\r\n    }\r\n    estimateLineHeights(cm);\r\n    regChange(cm);\r\n    clearCaches(cm);\r\n    setTimeout(function(){updateScrollbars(cm);}, 100);\r\n  }\r\n\r\n  // Returns a function that estimates the height of a line, to use as\r\n  // first approximation until the line becomes visible (and is thus\r\n  // properly measurable).\r\n  function estimateHeight(cm) {\r\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\r\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\r\n    return function(line) {\r\n      if (lineIsHidden(cm.doc, line)) return 0;\r\n\r\n      var widgetsHeight = 0;\r\n      if (line.widgets) for (var i = 0; i < line.widgets.length; i++) {\r\n        if (line.widgets[i].height) widgetsHeight += line.widgets[i].height;\r\n      }\r\n\r\n      if (wrapping)\r\n        return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;\r\n      else\r\n        return widgetsHeight + th;\r\n    };\r\n  }\r\n\r\n  function estimateLineHeights(cm) {\r\n    var doc = cm.doc, est = estimateHeight(cm);\r\n    doc.iter(function(line) {\r\n      var estHeight = est(line);\r\n      if (estHeight != line.height) updateLineHeight(line, estHeight);\r\n    });\r\n  }\r\n\r\n  function keyMapChanged(cm) {\r\n    var map = keyMap[cm.options.keyMap], style = map.style;\r\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-keymap-\\S+/g, "") +\r\n      (style ? " cm-keymap-" + style : "");\r\n  }\r\n\r\n  function themeChanged(cm) {\r\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, "") +\r\n      cm.options.theme.replace(/(^|\\s)\\s*/g, " cm-s-");\r\n    clearCaches(cm);\r\n  }\r\n\r\n  function guttersChanged(cm) {\r\n    updateGutters(cm);\r\n    regChange(cm);\r\n    setTimeout(function(){alignHorizontally(cm);}, 20);\r\n  }\r\n\r\n  // Rebuild the gutter elements, ensure the margin to the left of the\r\n  // code matches their width.\r\n  function updateGutters(cm) {\r\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\r\n    removeChildren(gutters);\r\n    for (var i = 0; i < specs.length; ++i) {\r\n      var gutterClass = specs[i];\r\n      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));\r\n      if (gutterClass == "CodeMirror-linenumbers") {\r\n        cm.display.lineGutter = gElt;\r\n        gElt.style.width = (cm.display.lineNumWidth || 1) + "px";\r\n      }\r\n    }\r\n    gutters.style.display = i ? "" : "none";\r\n    updateGutterSpace(cm);\r\n  }\r\n\r\n  function updateGutterSpace(cm) {\r\n    var width = cm.display.gutters.offsetWidth;\r\n    cm.display.sizer.style.marginLeft = width + "px";\r\n    cm.display.scrollbarH.style.left = cm.options.fixedGutter ? width + "px" : 0;\r\n  }\r\n\r\n  // Compute the character length of a line, taking into account\r\n  // collapsed ranges (see markText) that might hide parts, and join\r\n  // other lines onto it.\r\n  function lineLength(line) {\r\n    if (line.height == 0) return 0;\r\n    var len = line.text.length, merged, cur = line;\r\n    while (merged = collapsedSpanAtStart(cur)) {\r\n      var found = merged.find(0, true);\r\n      cur = found.from.line;\r\n      len += found.from.ch - found.to.ch;\r\n    }\r\n    cur = line;\r\n    while (merged = collapsedSpanAtEnd(cur)) {\r\n      var found = merged.find(0, true);\r\n      len -= cur.text.length - found.from.ch;\r\n      cur = found.to.line;\r\n      len += cur.text.length - found.to.ch;\r\n    }\r\n    return len;\r\n  }\r\n\r\n  // Find the longest line in the document.\r\n  function findMaxLine(cm) {\r\n    var d = cm.display, doc = cm.doc;\r\n    d.maxLine = getLine(doc, doc.first);\r\n    d.maxLineLength = lineLength(d.maxLine);\r\n    d.maxLineChanged = true;\r\n    doc.iter(function(line) {\r\n      var len = lineLength(line);\r\n      if (len > d.maxLineLength) {\r\n        d.maxLineLength = len;\r\n        d.maxLine = line;\r\n      }\r\n    });\r\n  }\r\n\r\n  // Make sure the gutters options contains the element\r\n  // "CodeMirror-linenumbers" when the lineNumbers option is true.\r\n  function setGuttersForLineNumbers(options) {\r\n    var found = indexOf(options.gutters, "CodeMirror-linenumbers");\r\n    if (found == -1 && options.lineNumbers) {\r\n      options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]);\r\n    } else if (found > -1 && !options.lineNumbers) {\r\n      options.gutters = options.gutters.slice(0);\r\n      options.gutters.splice(found, 1);\r\n    }\r\n  }\r\n\r\n  // SCROLLBARS\r\n\r\n  function hScrollbarTakesSpace(cm) {\r\n    return cm.display.scroller.clientHeight - cm.display.wrapper.clientHeight < scrollerCutOff - 3;\r\n  }\r\n\r\n  // Prepare DOM reads needed to update the scrollbars. Done in one\r\n  // shot to minimize update/measure roundtrips.\r\n  function measureForScrollbars(cm) {\r\n    var scroll = cm.display.scroller;\r\n    return {\r\n      clientHeight: scroll.clientHeight,\r\n      barHeight: cm.display.scrollbarV.clientHeight,\r\n      scrollWidth: scroll.scrollWidth, clientWidth: scroll.clientWidth,\r\n      hScrollbarTakesSpace: hScrollbarTakesSpace(cm),\r\n      barWidth: cm.display.scrollbarH.clientWidth,\r\n      docHeight: Math.round(cm.doc.height + paddingVert(cm.display))\r\n    };\r\n  }\r\n\r\n  // Re-synchronize the fake scrollbars with the actual size of the\r\n  // content.\r\n  function updateScrollbars(cm, measure) {\r\n    if (!measure) measure = measureForScrollbars(cm);\r\n    var d = cm.display, sWidth = scrollbarWidth(d.measure);\r\n    var scrollHeight = measure.docHeight + scrollerCutOff;\r\n    var needsH = measure.scrollWidth > measure.clientWidth;\r\n    if (needsH && measure.scrollWidth <= measure.clientWidth + 1 &&\r\n        sWidth > 0 && !measure.hScrollbarTakesSpace)\r\n      needsH = false; // (Issue #2562)\r\n    var needsV = scrollHeight > measure.clientHeight;\r\n\r\n    if (needsV) {\r\n      d.scrollbarV.style.display = "block";\r\n      d.scrollbarV.style.bottom = needsH ? sWidth + "px" : "0";\r\n      // A bug in IE8 can cause this value to be negative, so guard it.\r\n      d.scrollbarV.firstChild.style.height =\r\n        Math.max(0, scrollHeight - measure.clientHeight + (measure.barHeight || d.scrollbarV.clientHeight)) + "px";\r\n    } else {\r\n      d.scrollbarV.style.display = "";\r\n      d.scrollbarV.firstChild.style.height = "0";\r\n    }\r\n    if (needsH) {\r\n      d.scrollbarH.style.display = "block";\r\n      d.scrollbarH.style.right = needsV ? sWidth + "px" : "0";\r\n      d.scrollbarH.firstChild.style.width =\r\n        (measure.scrollWidth - measure.clientWidth + (measure.barWidth || d.scrollbarH.clientWidth)) + "px";\r\n    } else {\r\n      d.scrollbarH.style.display = "";\r\n      d.scrollbarH.firstChild.style.width = "0";\r\n    }\r\n    if (needsH && needsV) {\r\n      d.scrollbarFiller.style.display = "block";\r\n      d.scrollbarFiller.style.height = d.scrollbarFiller.style.width = sWidth + "px";\r\n    } else d.scrollbarFiller.style.display = "";\r\n    if (needsH && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\r\n      d.gutterFiller.style.display = "block";\r\n      d.gutterFiller.style.height = sWidth + "px";\r\n      d.gutterFiller.style.width = d.gutters.offsetWidth + "px";\r\n    } else d.gutterFiller.style.display = "";\r\n\r\n    if (!cm.state.checkedOverlayScrollbar && measure.clientHeight > 0) {\r\n      if (sWidth === 0) {\r\n        var w = mac && !mac_geMountainLion ? "12px" : "18px";\r\n        d.scrollbarV.style.minWidth = d.scrollbarH.style.minHeight = w;\r\n        var barMouseDown = function(e) {\r\n          if (e_target(e) != d.scrollbarV && e_target(e) != d.scrollbarH)\r\n            operation(cm, onMouseDown)(e);\r\n        };\r\n        on(d.scrollbarV, "mousedown", barMouseDown);\r\n        on(d.scrollbarH, "mousedown", barMouseDown);\r\n      }\r\n      cm.state.checkedOverlayScrollbar = true;\r\n    }\r\n  }\r\n\r\n  // Compute the lines that are visible in a given viewport (defaults\r\n  // the the current scroll position). viewport may contain top,\r\n  // height, and ensure (see op.scrollToPos) properties.\r\n  function visibleLines(display, doc, viewport) {\r\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\r\n    top = Math.floor(top - paddingTop(display));\r\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\r\n\r\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\r\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\r\n    // forces those lines into the viewport (if possible).\r\n    if (viewport && viewport.ensure) {\r\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\r\n      if (ensureFrom < from)\r\n        return {from: ensureFrom,\r\n                to: lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)};\r\n      if (Math.min(ensureTo, doc.lastLine()) >= to)\r\n        return {from: lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight),\r\n                to: ensureTo};\r\n    }\r\n    return {from: from, to: Math.max(to, from + 1)};\r\n  }\r\n\r\n  // LINE NUMBERS\r\n\r\n  // Re-align line numbers and gutter marks to compensate for\r\n  // horizontal scrolling.\r\n  function alignHorizontally(cm) {\r\n    var display = cm.display, view = display.view;\r\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) return;\r\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\r\n    var gutterW = display.gutters.offsetWidth, left = comp + "px";\r\n    for (var i = 0; i < view.length; i++) if (!view[i].hidden) {\r\n      if (cm.options.fixedGutter && view[i].gutter)\r\n        view[i].gutter.style.left = left;\r\n      var align = view[i].alignable;\r\n      if (align) for (var j = 0; j < align.length; j++)\r\n        align[j].style.left = left;\r\n    }\r\n    if (cm.options.fixedGutter)\r\n      display.gutters.style.left = (comp + gutterW) + "px";\r\n  }\r\n\r\n  // Used to ensure that the line number gutter is still the right\r\n  // size for the current document size. Returns true when an update\r\n  // is needed.\r\n  function maybeUpdateLineNumberWidth(cm) {\r\n    if (!cm.options.lineNumbers) return false;\r\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\r\n    if (last.length != display.lineNumChars) {\r\n      var test = display.measure.appendChild(elt("div", [elt("div", last)],\r\n                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));\r\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\r\n      display.lineGutter.style.width = "";\r\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding);\r\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\r\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\r\n      display.lineGutter.style.width = display.lineNumWidth + "px";\r\n      updateGutterSpace(cm);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  function lineNumberFor(options, i) {\r\n    return String(options.lineNumberFormatter(i + options.firstLineNumber));\r\n  }\r\n\r\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\r\n  // but using getBoundingClientRect to get a sub-pixel-accurate\r\n  // result.\r\n  function compensateForHScroll(display) {\r\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;\r\n  }\r\n\r\n  // DISPLAY DRAWING\r\n\r\n  function DisplayUpdate(cm, viewport, force) {\r\n    var display = cm.display;\r\n\r\n    this.viewport = viewport;\r\n    // Store some values that we\'ll need later (but don\'t want to force a relayout for)\r\n    this.visible = visibleLines(display, cm.doc, viewport);\r\n    this.editorIsHidden = !display.wrapper.offsetWidth;\r\n    this.wrapperHeight = display.wrapper.clientHeight;\r\n    this.oldViewFrom = display.viewFrom; this.oldViewTo = display.viewTo;\r\n    this.oldScrollerWidth = display.scroller.clientWidth;\r\n    this.force = force;\r\n    this.dims = getDimensions(cm);\r\n  }\r\n\r\n  // Does the actual updating of the line display. Bails out\r\n  // (returning false) when there is nothing to be done and forced is\r\n  // false.\r\n  function updateDisplayIfNeeded(cm, update) {\r\n    var display = cm.display, doc = cm.doc;\r\n    if (update.editorIsHidden) {\r\n      resetView(cm);\r\n      return false;\r\n    }\r\n\r\n    // Bail out if the visible area is already rendered and nothing changed.\r\n    if (!update.force &&\r\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\r\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\r\n        countDirtyView(cm) == 0)\r\n      return false;\r\n\r\n    if (maybeUpdateLineNumberWidth(cm)) {\r\n      resetView(cm);\r\n      update.dims = getDimensions(cm);\r\n    }\r\n\r\n    // Compute a suitable new viewport (from & to)\r\n    var end = doc.first + doc.size;\r\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\r\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\r\n    if (display.viewFrom < from && from - display.viewFrom < 20) from = Math.max(doc.first, display.viewFrom);\r\n    if (display.viewTo > to && display.viewTo - to < 20) to = Math.min(end, display.viewTo);\r\n    if (sawCollapsedSpans) {\r\n      from = visualLineNo(cm.doc, from);\r\n      to = visualLineEndNo(cm.doc, to);\r\n    }\r\n\r\n    var different = from != display.viewFrom || to != display.viewTo ||\r\n      display.lastSizeC != update.wrapperHeight;\r\n    adjustView(cm, from, to);\r\n\r\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\r\n    // Position the mover div to align with the current scroll position\r\n    cm.display.mover.style.top = display.viewOffset + "px";\r\n\r\n    var toUpdate = countDirtyView(cm);\r\n    if (!different && toUpdate == 0 && !update.force &&\r\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\r\n      return false;\r\n\r\n    // For big changes, we hide the enclosing element during the\r\n    // update, since that speeds up the operations on most browsers.\r\n    var focused = activeElt();\r\n    if (toUpdate > 4) display.lineDiv.style.display = "none";\r\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\r\n    if (toUpdate > 4) display.lineDiv.style.display = "";\r\n    // There might have been a widget with a focused element that got\r\n    // hidden or updated, if so re-focus it.\r\n    if (focused && activeElt() != focused && focused.offsetHeight) focused.focus();\r\n\r\n    // Prevent selection and cursors from interfering with the scroll\r\n    // width.\r\n    removeChildren(display.cursorDiv);\r\n    removeChildren(display.selectionDiv);\r\n\r\n    if (different) {\r\n      display.lastSizeC = update.wrapperHeight;\r\n      startWorker(cm, 400);\r\n    }\r\n\r\n    display.updateLineNumbers = null;\r\n\r\n    return true;\r\n  }\r\n\r\n  function postUpdateDisplay(cm, update) {\r\n    var force = update.force, viewport = update.viewport;\r\n    for (var first = true;; first = false) {\r\n      if (first && cm.options.lineWrapping && update.oldScrollerWidth != cm.display.scroller.clientWidth) {\r\n        force = true;\r\n      } else {\r\n        force = false;\r\n        // Clip forced viewport to actual scrollable area.\r\n        if (viewport && viewport.top != null)\r\n          viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - scrollerCutOff -\r\n                                    cm.display.scroller.clientHeight, viewport.top)};\r\n        // Updated line heights might result in the drawn area not\r\n        // actually covering the viewport. Keep looping until it does.\r\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\r\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\r\n          break;\r\n      }\r\n      if (!updateDisplayIfNeeded(cm, update)) break;\r\n      updateHeightsInViewport(cm);\r\n      var barMeasure = measureForScrollbars(cm);\r\n      updateSelection(cm);\r\n      setDocumentHeight(cm, barMeasure);\r\n      updateScrollbars(cm, barMeasure);\r\n    }\r\n\r\n    signalLater(cm, "update", cm);\r\n    if (cm.display.viewFrom != update.oldViewFrom || cm.display.viewTo != update.oldViewTo)\r\n      signalLater(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);\r\n  }\r\n\r\n  function updateDisplaySimple(cm, viewport) {\r\n    var update = new DisplayUpdate(cm, viewport);\r\n    if (updateDisplayIfNeeded(cm, update)) {\r\n      updateHeightsInViewport(cm);\r\n      postUpdateDisplay(cm, update);\r\n      var barMeasure = measureForScrollbars(cm);\r\n      updateSelection(cm);\r\n      setDocumentHeight(cm, barMeasure);\r\n      updateScrollbars(cm, barMeasure);\r\n    }\r\n  }\r\n\r\n  function setDocumentHeight(cm, measure) {\r\n    cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = measure.docHeight + "px";\r\n    cm.display.gutters.style.height = Math.max(measure.docHeight, measure.clientHeight - scrollerCutOff) + "px";\r\n  }\r\n\r\n  function checkForWebkitWidthBug(cm, measure) {\r\n    // Work around Webkit bug where it sometimes reserves space for a\r\n    // non-existing phantom scrollbar in the scroller (Issue #2420)\r\n    if (cm.display.sizer.offsetWidth + cm.display.gutters.offsetWidth < cm.display.scroller.clientWidth - 1) {\r\n      cm.display.sizer.style.minHeight = cm.display.heightForcer.style.top = "0px";\r\n      cm.display.gutters.style.height = measure.docHeight + "px";\r\n    }\r\n  }\r\n\r\n  // Read the actual heights of the rendered lines, and update their\r\n  // stored heights to match.\r\n  function updateHeightsInViewport(cm) {\r\n    var display = cm.display;\r\n    var prevBottom = display.lineDiv.offsetTop;\r\n    for (var i = 0; i < display.view.length; i++) {\r\n      var cur = display.view[i], height;\r\n      if (cur.hidden) continue;\r\n      if (ie && ie_version < 8) {\r\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\r\n        height = bot - prevBottom;\r\n        prevBottom = bot;\r\n      } else {\r\n        var box = cur.node.getBoundingClientRect();\r\n        height = box.bottom - box.top;\r\n      }\r\n      var diff = cur.line.height - height;\r\n      if (height < 2) height = textHeight(display);\r\n      if (diff > .001 || diff < -.001) {\r\n        updateLineHeight(cur.line, height);\r\n        updateWidgetHeight(cur.line);\r\n        if (cur.rest) for (var j = 0; j < cur.rest.length; j++)\r\n          updateWidgetHeight(cur.rest[j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  // Read and store the height of line widgets associated with the\r\n  // given line.\r\n  function updateWidgetHeight(line) {\r\n    if (line.widgets) for (var i = 0; i < line.widgets.length; ++i)\r\n      line.widgets[i].height = line.widgets[i].node.offsetHeight;\r\n  }\r\n\r\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\r\n  // view, so that we don\'t interleave reading and writing to the DOM.\r\n  function getDimensions(cm) {\r\n    var d = cm.display, left = {}, width = {};\r\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\r\n      left[cm.options.gutters[i]] = n.offsetLeft;\r\n      width[cm.options.gutters[i]] = n.offsetWidth;\r\n    }\r\n    return {fixedPos: compensateForHScroll(d),\r\n            gutterTotalWidth: d.gutters.offsetWidth,\r\n            gutterLeft: left,\r\n            gutterWidth: width,\r\n            wrapperWidth: d.wrapper.clientWidth};\r\n  }\r\n\r\n  // Sync the actual display DOM structure with display.view, removing\r\n  // nodes for lines that are no longer in view, and creating the ones\r\n  // that are not there yet, and updating the ones that are out of\r\n  // date.\r\n  function patchDisplay(cm, updateNumbersFrom, dims) {\r\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\r\n    var container = display.lineDiv, cur = container.firstChild;\r\n\r\n    function rm(node) {\r\n      var next = node.nextSibling;\r\n      // Works around a throw-scroll bug in OS X Webkit\r\n      if (webkit && mac && cm.display.currentWheelTarget == node)\r\n        node.style.display = "none";\r\n      else\r\n        node.parentNode.removeChild(node);\r\n      return next;\r\n    }\r\n\r\n    var view = display.view, lineN = display.viewFrom;\r\n    // Loop over the elements in the view, syncing cur (the DOM nodes\r\n    // in display.lineDiv) with the view as we go.\r\n    for (var i = 0; i < view.length; i++) {\r\n      var lineView = view[i];\r\n      if (lineView.hidden) {\r\n      } else if (!lineView.node) { // Not drawn yet\r\n        var node = buildLineElement(cm, lineView, lineN, dims);\r\n        container.insertBefore(node, cur);\r\n      } else { // Already drawn\r\n        while (cur != lineView.node) cur = rm(cur);\r\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\r\n          updateNumbersFrom <= lineN && lineView.lineNumber;\r\n        if (lineView.changes) {\r\n          if (indexOf(lineView.changes, "gutter") > -1) updateNumber = false;\r\n          updateLineForChanges(cm, lineView, lineN, dims);\r\n        }\r\n        if (updateNumber) {\r\n          removeChildren(lineView.lineNumber);\r\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\r\n        }\r\n        cur = lineView.node.nextSibling;\r\n      }\r\n      lineN += lineView.size;\r\n    }\r\n    while (cur) cur = rm(cur);\r\n  }\r\n\r\n  // When an aspect of a line changes, a string is added to\r\n  // lineView.changes. This updates the relevant part of the line\'s\r\n  // DOM structure.\r\n  function updateLineForChanges(cm, lineView, lineN, dims) {\r\n    for (var j = 0; j < lineView.changes.length; j++) {\r\n      var type = lineView.changes[j];\r\n      if (type == "text") updateLineText(cm, lineView);\r\n      else if (type == "gutter") updateLineGutter(cm, lineView, lineN, dims);\r\n      else if (type == "class") updateLineClasses(lineView);\r\n      else if (type == "widget") updateLineWidgets(lineView, dims);\r\n    }\r\n    lineView.changes = null;\r\n  }\r\n\r\n  // Lines with gutter elements, widgets or a background class need to\r\n  // be wrapped, and have the extra elements added to the wrapper div\r\n  function ensureLineWrapped(lineView) {\r\n    if (lineView.node == lineView.text) {\r\n      lineView.node = elt("div", null, null, "position: relative");\r\n      if (lineView.text.parentNode)\r\n        lineView.text.parentNode.replaceChild(lineView.node, lineView.text);\r\n      lineView.node.appendChild(lineView.text);\r\n      if (ie && ie_version < 8) lineView.node.style.zIndex = 2;\r\n    }\r\n    return lineView.node;\r\n  }\r\n\r\n  function updateLineBackground(lineView) {\r\n    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;\r\n    if (cls) cls += " CodeMirror-linebackground";\r\n    if (lineView.background) {\r\n      if (cls) lineView.background.className = cls;\r\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\r\n    } else if (cls) {\r\n      var wrap = ensureLineWrapped(lineView);\r\n      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);\r\n    }\r\n  }\r\n\r\n  // Wrapper around buildLineContent which will reuse the structure\r\n  // in display.externalMeasured when possible.\r\n  function getLineContent(cm, lineView) {\r\n    var ext = cm.display.externalMeasured;\r\n    if (ext && ext.line == lineView.line) {\r\n      cm.display.externalMeasured = null;\r\n      lineView.measure = ext.measure;\r\n      return ext.built;\r\n    }\r\n    return buildLineContent(cm, lineView);\r\n  }\r\n\r\n  // Redraw the line\'s text. Interacts with the background and text\r\n  // classes because the mode may output tokens that influence these\r\n  // classes.\r\n  function updateLineText(cm, lineView) {\r\n    var cls = lineView.text.className;\r\n    var built = getLineContent(cm, lineView);\r\n    if (lineView.text == lineView.node) lineView.node = built.pre;\r\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\r\n    lineView.text = built.pre;\r\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\r\n      lineView.bgClass = built.bgClass;\r\n      lineView.textClass = built.textClass;\r\n      updateLineClasses(lineView);\r\n    } else if (cls) {\r\n      lineView.text.className = cls;\r\n    }\r\n  }\r\n\r\n  function updateLineClasses(lineView) {\r\n    updateLineBackground(lineView);\r\n    if (lineView.line.wrapClass)\r\n      ensureLineWrapped(lineView).className = lineView.line.wrapClass;\r\n    else if (lineView.node != lineView.text)\r\n      lineView.node.className = "";\r\n    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;\r\n    lineView.text.className = textClass || "";\r\n  }\r\n\r\n  function updateLineGutter(cm, lineView, lineN, dims) {\r\n    if (lineView.gutter) {\r\n      lineView.node.removeChild(lineView.gutter);\r\n      lineView.gutter = null;\r\n    }\r\n    var markers = lineView.line.gutterMarkers;\r\n    if (cm.options.lineNumbers || markers) {\r\n      var wrap = ensureLineWrapped(lineView);\r\n      var gutterWrap = lineView.gutter =\r\n        wrap.insertBefore(elt("div", null, "CodeMirror-gutter-wrapper", "position: absolute; left: " +\r\n                              (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"),\r\n                          lineView.text);\r\n      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))\r\n        lineView.lineNumber = gutterWrap.appendChild(\r\n          elt("div", lineNumberFor(cm.options, lineN),\r\n              "CodeMirror-linenumber CodeMirror-gutter-elt",\r\n              "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: "\r\n              + cm.display.lineNumInnerWidth + "px"));\r\n      if (markers) for (var k = 0; k < cm.options.gutters.length; ++k) {\r\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\r\n        if (found)\r\n          gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " +\r\n                                     dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));\r\n      }\r\n    }\r\n  }\r\n\r\n  function updateLineWidgets(lineView, dims) {\r\n    if (lineView.alignable) lineView.alignable = null;\r\n    for (var node = lineView.node.firstChild, next; node; node = next) {\r\n      var next = node.nextSibling;\r\n      if (node.className == "CodeMirror-linewidget")\r\n        lineView.node.removeChild(node);\r\n    }\r\n    insertLineWidgets(lineView, dims);\r\n  }\r\n\r\n  // Build a line\'s DOM representation from scratch\r\n  function buildLineElement(cm, lineView, lineN, dims) {\r\n    var built = getLineContent(cm, lineView);\r\n    lineView.text = lineView.node = built.pre;\r\n    if (built.bgClass) lineView.bgClass = built.bgClass;\r\n    if (built.textClass) lineView.textClass = built.textClass;\r\n\r\n    updateLineClasses(lineView);\r\n    updateLineGutter(cm, lineView, lineN, dims);\r\n    insertLineWidgets(lineView, dims);\r\n    return lineView.node;\r\n  }\r\n\r\n  // A lineView may contain multiple logical lines (when merged by\r\n  // collapsed spans). The widgets for all of them need to be drawn.\r\n  function insertLineWidgets(lineView, dims) {\r\n    insertLineWidgetsFor(lineView.line, lineView, dims, true);\r\n    if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\r\n      insertLineWidgetsFor(lineView.rest[i], lineView, dims, false);\r\n  }\r\n\r\n  function insertLineWidgetsFor(line, lineView, dims, allowAbove) {\r\n    if (!line.widgets) return;\r\n    var wrap = ensureLineWrapped(lineView);\r\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\r\n      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget");\r\n      if (!widget.handleMouseEvents) node.ignoreEvents = true;\r\n      positionLineWidget(widget, node, lineView, dims);\r\n      if (allowAbove && widget.above)\r\n        wrap.insertBefore(node, lineView.gutter || lineView.text);\r\n      else\r\n        wrap.appendChild(node);\r\n      signalLater(widget, "redraw");\r\n    }\r\n  }\r\n\r\n  function positionLineWidget(widget, node, lineView, dims) {\r\n    if (widget.noHScroll) {\r\n      (lineView.alignable || (lineView.alignable = [])).push(node);\r\n      var width = dims.wrapperWidth;\r\n      node.style.left = dims.fixedPos + "px";\r\n      if (!widget.coverGutter) {\r\n        width -= dims.gutterTotalWidth;\r\n        node.style.paddingLeft = dims.gutterTotalWidth + "px";\r\n      }\r\n      node.style.width = width + "px";\r\n    }\r\n    if (widget.coverGutter) {\r\n      node.style.zIndex = 5;\r\n      node.style.position = "relative";\r\n      if (!widget.noHScroll) node.style.marginLeft = -dims.gutterTotalWidth + "px";\r\n    }\r\n  }\r\n\r\n  // POSITION OBJECT\r\n\r\n  // A Pos instance represents a position within the text.\r\n  var Pos = CodeMirror.Pos = function(line, ch) {\r\n    if (!(this instanceof Pos)) return new Pos(line, ch);\r\n    this.line = line; this.ch = ch;\r\n  };\r\n\r\n  // Compare two positions, return 0 if they are the same, a negative\r\n  // number when a is less, and a positive number otherwise.\r\n  var cmp = CodeMirror.cmpPos = function(a, b) { return a.line - b.line || a.ch - b.ch; };\r\n\r\n  function copyPos(x) {return Pos(x.line, x.ch);}\r\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a; }\r\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b; }\r\n\r\n  // SELECTION / CURSOR\r\n\r\n  // Selection objects are immutable. A new one is created every time\r\n  // the selection changes. A selection is one or more non-overlapping\r\n  // (and non-touching) ranges, sorted, and an integer that indicates\r\n  // which one is the primary selection (the one that\'s scrolled into\r\n  // view, that getCursor returns, etc).\r\n  function Selection(ranges, primIndex) {\r\n    this.ranges = ranges;\r\n    this.primIndex = primIndex;\r\n  }\r\n\r\n  Selection.prototype = {\r\n    primary: function() { return this.ranges[this.primIndex]; },\r\n    equals: function(other) {\r\n      if (other == this) return true;\r\n      if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return false;\r\n      for (var i = 0; i < this.ranges.length; i++) {\r\n        var here = this.ranges[i], there = other.ranges[i];\r\n        if (cmp(here.anchor, there.anchor) != 0 || cmp(here.head, there.head) != 0) return false;\r\n      }\r\n      return true;\r\n    },\r\n    deepCopy: function() {\r\n      for (var out = [], i = 0; i < this.ranges.length; i++)\r\n        out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head));\r\n      return new Selection(out, this.primIndex);\r\n    },\r\n    somethingSelected: function() {\r\n      for (var i = 0; i < this.ranges.length; i++)\r\n        if (!this.ranges[i].empty()) return true;\r\n      return false;\r\n    },\r\n    contains: function(pos, end) {\r\n      if (!end) end = pos;\r\n      for (var i = 0; i < this.ranges.length; i++) {\r\n        var range = this.ranges[i];\r\n        if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\r\n          return i;\r\n      }\r\n      return -1;\r\n    }\r\n  };\r\n\r\n  function Range(anchor, head) {\r\n    this.anchor = anchor; this.head = head;\r\n  }\r\n\r\n  Range.prototype = {\r\n    from: function() { return minPos(this.anchor, this.head); },\r\n    to: function() { return maxPos(this.anchor, this.head); },\r\n    empty: function() {\r\n      return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;\r\n    }\r\n  };\r\n\r\n  // Take an unsorted, potentially overlapping set of ranges, and\r\n  // build a selection out of it. \'Consumes\' ranges array (modifying\r\n  // it).\r\n  function normalizeSelection(ranges, primIndex) {\r\n    var prim = ranges[primIndex];\r\n    ranges.sort(function(a, b) { return cmp(a.from(), b.from()); });\r\n    primIndex = indexOf(ranges, prim);\r\n    for (var i = 1; i < ranges.length; i++) {\r\n      var cur = ranges[i], prev = ranges[i - 1];\r\n      if (cmp(prev.to(), cur.from()) >= 0) {\r\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\r\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\r\n        if (i <= primIndex) --primIndex;\r\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\r\n      }\r\n    }\r\n    return new Selection(ranges, primIndex);\r\n  }\r\n\r\n  function simpleSelection(anchor, head) {\r\n    return new Selection([new Range(anchor, head || anchor)], 0);\r\n  }\r\n\r\n  // Most of the external API clips given positions to make sure they\r\n  // actually exist within the document.\r\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));}\r\n  function clipPos(doc, pos) {\r\n    if (pos.line < doc.first) return Pos(doc.first, 0);\r\n    var last = doc.first + doc.size - 1;\r\n    if (pos.line > last) return Pos(last, getLine(doc, last).text.length);\r\n    return clipToLen(pos, getLine(doc, pos.line).text.length);\r\n  }\r\n  function clipToLen(pos, linelen) {\r\n    var ch = pos.ch;\r\n    if (ch == null || ch > linelen) return Pos(pos.line, linelen);\r\n    else if (ch < 0) return Pos(pos.line, 0);\r\n    else return pos;\r\n  }\r\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size;}\r\n  function clipPosArray(doc, array) {\r\n    for (var out = [], i = 0; i < array.length; i++) out[i] = clipPos(doc, array[i]);\r\n    return out;\r\n  }\r\n\r\n  // SELECTION UPDATES\r\n\r\n  // The \'scroll\' parameter given to many of these indicated whether\r\n  // the new cursor position should be scrolled into view after\r\n  // modifying the selection.\r\n\r\n  // If shift is held or the extend flag is set, extends a range to\r\n  // include a given position (and optionally a second position).\r\n  // Otherwise, simply returns the range between the given positions.\r\n  // Used for cursor motion and such.\r\n  function extendRange(doc, range, head, other) {\r\n    if (doc.cm && doc.cm.display.shift || doc.extend) {\r\n      var anchor = range.anchor;\r\n      if (other) {\r\n        var posBefore = cmp(head, anchor) < 0;\r\n        if (posBefore != (cmp(other, anchor) < 0)) {\r\n          anchor = head;\r\n          head = other;\r\n        } else if (posBefore != (cmp(head, other) < 0)) {\r\n          head = other;\r\n        }\r\n      }\r\n      return new Range(anchor, head);\r\n    } else {\r\n      return new Range(other || head, head);\r\n    }\r\n  }\r\n\r\n  // Extend the primary selection range, discard the rest.\r\n  function extendSelection(doc, head, other, options) {\r\n    setSelection(doc, new Selection([extendRange(doc, doc.sel.primary(), head, other)], 0), options);\r\n  }\r\n\r\n  // Extend all selections (pos is an array of selections with length\r\n  // equal the number of selections)\r\n  function extendSelections(doc, heads, options) {\r\n    for (var out = [], i = 0; i < doc.sel.ranges.length; i++)\r\n      out[i] = extendRange(doc, doc.sel.ranges[i], heads[i], null);\r\n    var newSel = normalizeSelection(out, doc.sel.primIndex);\r\n    setSelection(doc, newSel, options);\r\n  }\r\n\r\n  // Updates a single range in the selection.\r\n  function replaceOneSelection(doc, i, range, options) {\r\n    var ranges = doc.sel.ranges.slice(0);\r\n    ranges[i] = range;\r\n    setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options);\r\n  }\r\n\r\n  // Reset the selection to a single range.\r\n  function setSimpleSelection(doc, anchor, head, options) {\r\n    setSelection(doc, simpleSelection(anchor, head), options);\r\n  }\r\n\r\n  // Give beforeSelectionChange handlers a change to influence a\r\n  // selection update.\r\n  function filterSelectionChange(doc, sel) {\r\n    var obj = {\r\n      ranges: sel.ranges,\r\n      update: function(ranges) {\r\n        this.ranges = [];\r\n        for (var i = 0; i < ranges.length; i++)\r\n          this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\r\n                                     clipPos(doc, ranges[i].head));\r\n      }\r\n    };\r\n    signal(doc, "beforeSelectionChange", doc, obj);\r\n    if (doc.cm) signal(doc.cm, "beforeSelectionChange", doc.cm, obj);\r\n    if (obj.ranges != sel.ranges) return normalizeSelection(obj.ranges, obj.ranges.length - 1);\r\n    else return sel;\r\n  }\r\n\r\n  function setSelectionReplaceHistory(doc, sel, options) {\r\n    var done = doc.history.done, last = lst(done);\r\n    if (last && last.ranges) {\r\n      done[done.length - 1] = sel;\r\n      setSelectionNoUndo(doc, sel, options);\r\n    } else {\r\n      setSelection(doc, sel, options);\r\n    }\r\n  }\r\n\r\n  // Set a new selection.\r\n  function setSelection(doc, sel, options) {\r\n    setSelectionNoUndo(doc, sel, options);\r\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\r\n  }\r\n\r\n  function setSelectionNoUndo(doc, sel, options) {\r\n    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))\r\n      sel = filterSelectionChange(doc, sel);\r\n\r\n    var bias = options && options.bias ||\r\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\r\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\r\n\r\n    if (!(options && options.scroll === false) && doc.cm)\r\n      ensureCursorVisible(doc.cm);\r\n  }\r\n\r\n  function setSelectionInner(doc, sel) {\r\n    if (sel.equals(doc.sel)) return;\r\n\r\n    doc.sel = sel;\r\n\r\n    if (doc.cm) {\r\n      doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = true;\r\n      signalCursorActivity(doc.cm);\r\n    }\r\n    signalLater(doc, "cursorActivity", doc);\r\n  }\r\n\r\n  // Verify that the selection does not partially select any atomic\r\n  // marked ranges.\r\n  function reCheckSelection(doc) {\r\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false), sel_dontScroll);\r\n  }\r\n\r\n  // Return a selection that does not partially select any atomic\r\n  // ranges.\r\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\r\n    var out;\r\n    for (var i = 0; i < sel.ranges.length; i++) {\r\n      var range = sel.ranges[i];\r\n      var newAnchor = skipAtomic(doc, range.anchor, bias, mayClear);\r\n      var newHead = skipAtomic(doc, range.head, bias, mayClear);\r\n      if (out || newAnchor != range.anchor || newHead != range.head) {\r\n        if (!out) out = sel.ranges.slice(0, i);\r\n        out[i] = new Range(newAnchor, newHead);\r\n      }\r\n    }\r\n    return out ? normalizeSelection(out, sel.primIndex) : sel;\r\n  }\r\n\r\n  // Ensure a given position is not inside an atomic range.\r\n  function skipAtomic(doc, pos, bias, mayClear) {\r\n    var flipped = false, curPos = pos;\r\n    var dir = bias || 1;\r\n    doc.cantEdit = false;\r\n    search: for (;;) {\r\n      var line = getLine(doc, curPos.line);\r\n      if (line.markedSpans) {\r\n        for (var i = 0; i < line.markedSpans.length; ++i) {\r\n          var sp = line.markedSpans[i], m = sp.marker;\r\n          if ((sp.from == null || (m.inclusiveLeft ? sp.from <= curPos.ch : sp.from < curPos.ch)) &&\r\n              (sp.to == null || (m.inclusiveRight ? sp.to >= curPos.ch : sp.to > curPos.ch))) {\r\n            if (mayClear) {\r\n              signal(m, "beforeCursorEnter");\r\n              if (m.explicitlyCleared) {\r\n                if (!line.markedSpans) break;\r\n                else {--i; continue;}\r\n              }\r\n            }\r\n            if (!m.atomic) continue;\r\n            var newPos = m.find(dir < 0 ? -1 : 1);\r\n            if (cmp(newPos, curPos) == 0) {\r\n              newPos.ch += dir;\r\n              if (newPos.ch < 0) {\r\n                if (newPos.line > doc.first) newPos = clipPos(doc, Pos(newPos.line - 1));\r\n                else newPos = null;\r\n              } else if (newPos.ch > line.text.length) {\r\n                if (newPos.line < doc.first + doc.size - 1) newPos = Pos(newPos.line + 1, 0);\r\n                else newPos = null;\r\n              }\r\n              if (!newPos) {\r\n                if (flipped) {\r\n                  // Driven in a corner -- no valid cursor position found at all\r\n                  // -- try again *with* clearing, if we didn\'t already\r\n                  if (!mayClear) return skipAtomic(doc, pos, bias, true);\r\n                  // Otherwise, turn off editing until further notice, and return the start of the doc\r\n                  doc.cantEdit = true;\r\n                  return Pos(doc.first, 0);\r\n                }\r\n                flipped = true; newPos = pos; dir = -dir;\r\n              }\r\n            }\r\n            curPos = newPos;\r\n            continue search;\r\n          }\r\n        }\r\n      }\r\n      return curPos;\r\n    }\r\n  }\r\n\r\n  // SELECTION DRAWING\r\n\r\n  // Redraw the selection and/or cursor\r\n  function drawSelection(cm) {\r\n    var display = cm.display, doc = cm.doc, result = {};\r\n    var curFragment = result.cursors = document.createDocumentFragment();\r\n    var selFragment = result.selection = document.createDocumentFragment();\r\n\r\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n      var range = doc.sel.ranges[i];\r\n      var collapsed = range.empty();\r\n      if (collapsed || cm.options.showCursorWhenSelecting)\r\n        drawSelectionCursor(cm, range, curFragment);\r\n      if (!collapsed)\r\n        drawSelectionRange(cm, range, selFragment);\r\n    }\r\n\r\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\r\n    if (cm.options.moveInputWithCursor) {\r\n      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");\r\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\r\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\r\n                                          headPos.top + lineOff.top - wrapOff.top));\r\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\r\n                                           headPos.left + lineOff.left - wrapOff.left));\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  function showSelection(cm, drawn) {\r\n    removeChildrenAndAdd(cm.display.cursorDiv, drawn.cursors);\r\n    removeChildrenAndAdd(cm.display.selectionDiv, drawn.selection);\r\n    if (drawn.teTop != null) {\r\n      cm.display.inputDiv.style.top = drawn.teTop + "px";\r\n      cm.display.inputDiv.style.left = drawn.teLeft + "px";\r\n    }\r\n  }\r\n\r\n  function updateSelection(cm) {\r\n    showSelection(cm, drawSelection(cm));\r\n  }\r\n\r\n  // Draws a cursor for the given range\r\n  function drawSelectionCursor(cm, range, output) {\r\n    var pos = cursorCoords(cm, range.head, "div", null, null, !cm.options.singleCursorHeightPerLine);\r\n\r\n    var cursor = output.appendChild(elt("div", "\\u00a0", "CodeMirror-cursor"));\r\n    cursor.style.left = pos.left + "px";\r\n    cursor.style.top = pos.top + "px";\r\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";\r\n\r\n    if (pos.other) {\r\n      // Secondary cursor, shown when on a \'jump\' in bi-directional text\r\n      var otherCursor = output.appendChild(elt("div", "\\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));\r\n      otherCursor.style.display = "";\r\n      otherCursor.style.left = pos.other.left + "px";\r\n      otherCursor.style.top = pos.other.top + "px";\r\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";\r\n    }\r\n  }\r\n\r\n  // Draws the given range as a highlighted selection\r\n  function drawSelectionRange(cm, range, output) {\r\n    var display = cm.display, doc = cm.doc;\r\n    var fragment = document.createDocumentFragment();\r\n    var padding = paddingH(cm.display), leftSide = padding.left, rightSide = display.lineSpace.offsetWidth - padding.right;\r\n\r\n    function add(left, top, width, bottom) {\r\n      if (top < 0) top = 0;\r\n      top = Math.round(top);\r\n      bottom = Math.round(bottom);\r\n      fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left +\r\n                               "px; top: " + top + "px; width: " + (width == null ? rightSide - left : width) +\r\n                               "px; height: " + (bottom - top) + "px"));\r\n    }\r\n\r\n    function drawForLine(line, fromArg, toArg) {\r\n      var lineObj = getLine(doc, line);\r\n      var lineLen = lineObj.text.length;\r\n      var start, end;\r\n      function coords(ch, bias) {\r\n        return charCoords(cm, Pos(line, ch), "div", lineObj, bias);\r\n      }\r\n\r\n      iterateBidiSections(getOrder(lineObj), fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir) {\r\n        var leftPos = coords(from, "left"), rightPos, left, right;\r\n        if (from == to) {\r\n          rightPos = leftPos;\r\n          left = right = leftPos.left;\r\n        } else {\r\n          rightPos = coords(to - 1, "right");\r\n          if (dir == "rtl") { var tmp = leftPos; leftPos = rightPos; rightPos = tmp; }\r\n          left = leftPos.left;\r\n          right = rightPos.right;\r\n        }\r\n        if (fromArg == null && from == 0) left = leftSide;\r\n        if (rightPos.top - leftPos.top > 3) { // Different lines, draw top part\r\n          add(left, leftPos.top, null, leftPos.bottom);\r\n          left = leftSide;\r\n          if (leftPos.bottom < rightPos.top) add(left, leftPos.bottom, null, rightPos.top);\r\n        }\r\n        if (toArg == null && to == lineLen) right = rightSide;\r\n        if (!start || leftPos.top < start.top || leftPos.top == start.top && leftPos.left < start.left)\r\n          start = leftPos;\r\n        if (!end || rightPos.bottom > end.bottom || rightPos.bottom == end.bottom && rightPos.right > end.right)\r\n          end = rightPos;\r\n        if (left < leftSide + 1) left = leftSide;\r\n        add(left, rightPos.top, right - left, rightPos.bottom);\r\n      });\r\n      return {start: start, end: end};\r\n    }\r\n\r\n    var sFrom = range.from(), sTo = range.to();\r\n    if (sFrom.line == sTo.line) {\r\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\r\n    } else {\r\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\r\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\r\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\r\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\r\n      if (singleVLine) {\r\n        if (leftEnd.top < rightStart.top - 2) {\r\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\r\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\r\n        } else {\r\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\r\n        }\r\n      }\r\n      if (leftEnd.bottom < rightStart.top)\r\n        add(leftSide, leftEnd.bottom, null, rightStart.top);\r\n    }\r\n\r\n    output.appendChild(fragment);\r\n  }\r\n\r\n  // Cursor-blinking\r\n  function restartBlink(cm) {\r\n    if (!cm.state.focused) return;\r\n    var display = cm.display;\r\n    clearInterval(display.blinker);\r\n    var on = true;\r\n    display.cursorDiv.style.visibility = "";\r\n    if (cm.options.cursorBlinkRate > 0)\r\n      display.blinker = setInterval(function() {\r\n        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";\r\n      }, cm.options.cursorBlinkRate);\r\n    else if (cm.options.cursorBlinkRate < 0)\r\n      display.cursorDiv.style.visibility = "hidden";\r\n  }\r\n\r\n  // HIGHLIGHT WORKER\r\n\r\n  function startWorker(cm, time) {\r\n    if (cm.doc.mode.startState && cm.doc.frontier < cm.display.viewTo)\r\n      cm.state.highlight.set(time, bind(highlightWorker, cm));\r\n  }\r\n\r\n  function highlightWorker(cm) {\r\n    var doc = cm.doc;\r\n    if (doc.frontier < doc.first) doc.frontier = doc.first;\r\n    if (doc.frontier >= cm.display.viewTo) return;\r\n    var end = +new Date + cm.options.workTime;\r\n    var state = copyState(doc.mode, getStateBefore(cm, doc.frontier));\r\n    var changedLines = [];\r\n\r\n    doc.iter(doc.frontier, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {\r\n      if (doc.frontier >= cm.display.viewFrom) { // Visible\r\n        var oldStyles = line.styles;\r\n        var highlighted = highlightLine(cm, line, state, true);\r\n        line.styles = highlighted.styles;\r\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\r\n        if (newCls) line.styleClasses = newCls;\r\n        else if (oldCls) line.styleClasses = null;\r\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\r\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\r\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];\r\n        if (ischange) changedLines.push(doc.frontier);\r\n        line.stateAfter = copyState(doc.mode, state);\r\n      } else {\r\n        processLine(cm, line.text, state);\r\n        line.stateAfter = doc.frontier % 5 == 0 ? copyState(doc.mode, state) : null;\r\n      }\r\n      ++doc.frontier;\r\n      if (+new Date > end) {\r\n        startWorker(cm, cm.options.workDelay);\r\n        return true;\r\n      }\r\n    });\r\n    if (changedLines.length) runInOp(cm, function() {\r\n      for (var i = 0; i < changedLines.length; i++)\r\n        regLineChange(cm, changedLines[i], "text");\r\n    });\r\n  }\r\n\r\n  // Finds the line to start with when starting a parse. Tries to\r\n  // find a line with a stateAfter, so that it can start with a\r\n  // valid state. If that fails, it returns the line with the\r\n  // smallest indentation, which tends to need the least context to\r\n  // parse correctly.\r\n  function findStartLine(cm, n, precise) {\r\n    var minindent, minline, doc = cm.doc;\r\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\r\n    for (var search = n; search > lim; --search) {\r\n      if (search <= doc.first) return doc.first;\r\n      var line = getLine(doc, search - 1);\r\n      if (line.stateAfter && (!precise || search <= doc.frontier)) return search;\r\n      var indented = countColumn(line.text, null, cm.options.tabSize);\r\n      if (minline == null || minindent > indented) {\r\n        minline = search - 1;\r\n        minindent = indented;\r\n      }\r\n    }\r\n    return minline;\r\n  }\r\n\r\n  function getStateBefore(cm, n, precise) {\r\n    var doc = cm.doc, display = cm.display;\r\n    if (!doc.mode.startState) return true;\r\n    var pos = findStartLine(cm, n, precise), state = pos > doc.first && getLine(doc, pos-1).stateAfter;\r\n    if (!state) state = startState(doc.mode);\r\n    else state = copyState(doc.mode, state);\r\n    doc.iter(pos, n, function(line) {\r\n      processLine(cm, line.text, state);\r\n      var save = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo;\r\n      line.stateAfter = save ? copyState(doc.mode, state) : null;\r\n      ++pos;\r\n    });\r\n    if (precise) doc.frontier = pos;\r\n    return state;\r\n  }\r\n\r\n  // POSITION MEASUREMENT\r\n\r\n  function paddingTop(display) {return display.lineSpace.offsetTop;}\r\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight;}\r\n  function paddingH(display) {\r\n    if (display.cachedPaddingH) return display.cachedPaddingH;\r\n    var e = removeChildrenAndAdd(display.measure, elt("pre", "x"));\r\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\r\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\r\n    if (!isNaN(data.left) && !isNaN(data.right)) display.cachedPaddingH = data;\r\n    return data;\r\n  }\r\n\r\n  // Ensure the lineView.wrapping.heights array is populated. This is\r\n  // an array of bottom offsets for the lines that make up a drawn\r\n  // line. When lineWrapping is on, there might be more than one\r\n  // height.\r\n  function ensureLineHeights(cm, lineView, rect) {\r\n    var wrapping = cm.options.lineWrapping;\r\n    var curWidth = wrapping && cm.display.scroller.clientWidth;\r\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\r\n      var heights = lineView.measure.heights = [];\r\n      if (wrapping) {\r\n        lineView.measure.width = curWidth;\r\n        var rects = lineView.text.firstChild.getClientRects();\r\n        for (var i = 0; i < rects.length - 1; i++) {\r\n          var cur = rects[i], next = rects[i + 1];\r\n          if (Math.abs(cur.bottom - next.bottom) > 2)\r\n            heights.push((cur.bottom + next.top) / 2 - rect.top);\r\n        }\r\n      }\r\n      heights.push(rect.bottom - rect.top);\r\n    }\r\n  }\r\n\r\n  // Find a line map (mapping character offsets to text nodes) and a\r\n  // measurement cache for the given line number. (A line view might\r\n  // contain multiple lines when collapsed ranges are present.)\r\n  function mapFromLineView(lineView, line, lineN) {\r\n    if (lineView.line == line)\r\n      return {map: lineView.measure.map, cache: lineView.measure.cache};\r\n    for (var i = 0; i < lineView.rest.length; i++)\r\n      if (lineView.rest[i] == line)\r\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]};\r\n    for (var i = 0; i < lineView.rest.length; i++)\r\n      if (lineNo(lineView.rest[i]) > lineN)\r\n        return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i], before: true};\r\n  }\r\n\r\n  // Render a line into the hidden node display.externalMeasured. Used\r\n  // when measurement is needed for a line that\'s not in the viewport.\r\n  function updateExternalMeasurement(cm, line) {\r\n    line = visualLine(line);\r\n    var lineN = lineNo(line);\r\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\r\n    view.lineN = lineN;\r\n    var built = view.built = buildLineContent(cm, view);\r\n    view.text = built.pre;\r\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\r\n    return view;\r\n  }\r\n\r\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\r\n  // for a given character.\r\n  function measureChar(cm, line, ch, bias) {\r\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);\r\n  }\r\n\r\n  // Find a line view that corresponds to the given line number.\r\n  function findViewForLine(cm, lineN) {\r\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\r\n      return cm.display.view[findViewIndex(cm, lineN)];\r\n    var ext = cm.display.externalMeasured;\r\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\r\n      return ext;\r\n  }\r\n\r\n  // Measurement can be split in two steps, the set-up work that\r\n  // applies to the whole line, and the measurement of the actual\r\n  // character. Functions like coordsChar, that need to do a lot of\r\n  // measurements in a row, can thus ensure that the set-up work is\r\n  // only done once.\r\n  function prepareMeasureForLine(cm, line) {\r\n    var lineN = lineNo(line);\r\n    var view = findViewForLine(cm, lineN);\r\n    if (view && !view.text)\r\n      view = null;\r\n    else if (view && view.changes)\r\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\r\n    if (!view)\r\n      view = updateExternalMeasurement(cm, line);\r\n\r\n    var info = mapFromLineView(view, line, lineN);\r\n    return {\r\n      line: line, view: view, rect: null,\r\n      map: info.map, cache: info.cache, before: info.before,\r\n      hasHeights: false\r\n    };\r\n  }\r\n\r\n  // Given a prepared measurement object, measures the position of an\r\n  // actual character (or fetches it from the cache).\r\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\r\n    if (prepared.before) ch = -1;\r\n    var key = ch + (bias || ""), found;\r\n    if (prepared.cache.hasOwnProperty(key)) {\r\n      found = prepared.cache[key];\r\n    } else {\r\n      if (!prepared.rect)\r\n        prepared.rect = prepared.view.text.getBoundingClientRect();\r\n      if (!prepared.hasHeights) {\r\n        ensureLineHeights(cm, prepared.view, prepared.rect);\r\n        prepared.hasHeights = true;\r\n      }\r\n      found = measureCharInner(cm, prepared, ch, bias);\r\n      if (!found.bogus) prepared.cache[key] = found;\r\n    }\r\n    return {left: found.left, right: found.right,\r\n            top: varHeight ? found.rtop : found.top,\r\n            bottom: varHeight ? found.rbottom : found.bottom};\r\n  }\r\n\r\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\r\n\r\n  function measureCharInner(cm, prepared, ch, bias) {\r\n    var map = prepared.map;\r\n\r\n    var node, start, end, collapse;\r\n    // First, search the line map for the text node corresponding to,\r\n    // or closest to, the target character.\r\n    for (var i = 0; i < map.length; i += 3) {\r\n      var mStart = map[i], mEnd = map[i + 1];\r\n      if (ch < mStart) {\r\n        start = 0; end = 1;\r\n        collapse = "left";\r\n      } else if (ch < mEnd) {\r\n        start = ch - mStart;\r\n        end = start + 1;\r\n      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {\r\n        end = mEnd - mStart;\r\n        start = end - 1;\r\n        if (ch >= mEnd) collapse = "right";\r\n      }\r\n      if (start != null) {\r\n        node = map[i + 2];\r\n        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))\r\n          collapse = bias;\r\n        if (bias == "left" && start == 0)\r\n          while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {\r\n            node = map[(i -= 3) + 2];\r\n            collapse = "left";\r\n          }\r\n        if (bias == "right" && start == mEnd - mStart)\r\n          while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {\r\n            node = map[(i += 3) + 2];\r\n            collapse = "right";\r\n          }\r\n        break;\r\n      }\r\n    }\r\n\r\n    var rect;\r\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\r\n      for (var i = 0; i < 4; i++) { // Retry a maximum of 4 times when nonsense rectangles are returned\r\n        while (start && isExtendingChar(prepared.line.text.charAt(mStart + start))) --start;\r\n        while (mStart + end < mEnd && isExtendingChar(prepared.line.text.charAt(mStart + end))) ++end;\r\n        if (ie && ie_version < 9 && start == 0 && end == mEnd - mStart) {\r\n          rect = node.parentNode.getBoundingClientRect();\r\n        } else if (ie && cm.options.lineWrapping) {\r\n          var rects = range(node, start, end).getClientRects();\r\n          if (rects.length)\r\n            rect = rects[bias == "right" ? rects.length - 1 : 0];\r\n          else\r\n            rect = nullRect;\r\n        } else {\r\n          rect = range(node, start, end).getBoundingClientRect() || nullRect;\r\n        }\r\n        if (rect.left || rect.right || start == 0) break;\r\n        end = start;\r\n        start = start - 1;\r\n        collapse = "right";\r\n      }\r\n      if (ie && ie_version < 11) rect = maybeUpdateRectForZooming(cm.display.measure, rect);\r\n    } else { // If it is a widget, simply get the box for the whole widget.\r\n      if (start > 0) collapse = bias = "right";\r\n      var rects;\r\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\r\n        rect = rects[bias == "right" ? rects.length - 1 : 0];\r\n      else\r\n        rect = node.getBoundingClientRect();\r\n    }\r\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\r\n      var rSpan = node.parentNode.getClientRects()[0];\r\n      if (rSpan)\r\n        rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom};\r\n      else\r\n        rect = nullRect;\r\n    }\r\n\r\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\r\n    var mid = (rtop + rbot) / 2;\r\n    var heights = prepared.view.measure.heights;\r\n    for (var i = 0; i < heights.length - 1; i++)\r\n      if (mid < heights[i]) break;\r\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\r\n    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,\r\n                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,\r\n                  top: top, bottom: bot};\r\n    if (!rect.left && !rect.right) result.bogus = true;\r\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\r\n\r\n    return result;\r\n  }\r\n\r\n  // Work around problem with bounding client rects on ranges being\r\n  // returned incorrectly when zoomed on IE10 and below.\r\n  function maybeUpdateRectForZooming(measure, rect) {\r\n    if (!window.screen || screen.logicalXDPI == null ||\r\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\r\n      return rect;\r\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\r\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\r\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\r\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY};\r\n  }\r\n\r\n  function clearLineMeasurementCacheFor(lineView) {\r\n    if (lineView.measure) {\r\n      lineView.measure.cache = {};\r\n      lineView.measure.heights = null;\r\n      if (lineView.rest) for (var i = 0; i < lineView.rest.length; i++)\r\n        lineView.measure.caches[i] = {};\r\n    }\r\n  }\r\n\r\n  function clearLineMeasurementCache(cm) {\r\n    cm.display.externalMeasure = null;\r\n    removeChildren(cm.display.lineMeasure);\r\n    for (var i = 0; i < cm.display.view.length; i++)\r\n      clearLineMeasurementCacheFor(cm.display.view[i]);\r\n  }\r\n\r\n  function clearCaches(cm) {\r\n    clearLineMeasurementCache(cm);\r\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\r\n    if (!cm.options.lineWrapping) cm.display.maxLineChanged = true;\r\n    cm.display.lineNumChars = null;\r\n  }\r\n\r\n  function pageScrollX() { return window.pageXOffset || (document.documentElement || document.body).scrollLeft; }\r\n  function pageScrollY() { return window.pageYOffset || (document.documentElement || document.body).scrollTop; }\r\n\r\n  // Converts a {top, bottom, left, right} box from line-local\r\n  // coordinates into another coordinate system. Context may be one of\r\n  // "line", "div" (display.lineDiv), "local"/null (editor), or "page".\r\n  function intoCoordSystem(cm, lineObj, rect, context) {\r\n    if (lineObj.widgets) for (var i = 0; i < lineObj.widgets.length; ++i) if (lineObj.widgets[i].above) {\r\n      var size = widgetHeight(lineObj.widgets[i]);\r\n      rect.top += size; rect.bottom += size;\r\n    }\r\n    if (context == "line") return rect;\r\n    if (!context) context = "local";\r\n    var yOff = heightAtLine(lineObj);\r\n    if (context == "local") yOff += paddingTop(cm.display);\r\n    else yOff -= cm.display.viewOffset;\r\n    if (context == "page" || context == "window") {\r\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\r\n      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());\r\n      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());\r\n      rect.left += xOff; rect.right += xOff;\r\n    }\r\n    rect.top += yOff; rect.bottom += yOff;\r\n    return rect;\r\n  }\r\n\r\n  // Coverts a box from "div" coords to another coordinate system.\r\n  // Context may be "window", "page", "div", or "local"/null.\r\n  function fromCoordSystem(cm, coords, context) {\r\n    if (context == "div") return coords;\r\n    var left = coords.left, top = coords.top;\r\n    // First move into "page" coordinate system\r\n    if (context == "page") {\r\n      left -= pageScrollX();\r\n      top -= pageScrollY();\r\n    } else if (context == "local" || !context) {\r\n      var localBox = cm.display.sizer.getBoundingClientRect();\r\n      left += localBox.left;\r\n      top += localBox.top;\r\n    }\r\n\r\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\r\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top};\r\n  }\r\n\r\n  function charCoords(cm, pos, context, lineObj, bias) {\r\n    if (!lineObj) lineObj = getLine(cm.doc, pos.line);\r\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);\r\n  }\r\n\r\n  // Returns a box for a given cursor position, which may have an\r\n  // \'other\' property containing the position of the secondary cursor\r\n  // on a bidi boundary.\r\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\r\n    lineObj = lineObj || getLine(cm.doc, pos.line);\r\n    if (!preparedMeasure) preparedMeasure = prepareMeasureForLine(cm, lineObj);\r\n    function get(ch, right) {\r\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);\r\n      if (right) m.left = m.right; else m.right = m.left;\r\n      return intoCoordSystem(cm, lineObj, m, context);\r\n    }\r\n    function getBidi(ch, partPos) {\r\n      var part = order[partPos], right = part.level % 2;\r\n      if (ch == bidiLeft(part) && partPos && part.level < order[partPos - 1].level) {\r\n        part = order[--partPos];\r\n        ch = bidiRight(part) - (part.level % 2 ? 0 : 1);\r\n        right = true;\r\n      } else if (ch == bidiRight(part) && partPos < order.length - 1 && part.level < order[partPos + 1].level) {\r\n        part = order[++partPos];\r\n        ch = bidiLeft(part) - part.level % 2;\r\n        right = false;\r\n      }\r\n      if (right && ch == part.to && ch > part.from) return get(ch - 1);\r\n      return get(ch, right);\r\n    }\r\n    var order = getOrder(lineObj), ch = pos.ch;\r\n    if (!order) return get(ch);\r\n    var partPos = getBidiPartAt(order, ch);\r\n    var val = getBidi(ch, partPos);\r\n    if (bidiOther != null) val.other = getBidi(ch, bidiOther);\r\n    return val;\r\n  }\r\n\r\n  // Used to cheaply estimate the coordinates for a position. Used for\r\n  // intermediate scroll updates.\r\n  function estimateCoords(cm, pos) {\r\n    var left = 0, pos = clipPos(cm.doc, pos);\r\n    if (!cm.options.lineWrapping) left = charWidth(cm.display) * pos.ch;\r\n    var lineObj = getLine(cm.doc, pos.line);\r\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\r\n    return {left: left, right: left, top: top, bottom: top + lineObj.height};\r\n  }\r\n\r\n  // Positions returned by coordsChar contain some extra information.\r\n  // xRel is the relative x position of the input coordinates compared\r\n  // to the found position (so xRel > 0 means the coordinates are to\r\n  // the right of the character position, for example). When outside\r\n  // is true, that means the coordinates lie outside the line\'s\r\n  // vertical range.\r\n  function PosWithInfo(line, ch, outside, xRel) {\r\n    var pos = Pos(line, ch);\r\n    pos.xRel = xRel;\r\n    if (outside) pos.outside = true;\r\n    return pos;\r\n  }\r\n\r\n  // Compute the character position closest to the given coordinates.\r\n  // Input must be lineSpace-local ("div" coordinate system).\r\n  function coordsChar(cm, x, y) {\r\n    var doc = cm.doc;\r\n    y += cm.display.viewOffset;\r\n    if (y < 0) return PosWithInfo(doc.first, 0, true, -1);\r\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\r\n    if (lineN > last)\r\n      return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, true, 1);\r\n    if (x < 0) x = 0;\r\n\r\n    var lineObj = getLine(doc, lineN);\r\n    for (;;) {\r\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\r\n      var merged = collapsedSpanAtEnd(lineObj);\r\n      var mergedPos = merged && merged.find(0, true);\r\n      if (merged && (found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0))\r\n        lineN = lineNo(lineObj = mergedPos.to.line);\r\n      else\r\n        return found;\r\n    }\r\n  }\r\n\r\n  function coordsCharInner(cm, lineObj, lineNo, x, y) {\r\n    var innerOff = y - heightAtLine(lineObj);\r\n    var wrongLine = false, adjust = 2 * cm.display.wrapper.clientWidth;\r\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\r\n\r\n    function getX(ch) {\r\n      var sp = cursorCoords(cm, Pos(lineNo, ch), "line", lineObj, preparedMeasure);\r\n      wrongLine = true;\r\n      if (innerOff > sp.bottom) return sp.left - adjust;\r\n      else if (innerOff < sp.top) return sp.left + adjust;\r\n      else wrongLine = false;\r\n      return sp.left;\r\n    }\r\n\r\n    var bidi = getOrder(lineObj), dist = lineObj.text.length;\r\n    var from = lineLeft(lineObj), to = lineRight(lineObj);\r\n    var fromX = getX(from), fromOutside = wrongLine, toX = getX(to), toOutside = wrongLine;\r\n\r\n    if (x > toX) return PosWithInfo(lineNo, to, toOutside, 1);\r\n    // Do a binary search between these bounds.\r\n    for (;;) {\r\n      if (bidi ? to == from || to == moveVisually(lineObj, from, 1) : to - from <= 1) {\r\n        var ch = x < fromX || x - fromX <= toX - x ? from : to;\r\n        var xDiff = x - (ch == from ? fromX : toX);\r\n        while (isExtendingChar(lineObj.text.charAt(ch))) ++ch;\r\n        var pos = PosWithInfo(lineNo, ch, ch == from ? fromOutside : toOutside,\r\n                              xDiff < -1 ? -1 : xDiff > 1 ? 1 : 0);\r\n        return pos;\r\n      }\r\n      var step = Math.ceil(dist / 2), middle = from + step;\r\n      if (bidi) {\r\n        middle = from;\r\n        for (var i = 0; i < step; ++i) middle = moveVisually(lineObj, middle, 1);\r\n      }\r\n      var middleX = getX(middle);\r\n      if (middleX > x) {to = middle; toX = middleX; if (toOutside = wrongLine) toX += 1000; dist = step;}\r\n      else {from = middle; fromX = middleX; fromOutside = wrongLine; dist -= step;}\r\n    }\r\n  }\r\n\r\n  var measureText;\r\n  // Compute the default text height.\r\n  function textHeight(display) {\r\n    if (display.cachedTextHeight != null) return display.cachedTextHeight;\r\n    if (measureText == null) {\r\n      measureText = elt("pre");\r\n      // Measure a bunch of lines, for browsers that compute\r\n      // fractional heights.\r\n      for (var i = 0; i < 49; ++i) {\r\n        measureText.appendChild(document.createTextNode("x"));\r\n        measureText.appendChild(elt("br"));\r\n      }\r\n      measureText.appendChild(document.createTextNode("x"));\r\n    }\r\n    removeChildrenAndAdd(display.measure, measureText);\r\n    var height = measureText.offsetHeight / 50;\r\n    if (height > 3) display.cachedTextHeight = height;\r\n    removeChildren(display.measure);\r\n    return height || 1;\r\n  }\r\n\r\n  // Compute the default character width.\r\n  function charWidth(display) {\r\n    if (display.cachedCharWidth != null) return display.cachedCharWidth;\r\n    var anchor = elt("span", "xxxxxxxxxx");\r\n    var pre = elt("pre", [anchor]);\r\n    removeChildrenAndAdd(display.measure, pre);\r\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\r\n    if (width > 2) display.cachedCharWidth = width;\r\n    return width || 10;\r\n  }\r\n\r\n  // OPERATIONS\r\n\r\n  // Operations are used to wrap a series of changes to the editor\r\n  // state in such a way that each change won\'t have to update the\r\n  // cursor and display (which would be awkward, slow, and\r\n  // error-prone). Instead, display updates are batched and then all\r\n  // combined and executed at once.\r\n\r\n  var operationGroup = null;\r\n\r\n  var nextOpId = 0;\r\n  // Start a new operation.\r\n  function startOperation(cm) {\r\n    cm.curOp = {\r\n      cm: cm,\r\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\r\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\r\n      forceUpdate: false,      // Used to force a redraw\r\n      updateInput: null,       // Whether to reset the input textarea\r\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\r\n      changeObjs: null,        // Accumulated changes, for firing change events\r\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\r\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\r\n      selectionChanged: false, // Whether the selection needs to be redrawn\r\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\r\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\r\n      scrollToPos: null,       // Used to scroll to a specific position\r\n      id: ++nextOpId           // Unique ID\r\n    };\r\n    if (operationGroup) {\r\n      operationGroup.ops.push(cm.curOp);\r\n    } else {\r\n      cm.curOp.ownsGroup = operationGroup = {\r\n        ops: [cm.curOp],\r\n        delayedCallbacks: []\r\n      };\r\n    }\r\n  }\r\n\r\n  function fireCallbacksForOps(group) {\r\n    // Calls delayed callbacks and cursorActivity handlers until no\r\n    // new ones appear\r\n    var callbacks = group.delayedCallbacks, i = 0;\r\n    do {\r\n      for (; i < callbacks.length; i++)\r\n        callbacks[i]();\r\n      for (var j = 0; j < group.ops.length; j++) {\r\n        var op = group.ops[j];\r\n        if (op.cursorActivityHandlers)\r\n          while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\r\n            op.cursorActivityHandlers[op.cursorActivityCalled++](op.cm);\r\n      }\r\n    } while (i < callbacks.length);\r\n  }\r\n\r\n  // Finish an operation, updating the display and signalling delayed events\r\n  function endOperation(cm) {\r\n    var op = cm.curOp, group = op.ownsGroup;\r\n    if (!group) return;\r\n\r\n    try { fireCallbacksForOps(group); }\r\n    finally {\r\n      operationGroup = null;\r\n      for (var i = 0; i < group.ops.length; i++)\r\n        group.ops[i].cm.curOp = null;\r\n      endOperations(group);\r\n    }\r\n  }\r\n\r\n  // The DOM updates done when an operation finishes are batched so\r\n  // that the minimum number of relayouts are required.\r\n  function endOperations(group) {\r\n    var ops = group.ops;\r\n    for (var i = 0; i < ops.length; i++) // Read DOM\r\n      endOperation_R1(ops[i]);\r\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\r\n      endOperation_W1(ops[i]);\r\n    for (var i = 0; i < ops.length; i++) // Read DOM\r\n      endOperation_R2(ops[i]);\r\n    for (var i = 0; i < ops.length; i++) // Write DOM (maybe)\r\n      endOperation_W2(ops[i]);\r\n    for (var i = 0; i < ops.length; i++) // Read DOM\r\n      endOperation_finish(ops[i]);\r\n  }\r\n\r\n  function endOperation_R1(op) {\r\n    var cm = op.cm, display = cm.display;\r\n    if (op.updateMaxLine) findMaxLine(cm);\r\n\r\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\r\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\r\n                         op.scrollToPos.to.line >= display.viewTo) ||\r\n      display.maxLineChanged && cm.options.lineWrapping;\r\n    op.update = op.mustUpdate &&\r\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\r\n  }\r\n\r\n  function endOperation_W1(op) {\r\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\r\n  }\r\n\r\n  function endOperation_R2(op) {\r\n    var cm = op.cm, display = cm.display;\r\n    if (op.updatedDisplay) updateHeightsInViewport(cm);\r\n\r\n    op.barMeasure = measureForScrollbars(cm);\r\n\r\n    // If the max line changed since it was last measured, measure it,\r\n    // and ensure the document\'s width matches it.\r\n    // updateDisplay_W2 will use these properties to do the actual resizing\r\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\r\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\r\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo +\r\n                                  scrollerCutOff - display.scroller.clientWidth);\r\n    }\r\n\r\n    if (op.updatedDisplay || op.selectionChanged)\r\n      op.newSelectionNodes = drawSelection(cm);\r\n  }\r\n\r\n  function endOperation_W2(op) {\r\n    var cm = op.cm;\r\n\r\n    if (op.adjustWidthTo != null) {\r\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";\r\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\r\n        setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);\r\n      cm.display.maxLineChanged = false;\r\n    }\r\n\r\n    if (op.newSelectionNodes)\r\n      showSelection(cm, op.newSelectionNodes);\r\n    if (op.updatedDisplay)\r\n      setDocumentHeight(cm, op.barMeasure);\r\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\r\n      updateScrollbars(cm, op.barMeasure);\r\n\r\n    if (op.selectionChanged) restartBlink(cm);\r\n\r\n    if (cm.state.focused && op.updateInput)\r\n      resetInput(cm, op.typing);\r\n  }\r\n\r\n  function endOperation_finish(op) {\r\n    var cm = op.cm, display = cm.display, doc = cm.doc;\r\n\r\n    if (op.adjustWidthTo != null && Math.abs(op.barMeasure.scrollWidth - cm.display.scroller.scrollWidth) > 1)\r\n      updateScrollbars(cm);\r\n\r\n    if (op.updatedDisplay) postUpdateDisplay(cm, op.update);\r\n\r\n    // Abort mouse wheel delta measurement, when scrolling explicitly\r\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\r\n      display.wheelStartX = display.wheelStartY = null;\r\n\r\n    // Propagate the scroll position to the actual DOM scroller\r\n    if (op.scrollTop != null && (display.scroller.scrollTop != op.scrollTop || op.forceScroll)) {\r\n      var top = Math.max(0, Math.min(display.scroller.scrollHeight - display.scroller.clientHeight, op.scrollTop));\r\n      display.scroller.scrollTop = display.scrollbarV.scrollTop = doc.scrollTop = top;\r\n    }\r\n    if (op.scrollLeft != null && (display.scroller.scrollLeft != op.scrollLeft || op.forceScroll)) {\r\n      var left = Math.max(0, Math.min(display.scroller.scrollWidth - display.scroller.clientWidth, op.scrollLeft));\r\n      display.scroller.scrollLeft = display.scrollbarH.scrollLeft = doc.scrollLeft = left;\r\n      alignHorizontally(cm);\r\n    }\r\n    // If we need to scroll a specific position into view, do so.\r\n    if (op.scrollToPos) {\r\n      var coords = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\r\n                                     clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\r\n      if (op.scrollToPos.isCursor && cm.state.focused) maybeScrollWindow(cm, coords);\r\n    }\r\n\r\n    // Fire events for markers that are hidden/unidden by editing or\r\n    // undoing\r\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\r\n    if (hidden) for (var i = 0; i < hidden.length; ++i)\r\n      if (!hidden[i].lines.length) signal(hidden[i], "hide");\r\n    if (unhidden) for (var i = 0; i < unhidden.length; ++i)\r\n      if (unhidden[i].lines.length) signal(unhidden[i], "unhide");\r\n\r\n    if (display.wrapper.offsetHeight)\r\n      doc.scrollTop = cm.display.scroller.scrollTop;\r\n\r\n    // Apply workaround for two webkit bugs\r\n    if (op.updatedDisplay && webkit) {\r\n      if (cm.options.lineWrapping)\r\n        checkForWebkitWidthBug(cm, op.barMeasure); // (Issue #2420)\r\n      if (op.barMeasure.scrollWidth > op.barMeasure.clientWidth &&\r\n          op.barMeasure.scrollWidth < op.barMeasure.clientWidth + 1 &&\r\n          !hScrollbarTakesSpace(cm))\r\n        updateScrollbars(cm); // (Issue #2562)\r\n    }\r\n\r\n    // Fire change events, and delayed event handlers\r\n    if (op.changeObjs)\r\n      signal(cm, "changes", cm, op.changeObjs);\r\n  }\r\n\r\n  // Run the given function in an operation\r\n  function runInOp(cm, f) {\r\n    if (cm.curOp) return f();\r\n    startOperation(cm);\r\n    try { return f(); }\r\n    finally { endOperation(cm); }\r\n  }\r\n  // Wraps a function in an operation. Returns the wrapped function.\r\n  function operation(cm, f) {\r\n    return function() {\r\n      if (cm.curOp) return f.apply(cm, arguments);\r\n      startOperation(cm);\r\n      try { return f.apply(cm, arguments); }\r\n      finally { endOperation(cm); }\r\n    };\r\n  }\r\n  // Used to add methods to editor and doc instances, wrapping them in\r\n  // operations.\r\n  function methodOp(f) {\r\n    return function() {\r\n      if (this.curOp) return f.apply(this, arguments);\r\n      startOperation(this);\r\n      try { return f.apply(this, arguments); }\r\n      finally { endOperation(this); }\r\n    };\r\n  }\r\n  function docMethodOp(f) {\r\n    return function() {\r\n      var cm = this.cm;\r\n      if (!cm || cm.curOp) return f.apply(this, arguments);\r\n      startOperation(cm);\r\n      try { return f.apply(this, arguments); }\r\n      finally { endOperation(cm); }\r\n    };\r\n  }\r\n\r\n  // VIEW TRACKING\r\n\r\n  // These objects are used to represent the visible (currently drawn)\r\n  // part of the document. A LineView may correspond to multiple\r\n  // logical lines, if those are connected by collapsed ranges.\r\n  function LineView(doc, line, lineN) {\r\n    // The starting line\r\n    this.line = line;\r\n    // Continuing lines, if any\r\n    this.rest = visualLineContinued(line);\r\n    // Number of logical lines in this visual line\r\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\r\n    this.node = this.text = null;\r\n    this.hidden = lineIsHidden(doc, line);\r\n  }\r\n\r\n  // Create a range of LineView objects for the given lines.\r\n  function buildViewArray(cm, from, to) {\r\n    var array = [], nextPos;\r\n    for (var pos = from; pos < to; pos = nextPos) {\r\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\r\n      nextPos = pos + view.size;\r\n      array.push(view);\r\n    }\r\n    return array;\r\n  }\r\n\r\n  // Updates the display.view data structure for a given change to the\r\n  // document. From and to are in pre-change coordinates. Lendiff is\r\n  // the amount of lines added or subtracted by the change. This is\r\n  // used for changes that span multiple lines, or change the way\r\n  // lines are divided into visual lines. regLineChange (below)\r\n  // registers single-line changes.\r\n  function regChange(cm, from, to, lendiff) {\r\n    if (from == null) from = cm.doc.first;\r\n    if (to == null) to = cm.doc.first + cm.doc.size;\r\n    if (!lendiff) lendiff = 0;\r\n\r\n    var display = cm.display;\r\n    if (lendiff && to < display.viewTo &&\r\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\r\n      display.updateLineNumbers = from;\r\n\r\n    cm.curOp.viewChanged = true;\r\n\r\n    if (from >= display.viewTo) { // Change after\r\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\r\n        resetView(cm);\r\n    } else if (to <= display.viewFrom) { // Change before\r\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\r\n        resetView(cm);\r\n      } else {\r\n        display.viewFrom += lendiff;\r\n        display.viewTo += lendiff;\r\n      }\r\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\r\n      resetView(cm);\r\n    } else if (from <= display.viewFrom) { // Top overlap\r\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\r\n      if (cut) {\r\n        display.view = display.view.slice(cut.index);\r\n        display.viewFrom = cut.lineN;\r\n        display.viewTo += lendiff;\r\n      } else {\r\n        resetView(cm);\r\n      }\r\n    } else if (to >= display.viewTo) { // Bottom overlap\r\n      var cut = viewCuttingPoint(cm, from, from, -1);\r\n      if (cut) {\r\n        display.view = display.view.slice(0, cut.index);\r\n        display.viewTo = cut.lineN;\r\n      } else {\r\n        resetView(cm);\r\n      }\r\n    } else { // Gap in the middle\r\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\r\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\r\n      if (cutTop && cutBot) {\r\n        display.view = display.view.slice(0, cutTop.index)\r\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\r\n          .concat(display.view.slice(cutBot.index));\r\n        display.viewTo += lendiff;\r\n      } else {\r\n        resetView(cm);\r\n      }\r\n    }\r\n\r\n    var ext = display.externalMeasured;\r\n    if (ext) {\r\n      if (to < ext.lineN)\r\n        ext.lineN += lendiff;\r\n      else if (from < ext.lineN + ext.size)\r\n        display.externalMeasured = null;\r\n    }\r\n  }\r\n\r\n  // Register a change to a single line. Type must be one of "text",\r\n  // "gutter", "class", "widget"\r\n  function regLineChange(cm, line, type) {\r\n    cm.curOp.viewChanged = true;\r\n    var display = cm.display, ext = cm.display.externalMeasured;\r\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\r\n      display.externalMeasured = null;\r\n\r\n    if (line < display.viewFrom || line >= display.viewTo) return;\r\n    var lineView = display.view[findViewIndex(cm, line)];\r\n    if (lineView.node == null) return;\r\n    var arr = lineView.changes || (lineView.changes = []);\r\n    if (indexOf(arr, type) == -1) arr.push(type);\r\n  }\r\n\r\n  // Clear the view.\r\n  function resetView(cm) {\r\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\r\n    cm.display.view = [];\r\n    cm.display.viewOffset = 0;\r\n  }\r\n\r\n  // Find the view element corresponding to a given line. Return null\r\n  // when the line isn\'t visible.\r\n  function findViewIndex(cm, n) {\r\n    if (n >= cm.display.viewTo) return null;\r\n    n -= cm.display.viewFrom;\r\n    if (n < 0) return null;\r\n    var view = cm.display.view;\r\n    for (var i = 0; i < view.length; i++) {\r\n      n -= view[i].size;\r\n      if (n < 0) return i;\r\n    }\r\n  }\r\n\r\n  function viewCuttingPoint(cm, oldN, newN, dir) {\r\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\r\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\r\n      return {index: index, lineN: newN};\r\n    for (var i = 0, n = cm.display.viewFrom; i < index; i++)\r\n      n += view[i].size;\r\n    if (n != oldN) {\r\n      if (dir > 0) {\r\n        if (index == view.length - 1) return null;\r\n        diff = (n + view[index].size) - oldN;\r\n        index++;\r\n      } else {\r\n        diff = n - oldN;\r\n      }\r\n      oldN += diff; newN += diff;\r\n    }\r\n    while (visualLineNo(cm.doc, newN) != newN) {\r\n      if (index == (dir < 0 ? 0 : view.length - 1)) return null;\r\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\r\n      index += dir;\r\n    }\r\n    return {index: index, lineN: newN};\r\n  }\r\n\r\n  // Force the view to cover a given range, adding empty view element\r\n  // or clipping off existing ones as needed.\r\n  function adjustView(cm, from, to) {\r\n    var display = cm.display, view = display.view;\r\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\r\n      display.view = buildViewArray(cm, from, to);\r\n      display.viewFrom = from;\r\n    } else {\r\n      if (display.viewFrom > from)\r\n        display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);\r\n      else if (display.viewFrom < from)\r\n        display.view = display.view.slice(findViewIndex(cm, from));\r\n      display.viewFrom = from;\r\n      if (display.viewTo < to)\r\n        display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));\r\n      else if (display.viewTo > to)\r\n        display.view = display.view.slice(0, findViewIndex(cm, to));\r\n    }\r\n    display.viewTo = to;\r\n  }\r\n\r\n  // Count the number of lines in the view whose DOM representation is\r\n  // out of date (or nonexistent).\r\n  function countDirtyView(cm) {\r\n    var view = cm.display.view, dirty = 0;\r\n    for (var i = 0; i < view.length; i++) {\r\n      var lineView = view[i];\r\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) ++dirty;\r\n    }\r\n    return dirty;\r\n  }\r\n\r\n  // INPUT HANDLING\r\n\r\n  // Poll for input changes, using the normal rate of polling. This\r\n  // runs as long as the editor is focused.\r\n  function slowPoll(cm) {\r\n    if (cm.display.pollingFast) return;\r\n    cm.display.poll.set(cm.options.pollInterval, function() {\r\n      readInput(cm);\r\n      if (cm.state.focused) slowPoll(cm);\r\n    });\r\n  }\r\n\r\n  // When an event has just come in that is likely to add or change\r\n  // something in the input textarea, we poll faster, to ensure that\r\n  // the change appears on the screen quickly.\r\n  function fastPoll(cm) {\r\n    var missed = false;\r\n    cm.display.pollingFast = true;\r\n    function p() {\r\n      var changed = readInput(cm);\r\n      if (!changed && !missed) {missed = true; cm.display.poll.set(60, p);}\r\n      else {cm.display.pollingFast = false; slowPoll(cm);}\r\n    }\r\n    cm.display.poll.set(20, p);\r\n  }\r\n\r\n  // This will be set to an array of strings when copying, so that,\r\n  // when pasting, we know what kind of selections the copied text\r\n  // was made out of.\r\n  var lastCopied = null;\r\n\r\n  // Read input from the textarea, and update the document to match.\r\n  // When something is selected, it is present in the textarea, and\r\n  // selected (unless it is huge, in which case a placeholder is\r\n  // used). When nothing is selected, the cursor sits after previously\r\n  // seen text (can be empty), which is stored in prevInput (we must\r\n  // not reset the textarea when typing, because that breaks IME).\r\n  function readInput(cm) {\r\n    var input = cm.display.input, prevInput = cm.display.prevInput, doc = cm.doc;\r\n    // Since this is called a *lot*, try to bail out as cheaply as\r\n    // possible when it is clear that nothing happened. hasSelection\r\n    // will be the case when there is a lot of text in the textarea,\r\n    // in which case reading its value would be expensive.\r\n    if (!cm.state.focused || (hasSelection(input) && !prevInput) || isReadOnly(cm) || cm.options.disableInput)\r\n      return false;\r\n    // See paste handler for more on the fakedLastChar kludge\r\n    if (cm.state.pasteIncoming && cm.state.fakedLastChar) {\r\n      input.value = input.value.substring(0, input.value.length - 1);\r\n      cm.state.fakedLastChar = false;\r\n    }\r\n    var text = input.value;\r\n    // If nothing changed, bail.\r\n    if (text == prevInput && !cm.somethingSelected()) return false;\r\n    // Work around nonsensical selection resetting in IE9/10, and\r\n    // inexplicable appearance of private area unicode characters on\r\n    // some key combos in Mac (#2689).\r\n    if (ie && ie_version >= 9 && cm.display.inputHasSelection === text ||\r\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\r\n      resetInput(cm);\r\n      return false;\r\n    }\r\n\r\n    var withOp = !cm.curOp;\r\n    if (withOp) startOperation(cm);\r\n    cm.display.shift = false;\r\n\r\n    if (text.charCodeAt(0) == 0x200b && doc.sel == cm.display.selForContextMenu && !prevInput)\r\n      prevInput = "\\u200b";\r\n    // Find the part of the input that is actually new\r\n    var same = 0, l = Math.min(prevInput.length, text.length);\r\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) ++same;\r\n    var inserted = text.slice(same), textLines = splitLines(inserted);\r\n\r\n    // When pasing N lines into N selections, insert one line per selection\r\n    var multiPaste = null;\r\n    if (cm.state.pasteIncoming && doc.sel.ranges.length > 1) {\r\n      if (lastCopied && lastCopied.join("\\n") == inserted)\r\n        multiPaste = doc.sel.ranges.length % lastCopied.length == 0 && map(lastCopied, splitLines);\r\n      else if (textLines.length == doc.sel.ranges.length)\r\n        multiPaste = map(textLines, function(l) { return [l]; });\r\n    }\r\n\r\n    // Normal behavior is to insert the new text into every selection\r\n    for (var i = doc.sel.ranges.length - 1; i >= 0; i--) {\r\n      var range = doc.sel.ranges[i];\r\n      var from = range.from(), to = range.to();\r\n      // Handle deletion\r\n      if (same < prevInput.length)\r\n        from = Pos(from.line, from.ch - (prevInput.length - same));\r\n      // Handle overwrite\r\n      else if (cm.state.overwrite && range.empty() && !cm.state.pasteIncoming)\r\n        to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));\r\n      var updateInput = cm.curOp.updateInput;\r\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i % multiPaste.length] : textLines,\r\n                         origin: cm.state.pasteIncoming ? "paste" : cm.state.cutIncoming ? "cut" : "+input"};\r\n      makeChange(cm.doc, changeEvent);\r\n      signalLater(cm, "inputRead", cm, changeEvent);\r\n      // When an \'electric\' character is inserted, immediately trigger a reindent\r\n      if (inserted && !cm.state.pasteIncoming && cm.options.electricChars &&\r\n          cm.options.smartIndent && range.head.ch < 100 &&\r\n          (!i || doc.sel.ranges[i - 1].head.line != range.head.line)) {\r\n        var mode = cm.getModeAt(range.head);\r\n        if (mode.electricChars) {\r\n          for (var j = 0; j < mode.electricChars.length; j++)\r\n            if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\r\n              indentLine(cm, range.head.line, "smart");\r\n              break;\r\n            }\r\n        } else if (mode.electricInput) {\r\n          var end = changeEnd(changeEvent);\r\n          if (mode.electricInput.test(getLine(doc, end.line).text.slice(0, end.ch)))\r\n            indentLine(cm, range.head.line, "smart");\r\n        }\r\n      }\r\n    }\r\n    ensureCursorVisible(cm);\r\n    cm.curOp.updateInput = updateInput;\r\n    cm.curOp.typing = true;\r\n\r\n    // Don\'t leave long text in the textarea, since it makes further polling slow\r\n    if (text.length > 1000 || text.indexOf("\\n") > -1) input.value = cm.display.prevInput = "";\r\n    else cm.display.prevInput = text;\r\n    if (withOp) endOperation(cm);\r\n    cm.state.pasteIncoming = cm.state.cutIncoming = false;\r\n    return true;\r\n  }\r\n\r\n  // Reset the input to correspond to the selection (or to be empty,\r\n  // when not typing and nothing is selected)\r\n  function resetInput(cm, typing) {\r\n    var minimal, selected, doc = cm.doc;\r\n    if (cm.somethingSelected()) {\r\n      cm.display.prevInput = "";\r\n      var range = doc.sel.primary();\r\n      minimal = hasCopyEvent &&\r\n        (range.to().line - range.from().line > 100 || (selected = cm.getSelection()).length > 1000);\r\n      var content = minimal ? "-" : selected || cm.getSelection();\r\n      cm.display.input.value = content;\r\n      if (cm.state.focused) selectInput(cm.display.input);\r\n      if (ie && ie_version >= 9) cm.display.inputHasSelection = content;\r\n    } else if (!typing) {\r\n      cm.display.prevInput = cm.display.input.value = "";\r\n      if (ie && ie_version >= 9) cm.display.inputHasSelection = null;\r\n    }\r\n    cm.display.inaccurateSelection = minimal;\r\n  }\r\n\r\n  function focusInput(cm) {\r\n    if (cm.options.readOnly != "nocursor" && (!mobile || activeElt() != cm.display.input))\r\n      cm.display.input.focus();\r\n  }\r\n\r\n  function ensureFocus(cm) {\r\n    if (!cm.state.focused) { focusInput(cm); onFocus(cm); }\r\n  }\r\n\r\n  function isReadOnly(cm) {\r\n    return cm.options.readOnly || cm.doc.cantEdit;\r\n  }\r\n\r\n  // EVENT HANDLERS\r\n\r\n  // Attach the necessary event handlers when initializing the editor\r\n  function registerEventHandlers(cm) {\r\n    var d = cm.display;\r\n    on(d.scroller, "mousedown", operation(cm, onMouseDown));\r\n    // Older IE\'s will not fire a second mousedown for a double click\r\n    if (ie && ie_version < 11)\r\n      on(d.scroller, "dblclick", operation(cm, function(e) {\r\n        if (signalDOMEvent(cm, e)) return;\r\n        var pos = posFromMouse(cm, e);\r\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) return;\r\n        e_preventDefault(e);\r\n        var word = cm.findWordAt(pos);\r\n        extendSelection(cm.doc, word.anchor, word.head);\r\n      }));\r\n    else\r\n      on(d.scroller, "dblclick", function(e) { signalDOMEvent(cm, e) || e_preventDefault(e); });\r\n    // Prevent normal selection in the editor (we handle our own)\r\n    on(d.lineSpace, "selectstart", function(e) {\r\n      if (!eventInWidget(d, e)) e_preventDefault(e);\r\n    });\r\n    // Some browsers fire contextmenu *after* opening the menu, at\r\n    // which point we can\'t mess with it anymore. Context menu is\r\n    // handled in onMouseDown for these browsers.\r\n    if (!captureRightClick) on(d.scroller, "contextmenu", function(e) {onContextMenu(cm, e);});\r\n\r\n    // Sync scrolling between fake scrollbars and real scrollable\r\n    // area, ensure viewport is updated when scrolling.\r\n    on(d.scroller, "scroll", function() {\r\n      if (d.scroller.clientHeight) {\r\n        setScrollTop(cm, d.scroller.scrollTop);\r\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\r\n        signal(cm, "scroll", cm);\r\n      }\r\n    });\r\n    on(d.scrollbarV, "scroll", function() {\r\n      if (d.scroller.clientHeight) setScrollTop(cm, d.scrollbarV.scrollTop);\r\n    });\r\n    on(d.scrollbarH, "scroll", function() {\r\n      if (d.scroller.clientHeight) setScrollLeft(cm, d.scrollbarH.scrollLeft);\r\n    });\r\n\r\n    // Listen to wheel events in order to try and update the viewport on time.\r\n    on(d.scroller, "mousewheel", function(e){onScrollWheel(cm, e);});\r\n    on(d.scroller, "DOMMouseScroll", function(e){onScrollWheel(cm, e);});\r\n\r\n    // Prevent clicks in the scrollbars from killing focus\r\n    function reFocus() { if (cm.state.focused) setTimeout(bind(focusInput, cm), 0); }\r\n    on(d.scrollbarH, "mousedown", reFocus);\r\n    on(d.scrollbarV, "mousedown", reFocus);\r\n    // Prevent wrapper from ever scrolling\r\n    on(d.wrapper, "scroll", function() { d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\r\n\r\n    on(d.input, "keyup", function(e) { onKeyUp.call(cm, e); });\r\n    on(d.input, "input", function() {\r\n      if (ie && ie_version >= 9 && cm.display.inputHasSelection) cm.display.inputHasSelection = null;\r\n      fastPoll(cm);\r\n    });\r\n    on(d.input, "keydown", operation(cm, onKeyDown));\r\n    on(d.input, "keypress", operation(cm, onKeyPress));\r\n    on(d.input, "focus", bind(onFocus, cm));\r\n    on(d.input, "blur", bind(onBlur, cm));\r\n\r\n    function drag_(e) {\r\n      if (!signalDOMEvent(cm, e)) e_stop(e);\r\n    }\r\n    if (cm.options.dragDrop) {\r\n      on(d.scroller, "dragstart", function(e){onDragStart(cm, e);});\r\n      on(d.scroller, "dragenter", drag_);\r\n      on(d.scroller, "dragover", drag_);\r\n      on(d.scroller, "drop", operation(cm, onDrop));\r\n    }\r\n    on(d.scroller, "paste", function(e) {\r\n      if (eventInWidget(d, e)) return;\r\n      cm.state.pasteIncoming = true;\r\n      focusInput(cm);\r\n      fastPoll(cm);\r\n    });\r\n    on(d.input, "paste", function() {\r\n      // Workaround for webkit bug https://bugs.webkit.org/show_bug.cgi?id=90206\r\n      // Add a char to the end of textarea before paste occur so that\r\n      // selection doesn\'t span to the end of textarea.\r\n      if (webkit && !cm.state.fakedLastChar && !(new Date - cm.state.lastMiddleDown < 200)) {\r\n        var start = d.input.selectionStart, end = d.input.selectionEnd;\r\n        d.input.value += "$";\r\n        // The selection end needs to be set before the start, otherwise there\r\n        // can be an intermediate non-empty selection between the two, which\r\n        // can override the middle-click paste buffer on linux and cause the\r\n        // wrong thing to get pasted.\r\n        d.input.selectionEnd = end;\r\n        d.input.selectionStart = start;\r\n        cm.state.fakedLastChar = true;\r\n      }\r\n      cm.state.pasteIncoming = true;\r\n      fastPoll(cm);\r\n    });\r\n\r\n    function prepareCopyCut(e) {\r\n      if (cm.somethingSelected()) {\r\n        lastCopied = cm.getSelections();\r\n        if (d.inaccurateSelection) {\r\n          d.prevInput = "";\r\n          d.inaccurateSelection = false;\r\n          d.input.value = lastCopied.join("\\n");\r\n          selectInput(d.input);\r\n        }\r\n      } else {\r\n        var text = [], ranges = [];\r\n        for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\r\n          var line = cm.doc.sel.ranges[i].head.line;\r\n          var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\r\n          ranges.push(lineRange);\r\n          text.push(cm.getRange(lineRange.anchor, lineRange.head));\r\n        }\r\n        if (e.type == "cut") {\r\n          cm.setSelections(ranges, null, sel_dontScroll);\r\n        } else {\r\n          d.prevInput = "";\r\n          d.input.value = text.join("\\n");\r\n          selectInput(d.input);\r\n        }\r\n        lastCopied = text;\r\n      }\r\n      if (e.type == "cut") cm.state.cutIncoming = true;\r\n    }\r\n    on(d.input, "cut", prepareCopyCut);\r\n    on(d.input, "copy", prepareCopyCut);\r\n\r\n    // Needed to handle Tab key in KHTML\r\n    if (khtml) on(d.sizer, "mouseup", function() {\r\n      if (activeElt() == d.input) d.input.blur();\r\n      focusInput(cm);\r\n    });\r\n  }\r\n\r\n  // Called when the window resizes\r\n  function onResize(cm) {\r\n    // Might be a text scaling operation, clear size caches.\r\n    var d = cm.display;\r\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\r\n    cm.setSize();\r\n  }\r\n\r\n  // MOUSE EVENTS\r\n\r\n  // Return true when the given mouse event happened in a widget\r\n  function eventInWidget(display, e) {\r\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\r\n      if (!n || n.ignoreEvents || n.parentNode == display.sizer && n != display.mover) return true;\r\n    }\r\n  }\r\n\r\n  // Given a mouse event, find the corresponding position. If liberal\r\n  // is false, it checks whether a gutter or scrollbar was clicked,\r\n  // and returns null if it was. forRect is used by rectangular\r\n  // selections, and tries to estimate a character position even for\r\n  // coordinates beyond the right of the text.\r\n  function posFromMouse(cm, e, liberal, forRect) {\r\n    var display = cm.display;\r\n    if (!liberal) {\r\n      var target = e_target(e);\r\n      if (target == display.scrollbarH || target == display.scrollbarV ||\r\n          target == display.scrollbarFiller || target == display.gutterFiller) return null;\r\n    }\r\n    var x, y, space = display.lineSpace.getBoundingClientRect();\r\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\r\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\r\n    catch (e) { return null; }\r\n    var coords = coordsChar(cm, x, y), line;\r\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\r\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\r\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\r\n    }\r\n    return coords;\r\n  }\r\n\r\n  // A mouse down can be a single click, double click, triple click,\r\n  // start of selection drag, start of text drag, new cursor\r\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\r\n  // middle-click-paste. Or it might be a click on something we should\r\n  // not interfere with, such as a scrollbar or widget.\r\n  function onMouseDown(e) {\r\n    if (signalDOMEvent(this, e)) return;\r\n    var cm = this, display = cm.display;\r\n    display.shift = e.shiftKey;\r\n\r\n    if (eventInWidget(display, e)) {\r\n      if (!webkit) {\r\n        // Briefly turn off draggability, to allow widgets to do\r\n        // normal dragging things.\r\n        display.scroller.draggable = false;\r\n        setTimeout(function(){display.scroller.draggable = true;}, 100);\r\n      }\r\n      return;\r\n    }\r\n    if (clickInGutter(cm, e)) return;\r\n    var start = posFromMouse(cm, e);\r\n    window.focus();\r\n\r\n    switch (e_button(e)) {\r\n    case 1:\r\n      if (start)\r\n        leftButtonDown(cm, e, start);\r\n      else if (e_target(e) == display.scroller)\r\n        e_preventDefault(e);\r\n      break;\r\n    case 2:\r\n      if (webkit) cm.state.lastMiddleDown = +new Date;\r\n      if (start) extendSelection(cm.doc, start);\r\n      setTimeout(bind(focusInput, cm), 20);\r\n      e_preventDefault(e);\r\n      break;\r\n    case 3:\r\n      if (captureRightClick) onContextMenu(cm, e);\r\n      break;\r\n    }\r\n  }\r\n\r\n  var lastClick, lastDoubleClick;\r\n  function leftButtonDown(cm, e, start) {\r\n    setTimeout(bind(ensureFocus, cm), 0);\r\n\r\n    var now = +new Date, type;\r\n    if (lastDoubleClick && lastDoubleClick.time > now - 400 && cmp(lastDoubleClick.pos, start) == 0) {\r\n      type = "triple";\r\n    } else if (lastClick && lastClick.time > now - 400 && cmp(lastClick.pos, start) == 0) {\r\n      type = "double";\r\n      lastDoubleClick = {time: now, pos: start};\r\n    } else {\r\n      type = "single";\r\n      lastClick = {time: now, pos: start};\r\n    }\r\n\r\n    var sel = cm.doc.sel, modifier = mac ? e.metaKey : e.ctrlKey;\r\n    if (cm.options.dragDrop && dragAndDrop && !isReadOnly(cm) &&\r\n        type == "single" && sel.contains(start) > -1 && sel.somethingSelected())\r\n      leftButtonStartDrag(cm, e, start, modifier);\r\n    else\r\n      leftButtonSelect(cm, e, start, type, modifier);\r\n  }\r\n\r\n  // Start a text drag. When it ends, see if any dragging actually\r\n  // happen, and treat as a click if it didn\'t.\r\n  function leftButtonStartDrag(cm, e, start, modifier) {\r\n    var display = cm.display;\r\n    var dragEnd = operation(cm, function(e2) {\r\n      if (webkit) display.scroller.draggable = false;\r\n      cm.state.draggingText = false;\r\n      off(document, "mouseup", dragEnd);\r\n      off(display.scroller, "drop", dragEnd);\r\n      if (Math.abs(e.clientX - e2.clientX) + Math.abs(e.clientY - e2.clientY) < 10) {\r\n        e_preventDefault(e2);\r\n        if (!modifier)\r\n          extendSelection(cm.doc, start);\r\n        focusInput(cm);\r\n        // Work around unexplainable focus problem in IE9 (#2127)\r\n        if (ie && ie_version == 9)\r\n          setTimeout(function() {document.body.focus(); focusInput(cm);}, 20);\r\n      }\r\n    });\r\n    // Let the drag handler handle this.\r\n    if (webkit) display.scroller.draggable = true;\r\n    cm.state.draggingText = dragEnd;\r\n    // IE\'s approach to draggable\r\n    if (display.scroller.dragDrop) display.scroller.dragDrop();\r\n    on(document, "mouseup", dragEnd);\r\n    on(display.scroller, "drop", dragEnd);\r\n  }\r\n\r\n  // Normal selection, as opposed to text dragging.\r\n  function leftButtonSelect(cm, e, start, type, addNew) {\r\n    var display = cm.display, doc = cm.doc;\r\n    e_preventDefault(e);\r\n\r\n    var ourRange, ourIndex, startSel = doc.sel;\r\n    if (addNew && !e.shiftKey) {\r\n      ourIndex = doc.sel.contains(start);\r\n      if (ourIndex > -1)\r\n        ourRange = doc.sel.ranges[ourIndex];\r\n      else\r\n        ourRange = new Range(start, start);\r\n    } else {\r\n      ourRange = doc.sel.primary();\r\n    }\r\n\r\n    if (e.altKey) {\r\n      type = "rect";\r\n      if (!addNew) ourRange = new Range(start, start);\r\n      start = posFromMouse(cm, e, true, true);\r\n      ourIndex = -1;\r\n    } else if (type == "double") {\r\n      var word = cm.findWordAt(start);\r\n      if (cm.display.shift || doc.extend)\r\n        ourRange = extendRange(doc, ourRange, word.anchor, word.head);\r\n      else\r\n        ourRange = word;\r\n    } else if (type == "triple") {\r\n      var line = new Range(Pos(start.line, 0), clipPos(doc, Pos(start.line + 1, 0)));\r\n      if (cm.display.shift || doc.extend)\r\n        ourRange = extendRange(doc, ourRange, line.anchor, line.head);\r\n      else\r\n        ourRange = line;\r\n    } else {\r\n      ourRange = extendRange(doc, ourRange, start);\r\n    }\r\n\r\n    if (!addNew) {\r\n      ourIndex = 0;\r\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\r\n      startSel = doc.sel;\r\n    } else if (ourIndex > -1) {\r\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\r\n    } else {\r\n      ourIndex = doc.sel.ranges.length;\r\n      setSelection(doc, normalizeSelection(doc.sel.ranges.concat([ourRange]), ourIndex),\r\n                   {scroll: false, origin: "*mouse"});\r\n    }\r\n\r\n    var lastPos = start;\r\n    function extendTo(pos) {\r\n      if (cmp(lastPos, pos) == 0) return;\r\n      lastPos = pos;\r\n\r\n      if (type == "rect") {\r\n        var ranges = [], tabSize = cm.options.tabSize;\r\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\r\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\r\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\r\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\r\n             line <= end; line++) {\r\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\r\n          if (left == right)\r\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos)));\r\n          else if (text.length > leftPos)\r\n            ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))));\r\n        }\r\n        if (!ranges.length) ranges.push(new Range(start, start));\r\n        setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\r\n                     {origin: "*mouse", scroll: false});\r\n        cm.scrollIntoView(pos);\r\n      } else {\r\n        var oldRange = ourRange;\r\n        var anchor = oldRange.anchor, head = pos;\r\n        if (type != "single") {\r\n          if (type == "double")\r\n            var range = cm.findWordAt(pos);\r\n          else\r\n            var range = new Range(Pos(pos.line, 0), clipPos(doc, Pos(pos.line + 1, 0)));\r\n          if (cmp(range.anchor, anchor) > 0) {\r\n            head = range.head;\r\n            anchor = minPos(oldRange.from(), range.anchor);\r\n          } else {\r\n            head = range.anchor;\r\n            anchor = maxPos(oldRange.to(), range.head);\r\n          }\r\n        }\r\n        var ranges = startSel.ranges.slice(0);\r\n        ranges[ourIndex] = new Range(clipPos(doc, anchor), head);\r\n        setSelection(doc, normalizeSelection(ranges, ourIndex), sel_mouse);\r\n      }\r\n    }\r\n\r\n    var editorSize = display.wrapper.getBoundingClientRect();\r\n    // Used to ensure timeout re-tries don\'t fire when another extend\r\n    // happened in the meantime (clearTimeout isn\'t reliable -- at\r\n    // least on Chrome, the timeouts still happen even when cleared,\r\n    // if the clear happens after their scheduled firing time).\r\n    var counter = 0;\r\n\r\n    function extend(e) {\r\n      var curCount = ++counter;\r\n      var cur = posFromMouse(cm, e, true, type == "rect");\r\n      if (!cur) return;\r\n      if (cmp(cur, lastPos) != 0) {\r\n        ensureFocus(cm);\r\n        extendTo(cur);\r\n        var visible = visibleLines(display, doc);\r\n        if (cur.line >= visible.to || cur.line < visible.from)\r\n          setTimeout(operation(cm, function(){if (counter == curCount) extend(e);}), 150);\r\n      } else {\r\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\r\n        if (outside) setTimeout(operation(cm, function() {\r\n          if (counter != curCount) return;\r\n          display.scroller.scrollTop += outside;\r\n          extend(e);\r\n        }), 50);\r\n      }\r\n    }\r\n\r\n    function done(e) {\r\n      counter = Infinity;\r\n      e_preventDefault(e);\r\n      focusInput(cm);\r\n      off(document, "mousemove", move);\r\n      off(document, "mouseup", up);\r\n      doc.history.lastSelOrigin = null;\r\n    }\r\n\r\n    var move = operation(cm, function(e) {\r\n      if (!e_button(e)) done(e);\r\n      else extend(e);\r\n    });\r\n    var up = operation(cm, done);\r\n    on(document, "mousemove", move);\r\n    on(document, "mouseup", up);\r\n  }\r\n\r\n  // Determines whether an event happened in the gutter, and fires the\r\n  // handlers for the corresponding event.\r\n  function gutterEvent(cm, e, type, prevent, signalfn) {\r\n    try { var mX = e.clientX, mY = e.clientY; }\r\n    catch(e) { return false; }\r\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return false;\r\n    if (prevent) e_preventDefault(e);\r\n\r\n    var display = cm.display;\r\n    var lineBox = display.lineDiv.getBoundingClientRect();\r\n\r\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);\r\n    mY -= lineBox.top - display.viewOffset;\r\n\r\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\r\n      var g = display.gutters.childNodes[i];\r\n      if (g && g.getBoundingClientRect().right >= mX) {\r\n        var line = lineAtHeight(cm.doc, mY);\r\n        var gutter = cm.options.gutters[i];\r\n        signalfn(cm, type, cm, line, gutter, e);\r\n        return e_defaultPrevented(e);\r\n      }\r\n    }\r\n  }\r\n\r\n  function clickInGutter(cm, e) {\r\n    return gutterEvent(cm, e, "gutterClick", true, signalLater);\r\n  }\r\n\r\n  // Kludge to work around strange IE behavior where it\'ll sometimes\r\n  // re-fire a series of drag-related events right after the drop (#1551)\r\n  var lastDrop = 0;\r\n\r\n  function onDrop(e) {\r\n    var cm = this;\r\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\r\n      return;\r\n    e_preventDefault(e);\r\n    if (ie) lastDrop = +new Date;\r\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\r\n    if (!pos || isReadOnly(cm)) return;\r\n    // Might be a file drop, in which case we simply extract the text\r\n    // and insert it.\r\n    if (files && files.length && window.FileReader && window.File) {\r\n      var n = files.length, text = Array(n), read = 0;\r\n      var loadFile = function(file, i) {\r\n        var reader = new FileReader;\r\n        reader.onload = operation(cm, function() {\r\n          text[i] = reader.result;\r\n          if (++read == n) {\r\n            pos = clipPos(cm.doc, pos);\r\n            var change = {from: pos, to: pos, text: splitLines(text.join("\\n")), origin: "paste"};\r\n            makeChange(cm.doc, change);\r\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\r\n          }\r\n        });\r\n        reader.readAsText(file);\r\n      };\r\n      for (var i = 0; i < n; ++i) loadFile(files[i], i);\r\n    } else { // Normal drop\r\n      // Don\'t do a replace if the drop happened inside of the selected text.\r\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\r\n        cm.state.draggingText(e);\r\n        // Ensure the editor is re-focused\r\n        setTimeout(bind(focusInput, cm), 20);\r\n        return;\r\n      }\r\n      try {\r\n        var text = e.dataTransfer.getData("Text");\r\n        if (text) {\r\n          if (cm.state.draggingText && !(mac ? e.metaKey : e.ctrlKey))\r\n            var selected = cm.listSelections();\r\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\r\n          if (selected) for (var i = 0; i < selected.length; ++i)\r\n            replaceRange(cm.doc, "", selected[i].anchor, selected[i].head, "drag");\r\n          cm.replaceSelection(text, "around", "paste");\r\n          focusInput(cm);\r\n        }\r\n      }\r\n      catch(e){}\r\n    }\r\n  }\r\n\r\n  function onDragStart(cm, e) {\r\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return; }\r\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) return;\r\n\r\n    e.dataTransfer.setData("Text", cm.getSelection());\r\n\r\n    // Use dummy image instead of default browsers image.\r\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don\'t do it there.\r\n    if (e.dataTransfer.setDragImage && !safari) {\r\n      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");\r\n      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";\r\n      if (presto) {\r\n        img.width = img.height = 1;\r\n        cm.display.wrapper.appendChild(img);\r\n        // Force a relayout, or Opera won\'t use our image for some obscure reason\r\n        img._top = img.offsetTop;\r\n      }\r\n      e.dataTransfer.setDragImage(img, 0, 0);\r\n      if (presto) img.parentNode.removeChild(img);\r\n    }\r\n  }\r\n\r\n  // SCROLL EVENTS\r\n\r\n  // Sync the scrollable area and scrollbars, ensure the viewport\r\n  // covers the visible area.\r\n  function setScrollTop(cm, val) {\r\n    if (Math.abs(cm.doc.scrollTop - val) < 2) return;\r\n    cm.doc.scrollTop = val;\r\n    if (!gecko) updateDisplaySimple(cm, {top: val});\r\n    if (cm.display.scroller.scrollTop != val) cm.display.scroller.scrollTop = val;\r\n    if (cm.display.scrollbarV.scrollTop != val) cm.display.scrollbarV.scrollTop = val;\r\n    if (gecko) updateDisplaySimple(cm);\r\n    startWorker(cm, 100);\r\n  }\r\n  // Sync scroller and scrollbar, ensure the gutter elements are\r\n  // aligned.\r\n  function setScrollLeft(cm, val, isScroller) {\r\n    if (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) return;\r\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\r\n    cm.doc.scrollLeft = val;\r\n    alignHorizontally(cm);\r\n    if (cm.display.scroller.scrollLeft != val) cm.display.scroller.scrollLeft = val;\r\n    if (cm.display.scrollbarH.scrollLeft != val) cm.display.scrollbarH.scrollLeft = val;\r\n  }\r\n\r\n  // Since the delta values reported on mouse wheel events are\r\n  // unstandardized between browsers and even browser versions, and\r\n  // generally horribly unpredictable, this code starts by measuring\r\n  // the scroll effect that the first few mouse wheel events have,\r\n  // and, from that, detects the way it can convert deltas to pixel\r\n  // offsets afterwards.\r\n  //\r\n  // The reason we want to know the amount a wheel event will scroll\r\n  // is that it gives us a chance to update the display before the\r\n  // actual scrolling happens, reducing flickering.\r\n\r\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\r\n  // Fill in a browser-detected starting value on browsers where we\r\n  // know one. These don\'t have to be accurate -- the result of them\r\n  // being wrong would just be a slight flicker on the first wheel\r\n  // scroll (if it is large enough).\r\n  if (ie) wheelPixelsPerUnit = -.53;\r\n  else if (gecko) wheelPixelsPerUnit = 15;\r\n  else if (chrome) wheelPixelsPerUnit = -.7;\r\n  else if (safari) wheelPixelsPerUnit = -1/3;\r\n\r\n  function onScrollWheel(cm, e) {\r\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\r\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) dx = e.detail;\r\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) dy = e.detail;\r\n    else if (dy == null) dy = e.wheelDelta;\r\n\r\n    var display = cm.display, scroll = display.scroller;\r\n    // Quit if there\'s nothing to scroll here\r\n    if (!(dx && scroll.scrollWidth > scroll.clientWidth ||\r\n          dy && scroll.scrollHeight > scroll.clientHeight)) return;\r\n\r\n    // Webkit browsers on OS X abort momentum scrolls when the target\r\n    // of the scroll event is removed from the scrollable element.\r\n    // This hack (see related code in patchDisplay) makes sure the\r\n    // element is kept around.\r\n    if (dy && mac && webkit) {\r\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\r\n        for (var i = 0; i < view.length; i++) {\r\n          if (view[i].node == cur) {\r\n            cm.display.currentWheelTarget = cur;\r\n            break outer;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    // On some browsers, horizontal scrolling will cause redraws to\r\n    // happen before the gutter has been realigned, causing it to\r\n    // wriggle around in a most unseemly way. When we have an\r\n    // estimated pixels/delta value, we just handle horizontal\r\n    // scrolling entirely here. It\'ll be slightly off from native, but\r\n    // better than glitching out.\r\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\r\n      if (dy)\r\n        setScrollTop(cm, Math.max(0, Math.min(scroll.scrollTop + dy * wheelPixelsPerUnit, scroll.scrollHeight - scroll.clientHeight)));\r\n      setScrollLeft(cm, Math.max(0, Math.min(scroll.scrollLeft + dx * wheelPixelsPerUnit, scroll.scrollWidth - scroll.clientWidth)));\r\n      e_preventDefault(e);\r\n      display.wheelStartX = null; // Abort measurement, if in progress\r\n      return;\r\n    }\r\n\r\n    // \'Project\' the visible viewport to cover the area that is being\r\n    // scrolled into view (if we know enough to estimate it).\r\n    if (dy && wheelPixelsPerUnit != null) {\r\n      var pixels = dy * wheelPixelsPerUnit;\r\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\r\n      if (pixels < 0) top = Math.max(0, top + pixels - 50);\r\n      else bot = Math.min(cm.doc.height, bot + pixels + 50);\r\n      updateDisplaySimple(cm, {top: top, bottom: bot});\r\n    }\r\n\r\n    if (wheelSamples < 20) {\r\n      if (display.wheelStartX == null) {\r\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\r\n        display.wheelDX = dx; display.wheelDY = dy;\r\n        setTimeout(function() {\r\n          if (display.wheelStartX == null) return;\r\n          var movedX = scroll.scrollLeft - display.wheelStartX;\r\n          var movedY = scroll.scrollTop - display.wheelStartY;\r\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\r\n            (movedX && display.wheelDX && movedX / display.wheelDX);\r\n          display.wheelStartX = display.wheelStartY = null;\r\n          if (!sample) return;\r\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\r\n          ++wheelSamples;\r\n        }, 200);\r\n      } else {\r\n        display.wheelDX += dx; display.wheelDY += dy;\r\n      }\r\n    }\r\n  }\r\n\r\n  // KEY EVENTS\r\n\r\n  // Run a handler that was bound to a key.\r\n  function doHandleBinding(cm, bound, dropShift) {\r\n    if (typeof bound == "string") {\r\n      bound = commands[bound];\r\n      if (!bound) return false;\r\n    }\r\n    // Ensure previous input has been read, so that the handler sees a\r\n    // consistent view of the document\r\n    if (cm.display.pollingFast && readInput(cm)) cm.display.pollingFast = false;\r\n    var prevShift = cm.display.shift, done = false;\r\n    try {\r\n      if (isReadOnly(cm)) cm.state.suppressEdits = true;\r\n      if (dropShift) cm.display.shift = false;\r\n      done = bound(cm) != Pass;\r\n    } finally {\r\n      cm.display.shift = prevShift;\r\n      cm.state.suppressEdits = false;\r\n    }\r\n    return done;\r\n  }\r\n\r\n  // Collect the currently active keymaps.\r\n  function allKeyMaps(cm) {\r\n    var maps = cm.state.keyMaps.slice(0);\r\n    if (cm.options.extraKeys) maps.push(cm.options.extraKeys);\r\n    maps.push(cm.options.keyMap);\r\n    return maps;\r\n  }\r\n\r\n  var maybeTransition;\r\n  // Handle a key from the keydown event.\r\n  function handleKeyBinding(cm, e) {\r\n    // Handle automatic keymap transitions\r\n    var startMap = getKeyMap(cm.options.keyMap), next = startMap.auto;\r\n    clearTimeout(maybeTransition);\r\n    if (next && !isModifierKey(e)) maybeTransition = setTimeout(function() {\r\n      if (getKeyMap(cm.options.keyMap) == startMap) {\r\n        cm.options.keyMap = (next.call ? next.call(null, cm) : next);\r\n        keyMapChanged(cm);\r\n      }\r\n    }, 50);\r\n\r\n    var name = keyName(e, true), handled = false;\r\n    if (!name) return false;\r\n    var keymaps = allKeyMaps(cm);\r\n\r\n    if (e.shiftKey) {\r\n      // First try to resolve full name (including \'Shift-\'). Failing\r\n      // that, see if there is a cursor-motion command (starting with\r\n      // \'go\') bound to the keyname without \'Shift-\'.\r\n      handled = lookupKey("Shift-" + name, keymaps, function(b) {return doHandleBinding(cm, b, true);})\r\n             || lookupKey(name, keymaps, function(b) {\r\n                  if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)\r\n                    return doHandleBinding(cm, b);\r\n                });\r\n    } else {\r\n      handled = lookupKey(name, keymaps, function(b) { return doHandleBinding(cm, b); });\r\n    }\r\n\r\n    if (handled) {\r\n      e_preventDefault(e);\r\n      restartBlink(cm);\r\n      signalLater(cm, "keyHandled", cm, name, e);\r\n    }\r\n    return handled;\r\n  }\r\n\r\n  // Handle a key from the keypress event\r\n  function handleCharBinding(cm, e, ch) {\r\n    var handled = lookupKey("\'" + ch + "\'", allKeyMaps(cm),\r\n                            function(b) { return doHandleBinding(cm, b, true); });\r\n    if (handled) {\r\n      e_preventDefault(e);\r\n      restartBlink(cm);\r\n      signalLater(cm, "keyHandled", cm, "\'" + ch + "\'", e);\r\n    }\r\n    return handled;\r\n  }\r\n\r\n  var lastStoppedKey = null;\r\n  function onKeyDown(e) {\r\n    var cm = this;\r\n    ensureFocus(cm);\r\n    if (signalDOMEvent(cm, e)) return;\r\n    // IE does strange things with escape.\r\n    if (ie && ie_version < 11 && e.keyCode == 27) e.returnValue = false;\r\n    var code = e.keyCode;\r\n    cm.display.shift = code == 16 || e.shiftKey;\r\n    var handled = handleKeyBinding(cm, e);\r\n    if (presto) {\r\n      lastStoppedKey = handled ? code : null;\r\n      // Opera has no cut event... we try to at least catch the key combo\r\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\r\n        cm.replaceSelection("", null, "cut");\r\n    }\r\n\r\n    // Turn mouse into crosshair when Alt is held on Mac.\r\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\r\n      showCrossHair(cm);\r\n  }\r\n\r\n  function showCrossHair(cm) {\r\n    var lineDiv = cm.display.lineDiv;\r\n    addClass(lineDiv, "CodeMirror-crosshair");\r\n\r\n    function up(e) {\r\n      if (e.keyCode == 18 || !e.altKey) {\r\n        rmClass(lineDiv, "CodeMirror-crosshair");\r\n        off(document, "keyup", up);\r\n        off(document, "mouseover", up);\r\n      }\r\n    }\r\n    on(document, "keyup", up);\r\n    on(document, "mouseover", up);\r\n  }\r\n\r\n  function onKeyUp(e) {\r\n    if (e.keyCode == 16) this.doc.sel.shift = false;\r\n    signalDOMEvent(this, e);\r\n  }\r\n\r\n  function onKeyPress(e) {\r\n    var cm = this;\r\n    if (signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) return;\r\n    var keyCode = e.keyCode, charCode = e.charCode;\r\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return;}\r\n    if (((presto && (!e.which || e.which < 10)) || khtml) && handleKeyBinding(cm, e)) return;\r\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\r\n    if (handleCharBinding(cm, e, ch)) return;\r\n    if (ie && ie_version >= 9) cm.display.inputHasSelection = null;\r\n    fastPoll(cm);\r\n  }\r\n\r\n  // FOCUS/BLUR EVENTS\r\n\r\n  function onFocus(cm) {\r\n    if (cm.options.readOnly == "nocursor") return;\r\n    if (!cm.state.focused) {\r\n      signal(cm, "focus", cm);\r\n      cm.state.focused = true;\r\n      addClass(cm.display.wrapper, "CodeMirror-focused");\r\n      // The prevInput test prevents this from firing when a context\r\n      // menu is closed (since the resetInput would kill the\r\n      // select-all detection hack)\r\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\r\n        resetInput(cm);\r\n        if (webkit) setTimeout(bind(resetInput, cm, true), 0); // Issue #1730\r\n      }\r\n    }\r\n    slowPoll(cm);\r\n    restartBlink(cm);\r\n  }\r\n  function onBlur(cm) {\r\n    if (cm.state.focused) {\r\n      signal(cm, "blur", cm);\r\n      cm.state.focused = false;\r\n      rmClass(cm.display.wrapper, "CodeMirror-focused");\r\n    }\r\n    clearInterval(cm.display.blinker);\r\n    setTimeout(function() {if (!cm.state.focused) cm.display.shift = false;}, 150);\r\n  }\r\n\r\n  // CONTEXT MENU HANDLING\r\n\r\n  // To make the context menu work, we need to briefly unhide the\r\n  // textarea (making it as unobtrusive as possible) to let the\r\n  // right-click take effect on it.\r\n  function onContextMenu(cm, e) {\r\n    if (signalDOMEvent(cm, e, "contextmenu")) return;\r\n    var display = cm.display;\r\n    if (eventInWidget(display, e) || contextMenuInGutter(cm, e)) return;\r\n\r\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\r\n    if (!pos || presto) return; // Opera is difficult.\r\n\r\n    // Reset the current text selection only if the click is done outside of the selection\r\n    // and \'resetSelectionOnContextMenu\' option is true.\r\n    var reset = cm.options.resetSelectionOnContextMenu;\r\n    if (reset && cm.doc.sel.contains(pos) == -1)\r\n      operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);\r\n\r\n    var oldCSS = display.input.style.cssText;\r\n    display.inputDiv.style.position = "absolute";\r\n    display.input.style.cssText = "position: fixed; width: 30px; height: 30px; top: " + (e.clientY - 5) +\r\n      "px; left: " + (e.clientX - 5) + "px; z-index: 1000; background: " +\r\n      (ie ? "rgba(255, 255, 255, .05)" : "transparent") +\r\n      "; outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";\r\n    if (webkit) var oldScrollY = window.scrollY; // Work around Chrome issue (#2712)\r\n    focusInput(cm);\r\n    if (webkit) window.scrollTo(null, oldScrollY);\r\n    resetInput(cm);\r\n    // Adds "Select all" to context menu in FF\r\n    if (!cm.somethingSelected()) display.input.value = display.prevInput = " ";\r\n    display.selForContextMenu = cm.doc.sel;\r\n    clearTimeout(display.detectingSelectAll);\r\n\r\n    // Select-all will be greyed out if there\'s nothing to select, so\r\n    // this adds a zero-width space so that we can later check whether\r\n    // it got selected.\r\n    function prepareSelectAllHack() {\r\n      if (display.input.selectionStart != null) {\r\n        var selected = cm.somethingSelected();\r\n        var extval = display.input.value = "\\u200b" + (selected ? display.input.value : "");\r\n        display.prevInput = selected ? "" : "\\u200b";\r\n        display.input.selectionStart = 1; display.input.selectionEnd = extval.length;\r\n        // Re-set this, in case some other handler touched the\r\n        // selection in the meantime.\r\n        display.selForContextMenu = cm.doc.sel;\r\n      }\r\n    }\r\n    function rehide() {\r\n      display.inputDiv.style.position = "relative";\r\n      display.input.style.cssText = oldCSS;\r\n      if (ie && ie_version < 9) display.scrollbarV.scrollTop = display.scroller.scrollTop = scrollPos;\r\n      slowPoll(cm);\r\n\r\n      // Try to detect the user choosing select-all\r\n      if (display.input.selectionStart != null) {\r\n        if (!ie || (ie && ie_version < 9)) prepareSelectAllHack();\r\n        var i = 0, poll = function() {\r\n          if (display.selForContextMenu == cm.doc.sel && display.input.selectionStart == 0)\r\n            operation(cm, commands.selectAll)(cm);\r\n          else if (i++ < 10) display.detectingSelectAll = setTimeout(poll, 500);\r\n          else resetInput(cm);\r\n        };\r\n        display.detectingSelectAll = setTimeout(poll, 200);\r\n      }\r\n    }\r\n\r\n    if (ie && ie_version >= 9) prepareSelectAllHack();\r\n    if (captureRightClick) {\r\n      e_stop(e);\r\n      var mouseup = function() {\r\n        off(window, "mouseup", mouseup);\r\n        setTimeout(rehide, 20);\r\n      };\r\n      on(window, "mouseup", mouseup);\r\n    } else {\r\n      setTimeout(rehide, 50);\r\n    }\r\n  }\r\n\r\n  function contextMenuInGutter(cm, e) {\r\n    if (!hasHandler(cm, "gutterContextMenu")) return false;\r\n    return gutterEvent(cm, e, "gutterContextMenu", false, signal);\r\n  }\r\n\r\n  // UPDATING\r\n\r\n  // Compute the position of the end of a change (its \'to\' property\r\n  // refers to the pre-change end).\r\n  var changeEnd = CodeMirror.changeEnd = function(change) {\r\n    if (!change.text) return change.to;\r\n    return Pos(change.from.line + change.text.length - 1,\r\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));\r\n  };\r\n\r\n  // Adjust a position to refer to the post-change position of the\r\n  // same text, or the end of the change if the change covers it.\r\n  function adjustForChange(pos, change) {\r\n    if (cmp(pos, change.from) < 0) return pos;\r\n    if (cmp(pos, change.to) <= 0) return changeEnd(change);\r\n\r\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\r\n    if (pos.line == change.to.line) ch += changeEnd(change).ch - change.to.ch;\r\n    return Pos(line, ch);\r\n  }\r\n\r\n  function computeSelAfterChange(doc, change) {\r\n    var out = [];\r\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n      var range = doc.sel.ranges[i];\r\n      out.push(new Range(adjustForChange(range.anchor, change),\r\n                         adjustForChange(range.head, change)));\r\n    }\r\n    return normalizeSelection(out, doc.sel.primIndex);\r\n  }\r\n\r\n  function offsetPos(pos, old, nw) {\r\n    if (pos.line == old.line)\r\n      return Pos(nw.line, pos.ch - old.ch + nw.ch);\r\n    else\r\n      return Pos(nw.line + (pos.line - old.line), pos.ch);\r\n  }\r\n\r\n  // Used by replaceSelections to allow moving the selection to the\r\n  // start or around the replaced test. Hint may be "start" or "around".\r\n  function computeReplacedSel(doc, changes, hint) {\r\n    var out = [];\r\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\r\n    for (var i = 0; i < changes.length; i++) {\r\n      var change = changes[i];\r\n      var from = offsetPos(change.from, oldPrev, newPrev);\r\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\r\n      oldPrev = change.to;\r\n      newPrev = to;\r\n      if (hint == "around") {\r\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\r\n        out[i] = new Range(inv ? to : from, inv ? from : to);\r\n      } else {\r\n        out[i] = new Range(from, from);\r\n      }\r\n    }\r\n    return new Selection(out, doc.sel.primIndex);\r\n  }\r\n\r\n  // Allow "beforeChange" event handlers to influence a change\r\n  function filterChange(doc, change, update) {\r\n    var obj = {\r\n      canceled: false,\r\n      from: change.from,\r\n      to: change.to,\r\n      text: change.text,\r\n      origin: change.origin,\r\n      cancel: function() { this.canceled = true; }\r\n    };\r\n    if (update) obj.update = function(from, to, text, origin) {\r\n      if (from) this.from = clipPos(doc, from);\r\n      if (to) this.to = clipPos(doc, to);\r\n      if (text) this.text = text;\r\n      if (origin !== undefined) this.origin = origin;\r\n    };\r\n    signal(doc, "beforeChange", doc, obj);\r\n    if (doc.cm) signal(doc.cm, "beforeChange", doc.cm, obj);\r\n\r\n    if (obj.canceled) return null;\r\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin};\r\n  }\r\n\r\n  // Apply a change to a document, and add it to the document\'s\r\n  // history, and propagating it to all linked documents.\r\n  function makeChange(doc, change, ignoreReadOnly) {\r\n    if (doc.cm) {\r\n      if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);\r\n      if (doc.cm.state.suppressEdits) return;\r\n    }\r\n\r\n    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {\r\n      change = filterChange(doc, change, true);\r\n      if (!change) return;\r\n    }\r\n\r\n    // Possibly split or suppress the update based on the presence\r\n    // of read-only spans in its range.\r\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\r\n    if (split) {\r\n      for (var i = split.length - 1; i >= 0; --i)\r\n        makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text});\r\n    } else {\r\n      makeChangeInner(doc, change);\r\n    }\r\n  }\r\n\r\n  function makeChangeInner(doc, change) {\r\n    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) return;\r\n    var selAfter = computeSelAfterChange(doc, change);\r\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\r\n\r\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\r\n    var rebased = [];\r\n\r\n    linkedDocs(doc, function(doc, sharedHist) {\r\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\r\n        rebaseHist(doc.history, change);\r\n        rebased.push(doc.history);\r\n      }\r\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\r\n    });\r\n  }\r\n\r\n  // Revert a change stored in a document\'s history.\r\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\r\n    if (doc.cm && doc.cm.state.suppressEdits) return;\r\n\r\n    var hist = doc.history, event, selAfter = doc.sel;\r\n    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;\r\n\r\n    // Verify that there is a useable event (so that ctrl-z won\'t\r\n    // needlessly clear selection events)\r\n    for (var i = 0; i < source.length; i++) {\r\n      event = source[i];\r\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\r\n        break;\r\n    }\r\n    if (i == source.length) return;\r\n    hist.lastOrigin = hist.lastSelOrigin = null;\r\n\r\n    for (;;) {\r\n      event = source.pop();\r\n      if (event.ranges) {\r\n        pushSelectionToHistory(event, dest);\r\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\r\n          setSelection(doc, event, {clearRedo: false});\r\n          return;\r\n        }\r\n        selAfter = event;\r\n      }\r\n      else break;\r\n    }\r\n\r\n    // Build up a reverse change object to add to the opposite history\r\n    // stack (redo when undoing, and vice versa).\r\n    var antiChanges = [];\r\n    pushSelectionToHistory(selAfter, dest);\r\n    dest.push({changes: antiChanges, generation: hist.generation});\r\n    hist.generation = event.generation || ++hist.maxGeneration;\r\n\r\n    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");\r\n\r\n    for (var i = event.changes.length - 1; i >= 0; --i) {\r\n      var change = event.changes[i];\r\n      change.origin = type;\r\n      if (filter && !filterChange(doc, change, false)) {\r\n        source.length = 0;\r\n        return;\r\n      }\r\n\r\n      antiChanges.push(historyChangeFromChange(doc, change));\r\n\r\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\r\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\r\n      if (!i && doc.cm) doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)});\r\n      var rebased = [];\r\n\r\n      // Propagate to the linked documents\r\n      linkedDocs(doc, function(doc, sharedHist) {\r\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\r\n          rebaseHist(doc.history, change);\r\n          rebased.push(doc.history);\r\n        }\r\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\r\n      });\r\n    }\r\n  }\r\n\r\n  // Sub-views need their line numbers shifted when text is added\r\n  // above or below them in the parent document.\r\n  function shiftDoc(doc, distance) {\r\n    if (distance == 0) return;\r\n    doc.first += distance;\r\n    doc.sel = new Selection(map(doc.sel.ranges, function(range) {\r\n      return new Range(Pos(range.anchor.line + distance, range.anchor.ch),\r\n                       Pos(range.head.line + distance, range.head.ch));\r\n    }), doc.sel.primIndex);\r\n    if (doc.cm) {\r\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\r\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\r\n        regLineChange(doc.cm, l, "gutter");\r\n    }\r\n  }\r\n\r\n  // More lower-level change function, handling only a single document\r\n  // (not linked ones).\r\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\r\n    if (doc.cm && !doc.cm.curOp)\r\n      return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);\r\n\r\n    if (change.to.line < doc.first) {\r\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\r\n      return;\r\n    }\r\n    if (change.from.line > doc.lastLine()) return;\r\n\r\n    // Clip the change to the size of this doc\r\n    if (change.from.line < doc.first) {\r\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\r\n      shiftDoc(doc, shift);\r\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\r\n                text: [lst(change.text)], origin: change.origin};\r\n    }\r\n    var last = doc.lastLine();\r\n    if (change.to.line > last) {\r\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\r\n                text: [change.text[0]], origin: change.origin};\r\n    }\r\n\r\n    change.removed = getBetween(doc, change.from, change.to);\r\n\r\n    if (!selAfter) selAfter = computeSelAfterChange(doc, change);\r\n    if (doc.cm) makeChangeSingleDocInEditor(doc.cm, change, spans);\r\n    else updateDoc(doc, change, spans);\r\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\r\n  }\r\n\r\n  // Handle the interaction of a change to a document with the editor\r\n  // that this document is part of.\r\n  function makeChangeSingleDocInEditor(cm, change, spans) {\r\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\r\n\r\n    var recomputeMaxLength = false, checkWidthStart = from.line;\r\n    if (!cm.options.lineWrapping) {\r\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\r\n      doc.iter(checkWidthStart, to.line + 1, function(line) {\r\n        if (line == display.maxLine) {\r\n          recomputeMaxLength = true;\r\n          return true;\r\n        }\r\n      });\r\n    }\r\n\r\n    if (doc.sel.contains(change.from, change.to) > -1)\r\n      signalCursorActivity(cm);\r\n\r\n    updateDoc(doc, change, spans, estimateHeight(cm));\r\n\r\n    if (!cm.options.lineWrapping) {\r\n      doc.iter(checkWidthStart, from.line + change.text.length, function(line) {\r\n        var len = lineLength(line);\r\n        if (len > display.maxLineLength) {\r\n          display.maxLine = line;\r\n          display.maxLineLength = len;\r\n          display.maxLineChanged = true;\r\n          recomputeMaxLength = false;\r\n        }\r\n      });\r\n      if (recomputeMaxLength) cm.curOp.updateMaxLine = true;\r\n    }\r\n\r\n    // Adjust frontier, schedule worker\r\n    doc.frontier = Math.min(doc.frontier, from.line);\r\n    startWorker(cm, 400);\r\n\r\n    var lendiff = change.text.length - (to.line - from.line) - 1;\r\n    // Remember that these lines changed, for updating the display\r\n    if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\r\n      regLineChange(cm, from.line, "text");\r\n    else\r\n      regChange(cm, from.line, to.line + 1, lendiff);\r\n\r\n    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");\r\n    if (changeHandler || changesHandler) {\r\n      var obj = {\r\n        from: from, to: to,\r\n        text: change.text,\r\n        removed: change.removed,\r\n        origin: change.origin\r\n      };\r\n      if (changeHandler) signalLater(cm, "change", cm, obj);\r\n      if (changesHandler) (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);\r\n    }\r\n    cm.display.selForContextMenu = null;\r\n  }\r\n\r\n  function replaceRange(doc, code, from, to, origin) {\r\n    if (!to) to = from;\r\n    if (cmp(to, from) < 0) { var tmp = to; to = from; from = tmp; }\r\n    if (typeof code == "string") code = splitLines(code);\r\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\r\n  }\r\n\r\n  // SCROLLING THINGS INTO VIEW\r\n\r\n  // If an editor sits on the top or bottom of the window, partially\r\n  // scrolled out of view, this ensures that the cursor is visible.\r\n  function maybeScrollWindow(cm, coords) {\r\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\r\n    if (coords.top + box.top < 0) doScroll = true;\r\n    else if (coords.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) doScroll = false;\r\n    if (doScroll != null && !phantom) {\r\n      var scrollNode = elt("div", "\\u200b", null, "position: absolute; top: " +\r\n                           (coords.top - display.viewOffset - paddingTop(cm.display)) + "px; height: " +\r\n                           (coords.bottom - coords.top + scrollerCutOff) + "px; left: " +\r\n                           coords.left + "px; width: 2px;");\r\n      cm.display.lineSpace.appendChild(scrollNode);\r\n      scrollNode.scrollIntoView(doScroll);\r\n      cm.display.lineSpace.removeChild(scrollNode);\r\n    }\r\n  }\r\n\r\n  // Scroll a given position into view (immediately), verifying that\r\n  // it actually became visible (as line heights are accurately\r\n  // measured, the position of something may \'drift\' during drawing).\r\n  function scrollPosIntoView(cm, pos, end, margin) {\r\n    if (margin == null) margin = 0;\r\n    for (;;) {\r\n      var changed = false, coords = cursorCoords(cm, pos);\r\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\r\n      var scrollPos = calculateScrollPos(cm, Math.min(coords.left, endCoords.left),\r\n                                         Math.min(coords.top, endCoords.top) - margin,\r\n                                         Math.max(coords.left, endCoords.left),\r\n                                         Math.max(coords.bottom, endCoords.bottom) + margin);\r\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\r\n      if (scrollPos.scrollTop != null) {\r\n        setScrollTop(cm, scrollPos.scrollTop);\r\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) changed = true;\r\n      }\r\n      if (scrollPos.scrollLeft != null) {\r\n        setScrollLeft(cm, scrollPos.scrollLeft);\r\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) changed = true;\r\n      }\r\n      if (!changed) return coords;\r\n    }\r\n  }\r\n\r\n  // Scroll a given set of coordinates into view (immediately).\r\n  function scrollIntoView(cm, x1, y1, x2, y2) {\r\n    var scrollPos = calculateScrollPos(cm, x1, y1, x2, y2);\r\n    if (scrollPos.scrollTop != null) setScrollTop(cm, scrollPos.scrollTop);\r\n    if (scrollPos.scrollLeft != null) setScrollLeft(cm, scrollPos.scrollLeft);\r\n  }\r\n\r\n  // Calculate a new scroll position needed to scroll the given\r\n  // rectangle into view. Returns an object with scrollTop and\r\n  // scrollLeft properties. When these are undefined, the\r\n  // vertical/horizontal position does not need to be adjusted.\r\n  function calculateScrollPos(cm, x1, y1, x2, y2) {\r\n    var display = cm.display, snapMargin = textHeight(cm.display);\r\n    if (y1 < 0) y1 = 0;\r\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\r\n    var screen = display.scroller.clientHeight - scrollerCutOff, result = {};\r\n    if (y2 - y1 > screen) y2 = y1 + screen;\r\n    var docBottom = cm.doc.height + paddingVert(display);\r\n    var atTop = y1 < snapMargin, atBottom = y2 > docBottom - snapMargin;\r\n    if (y1 < screentop) {\r\n      result.scrollTop = atTop ? 0 : y1;\r\n    } else if (y2 > screentop + screen) {\r\n      var newTop = Math.min(y1, (atBottom ? docBottom : y2) - screen);\r\n      if (newTop != screentop) result.scrollTop = newTop;\r\n    }\r\n\r\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\r\n    var screenw = display.scroller.clientWidth - scrollerCutOff - display.gutters.offsetWidth;\r\n    var tooWide = x2 - x1 > screenw;\r\n    if (tooWide) x2 = y1 + screen;\r\n    if (x1 < 10)\r\n      result.scrollLeft = 0;\r\n    else if (x1 < screenleft)\r\n      result.scrollLeft = Math.max(0, x1 - (tooWide ? 0 : 10));\r\n    else if (x2 > screenw + screenleft - 3)\r\n      result.scrollLeft = x2 + (tooWide ? 0 : 10) - screenw;\r\n\r\n    return result;\r\n  }\r\n\r\n  // Store a relative adjustment to the scroll position in the current\r\n  // operation (to be applied when the operation finishes).\r\n  function addToScrollPos(cm, left, top) {\r\n    if (left != null || top != null) resolveScrollToPos(cm);\r\n    if (left != null)\r\n      cm.curOp.scrollLeft = (cm.curOp.scrollLeft == null ? cm.doc.scrollLeft : cm.curOp.scrollLeft) + left;\r\n    if (top != null)\r\n      cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\r\n  }\r\n\r\n  // Make sure that at the end of the operation the current cursor is\r\n  // shown.\r\n  function ensureCursorVisible(cm) {\r\n    resolveScrollToPos(cm);\r\n    var cur = cm.getCursor(), from = cur, to = cur;\r\n    if (!cm.options.lineWrapping) {\r\n      from = cur.ch ? Pos(cur.line, cur.ch - 1) : cur;\r\n      to = Pos(cur.line, cur.ch + 1);\r\n    }\r\n    cm.curOp.scrollToPos = {from: from, to: to, margin: cm.options.cursorScrollMargin, isCursor: true};\r\n  }\r\n\r\n  // When an operation has its scrollToPos property set, and another\r\n  // scroll action is applied before the end of the operation, this\r\n  // \'simulates\' scrolling that position into view in a cheap way, so\r\n  // that the effect of intermediate scroll commands is not ignored.\r\n  function resolveScrollToPos(cm) {\r\n    var range = cm.curOp.scrollToPos;\r\n    if (range) {\r\n      cm.curOp.scrollToPos = null;\r\n      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);\r\n      var sPos = calculateScrollPos(cm, Math.min(from.left, to.left),\r\n                                    Math.min(from.top, to.top) - range.margin,\r\n                                    Math.max(from.right, to.right),\r\n                                    Math.max(from.bottom, to.bottom) + range.margin);\r\n      cm.scrollTo(sPos.scrollLeft, sPos.scrollTop);\r\n    }\r\n  }\r\n\r\n  // API UTILITIES\r\n\r\n  // Indent the given line. The how parameter can be "smart",\r\n  // "add"/null, "subtract", or "prev". When aggressive is false\r\n  // (typically set to true for forced single-line indents), empty\r\n  // lines are not indented, and places where the mode returns Pass\r\n  // are left alone.\r\n  function indentLine(cm, n, how, aggressive) {\r\n    var doc = cm.doc, state;\r\n    if (how == null) how = "add";\r\n    if (how == "smart") {\r\n      // Fall back to "prev" when the mode doesn\'t have an indentation\r\n      // method.\r\n      if (!doc.mode.indent) how = "prev";\r\n      else state = getStateBefore(cm, n);\r\n    }\r\n\r\n    var tabSize = cm.options.tabSize;\r\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\r\n    if (line.stateAfter) line.stateAfter = null;\r\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\r\n    if (!aggressive && !/\\S/.test(line.text)) {\r\n      indentation = 0;\r\n      how = "not";\r\n    } else if (how == "smart") {\r\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\r\n      if (indentation == Pass || indentation > 150) {\r\n        if (!aggressive) return;\r\n        how = "prev";\r\n      }\r\n    }\r\n    if (how == "prev") {\r\n      if (n > doc.first) indentation = countColumn(getLine(doc, n-1).text, null, tabSize);\r\n      else indentation = 0;\r\n    } else if (how == "add") {\r\n      indentation = curSpace + cm.options.indentUnit;\r\n    } else if (how == "subtract") {\r\n      indentation = curSpace - cm.options.indentUnit;\r\n    } else if (typeof how == "number") {\r\n      indentation = curSpace + how;\r\n    }\r\n    indentation = Math.max(0, indentation);\r\n\r\n    var indentString = "", pos = 0;\r\n    if (cm.options.indentWithTabs)\r\n      for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\\t";}\r\n    if (pos < indentation) indentString += spaceStr(indentation - pos);\r\n\r\n    if (indentString != curSpaceString) {\r\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");\r\n    } else {\r\n      // Ensure that, if the cursor was in the whitespace at the start\r\n      // of the line, it is moved to the end of that space.\r\n      for (var i = 0; i < doc.sel.ranges.length; i++) {\r\n        var range = doc.sel.ranges[i];\r\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\r\n          var pos = Pos(n, curSpaceString.length);\r\n          replaceOneSelection(doc, i, new Range(pos, pos));\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    line.stateAfter = null;\r\n  }\r\n\r\n  // Utility for applying a change to a line by handle or number,\r\n  // returning the number and optionally registering the line as\r\n  // changed.\r\n  function changeLine(doc, handle, changeType, op) {\r\n    var no = handle, line = handle;\r\n    if (typeof handle == "number") line = getLine(doc, clipLine(doc, handle));\r\n    else no = lineNo(handle);\r\n    if (no == null) return null;\r\n    if (op(line, no) && doc.cm) regLineChange(doc.cm, no, changeType);\r\n    return line;\r\n  }\r\n\r\n  // Helper for deleting text near the selection(s), used to implement\r\n  // backspace, delete, and similar functionality.\r\n  function deleteNearSelection(cm, compute) {\r\n    var ranges = cm.doc.sel.ranges, kill = [];\r\n    // Build up a set of ranges to kill first, merging overlapping\r\n    // ranges.\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var toKill = compute(ranges[i]);\r\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\r\n        var replaced = kill.pop();\r\n        if (cmp(replaced.from, toKill.from) < 0) {\r\n          toKill.from = replaced.from;\r\n          break;\r\n        }\r\n      }\r\n      kill.push(toKill);\r\n    }\r\n    // Next, remove those actual ranges.\r\n    runInOp(cm, function() {\r\n      for (var i = kill.length - 1; i >= 0; i--)\r\n        replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");\r\n      ensureCursorVisible(cm);\r\n    });\r\n  }\r\n\r\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\r\n  // right), unit can be "char", "column" (like char, but doesn\'t\r\n  // cross line boundaries), "word" (across next word), or "group" (to\r\n  // the start of next group of word or non-word-non-whitespace\r\n  // chars). The visually param controls whether, in right-to-left\r\n  // text, direction 1 means to move towards the next index in the\r\n  // string, or towards the character to the right of the current\r\n  // position. The resulting position will have a hitSide=true\r\n  // property if it reached the end of the document.\r\n  function findPosH(doc, pos, dir, unit, visually) {\r\n    var line = pos.line, ch = pos.ch, origDir = dir;\r\n    var lineObj = getLine(doc, line);\r\n    var possible = true;\r\n    function findNextLine() {\r\n      var l = line + dir;\r\n      if (l < doc.first || l >= doc.first + doc.size) return (possible = false);\r\n      line = l;\r\n      return lineObj = getLine(doc, l);\r\n    }\r\n    function moveOnce(boundToLine) {\r\n      var next = (visually ? moveVisually : moveLogically)(lineObj, ch, dir, true);\r\n      if (next == null) {\r\n        if (!boundToLine && findNextLine()) {\r\n          if (visually) ch = (dir < 0 ? lineRight : lineLeft)(lineObj);\r\n          else ch = dir < 0 ? lineObj.text.length : 0;\r\n        } else return (possible = false);\r\n      } else ch = next;\r\n      return true;\r\n    }\r\n\r\n    if (unit == "char") moveOnce();\r\n    else if (unit == "column") moveOnce(true);\r\n    else if (unit == "word" || unit == "group") {\r\n      var sawType = null, group = unit == "group";\r\n      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");\r\n      for (var first = true;; first = false) {\r\n        if (dir < 0 && !moveOnce(!first)) break;\r\n        var cur = lineObj.text.charAt(ch) || "\\n";\r\n        var type = isWordChar(cur, helper) ? "w"\r\n          : group && cur == "\\n" ? "n"\r\n          : !group || /\\s/.test(cur) ? null\r\n          : "p";\r\n        if (group && !first && !type) type = "s";\r\n        if (sawType && sawType != type) {\r\n          if (dir < 0) {dir = 1; moveOnce();}\r\n          break;\r\n        }\r\n\r\n        if (type) sawType = type;\r\n        if (dir > 0 && !moveOnce(!first)) break;\r\n      }\r\n    }\r\n    var result = skipAtomic(doc, Pos(line, ch), origDir, true);\r\n    if (!possible) result.hitSide = true;\r\n    return result;\r\n  }\r\n\r\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\r\n  // "page" or "line". The resulting position will have a hitSide=true\r\n  // property if it reached the end of the document.\r\n  function findPosV(cm, pos, dir, unit) {\r\n    var doc = cm.doc, x = pos.left, y;\r\n    if (unit == "page") {\r\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\r\n      y = pos.top + dir * (pageSize - (dir < 0 ? 1.5 : .5) * textHeight(cm.display));\r\n    } else if (unit == "line") {\r\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\r\n    }\r\n    for (;;) {\r\n      var target = coordsChar(cm, x, y);\r\n      if (!target.outside) break;\r\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break; }\r\n      y += dir * 5;\r\n    }\r\n    return target;\r\n  }\r\n\r\n  // EDITOR METHODS\r\n\r\n  // The publicly visible API. Note that methodOp(f) means\r\n  // \'wrap f in an operation, performed on its `this` parameter\'.\r\n\r\n  // This is not the complete set of editor methods. Most of the\r\n  // methods defined on the Doc type are also injected into\r\n  // CodeMirror.prototype, for backwards compatibility and\r\n  // convenience.\r\n\r\n  CodeMirror.prototype = {\r\n    constructor: CodeMirror,\r\n    focus: function(){window.focus(); focusInput(this); fastPoll(this);},\r\n\r\n    setOption: function(option, value) {\r\n      var options = this.options, old = options[option];\r\n      if (options[option] == value && option != "mode") return;\r\n      options[option] = value;\r\n      if (optionHandlers.hasOwnProperty(option))\r\n        operation(this, optionHandlers[option])(this, value, old);\r\n    },\r\n\r\n    getOption: function(option) {return this.options[option];},\r\n    getDoc: function() {return this.doc;},\r\n\r\n    addKeyMap: function(map, bottom) {\r\n      this.state.keyMaps[bottom ? "push" : "unshift"](map);\r\n    },\r\n    removeKeyMap: function(map) {\r\n      var maps = this.state.keyMaps;\r\n      for (var i = 0; i < maps.length; ++i)\r\n        if (maps[i] == map || (typeof maps[i] != "string" && maps[i].name == map)) {\r\n          maps.splice(i, 1);\r\n          return true;\r\n        }\r\n    },\r\n\r\n    addOverlay: methodOp(function(spec, options) {\r\n      var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\r\n      if (mode.startState) throw new Error("Overlays may not be stateful.");\r\n      this.state.overlays.push({mode: mode, modeSpec: spec, opaque: options && options.opaque});\r\n      this.state.modeGen++;\r\n      regChange(this);\r\n    }),\r\n    removeOverlay: methodOp(function(spec) {\r\n      var overlays = this.state.overlays;\r\n      for (var i = 0; i < overlays.length; ++i) {\r\n        var cur = overlays[i].modeSpec;\r\n        if (cur == spec || typeof spec == "string" && cur.name == spec) {\r\n          overlays.splice(i, 1);\r\n          this.state.modeGen++;\r\n          regChange(this);\r\n          return;\r\n        }\r\n      }\r\n    }),\r\n\r\n    indentLine: methodOp(function(n, dir, aggressive) {\r\n      if (typeof dir != "string" && typeof dir != "number") {\r\n        if (dir == null) dir = this.options.smartIndent ? "smart" : "prev";\r\n        else dir = dir ? "add" : "subtract";\r\n      }\r\n      if (isLine(this.doc, n)) indentLine(this, n, dir, aggressive);\r\n    }),\r\n    indentSelection: methodOp(function(how) {\r\n      var ranges = this.doc.sel.ranges, end = -1;\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var range = ranges[i];\r\n        if (!range.empty()) {\r\n          var from = range.from(), to = range.to();\r\n          var start = Math.max(end, from.line);\r\n          end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\r\n          for (var j = start; j < end; ++j)\r\n            indentLine(this, j, how);\r\n          var newRanges = this.doc.sel.ranges;\r\n          if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\r\n            replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll);\r\n        } else if (range.head.line > end) {\r\n          indentLine(this, range.head.line, how, true);\r\n          end = range.head.line;\r\n          if (i == this.doc.sel.primIndex) ensureCursorVisible(this);\r\n        }\r\n      }\r\n    }),\r\n\r\n    // Fetch the parser token for a given character. Useful for hacks\r\n    // that want to inspect the mode state (say, for completion).\r\n    getTokenAt: function(pos, precise) {\r\n      var doc = this.doc;\r\n      pos = clipPos(doc, pos);\r\n      var state = getStateBefore(this, pos.line, precise), mode = this.doc.mode;\r\n      var line = getLine(doc, pos.line);\r\n      var stream = new StringStream(line.text, this.options.tabSize);\r\n      while (stream.pos < pos.ch && !stream.eol()) {\r\n        stream.start = stream.pos;\r\n        var style = readToken(mode, stream, state);\r\n      }\r\n      return {start: stream.start,\r\n              end: stream.pos,\r\n              string: stream.current(),\r\n              type: style || null,\r\n              state: state};\r\n    },\r\n\r\n    getTokenTypeAt: function(pos) {\r\n      pos = clipPos(this.doc, pos);\r\n      var styles = getLineStyles(this, getLine(this.doc, pos.line));\r\n      var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\r\n      var type;\r\n      if (ch == 0) type = styles[2];\r\n      else for (;;) {\r\n        var mid = (before + after) >> 1;\r\n        if ((mid ? styles[mid * 2 - 1] : 0) >= ch) after = mid;\r\n        else if (styles[mid * 2 + 1] < ch) before = mid + 1;\r\n        else { type = styles[mid * 2 + 2]; break; }\r\n      }\r\n      var cut = type ? type.indexOf("cm-overlay ") : -1;\r\n      return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1);\r\n    },\r\n\r\n    getModeAt: function(pos) {\r\n      var mode = this.doc.mode;\r\n      if (!mode.innerMode) return mode;\r\n      return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode;\r\n    },\r\n\r\n    getHelper: function(pos, type) {\r\n      return this.getHelpers(pos, type)[0];\r\n    },\r\n\r\n    getHelpers: function(pos, type) {\r\n      var found = [];\r\n      if (!helpers.hasOwnProperty(type)) return helpers;\r\n      var help = helpers[type], mode = this.getModeAt(pos);\r\n      if (typeof mode[type] == "string") {\r\n        if (help[mode[type]]) found.push(help[mode[type]]);\r\n      } else if (mode[type]) {\r\n        for (var i = 0; i < mode[type].length; i++) {\r\n          var val = help[mode[type][i]];\r\n          if (val) found.push(val);\r\n        }\r\n      } else if (mode.helperType && help[mode.helperType]) {\r\n        found.push(help[mode.helperType]);\r\n      } else if (help[mode.name]) {\r\n        found.push(help[mode.name]);\r\n      }\r\n      for (var i = 0; i < help._global.length; i++) {\r\n        var cur = help._global[i];\r\n        if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)\r\n          found.push(cur.val);\r\n      }\r\n      return found;\r\n    },\r\n\r\n    getStateAfter: function(line, precise) {\r\n      var doc = this.doc;\r\n      line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\r\n      return getStateBefore(this, line + 1, precise);\r\n    },\r\n\r\n    cursorCoords: function(start, mode) {\r\n      var pos, range = this.doc.sel.primary();\r\n      if (start == null) pos = range.head;\r\n      else if (typeof start == "object") pos = clipPos(this.doc, start);\r\n      else pos = start ? range.from() : range.to();\r\n      return cursorCoords(this, pos, mode || "page");\r\n    },\r\n\r\n    charCoords: function(pos, mode) {\r\n      return charCoords(this, clipPos(this.doc, pos), mode || "page");\r\n    },\r\n\r\n    coordsChar: function(coords, mode) {\r\n      coords = fromCoordSystem(this, coords, mode || "page");\r\n      return coordsChar(this, coords.left, coords.top);\r\n    },\r\n\r\n    lineAtHeight: function(height, mode) {\r\n      height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;\r\n      return lineAtHeight(this.doc, height + this.display.viewOffset);\r\n    },\r\n    heightAtLine: function(line, mode) {\r\n      var end = false, last = this.doc.first + this.doc.size - 1;\r\n      if (line < this.doc.first) line = this.doc.first;\r\n      else if (line > last) { line = last; end = true; }\r\n      var lineObj = getLine(this.doc, line);\r\n      return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page").top +\r\n        (end ? this.doc.height - heightAtLine(lineObj) : 0);\r\n    },\r\n\r\n    defaultTextHeight: function() { return textHeight(this.display); },\r\n    defaultCharWidth: function() { return charWidth(this.display); },\r\n\r\n    setGutterMarker: methodOp(function(line, gutterID, value) {\r\n      return changeLine(this.doc, line, "gutter", function(line) {\r\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\r\n        markers[gutterID] = value;\r\n        if (!value && isEmpty(markers)) line.gutterMarkers = null;\r\n        return true;\r\n      });\r\n    }),\r\n\r\n    clearGutter: methodOp(function(gutterID) {\r\n      var cm = this, doc = cm.doc, i = doc.first;\r\n      doc.iter(function(line) {\r\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\r\n          line.gutterMarkers[gutterID] = null;\r\n          regLineChange(cm, i, "gutter");\r\n          if (isEmpty(line.gutterMarkers)) line.gutterMarkers = null;\r\n        }\r\n        ++i;\r\n      });\r\n    }),\r\n\r\n    addLineWidget: methodOp(function(handle, node, options) {\r\n      return addLineWidget(this, handle, node, options);\r\n    }),\r\n\r\n    removeLineWidget: function(widget) { widget.clear(); },\r\n\r\n    lineInfo: function(line) {\r\n      if (typeof line == "number") {\r\n        if (!isLine(this.doc, line)) return null;\r\n        var n = line;\r\n        line = getLine(this.doc, line);\r\n        if (!line) return null;\r\n      } else {\r\n        var n = lineNo(line);\r\n        if (n == null) return null;\r\n      }\r\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\r\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\r\n              widgets: line.widgets};\r\n    },\r\n\r\n    getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo};},\r\n\r\n    addWidget: function(pos, node, scroll, vert, horiz) {\r\n      var display = this.display;\r\n      pos = cursorCoords(this, clipPos(this.doc, pos));\r\n      var top = pos.bottom, left = pos.left;\r\n      node.style.position = "absolute";\r\n      display.sizer.appendChild(node);\r\n      if (vert == "over") {\r\n        top = pos.top;\r\n      } else if (vert == "above" || vert == "near") {\r\n        var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\r\n        hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\r\n        // Default to positioning above (if specified and possible); otherwise default to positioning below\r\n        if ((vert == \'above\' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\r\n          top = pos.top - node.offsetHeight;\r\n        else if (pos.bottom + node.offsetHeight <= vspace)\r\n          top = pos.bottom;\r\n        if (left + node.offsetWidth > hspace)\r\n          left = hspace - node.offsetWidth;\r\n      }\r\n      node.style.top = top + "px";\r\n      node.style.left = node.style.right = "";\r\n      if (horiz == "right") {\r\n        left = display.sizer.clientWidth - node.offsetWidth;\r\n        node.style.right = "0px";\r\n      } else {\r\n        if (horiz == "left") left = 0;\r\n        else if (horiz == "middle") left = (display.sizer.clientWidth - node.offsetWidth) / 2;\r\n        node.style.left = left + "px";\r\n      }\r\n      if (scroll)\r\n        scrollIntoView(this, left, top, left + node.offsetWidth, top + node.offsetHeight);\r\n    },\r\n\r\n    triggerOnKeyDown: methodOp(onKeyDown),\r\n    triggerOnKeyPress: methodOp(onKeyPress),\r\n    triggerOnKeyUp: onKeyUp,\r\n\r\n    execCommand: function(cmd) {\r\n      if (commands.hasOwnProperty(cmd))\r\n        return commands[cmd](this);\r\n    },\r\n\r\n    findPosH: function(from, amount, unit, visually) {\r\n      var dir = 1;\r\n      if (amount < 0) { dir = -1; amount = -amount; }\r\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\r\n        cur = findPosH(this.doc, cur, dir, unit, visually);\r\n        if (cur.hitSide) break;\r\n      }\r\n      return cur;\r\n    },\r\n\r\n    moveH: methodOp(function(dir, unit) {\r\n      var cm = this;\r\n      cm.extendSelectionsBy(function(range) {\r\n        if (cm.display.shift || cm.doc.extend || range.empty())\r\n          return findPosH(cm.doc, range.head, dir, unit, cm.options.rtlMoveVisually);\r\n        else\r\n          return dir < 0 ? range.from() : range.to();\r\n      }, sel_move);\r\n    }),\r\n\r\n    deleteH: methodOp(function(dir, unit) {\r\n      var sel = this.doc.sel, doc = this.doc;\r\n      if (sel.somethingSelected())\r\n        doc.replaceSelection("", null, "+delete");\r\n      else\r\n        deleteNearSelection(this, function(range) {\r\n          var other = findPosH(doc, range.head, dir, unit, false);\r\n          return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other};\r\n        });\r\n    }),\r\n\r\n    findPosV: function(from, amount, unit, goalColumn) {\r\n      var dir = 1, x = goalColumn;\r\n      if (amount < 0) { dir = -1; amount = -amount; }\r\n      for (var i = 0, cur = clipPos(this.doc, from); i < amount; ++i) {\r\n        var coords = cursorCoords(this, cur, "div");\r\n        if (x == null) x = coords.left;\r\n        else coords.left = x;\r\n        cur = findPosV(this, coords, dir, unit);\r\n        if (cur.hitSide) break;\r\n      }\r\n      return cur;\r\n    },\r\n\r\n    moveV: methodOp(function(dir, unit) {\r\n      var cm = this, doc = this.doc, goals = [];\r\n      var collapse = !cm.display.shift && !doc.extend && doc.sel.somethingSelected();\r\n      doc.extendSelectionsBy(function(range) {\r\n        if (collapse)\r\n          return dir < 0 ? range.from() : range.to();\r\n        var headPos = cursorCoords(cm, range.head, "div");\r\n        if (range.goalColumn != null) headPos.left = range.goalColumn;\r\n        goals.push(headPos.left);\r\n        var pos = findPosV(cm, headPos, dir, unit);\r\n        if (unit == "page" && range == doc.sel.primary())\r\n          addToScrollPos(cm, null, charCoords(cm, pos, "div").top - headPos.top);\r\n        return pos;\r\n      }, sel_move);\r\n      if (goals.length) for (var i = 0; i < doc.sel.ranges.length; i++)\r\n        doc.sel.ranges[i].goalColumn = goals[i];\r\n    }),\r\n\r\n    // Find the word at the given position (as returned by coordsChar).\r\n    findWordAt: function(pos) {\r\n      var doc = this.doc, line = getLine(doc, pos.line).text;\r\n      var start = pos.ch, end = pos.ch;\r\n      if (line) {\r\n        var helper = this.getHelper(pos, "wordChars");\r\n        if ((pos.xRel < 0 || end == line.length) && start) --start; else ++end;\r\n        var startChar = line.charAt(start);\r\n        var check = isWordChar(startChar, helper)\r\n          ? function(ch) { return isWordChar(ch, helper); }\r\n          : /\\s/.test(startChar) ? function(ch) {return /\\s/.test(ch);}\r\n          : function(ch) {return !/\\s/.test(ch) && !isWordChar(ch);};\r\n        while (start > 0 && check(line.charAt(start - 1))) --start;\r\n        while (end < line.length && check(line.charAt(end))) ++end;\r\n      }\r\n      return new Range(Pos(pos.line, start), Pos(pos.line, end));\r\n    },\r\n\r\n    toggleOverwrite: function(value) {\r\n      if (value != null && value == this.state.overwrite) return;\r\n      if (this.state.overwrite = !this.state.overwrite)\r\n        addClass(this.display.cursorDiv, "CodeMirror-overwrite");\r\n      else\r\n        rmClass(this.display.cursorDiv, "CodeMirror-overwrite");\r\n\r\n      signal(this, "overwriteToggle", this, this.state.overwrite);\r\n    },\r\n    hasFocus: function() { return activeElt() == this.display.input; },\r\n\r\n    scrollTo: methodOp(function(x, y) {\r\n      if (x != null || y != null) resolveScrollToPos(this);\r\n      if (x != null) this.curOp.scrollLeft = x;\r\n      if (y != null) this.curOp.scrollTop = y;\r\n    }),\r\n    getScrollInfo: function() {\r\n      var scroller = this.display.scroller, co = scrollerCutOff;\r\n      return {left: scroller.scrollLeft, top: scroller.scrollTop,\r\n              height: scroller.scrollHeight - co, width: scroller.scrollWidth - co,\r\n              clientHeight: scroller.clientHeight - co, clientWidth: scroller.clientWidth - co};\r\n    },\r\n\r\n    scrollIntoView: methodOp(function(range, margin) {\r\n      if (range == null) {\r\n        range = {from: this.doc.sel.primary().head, to: null};\r\n        if (margin == null) margin = this.options.cursorScrollMargin;\r\n      } else if (typeof range == "number") {\r\n        range = {from: Pos(range, 0), to: null};\r\n      } else if (range.from == null) {\r\n        range = {from: range, to: null};\r\n      }\r\n      if (!range.to) range.to = range.from;\r\n      range.margin = margin || 0;\r\n\r\n      if (range.from.line != null) {\r\n        resolveScrollToPos(this);\r\n        this.curOp.scrollToPos = range;\r\n      } else {\r\n        var sPos = calculateScrollPos(this, Math.min(range.from.left, range.to.left),\r\n                                      Math.min(range.from.top, range.to.top) - range.margin,\r\n                                      Math.max(range.from.right, range.to.right),\r\n                                      Math.max(range.from.bottom, range.to.bottom) + range.margin);\r\n        this.scrollTo(sPos.scrollLeft, sPos.scrollTop);\r\n      }\r\n    }),\r\n\r\n    setSize: methodOp(function(width, height) {\r\n      var cm = this;\r\n      function interpret(val) {\r\n        return typeof val == "number" || /^\\d+$/.test(String(val)) ? val + "px" : val;\r\n      }\r\n      if (width != null) cm.display.wrapper.style.width = interpret(width);\r\n      if (height != null) cm.display.wrapper.style.height = interpret(height);\r\n      if (cm.options.lineWrapping) clearLineMeasurementCache(this);\r\n      var lineNo = cm.display.viewFrom;\r\n      cm.doc.iter(lineNo, cm.display.viewTo, function(line) {\r\n        if (line.widgets) for (var i = 0; i < line.widgets.length; i++)\r\n          if (line.widgets[i].noHScroll) { regLineChange(cm, lineNo, "widget"); break; }\r\n        ++lineNo;\r\n      });\r\n      cm.curOp.forceUpdate = true;\r\n      signal(cm, "refresh", this);\r\n    }),\r\n\r\n    operation: function(f){return runInOp(this, f);},\r\n\r\n    refresh: methodOp(function() {\r\n      var oldHeight = this.display.cachedTextHeight;\r\n      regChange(this);\r\n      this.curOp.forceUpdate = true;\r\n      clearCaches(this);\r\n      this.scrollTo(this.doc.scrollLeft, this.doc.scrollTop);\r\n      updateGutterSpace(this);\r\n      if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\r\n        estimateLineHeights(this);\r\n      signal(this, "refresh", this);\r\n    }),\r\n\r\n    swapDoc: methodOp(function(doc) {\r\n      var old = this.doc;\r\n      old.cm = null;\r\n      attachDoc(this, doc);\r\n      clearCaches(this);\r\n      resetInput(this);\r\n      this.scrollTo(doc.scrollLeft, doc.scrollTop);\r\n      this.curOp.forceScroll = true;\r\n      signalLater(this, "swapDoc", this, old);\r\n      return old;\r\n    }),\r\n\r\n    getInputField: function(){return this.display.input;},\r\n    getWrapperElement: function(){return this.display.wrapper;},\r\n    getScrollerElement: function(){return this.display.scroller;},\r\n    getGutterElement: function(){return this.display.gutters;}\r\n  };\r\n  eventMixin(CodeMirror);\r\n\r\n  // OPTION DEFAULTS\r\n\r\n  // The default configuration options.\r\n  var defaults = CodeMirror.defaults = {};\r\n  // Functions to run when options are changed.\r\n  var optionHandlers = CodeMirror.optionHandlers = {};\r\n\r\n  function option(name, deflt, handle, notOnInit) {\r\n    CodeMirror.defaults[name] = deflt;\r\n    if (handle) optionHandlers[name] =\r\n      notOnInit ? function(cm, val, old) {if (old != Init) handle(cm, val, old);} : handle;\r\n  }\r\n\r\n  // Passed to option handlers when there is no old value.\r\n  var Init = CodeMirror.Init = {toString: function(){return "CodeMirror.Init";}};\r\n\r\n  // These two are, on init, called from the constructor because they\r\n  // have to be initialized before the editor can start at all.\r\n  option("value", "", function(cm, val) {\r\n    cm.setValue(val);\r\n  }, true);\r\n  option("mode", null, function(cm, val) {\r\n    cm.doc.modeOption = val;\r\n    loadMode(cm);\r\n  }, true);\r\n\r\n  option("indentUnit", 2, loadMode, true);\r\n  option("indentWithTabs", false);\r\n  option("smartIndent", true);\r\n  option("tabSize", 4, function(cm) {\r\n    resetModeState(cm);\r\n    clearCaches(cm);\r\n    regChange(cm);\r\n  }, true);\r\n  option("specialChars", /[\\t\\u0000-\\u0019\\u00ad\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function(cm, val) {\r\n    cm.options.specialChars = new RegExp(val.source + (val.test("\\t") ? "" : "|\\t"), "g");\r\n    cm.refresh();\r\n  }, true);\r\n  option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {cm.refresh();}, true);\r\n  option("electricChars", true);\r\n  option("rtlMoveVisually", !windows);\r\n  option("wholeLineUpdateBefore", true);\r\n\r\n  option("theme", "default", function(cm) {\r\n    themeChanged(cm);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option("keyMap", "default", keyMapChanged);\r\n  option("extraKeys", null);\r\n\r\n  option("lineWrapping", false, wrappingChanged, true);\r\n  option("gutters", [], function(cm) {\r\n    setGuttersForLineNumbers(cm.options);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option("fixedGutter", true, function(cm, val) {\r\n    cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";\r\n    cm.refresh();\r\n  }, true);\r\n  option("coverGutterNextToScrollbar", false, updateScrollbars, true);\r\n  option("lineNumbers", false, function(cm) {\r\n    setGuttersForLineNumbers(cm.options);\r\n    guttersChanged(cm);\r\n  }, true);\r\n  option("firstLineNumber", 1, guttersChanged, true);\r\n  option("lineNumberFormatter", function(integer) {return integer;}, guttersChanged, true);\r\n  option("showCursorWhenSelecting", false, updateSelection, true);\r\n\r\n  option("resetSelectionOnContextMenu", true);\r\n\r\n  option("readOnly", false, function(cm, val) {\r\n    if (val == "nocursor") {\r\n      onBlur(cm);\r\n      cm.display.input.blur();\r\n      cm.display.disabled = true;\r\n    } else {\r\n      cm.display.disabled = false;\r\n      if (!val) resetInput(cm);\r\n    }\r\n  });\r\n  option("disableInput", false, function(cm, val) {if (!val) resetInput(cm);}, true);\r\n  option("dragDrop", true);\r\n\r\n  option("cursorBlinkRate", 530);\r\n  option("cursorScrollMargin", 0);\r\n  option("cursorHeight", 1, updateSelection, true);\r\n  option("singleCursorHeightPerLine", true, updateSelection, true);\r\n  option("workTime", 100);\r\n  option("workDelay", 100);\r\n  option("flattenSpans", true, resetModeState, true);\r\n  option("addModeClass", false, resetModeState, true);\r\n  option("pollInterval", 100);\r\n  option("undoDepth", 200, function(cm, val){cm.doc.history.undoDepth = val;});\r\n  option("historyEventDelay", 1250);\r\n  option("viewportMargin", 10, function(cm){cm.refresh();}, true);\r\n  option("maxHighlightLength", 10000, resetModeState, true);\r\n  option("moveInputWithCursor", true, function(cm, val) {\r\n    if (!val) cm.display.inputDiv.style.top = cm.display.inputDiv.style.left = 0;\r\n  });\r\n\r\n  option("tabindex", null, function(cm, val) {\r\n    cm.display.input.tabIndex = val || "";\r\n  });\r\n  option("autofocus", null);\r\n\r\n  // MODE DEFINITION AND QUERYING\r\n\r\n  // Known modes, by name and by MIME\r\n  var modes = CodeMirror.modes = {}, mimeModes = CodeMirror.mimeModes = {};\r\n\r\n  // Extra arguments are stored as the mode\'s dependencies, which is\r\n  // used by (legacy) mechanisms like loadmode.js to automatically\r\n  // load a mode. (Preferred mechanism is the require/define calls.)\r\n  CodeMirror.defineMode = function(name, mode) {\r\n    if (!CodeMirror.defaults.mode && name != "null") CodeMirror.defaults.mode = name;\r\n    if (arguments.length > 2) {\r\n      mode.dependencies = [];\r\n      for (var i = 2; i < arguments.length; ++i) mode.dependencies.push(arguments[i]);\r\n    }\r\n    modes[name] = mode;\r\n  };\r\n\r\n  CodeMirror.defineMIME = function(mime, spec) {\r\n    mimeModes[mime] = spec;\r\n  };\r\n\r\n  // Given a MIME type, a {name, ...options} config object, or a name\r\n  // string, return a mode config object.\r\n  CodeMirror.resolveMode = function(spec) {\r\n    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {\r\n      spec = mimeModes[spec];\r\n    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {\r\n      var found = mimeModes[spec.name];\r\n      if (typeof found == "string") found = {name: found};\r\n      spec = createObj(found, spec);\r\n      spec.name = found.name;\r\n    } else if (typeof spec == "string" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\r\n      return CodeMirror.resolveMode("application/xml");\r\n    }\r\n    if (typeof spec == "string") return {name: spec};\r\n    else return spec || {name: "null"};\r\n  };\r\n\r\n  // Given a mode spec (anything that resolveMode accepts), find and\r\n  // initialize an actual mode object.\r\n  CodeMirror.getMode = function(options, spec) {\r\n    var spec = CodeMirror.resolveMode(spec);\r\n    var mfactory = modes[spec.name];\r\n    if (!mfactory) return CodeMirror.getMode(options, "text/plain");\r\n    var modeObj = mfactory(options, spec);\r\n    if (modeExtensions.hasOwnProperty(spec.name)) {\r\n      var exts = modeExtensions[spec.name];\r\n      for (var prop in exts) {\r\n        if (!exts.hasOwnProperty(prop)) continue;\r\n        if (modeObj.hasOwnProperty(prop)) modeObj["_" + prop] = modeObj[prop];\r\n        modeObj[prop] = exts[prop];\r\n      }\r\n    }\r\n    modeObj.name = spec.name;\r\n    if (spec.helperType) modeObj.helperType = spec.helperType;\r\n    if (spec.modeProps) for (var prop in spec.modeProps)\r\n      modeObj[prop] = spec.modeProps[prop];\r\n\r\n    return modeObj;\r\n  };\r\n\r\n  // Minimal default mode.\r\n  CodeMirror.defineMode("null", function() {\r\n    return {token: function(stream) {stream.skipToEnd();}};\r\n  });\r\n  CodeMirror.defineMIME("text/plain", "null");\r\n\r\n  // This can be used to attach properties to mode objects from\r\n  // outside the actual mode definition.\r\n  var modeExtensions = CodeMirror.modeExtensions = {};\r\n  CodeMirror.extendMode = function(mode, properties) {\r\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\r\n    copyObj(properties, exts);\r\n  };\r\n\r\n  // EXTENSIONS\r\n\r\n  CodeMirror.defineExtension = function(name, func) {\r\n    CodeMirror.prototype[name] = func;\r\n  };\r\n  CodeMirror.defineDocExtension = function(name, func) {\r\n    Doc.prototype[name] = func;\r\n  };\r\n  CodeMirror.defineOption = option;\r\n\r\n  var initHooks = [];\r\n  CodeMirror.defineInitHook = function(f) {initHooks.push(f);};\r\n\r\n  var helpers = CodeMirror.helpers = {};\r\n  CodeMirror.registerHelper = function(type, name, value) {\r\n    if (!helpers.hasOwnProperty(type)) helpers[type] = CodeMirror[type] = {_global: []};\r\n    helpers[type][name] = value;\r\n  };\r\n  CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\r\n    CodeMirror.registerHelper(type, name, value);\r\n    helpers[type]._global.push({pred: predicate, val: value});\r\n  };\r\n\r\n  // MODE STATE HANDLING\r\n\r\n  // Utility functions for working with state. Exported because nested\r\n  // modes need to do this for their inner modes.\r\n\r\n  var copyState = CodeMirror.copyState = function(mode, state) {\r\n    if (state === true) return state;\r\n    if (mode.copyState) return mode.copyState(state);\r\n    var nstate = {};\r\n    for (var n in state) {\r\n      var val = state[n];\r\n      if (val instanceof Array) val = val.concat([]);\r\n      nstate[n] = val;\r\n    }\r\n    return nstate;\r\n  };\r\n\r\n  var startState = CodeMirror.startState = function(mode, a1, a2) {\r\n    return mode.startState ? mode.startState(a1, a2) : true;\r\n  };\r\n\r\n  // Given a mode and a state (for that mode), find the inner mode and\r\n  // state at the position that the state refers to.\r\n  CodeMirror.innerMode = function(mode, state) {\r\n    while (mode.innerMode) {\r\n      var info = mode.innerMode(state);\r\n      if (!info || info.mode == mode) break;\r\n      state = info.state;\r\n      mode = info.mode;\r\n    }\r\n    return info || {mode: mode, state: state};\r\n  };\r\n\r\n  // STANDARD COMMANDS\r\n\r\n  // Commands are parameter-less actions that can be performed on an\r\n  // editor, mostly used for keybindings.\r\n  var commands = CodeMirror.commands = {\r\n    selectAll: function(cm) {cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);},\r\n    singleSelection: function(cm) {\r\n      cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);\r\n    },\r\n    killLine: function(cm) {\r\n      deleteNearSelection(cm, function(range) {\r\n        if (range.empty()) {\r\n          var len = getLine(cm.doc, range.head.line).text.length;\r\n          if (range.head.ch == len && range.head.line < cm.lastLine())\r\n            return {from: range.head, to: Pos(range.head.line + 1, 0)};\r\n          else\r\n            return {from: range.head, to: Pos(range.head.line, len)};\r\n        } else {\r\n          return {from: range.from(), to: range.to()};\r\n        }\r\n      });\r\n    },\r\n    deleteLine: function(cm) {\r\n      deleteNearSelection(cm, function(range) {\r\n        return {from: Pos(range.from().line, 0),\r\n                to: clipPos(cm.doc, Pos(range.to().line + 1, 0))};\r\n      });\r\n    },\r\n    delLineLeft: function(cm) {\r\n      deleteNearSelection(cm, function(range) {\r\n        return {from: Pos(range.from().line, 0), to: range.from()};\r\n      });\r\n    },\r\n    delWrappedLineLeft: function(cm) {\r\n      deleteNearSelection(cm, function(range) {\r\n        var top = cm.charCoords(range.head, "div").top + 5;\r\n        var leftPos = cm.coordsChar({left: 0, top: top}, "div");\r\n        return {from: leftPos, to: range.from()};\r\n      });\r\n    },\r\n    delWrappedLineRight: function(cm) {\r\n      deleteNearSelection(cm, function(range) {\r\n        var top = cm.charCoords(range.head, "div").top + 5;\r\n        var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");\r\n        return {from: range.from(), to: rightPos };\r\n      });\r\n    },\r\n    undo: function(cm) {cm.undo();},\r\n    redo: function(cm) {cm.redo();},\r\n    undoSelection: function(cm) {cm.undoSelection();},\r\n    redoSelection: function(cm) {cm.redoSelection();},\r\n    goDocStart: function(cm) {cm.extendSelection(Pos(cm.firstLine(), 0));},\r\n    goDocEnd: function(cm) {cm.extendSelection(Pos(cm.lastLine()));},\r\n    goLineStart: function(cm) {\r\n      cm.extendSelectionsBy(function(range) { return lineStart(cm, range.head.line); },\r\n                            {origin: "+move", bias: 1});\r\n    },\r\n    goLineStartSmart: function(cm) {\r\n      cm.extendSelectionsBy(function(range) {\r\n        return lineStartSmart(cm, range.head);\r\n      }, {origin: "+move", bias: 1});\r\n    },\r\n    goLineEnd: function(cm) {\r\n      cm.extendSelectionsBy(function(range) { return lineEnd(cm, range.head.line); },\r\n                            {origin: "+move", bias: -1});\r\n    },\r\n    goLineRight: function(cm) {\r\n      cm.extendSelectionsBy(function(range) {\r\n        var top = cm.charCoords(range.head, "div").top + 5;\r\n        return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");\r\n      }, sel_move);\r\n    },\r\n    goLineLeft: function(cm) {\r\n      cm.extendSelectionsBy(function(range) {\r\n        var top = cm.charCoords(range.head, "div").top + 5;\r\n        return cm.coordsChar({left: 0, top: top}, "div");\r\n      }, sel_move);\r\n    },\r\n    goLineLeftSmart: function(cm) {\r\n      cm.extendSelectionsBy(function(range) {\r\n        var top = cm.charCoords(range.head, "div").top + 5;\r\n        var pos = cm.coordsChar({left: 0, top: top}, "div");\r\n        if (pos.ch < cm.getLine(pos.line).search(/\\S/)) return lineStartSmart(cm, range.head);\r\n        return pos;\r\n      }, sel_move);\r\n    },\r\n    goLineUp: function(cm) {cm.moveV(-1, "line");},\r\n    goLineDown: function(cm) {cm.moveV(1, "line");},\r\n    goPageUp: function(cm) {cm.moveV(-1, "page");},\r\n    goPageDown: function(cm) {cm.moveV(1, "page");},\r\n    goCharLeft: function(cm) {cm.moveH(-1, "char");},\r\n    goCharRight: function(cm) {cm.moveH(1, "char");},\r\n    goColumnLeft: function(cm) {cm.moveH(-1, "column");},\r\n    goColumnRight: function(cm) {cm.moveH(1, "column");},\r\n    goWordLeft: function(cm) {cm.moveH(-1, "word");},\r\n    goGroupRight: function(cm) {cm.moveH(1, "group");},\r\n    goGroupLeft: function(cm) {cm.moveH(-1, "group");},\r\n    goWordRight: function(cm) {cm.moveH(1, "word");},\r\n    delCharBefore: function(cm) {cm.deleteH(-1, "char");},\r\n    delCharAfter: function(cm) {cm.deleteH(1, "char");},\r\n    delWordBefore: function(cm) {cm.deleteH(-1, "word");},\r\n    delWordAfter: function(cm) {cm.deleteH(1, "word");},\r\n    delGroupBefore: function(cm) {cm.deleteH(-1, "group");},\r\n    delGroupAfter: function(cm) {cm.deleteH(1, "group");},\r\n    indentAuto: function(cm) {cm.indentSelection("smart");},\r\n    indentMore: function(cm) {cm.indentSelection("add");},\r\n    indentLess: function(cm) {cm.indentSelection("subtract");},\r\n    insertTab: function(cm) {cm.replaceSelection("\\t");},\r\n    insertSoftTab: function(cm) {\r\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var pos = ranges[i].from();\r\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\r\n        spaces.push(new Array(tabSize - col % tabSize + 1).join(" "));\r\n      }\r\n      cm.replaceSelections(spaces);\r\n    },\r\n    defaultTab: function(cm) {\r\n      if (cm.somethingSelected()) cm.indentSelection("add");\r\n      else cm.execCommand("insertTab");\r\n    },\r\n    transposeChars: function(cm) {\r\n      runInOp(cm, function() {\r\n        var ranges = cm.listSelections(), newSel = [];\r\n        for (var i = 0; i < ranges.length; i++) {\r\n          var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\r\n          if (line) {\r\n            if (cur.ch == line.length) cur = new Pos(cur.line, cur.ch - 1);\r\n            if (cur.ch > 0) {\r\n              cur = new Pos(cur.line, cur.ch + 1);\r\n              cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\r\n                              Pos(cur.line, cur.ch - 2), cur, "+transpose");\r\n            } else if (cur.line > cm.doc.first) {\r\n              var prev = getLine(cm.doc, cur.line - 1).text;\r\n              if (prev)\r\n                cm.replaceRange(line.charAt(0) + "\\n" + prev.charAt(prev.length - 1),\r\n                                Pos(cur.line - 1, prev.length - 1), Pos(cur.line, 1), "+transpose");\r\n            }\r\n          }\r\n          newSel.push(new Range(cur, cur));\r\n        }\r\n        cm.setSelections(newSel);\r\n      });\r\n    },\r\n    newlineAndIndent: function(cm) {\r\n      runInOp(cm, function() {\r\n        var len = cm.listSelections().length;\r\n        for (var i = 0; i < len; i++) {\r\n          var range = cm.listSelections()[i];\r\n          cm.replaceRange("\\n", range.anchor, range.head, "+input");\r\n          cm.indentLine(range.from().line + 1, null, true);\r\n          ensureCursorVisible(cm);\r\n        }\r\n      });\r\n    },\r\n    toggleOverwrite: function(cm) {cm.toggleOverwrite();}\r\n  };\r\n\r\n  // STANDARD KEYMAPS\r\n\r\n  var keyMap = CodeMirror.keyMap = {};\r\n  keyMap.basic = {\r\n    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",\r\n    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",\r\n    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",\r\n    "Tab": "defaultTab", "Shift-Tab": "indentAuto",\r\n    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",\r\n    "Esc": "singleSelection"\r\n  };\r\n  // Note that the save and find-related commands aren\'t defined by\r\n  // default. User code or addons can define them. Unknown commands\r\n  // are simply ignored.\r\n  keyMap.pcDefault = {\r\n    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",\r\n    "Ctrl-Home": "goDocStart", "Ctrl-Up": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Down": "goDocEnd",\r\n    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",\r\n    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",\r\n    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",\r\n    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",\r\n    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",\r\n    fallthrough: "basic"\r\n  };\r\n  keyMap.macDefault = {\r\n    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",\r\n    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",\r\n    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",\r\n    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",\r\n    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",\r\n    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",\r\n    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection",\r\n    fallthrough: ["basic", "emacsy"]\r\n  };\r\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\r\n  keyMap.emacsy = {\r\n    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",\r\n    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",\r\n    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",\r\n    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars"\r\n  };\r\n  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;\r\n\r\n  // KEYMAP DISPATCH\r\n\r\n  function getKeyMap(val) {\r\n    if (typeof val == "string") return keyMap[val];\r\n    else return val;\r\n  }\r\n\r\n  // Given an array of keymaps and a key name, call handle on any\r\n  // bindings found, until that returns a truthy value, at which point\r\n  // we consider the key handled. Implements things like binding a key\r\n  // to false stopping further handling and keymap fallthrough.\r\n  var lookupKey = CodeMirror.lookupKey = function(name, maps, handle) {\r\n    function lookup(map) {\r\n      map = getKeyMap(map);\r\n      var found = map[name];\r\n      if (found === false) return "stop";\r\n      if (found != null && handle(found)) return true;\r\n      if (map.nofallthrough) return "stop";\r\n\r\n      var fallthrough = map.fallthrough;\r\n      if (fallthrough == null) return false;\r\n      if (Object.prototype.toString.call(fallthrough) != "[object Array]")\r\n        return lookup(fallthrough);\r\n      for (var i = 0; i < fallthrough.length; ++i) {\r\n        var done = lookup(fallthrough[i]);\r\n        if (done) return done;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    for (var i = 0; i < maps.length; ++i) {\r\n      var done = lookup(maps[i]);\r\n      if (done) return done != "stop";\r\n    }\r\n  };\r\n\r\n  // Modifier key presses don\'t count as \'real\' key presses for the\r\n  // purpose of keymap fallthrough.\r\n  var isModifierKey = CodeMirror.isModifierKey = function(event) {\r\n    var name = keyNames[event.keyCode];\r\n    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod";\r\n  };\r\n\r\n  // Look up the name of a key as indicated by an event object.\r\n  var keyName = CodeMirror.keyName = function(event, noShift) {\r\n    if (presto && event.keyCode == 34 && event["char"]) return false;\r\n    var name = keyNames[event.keyCode];\r\n    if (name == null || event.altGraphKey) return false;\r\n    if (event.altKey) name = "Alt-" + name;\r\n    if (flipCtrlCmd ? event.metaKey : event.ctrlKey) name = "Ctrl-" + name;\r\n    if (flipCtrlCmd ? event.ctrlKey : event.metaKey) name = "Cmd-" + name;\r\n    if (!noShift && event.shiftKey) name = "Shift-" + name;\r\n    return name;\r\n  };\r\n\r\n  // FROMTEXTAREA\r\n\r\n  CodeMirror.fromTextArea = function(textarea, options) {\r\n    if (!options) options = {};\r\n    options.value = textarea.value;\r\n    if (!options.tabindex && textarea.tabindex)\r\n      options.tabindex = textarea.tabindex;\r\n    if (!options.placeholder && textarea.placeholder)\r\n      options.placeholder = textarea.placeholder;\r\n    // Set autofocus to true if this textarea is focused, or if it has\r\n    // autofocus and no other element is focused.\r\n    if (options.autofocus == null) {\r\n      var hasFocus = activeElt();\r\n      options.autofocus = hasFocus == textarea ||\r\n        textarea.getAttribute("autofocus") != null && hasFocus == document.body;\r\n    }\r\n\r\n    function save() {textarea.value = cm.getValue();}\r\n    if (textarea.form) {\r\n      on(textarea.form, "submit", save);\r\n      // Deplorable hack to make the submit method do the right thing.\r\n      if (!options.leaveSubmitMethodAlone) {\r\n        var form = textarea.form, realSubmit = form.submit;\r\n        try {\r\n          var wrappedSubmit = form.submit = function() {\r\n            save();\r\n            form.submit = realSubmit;\r\n            form.submit();\r\n            form.submit = wrappedSubmit;\r\n          };\r\n        } catch(e) {}\r\n      }\r\n    }\r\n\r\n    textarea.style.display = "none";\r\n    var cm = CodeMirror(function(node) {\r\n      textarea.parentNode.insertBefore(node, textarea.nextSibling);\r\n    }, options);\r\n    cm.save = save;\r\n    cm.getTextArea = function() { return textarea; };\r\n    cm.toTextArea = function() {\r\n      save();\r\n      textarea.parentNode.removeChild(cm.getWrapperElement());\r\n      textarea.style.display = "";\r\n      if (textarea.form) {\r\n        off(textarea.form, "submit", save);\r\n        if (typeof textarea.form.submit == "function")\r\n          textarea.form.submit = realSubmit;\r\n      }\r\n    };\r\n    return cm;\r\n  };\r\n\r\n  // STRING STREAM\r\n\r\n  // Fed to the mode parsers, provides helper functions to make\r\n  // parsers more succinct.\r\n\r\n  var StringStream = CodeMirror.StringStream = function(string, tabSize) {\r\n    this.pos = this.start = 0;\r\n    this.string = string;\r\n    this.tabSize = tabSize || 8;\r\n    this.lastColumnPos = this.lastColumnValue = 0;\r\n    this.lineStart = 0;\r\n  };\r\n\r\n  StringStream.prototype = {\r\n    eol: function() {return this.pos >= this.string.length;},\r\n    sol: function() {return this.pos == this.lineStart;},\r\n    peek: function() {return this.string.charAt(this.pos) || undefined;},\r\n    next: function() {\r\n      if (this.pos < this.string.length)\r\n        return this.string.charAt(this.pos++);\r\n    },\r\n    eat: function(match) {\r\n      var ch = this.string.charAt(this.pos);\r\n      if (typeof match == "string") var ok = ch == match;\r\n      else var ok = ch && (match.test ? match.test(ch) : match(ch));\r\n      if (ok) {++this.pos; return ch;}\r\n    },\r\n    eatWhile: function(match) {\r\n      var start = this.pos;\r\n      while (this.eat(match)){}\r\n      return this.pos > start;\r\n    },\r\n    eatSpace: function() {\r\n      var start = this.pos;\r\n      while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\r\n      return this.pos > start;\r\n    },\r\n    skipToEnd: function() {this.pos = this.string.length;},\r\n    skipTo: function(ch) {\r\n      var found = this.string.indexOf(ch, this.pos);\r\n      if (found > -1) {this.pos = found; return true;}\r\n    },\r\n    backUp: function(n) {this.pos -= n;},\r\n    column: function() {\r\n      if (this.lastColumnPos < this.start) {\r\n        this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\r\n        this.lastColumnPos = this.start;\r\n      }\r\n      return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\r\n    },\r\n    indentation: function() {\r\n      return countColumn(this.string, null, this.tabSize) -\r\n        (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);\r\n    },\r\n    match: function(pattern, consume, caseInsensitive) {\r\n      if (typeof pattern == "string") {\r\n        var cased = function(str) {return caseInsensitive ? str.toLowerCase() : str;};\r\n        var substr = this.string.substr(this.pos, pattern.length);\r\n        if (cased(substr) == cased(pattern)) {\r\n          if (consume !== false) this.pos += pattern.length;\r\n          return true;\r\n        }\r\n      } else {\r\n        var match = this.string.slice(this.pos).match(pattern);\r\n        if (match && match.index > 0) return null;\r\n        if (match && consume !== false) this.pos += match[0].length;\r\n        return match;\r\n      }\r\n    },\r\n    current: function(){return this.string.slice(this.start, this.pos);},\r\n    hideFirstChars: function(n, inner) {\r\n      this.lineStart += n;\r\n      try { return inner(); }\r\n      finally { this.lineStart -= n; }\r\n    }\r\n  };\r\n\r\n  // TEXTMARKERS\r\n\r\n  // Created with markText and setBookmark methods. A TextMarker is a\r\n  // handle that can be used to clear or find a marked position in the\r\n  // document. Line objects hold arrays (markedSpans) containing\r\n  // {from, to, marker} object pointing to such marker objects, and\r\n  // indicating that such a marker is present on that line. Multiple\r\n  // lines may point to the same marker when it spans across lines.\r\n  // The spans will have null for their from/to properties when the\r\n  // marker continues beyond the start/end of the line. Markers have\r\n  // links back to the lines they currently touch.\r\n\r\n  var TextMarker = CodeMirror.TextMarker = function(doc, type) {\r\n    this.lines = [];\r\n    this.type = type;\r\n    this.doc = doc;\r\n  };\r\n  eventMixin(TextMarker);\r\n\r\n  // Clear the marker.\r\n  TextMarker.prototype.clear = function() {\r\n    if (this.explicitlyCleared) return;\r\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\r\n    if (withOp) startOperation(cm);\r\n    if (hasHandler(this, "clear")) {\r\n      var found = this.find();\r\n      if (found) signalLater(this, "clear", found.from, found.to);\r\n    }\r\n    var min = null, max = null;\r\n    for (var i = 0; i < this.lines.length; ++i) {\r\n      var line = this.lines[i];\r\n      var span = getMarkedSpanFor(line.markedSpans, this);\r\n      if (cm && !this.collapsed) regLineChange(cm, lineNo(line), "text");\r\n      else if (cm) {\r\n        if (span.to != null) max = lineNo(line);\r\n        if (span.from != null) min = lineNo(line);\r\n      }\r\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\r\n      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)\r\n        updateLineHeight(line, textHeight(cm.display));\r\n    }\r\n    if (cm && this.collapsed && !cm.options.lineWrapping) for (var i = 0; i < this.lines.length; ++i) {\r\n      var visual = visualLine(this.lines[i]), len = lineLength(visual);\r\n      if (len > cm.display.maxLineLength) {\r\n        cm.display.maxLine = visual;\r\n        cm.display.maxLineLength = len;\r\n        cm.display.maxLineChanged = true;\r\n      }\r\n    }\r\n\r\n    if (min != null && cm && this.collapsed) regChange(cm, min, max + 1);\r\n    this.lines.length = 0;\r\n    this.explicitlyCleared = true;\r\n    if (this.atomic && this.doc.cantEdit) {\r\n      this.doc.cantEdit = false;\r\n      if (cm) reCheckSelection(cm.doc);\r\n    }\r\n    if (cm) signalLater(cm, "markerCleared", cm, this);\r\n    if (withOp) endOperation(cm);\r\n    if (this.parent) this.parent.clear();\r\n  };\r\n\r\n  // Find the position of the marker in the document. Returns a {from,\r\n  // to} object by default. Side can be passed to get a specific side\r\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\r\n  // Pos objects returned contain a line object, rather than a line\r\n  // number (used to prevent looking up the same line twice).\r\n  TextMarker.prototype.find = function(side, lineObj) {\r\n    if (side == null && this.type == "bookmark") side = 1;\r\n    var from, to;\r\n    for (var i = 0; i < this.lines.length; ++i) {\r\n      var line = this.lines[i];\r\n      var span = getMarkedSpanFor(line.markedSpans, this);\r\n      if (span.from != null) {\r\n        from = Pos(lineObj ? line : lineNo(line), span.from);\r\n        if (side == -1) return from;\r\n      }\r\n      if (span.to != null) {\r\n        to = Pos(lineObj ? line : lineNo(line), span.to);\r\n        if (side == 1) return to;\r\n      }\r\n    }\r\n    return from && {from: from, to: to};\r\n  };\r\n\r\n  // Signals that the marker\'s widget changed, and surrounding layout\r\n  // should be recomputed.\r\n  TextMarker.prototype.changed = function() {\r\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\r\n    if (!pos || !cm) return;\r\n    runInOp(cm, function() {\r\n      var line = pos.line, lineN = lineNo(pos.line);\r\n      var view = findViewForLine(cm, lineN);\r\n      if (view) {\r\n        clearLineMeasurementCacheFor(view);\r\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\r\n      }\r\n      cm.curOp.updateMaxLine = true;\r\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\r\n        var oldHeight = widget.height;\r\n        widget.height = null;\r\n        var dHeight = widgetHeight(widget) - oldHeight;\r\n        if (dHeight)\r\n          updateLineHeight(line, line.height + dHeight);\r\n      }\r\n    });\r\n  };\r\n\r\n  TextMarker.prototype.attachLine = function(line) {\r\n    if (!this.lines.length && this.doc.cm) {\r\n      var op = this.doc.cm.curOp;\r\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\r\n        (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);\r\n    }\r\n    this.lines.push(line);\r\n  };\r\n  TextMarker.prototype.detachLine = function(line) {\r\n    this.lines.splice(indexOf(this.lines, line), 1);\r\n    if (!this.lines.length && this.doc.cm) {\r\n      var op = this.doc.cm.curOp;\r\n      (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\r\n    }\r\n  };\r\n\r\n  // Collapsed markers have unique ids, in order to be able to order\r\n  // them, which is needed for uniquely determining an outer marker\r\n  // when they overlap (they may nest, but not partially overlap).\r\n  var nextMarkerId = 0;\r\n\r\n  // Create a marker, wire it up to the right lines, and\r\n  function markText(doc, from, to, options, type) {\r\n    // Shared markers (across linked documents) are handled separately\r\n    // (markTextShared will call out to this again, once per\r\n    // document).\r\n    if (options && options.shared) return markTextShared(doc, from, to, options, type);\r\n    // Ensure we are in an operation.\r\n    if (doc.cm && !doc.cm.curOp) return operation(doc.cm, markText)(doc, from, to, options, type);\r\n\r\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\r\n    if (options) copyObj(options, marker, false);\r\n    // Don\'t connect empty markers unless clearWhenEmpty is false\r\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\r\n      return marker;\r\n    if (marker.replacedWith) {\r\n      // Showing up as a widget implies collapsed (widget replaces text)\r\n      marker.collapsed = true;\r\n      marker.widgetNode = elt("span", [marker.replacedWith], "CodeMirror-widget");\r\n      if (!options.handleMouseEvents) marker.widgetNode.ignoreEvents = true;\r\n      if (options.insertLeft) marker.widgetNode.insertLeft = true;\r\n    }\r\n    if (marker.collapsed) {\r\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\r\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\r\n        throw new Error("Inserting collapsed marker partially overlapping an existing one");\r\n      sawCollapsedSpans = true;\r\n    }\r\n\r\n    if (marker.addToHistory)\r\n      addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN);\r\n\r\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\r\n    doc.iter(curLine, to.line + 1, function(line) {\r\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\r\n        updateMaxLine = true;\r\n      if (marker.collapsed && curLine != from.line) updateLineHeight(line, 0);\r\n      addMarkedSpan(line, new MarkedSpan(marker,\r\n                                         curLine == from.line ? from.ch : null,\r\n                                         curLine == to.line ? to.ch : null));\r\n      ++curLine;\r\n    });\r\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\r\n    if (marker.collapsed) doc.iter(from.line, to.line + 1, function(line) {\r\n      if (lineIsHidden(doc, line)) updateLineHeight(line, 0);\r\n    });\r\n\r\n    if (marker.clearOnEnter) on(marker, "beforeCursorEnter", function() { marker.clear(); });\r\n\r\n    if (marker.readOnly) {\r\n      sawReadOnlySpans = true;\r\n      if (doc.history.done.length || doc.history.undone.length)\r\n        doc.clearHistory();\r\n    }\r\n    if (marker.collapsed) {\r\n      marker.id = ++nextMarkerId;\r\n      marker.atomic = true;\r\n    }\r\n    if (cm) {\r\n      // Sync editor state\r\n      if (updateMaxLine) cm.curOp.updateMaxLine = true;\r\n      if (marker.collapsed)\r\n        regChange(cm, from.line, to.line + 1);\r\n      else if (marker.className || marker.title || marker.startStyle || marker.endStyle)\r\n        for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");\r\n      if (marker.atomic) reCheckSelection(cm.doc);\r\n      signalLater(cm, "markerAdded", cm, marker);\r\n    }\r\n    return marker;\r\n  }\r\n\r\n  // SHARED TEXTMARKERS\r\n\r\n  // A shared marker spans multiple linked documents. It is\r\n  // implemented as a meta-marker-object controlling multiple normal\r\n  // markers.\r\n  var SharedTextMarker = CodeMirror.SharedTextMarker = function(markers, primary) {\r\n    this.markers = markers;\r\n    this.primary = primary;\r\n    for (var i = 0; i < markers.length; ++i)\r\n      markers[i].parent = this;\r\n  };\r\n  eventMixin(SharedTextMarker);\r\n\r\n  SharedTextMarker.prototype.clear = function() {\r\n    if (this.explicitlyCleared) return;\r\n    this.explicitlyCleared = true;\r\n    for (var i = 0; i < this.markers.length; ++i)\r\n      this.markers[i].clear();\r\n    signalLater(this, "clear");\r\n  };\r\n  SharedTextMarker.prototype.find = function(side, lineObj) {\r\n    return this.primary.find(side, lineObj);\r\n  };\r\n\r\n  function markTextShared(doc, from, to, options, type) {\r\n    options = copyObj(options);\r\n    options.shared = false;\r\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\r\n    var widget = options.widgetNode;\r\n    linkedDocs(doc, function(doc) {\r\n      if (widget) options.widgetNode = widget.cloneNode(true);\r\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\r\n      for (var i = 0; i < doc.linked.length; ++i)\r\n        if (doc.linked[i].isParent) return;\r\n      primary = lst(markers);\r\n    });\r\n    return new SharedTextMarker(markers, primary);\r\n  }\r\n\r\n  function findSharedMarkers(doc) {\r\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())),\r\n                         function(m) { return m.parent; });\r\n  }\r\n\r\n  function copySharedMarkers(doc, markers) {\r\n    for (var i = 0; i < markers.length; i++) {\r\n      var marker = markers[i], pos = marker.find();\r\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\r\n      if (cmp(mFrom, mTo)) {\r\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\r\n        marker.markers.push(subMark);\r\n        subMark.parent = marker;\r\n      }\r\n    }\r\n  }\r\n\r\n  function detachSharedMarkers(markers) {\r\n    for (var i = 0; i < markers.length; i++) {\r\n      var marker = markers[i], linked = [marker.primary.doc];;\r\n      linkedDocs(marker.primary.doc, function(d) { linked.push(d); });\r\n      for (var j = 0; j < marker.markers.length; j++) {\r\n        var subMarker = marker.markers[j];\r\n        if (indexOf(linked, subMarker.doc) == -1) {\r\n          subMarker.parent = null;\r\n          marker.markers.splice(j--, 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // TEXTMARKER SPANS\r\n\r\n  function MarkedSpan(marker, from, to) {\r\n    this.marker = marker;\r\n    this.from = from; this.to = to;\r\n  }\r\n\r\n  // Search an array of spans for a span matching the given marker.\r\n  function getMarkedSpanFor(spans, marker) {\r\n    if (spans) for (var i = 0; i < spans.length; ++i) {\r\n      var span = spans[i];\r\n      if (span.marker == marker) return span;\r\n    }\r\n  }\r\n  // Remove a span from an array, returning undefined if no spans are\r\n  // left (we don\'t store arrays for lines without spans).\r\n  function removeMarkedSpan(spans, span) {\r\n    for (var r, i = 0; i < spans.length; ++i)\r\n      if (spans[i] != span) (r || (r = [])).push(spans[i]);\r\n    return r;\r\n  }\r\n  // Add a span to a line.\r\n  function addMarkedSpan(line, span) {\r\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\r\n    span.marker.attachLine(line);\r\n  }\r\n\r\n  // Used for the algorithm that adjusts markers for a change in the\r\n  // document. These functions cut an array of spans at a given\r\n  // character position, returning an array of remaining chunks (or\r\n  // undefined if nothing remains).\r\n  function markedSpansBefore(old, startCh, isInsert) {\r\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\r\n      var span = old[i], marker = span.marker;\r\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\r\n      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {\r\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);\r\n        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\r\n      }\r\n    }\r\n    return nw;\r\n  }\r\n  function markedSpansAfter(old, endCh, isInsert) {\r\n    if (old) for (var i = 0, nw; i < old.length; ++i) {\r\n      var span = old[i], marker = span.marker;\r\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\r\n      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {\r\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);\r\n        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\r\n                                              span.to == null ? null : span.to - endCh));\r\n      }\r\n    }\r\n    return nw;\r\n  }\r\n\r\n  // Given a change object, compute the new set of marker spans that\r\n  // cover the line in which the change took place. Removes spans\r\n  // entirely within the change, reconnects spans belonging to the\r\n  // same marker that appear on both sides of the change, and cuts off\r\n  // spans partially within the change. Returns an array of span\r\n  // arrays with one element for each line in (after) the change.\r\n  function stretchSpansOverChange(doc, change) {\r\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\r\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\r\n    if (!oldFirst && !oldLast) return null;\r\n\r\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\r\n    // Get the spans that \'stick out\' on both sides\r\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\r\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\r\n\r\n    // Next, merge those two ends\r\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\r\n    if (first) {\r\n      // Fix up .to properties of first\r\n      for (var i = 0; i < first.length; ++i) {\r\n        var span = first[i];\r\n        if (span.to == null) {\r\n          var found = getMarkedSpanFor(last, span.marker);\r\n          if (!found) span.to = startCh;\r\n          else if (sameLine) span.to = found.to == null ? null : found.to + offset;\r\n        }\r\n      }\r\n    }\r\n    if (last) {\r\n      // Fix up .from in last (or move them into first in case of sameLine)\r\n      for (var i = 0; i < last.length; ++i) {\r\n        var span = last[i];\r\n        if (span.to != null) span.to += offset;\r\n        if (span.from == null) {\r\n          var found = getMarkedSpanFor(first, span.marker);\r\n          if (!found) {\r\n            span.from = offset;\r\n            if (sameLine) (first || (first = [])).push(span);\r\n          }\r\n        } else {\r\n          span.from += offset;\r\n          if (sameLine) (first || (first = [])).push(span);\r\n        }\r\n      }\r\n    }\r\n    // Make sure we didn\'t create any zero-length spans\r\n    if (first) first = clearEmptySpans(first);\r\n    if (last && last != first) last = clearEmptySpans(last);\r\n\r\n    var newMarkers = [first];\r\n    if (!sameLine) {\r\n      // Fill gap with whole-line-spans\r\n      var gap = change.text.length - 2, gapMarkers;\r\n      if (gap > 0 && first)\r\n        for (var i = 0; i < first.length; ++i)\r\n          if (first[i].to == null)\r\n            (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i].marker, null, null));\r\n      for (var i = 0; i < gap; ++i)\r\n        newMarkers.push(gapMarkers);\r\n      newMarkers.push(last);\r\n    }\r\n    return newMarkers;\r\n  }\r\n\r\n  // Remove spans that are empty and don\'t have a clearWhenEmpty\r\n  // option of false.\r\n  function clearEmptySpans(spans) {\r\n    for (var i = 0; i < spans.length; ++i) {\r\n      var span = spans[i];\r\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\r\n        spans.splice(i--, 1);\r\n    }\r\n    if (!spans.length) return null;\r\n    return spans;\r\n  }\r\n\r\n  // Used for un/re-doing changes from the history. Combines the\r\n  // result of computing the existing spans with the set of spans that\r\n  // existed in the history (so that deleting around a span and then\r\n  // undoing brings back the span).\r\n  function mergeOldSpans(doc, change) {\r\n    var old = getOldSpans(doc, change);\r\n    var stretched = stretchSpansOverChange(doc, change);\r\n    if (!old) return stretched;\r\n    if (!stretched) return old;\r\n\r\n    for (var i = 0; i < old.length; ++i) {\r\n      var oldCur = old[i], stretchCur = stretched[i];\r\n      if (oldCur && stretchCur) {\r\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\r\n          var span = stretchCur[j];\r\n          for (var k = 0; k < oldCur.length; ++k)\r\n            if (oldCur[k].marker == span.marker) continue spans;\r\n          oldCur.push(span);\r\n        }\r\n      } else if (stretchCur) {\r\n        old[i] = stretchCur;\r\n      }\r\n    }\r\n    return old;\r\n  }\r\n\r\n  // Used to \'clip\' out readOnly ranges when making a change.\r\n  function removeReadOnlyRanges(doc, from, to) {\r\n    var markers = null;\r\n    doc.iter(from.line, to.line + 1, function(line) {\r\n      if (line.markedSpans) for (var i = 0; i < line.markedSpans.length; ++i) {\r\n        var mark = line.markedSpans[i].marker;\r\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\r\n          (markers || (markers = [])).push(mark);\r\n      }\r\n    });\r\n    if (!markers) return null;\r\n    var parts = [{from: from, to: to}];\r\n    for (var i = 0; i < markers.length; ++i) {\r\n      var mk = markers[i], m = mk.find(0);\r\n      for (var j = 0; j < parts.length; ++j) {\r\n        var p = parts[j];\r\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) continue;\r\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\r\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\r\n          newParts.push({from: p.from, to: m.from});\r\n        if (dto > 0 || !mk.inclusiveRight && !dto)\r\n          newParts.push({from: m.to, to: p.to});\r\n        parts.splice.apply(parts, newParts);\r\n        j += newParts.length - 1;\r\n      }\r\n    }\r\n    return parts;\r\n  }\r\n\r\n  // Connect or disconnect spans from a line.\r\n  function detachMarkedSpans(line) {\r\n    var spans = line.markedSpans;\r\n    if (!spans) return;\r\n    for (var i = 0; i < spans.length; ++i)\r\n      spans[i].marker.detachLine(line);\r\n    line.markedSpans = null;\r\n  }\r\n  function attachMarkedSpans(line, spans) {\r\n    if (!spans) return;\r\n    for (var i = 0; i < spans.length; ++i)\r\n      spans[i].marker.attachLine(line);\r\n    line.markedSpans = spans;\r\n  }\r\n\r\n  // Helpers used when computing which overlapping collapsed span\r\n  // counts as the larger one.\r\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0; }\r\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0; }\r\n\r\n  // Returns a number indicating which of two overlapping collapsed\r\n  // spans is larger (and thus includes the other). Falls back to\r\n  // comparing ids when the spans cover exactly the same range.\r\n  function compareCollapsedMarkers(a, b) {\r\n    var lenDiff = a.lines.length - b.lines.length;\r\n    if (lenDiff != 0) return lenDiff;\r\n    var aPos = a.find(), bPos = b.find();\r\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\r\n    if (fromCmp) return -fromCmp;\r\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\r\n    if (toCmp) return toCmp;\r\n    return b.id - a.id;\r\n  }\r\n\r\n  // Find out whether a line ends or starts in a collapsed span. If\r\n  // so, return the marker for that span.\r\n  function collapsedSpanAtSide(line, start) {\r\n    var sps = sawCollapsedSpans && line.markedSpans, found;\r\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\r\n      sp = sps[i];\r\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\r\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\r\n        found = sp.marker;\r\n    }\r\n    return found;\r\n  }\r\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true); }\r\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false); }\r\n\r\n  // Test whether there exists a collapsed span that partially\r\n  // overlaps (covers the start or end, but not both) of a new span.\r\n  // Such overlap is not allowed.\r\n  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {\r\n    var line = getLine(doc, lineNo);\r\n    var sps = sawCollapsedSpans && line.markedSpans;\r\n    if (sps) for (var i = 0; i < sps.length; ++i) {\r\n      var sp = sps[i];\r\n      if (!sp.marker.collapsed) continue;\r\n      var found = sp.marker.find(0);\r\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\r\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\r\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) continue;\r\n      if (fromCmp <= 0 && (cmp(found.to, from) > 0 || (sp.marker.inclusiveRight && marker.inclusiveLeft)) ||\r\n          fromCmp >= 0 && (cmp(found.from, to) < 0 || (sp.marker.inclusiveLeft && marker.inclusiveRight)))\r\n        return true;\r\n    }\r\n  }\r\n\r\n  // A visual line is a line as drawn on the screen. Folding, for\r\n  // example, can cause multiple logical lines to appear on the same\r\n  // visual line. This finds the start of the visual line that the\r\n  // given line is part of (usually that is the line itself).\r\n  function visualLine(line) {\r\n    var merged;\r\n    while (merged = collapsedSpanAtStart(line))\r\n      line = merged.find(-1, true).line;\r\n    return line;\r\n  }\r\n\r\n  // Returns an array of logical lines that continue the visual line\r\n  // started by the argument, or undefined if there are no such lines.\r\n  function visualLineContinued(line) {\r\n    var merged, lines;\r\n    while (merged = collapsedSpanAtEnd(line)) {\r\n      line = merged.find(1, true).line;\r\n      (lines || (lines = [])).push(line);\r\n    }\r\n    return lines;\r\n  }\r\n\r\n  // Get the line number of the start of the visual line that the\r\n  // given line number is part of.\r\n  function visualLineNo(doc, lineN) {\r\n    var line = getLine(doc, lineN), vis = visualLine(line);\r\n    if (line == vis) return lineN;\r\n    return lineNo(vis);\r\n  }\r\n  // Get the line number of the start of the next visual line after\r\n  // the given line.\r\n  function visualLineEndNo(doc, lineN) {\r\n    if (lineN > doc.lastLine()) return lineN;\r\n    var line = getLine(doc, lineN), merged;\r\n    if (!lineIsHidden(doc, line)) return lineN;\r\n    while (merged = collapsedSpanAtEnd(line))\r\n      line = merged.find(1, true).line;\r\n    return lineNo(line) + 1;\r\n  }\r\n\r\n  // Compute whether a line is hidden. Lines count as hidden when they\r\n  // are part of a visual line that starts with another line, or when\r\n  // they are entirely covered by collapsed, non-widget span.\r\n  function lineIsHidden(doc, line) {\r\n    var sps = sawCollapsedSpans && line.markedSpans;\r\n    if (sps) for (var sp, i = 0; i < sps.length; ++i) {\r\n      sp = sps[i];\r\n      if (!sp.marker.collapsed) continue;\r\n      if (sp.from == null) return true;\r\n      if (sp.marker.widgetNode) continue;\r\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\r\n        return true;\r\n    }\r\n  }\r\n  function lineIsHiddenInner(doc, line, span) {\r\n    if (span.to == null) {\r\n      var end = span.marker.find(1, true);\r\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));\r\n    }\r\n    if (span.marker.inclusiveRight && span.to == line.text.length)\r\n      return true;\r\n    for (var sp, i = 0; i < line.markedSpans.length; ++i) {\r\n      sp = line.markedSpans[i];\r\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\r\n          (sp.to == null || sp.to != span.from) &&\r\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\r\n          lineIsHiddenInner(doc, line, sp)) return true;\r\n    }\r\n  }\r\n\r\n  // LINE WIDGETS\r\n\r\n  // Line widgets are block elements displayed above or below a line.\r\n\r\n  var LineWidget = CodeMirror.LineWidget = function(cm, node, options) {\r\n    if (options) for (var opt in options) if (options.hasOwnProperty(opt))\r\n      this[opt] = options[opt];\r\n    this.cm = cm;\r\n    this.node = node;\r\n  };\r\n  eventMixin(LineWidget);\r\n\r\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\r\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\r\n      addToScrollPos(cm, null, diff);\r\n  }\r\n\r\n  LineWidget.prototype.clear = function() {\r\n    var cm = this.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\r\n    if (no == null || !ws) return;\r\n    for (var i = 0; i < ws.length; ++i) if (ws[i] == this) ws.splice(i--, 1);\r\n    if (!ws.length) line.widgets = null;\r\n    var height = widgetHeight(this);\r\n    runInOp(cm, function() {\r\n      adjustScrollWhenAboveVisible(cm, line, -height);\r\n      regLineChange(cm, no, "widget");\r\n      updateLineHeight(line, Math.max(0, line.height - height));\r\n    });\r\n  };\r\n  LineWidget.prototype.changed = function() {\r\n    var oldH = this.height, cm = this.cm, line = this.line;\r\n    this.height = null;\r\n    var diff = widgetHeight(this) - oldH;\r\n    if (!diff) return;\r\n    runInOp(cm, function() {\r\n      cm.curOp.forceUpdate = true;\r\n      adjustScrollWhenAboveVisible(cm, line, diff);\r\n      updateLineHeight(line, line.height + diff);\r\n    });\r\n  };\r\n\r\n  function widgetHeight(widget) {\r\n    if (widget.height != null) return widget.height;\r\n    if (!contains(document.body, widget.node)) {\r\n      var parentStyle = "position: relative;";\r\n      if (widget.coverGutter)\r\n        parentStyle += "margin-left: -" + widget.cm.getGutterElement().offsetWidth + "px;";\r\n      removeChildrenAndAdd(widget.cm.display.measure, elt("div", [widget.node], null, parentStyle));\r\n    }\r\n    return widget.height = widget.node.offsetHeight;\r\n  }\r\n\r\n  function addLineWidget(cm, handle, node, options) {\r\n    var widget = new LineWidget(cm, node, options);\r\n    if (widget.noHScroll) cm.display.alignWidgets = true;\r\n    changeLine(cm.doc, handle, "widget", function(line) {\r\n      var widgets = line.widgets || (line.widgets = []);\r\n      if (widget.insertAt == null) widgets.push(widget);\r\n      else widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget);\r\n      widget.line = line;\r\n      if (!lineIsHidden(cm.doc, line)) {\r\n        var aboveVisible = heightAtLine(line) < cm.doc.scrollTop;\r\n        updateLineHeight(line, line.height + widgetHeight(widget));\r\n        if (aboveVisible) addToScrollPos(cm, null, widget.height);\r\n        cm.curOp.forceUpdate = true;\r\n      }\r\n      return true;\r\n    });\r\n    return widget;\r\n  }\r\n\r\n  // LINE DATA STRUCTURE\r\n\r\n  // Line objects. These hold state related to a line, including\r\n  // highlighting info (the styles array).\r\n  var Line = CodeMirror.Line = function(text, markedSpans, estimateHeight) {\r\n    this.text = text;\r\n    attachMarkedSpans(this, markedSpans);\r\n    this.height = estimateHeight ? estimateHeight(this) : 1;\r\n  };\r\n  eventMixin(Line);\r\n  Line.prototype.lineNo = function() { return lineNo(this); };\r\n\r\n  // Change the content (text, markers) of a line. Automatically\r\n  // invalidates cached information and tries to re-estimate the\r\n  // line\'s height.\r\n  function updateLine(line, text, markedSpans, estimateHeight) {\r\n    line.text = text;\r\n    if (line.stateAfter) line.stateAfter = null;\r\n    if (line.styles) line.styles = null;\r\n    if (line.order != null) line.order = null;\r\n    detachMarkedSpans(line);\r\n    attachMarkedSpans(line, markedSpans);\r\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\r\n    if (estHeight != line.height) updateLineHeight(line, estHeight);\r\n  }\r\n\r\n  // Detach a line from the document tree and its markers.\r\n  function cleanUpLine(line) {\r\n    line.parent = null;\r\n    detachMarkedSpans(line);\r\n  }\r\n\r\n  function extractLineClasses(type, output) {\r\n    if (type) for (;;) {\r\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\r\n      if (!lineClass) break;\r\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\r\n      var prop = lineClass[1] ? "bgClass" : "textClass";\r\n      if (output[prop] == null)\r\n        output[prop] = lineClass[2];\r\n      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(output[prop]))\r\n        output[prop] += " " + lineClass[2];\r\n    }\r\n    return type;\r\n  }\r\n\r\n  function callBlankLine(mode, state) {\r\n    if (mode.blankLine) return mode.blankLine(state);\r\n    if (!mode.innerMode) return;\r\n    var inner = CodeMirror.innerMode(mode, state);\r\n    if (inner.mode.blankLine) return inner.mode.blankLine(inner.state);\r\n  }\r\n\r\n  function readToken(mode, stream, state) {\r\n    for (var i = 0; i < 10; i++) {\r\n      var style = mode.token(stream, state);\r\n      if (stream.pos > stream.start) return style;\r\n    }\r\n    throw new Error("Mode " + mode.name + " failed to advance stream.");\r\n  }\r\n\r\n  // Run the given mode\'s parser over a line, calling f for each token.\r\n  function runMode(cm, text, mode, state, f, lineClasses, forceToEnd) {\r\n    var flattenSpans = mode.flattenSpans;\r\n    if (flattenSpans == null) flattenSpans = cm.options.flattenSpans;\r\n    var curStart = 0, curStyle = null;\r\n    var stream = new StringStream(text, cm.options.tabSize), style;\r\n    if (text == "") extractLineClasses(callBlankLine(mode, state), lineClasses);\r\n    while (!stream.eol()) {\r\n      if (stream.pos > cm.options.maxHighlightLength) {\r\n        flattenSpans = false;\r\n        if (forceToEnd) processLine(cm, text, state, stream.pos);\r\n        stream.pos = text.length;\r\n        style = null;\r\n      } else {\r\n        style = extractLineClasses(readToken(mode, stream, state), lineClasses);\r\n      }\r\n      if (cm.options.addModeClass) {\r\n        var mName = CodeMirror.innerMode(mode, state).mode.name;\r\n        if (mName) style = "m-" + (style ? mName + " " + style : mName);\r\n      }\r\n      if (!flattenSpans || curStyle != style) {\r\n        if (curStart < stream.start) f(stream.start, curStyle);\r\n        curStart = stream.start; curStyle = style;\r\n      }\r\n      stream.start = stream.pos;\r\n    }\r\n    while (curStart < stream.pos) {\r\n      // Webkit seems to refuse to render text nodes longer than 57444 characters\r\n      var pos = Math.min(stream.pos, curStart + 50000);\r\n      f(pos, curStyle);\r\n      curStart = pos;\r\n    }\r\n  }\r\n\r\n  // Compute a style array (an array starting with a mode generation\r\n  // -- for invalidation -- followed by pairs of end positions and\r\n  // style strings), which is used to highlight the tokens on the\r\n  // line.\r\n  function highlightLine(cm, line, state, forceToEnd) {\r\n    // A styles array always starts with a number identifying the\r\n    // mode/overlays that it is based on (for easy invalidation).\r\n    var st = [cm.state.modeGen], lineClasses = {};\r\n    // Compute the base array of styles\r\n    runMode(cm, line.text, cm.doc.mode, state, function(end, style) {\r\n      st.push(end, style);\r\n    }, lineClasses, forceToEnd);\r\n\r\n    // Run overlays, adjust style array.\r\n    for (var o = 0; o < cm.state.overlays.length; ++o) {\r\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\r\n      runMode(cm, line.text, overlay.mode, true, function(end, style) {\r\n        var start = i;\r\n        // Ensure there\'s a token end at the current position, and that i points at it\r\n        while (at < end) {\r\n          var i_end = st[i];\r\n          if (i_end > end)\r\n            st.splice(i, 1, end, st[i+1], i_end);\r\n          i += 2;\r\n          at = Math.min(end, i_end);\r\n        }\r\n        if (!style) return;\r\n        if (overlay.opaque) {\r\n          st.splice(start, i - start, end, "cm-overlay " + style);\r\n          i = start + 2;\r\n        } else {\r\n          for (; start < i; start += 2) {\r\n            var cur = st[start+1];\r\n            st[start+1] = (cur ? cur + " " : "") + "cm-overlay " + style;\r\n          }\r\n        }\r\n      }, lineClasses);\r\n    }\r\n\r\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null};\r\n  }\r\n\r\n  function getLineStyles(cm, line) {\r\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\r\n      var result = highlightLine(cm, line, line.stateAfter = getStateBefore(cm, lineNo(line)));\r\n      line.styles = result.styles;\r\n      if (result.classes) line.styleClasses = result.classes;\r\n      else if (line.styleClasses) line.styleClasses = null;\r\n    }\r\n    return line.styles;\r\n  }\r\n\r\n  // Lightweight form of highlight -- proceed over this line and\r\n  // update state, but don\'t save a style array. Used for lines that\r\n  // aren\'t currently visible.\r\n  function processLine(cm, text, state, startAt) {\r\n    var mode = cm.doc.mode;\r\n    var stream = new StringStream(text, cm.options.tabSize);\r\n    stream.start = stream.pos = startAt || 0;\r\n    if (text == "") callBlankLine(mode, state);\r\n    while (!stream.eol() && stream.pos <= cm.options.maxHighlightLength) {\r\n      readToken(mode, stream, state);\r\n      stream.start = stream.pos;\r\n    }\r\n  }\r\n\r\n  // Convert a style as returned by a mode (either null, or a string\r\n  // containing one or more styles) to a CSS style. This is cached,\r\n  // and also looks for line-wide styles.\r\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\r\n  function interpretTokenStyle(style, options) {\r\n    if (!style || /^\\s*$/.test(style)) return null;\r\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\r\n    return cache[style] ||\r\n      (cache[style] = style.replace(/\\S+/g, "cm-$&"));\r\n  }\r\n\r\n  // Render the DOM representation of the text of a line. Also builds\r\n  // up a \'line map\', which points at the DOM nodes that represent\r\n  // specific stretches of text, and is used by the measuring code.\r\n  // The returned object contains the DOM node, this map, and\r\n  // information about line-wide styles that were set by the mode.\r\n  function buildLineContent(cm, lineView) {\r\n    // The padding-right forces the element to have a \'border\', which\r\n    // is needed on Webkit to be able to get line-level bounding\r\n    // rectangles for it (in measureChar).\r\n    var content = elt("span", null, null, webkit ? "padding-right: .1px" : null);\r\n    var builder = {pre: elt("pre", [content]), content: content, col: 0, pos: 0, cm: cm};\r\n    lineView.measure = {};\r\n\r\n    // Iterate over the logical lines that make up this visual line.\r\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\r\n      var line = i ? lineView.rest[i - 1] : lineView.line, order;\r\n      builder.pos = 0;\r\n      builder.addToken = buildToken;\r\n      // Optionally wire in some hacks into the token-rendering\r\n      // algorithm, to deal with browser quirks.\r\n      if ((ie || webkit) && cm.getOption("lineWrapping"))\r\n        builder.addToken = buildTokenSplitSpaces(builder.addToken);\r\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line)))\r\n        builder.addToken = buildTokenBadBidi(builder.addToken, order);\r\n      builder.map = [];\r\n      insertLineContent(line, builder, getLineStyles(cm, line));\r\n      if (line.styleClasses) {\r\n        if (line.styleClasses.bgClass)\r\n          builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");\r\n        if (line.styleClasses.textClass)\r\n          builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");\r\n      }\r\n\r\n      // Ensure at least a single node is present, for measuring.\r\n      if (builder.map.length == 0)\r\n        builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));\r\n\r\n      // Store the map and a cache object for the current logical line\r\n      if (i == 0) {\r\n        lineView.measure.map = builder.map;\r\n        lineView.measure.cache = {};\r\n      } else {\r\n        (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);\r\n        (lineView.measure.caches || (lineView.measure.caches = [])).push({});\r\n      }\r\n    }\r\n\r\n    signal(cm, "renderLine", cm, lineView.line, builder.pre);\r\n    if (builder.pre.className)\r\n      builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");\r\n    return builder;\r\n  }\r\n\r\n  function defaultSpecialCharPlaceholder(ch) {\r\n    var token = elt("span", "\\u2022", "cm-invalidchar");\r\n    token.title = "\\\\u" + ch.charCodeAt(0).toString(16);\r\n    return token;\r\n  }\r\n\r\n  // Build up the DOM representation for a single token, and add it to\r\n  // the line map. Takes care to render special characters separately.\r\n  function buildToken(builder, text, style, startStyle, endStyle, title) {\r\n    if (!text) return;\r\n    var special = builder.cm.options.specialChars, mustWrap = false;\r\n    if (!special.test(text)) {\r\n      builder.col += text.length;\r\n      var content = document.createTextNode(text);\r\n      builder.map.push(builder.pos, builder.pos + text.length, content);\r\n      if (ie && ie_version < 9) mustWrap = true;\r\n      builder.pos += text.length;\r\n    } else {\r\n      var content = document.createDocumentFragment(), pos = 0;\r\n      while (true) {\r\n        special.lastIndex = pos;\r\n        var m = special.exec(text);\r\n        var skipped = m ? m.index - pos : text.length - pos;\r\n        if (skipped) {\r\n          var txt = document.createTextNode(text.slice(pos, pos + skipped));\r\n          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));\r\n          else content.appendChild(txt);\r\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\r\n          builder.col += skipped;\r\n          builder.pos += skipped;\r\n        }\r\n        if (!m) break;\r\n        pos += skipped + 1;\r\n        if (m[0] == "\\t") {\r\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\r\n          var txt = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));\r\n          builder.col += tabWidth;\r\n        } else {\r\n          var txt = builder.cm.options.specialCharPlaceholder(m[0]);\r\n          if (ie && ie_version < 9) content.appendChild(elt("span", [txt]));\r\n          else content.appendChild(txt);\r\n          builder.col += 1;\r\n        }\r\n        builder.map.push(builder.pos, builder.pos + 1, txt);\r\n        builder.pos++;\r\n      }\r\n    }\r\n    if (style || startStyle || endStyle || mustWrap) {\r\n      var fullStyle = style || "";\r\n      if (startStyle) fullStyle += startStyle;\r\n      if (endStyle) fullStyle += endStyle;\r\n      var token = elt("span", [content], fullStyle);\r\n      if (title) token.title = title;\r\n      return builder.content.appendChild(token);\r\n    }\r\n    builder.content.appendChild(content);\r\n  }\r\n\r\n  function buildTokenSplitSpaces(inner) {\r\n    function split(old) {\r\n      var out = " ";\r\n      for (var i = 0; i < old.length - 2; ++i) out += i % 2 ? " " : "\\u00a0";\r\n      out += " ";\r\n      return out;\r\n    }\r\n    return function(builder, text, style, startStyle, endStyle, title) {\r\n      inner(builder, text.replace(/ {3,}/g, split), style, startStyle, endStyle, title);\r\n    };\r\n  }\r\n\r\n  // Work around nonsense dimensions being reported for stretches of\r\n  // right-to-left text.\r\n  function buildTokenBadBidi(inner, order) {\r\n    return function(builder, text, style, startStyle, endStyle, title) {\r\n      style = style ? style + " cm-force-border" : "cm-force-border";\r\n      var start = builder.pos, end = start + text.length;\r\n      for (;;) {\r\n        // Find the part that overlaps with the start of this text\r\n        for (var i = 0; i < order.length; i++) {\r\n          var part = order[i];\r\n          if (part.to > start && part.from <= start) break;\r\n        }\r\n        if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title);\r\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, title);\r\n        startStyle = null;\r\n        text = text.slice(part.to - start);\r\n        start = part.to;\r\n      }\r\n    };\r\n  }\r\n\r\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\r\n    var widget = !ignoreWidget && marker.widgetNode;\r\n    if (widget) {\r\n      builder.map.push(builder.pos, builder.pos + size, widget);\r\n      builder.content.appendChild(widget);\r\n    }\r\n    builder.pos += size;\r\n  }\r\n\r\n  // Outputs a number of spans to make up a line, taking highlighting\r\n  // and marked text into account.\r\n  function insertLineContent(line, builder, styles) {\r\n    var spans = line.markedSpans, allText = line.text, at = 0;\r\n    if (!spans) {\r\n      for (var i = 1; i < styles.length; i+=2)\r\n        builder.addToken(builder, allText.slice(at, at = styles[i]), interpretTokenStyle(styles[i+1], builder.cm.options));\r\n      return;\r\n    }\r\n\r\n    var len = allText.length, pos = 0, i = 1, text = "", style;\r\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, title, collapsed;\r\n    for (;;) {\r\n      if (nextChange == pos) { // Update current marker set\r\n        spanStyle = spanEndStyle = spanStartStyle = title = "";\r\n        collapsed = null; nextChange = Infinity;\r\n        var foundBookmarks = [];\r\n        for (var j = 0; j < spans.length; ++j) {\r\n          var sp = spans[j], m = sp.marker;\r\n          if (sp.from <= pos && (sp.to == null || sp.to > pos)) {\r\n            if (sp.to != null && nextChange > sp.to) { nextChange = sp.to; spanEndStyle = ""; }\r\n            if (m.className) spanStyle += " " + m.className;\r\n            if (m.startStyle && sp.from == pos) spanStartStyle += " " + m.startStyle;\r\n            if (m.endStyle && sp.to == nextChange) spanEndStyle += " " + m.endStyle;\r\n            if (m.title && !title) title = m.title;\r\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\r\n              collapsed = sp;\r\n          } else if (sp.from > pos && nextChange > sp.from) {\r\n            nextChange = sp.from;\r\n          }\r\n          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) foundBookmarks.push(m);\r\n        }\r\n        if (collapsed && (collapsed.from || 0) == pos) {\r\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\r\n                             collapsed.marker, collapsed.from == null);\r\n          if (collapsed.to == null) return;\r\n        }\r\n        if (!collapsed && foundBookmarks.length) for (var j = 0; j < foundBookmarks.length; ++j)\r\n          buildCollapsedSpan(builder, 0, foundBookmarks[j]);\r\n      }\r\n      if (pos >= len) break;\r\n\r\n      var upto = Math.min(len, nextChange);\r\n      while (true) {\r\n        if (text) {\r\n          var end = pos + text.length;\r\n          if (!collapsed) {\r\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\r\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\r\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title);\r\n          }\r\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break;}\r\n          pos = end;\r\n          spanStartStyle = "";\r\n        }\r\n        text = allText.slice(at, at = styles[i++]);\r\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\r\n      }\r\n    }\r\n  }\r\n\r\n  // DOCUMENT DATA STRUCTURE\r\n\r\n  // By default, updates that start and end at the beginning of a line\r\n  // are treated specially, in order to make the association of line\r\n  // widgets and marker elements with the text behave more intuitive.\r\n  function isWholeLineUpdate(doc, change) {\r\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&\r\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore);\r\n  }\r\n\r\n  // Perform a change on the document data structure.\r\n  function updateDoc(doc, change, markedSpans, estimateHeight) {\r\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null;}\r\n    function update(line, text, spans) {\r\n      updateLine(line, text, spans, estimateHeight);\r\n      signalLater(line, "change", line, change);\r\n    }\r\n\r\n    var from = change.from, to = change.to, text = change.text;\r\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\r\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\r\n\r\n    // Adjust the line structure\r\n    if (isWholeLineUpdate(doc, change)) {\r\n      // This is a whole-line replace. Treated specially to make\r\n      // sure line objects move the way they are supposed to.\r\n      for (var i = 0, added = []; i < text.length - 1; ++i)\r\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\r\n      update(lastLine, lastLine.text, lastSpans);\r\n      if (nlines) doc.remove(from.line, nlines);\r\n      if (added.length) doc.insert(from.line, added);\r\n    } else if (firstLine == lastLine) {\r\n      if (text.length == 1) {\r\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\r\n      } else {\r\n        for (var added = [], i = 1; i < text.length - 1; ++i)\r\n          added.push(new Line(text[i], spansFor(i), estimateHeight));\r\n        added.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));\r\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\r\n        doc.insert(from.line + 1, added);\r\n      }\r\n    } else if (text.length == 1) {\r\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\r\n      doc.remove(from.line + 1, nlines);\r\n    } else {\r\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\r\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\r\n      for (var i = 1, added = []; i < text.length - 1; ++i)\r\n        added.push(new Line(text[i], spansFor(i), estimateHeight));\r\n      if (nlines > 1) doc.remove(from.line + 1, nlines - 1);\r\n      doc.insert(from.line + 1, added);\r\n    }\r\n\r\n    signalLater(doc, "change", doc, change);\r\n  }\r\n\r\n  // The document is represented as a BTree consisting of leaves, with\r\n  // chunk of lines in them, and branches, with up to ten leaves or\r\n  // other branch nodes below them. The top node is always a branch\r\n  // node, and is the document object itself (meaning it has\r\n  // additional methods and properties).\r\n  //\r\n  // All nodes have parent links. The tree is used both to go from\r\n  // line numbers to line objects, and to go from objects to numbers.\r\n  // It also indexes by height, and is used to convert between height\r\n  // and line object, and to find the total height of the document.\r\n  //\r\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\r\n\r\n  function LeafChunk(lines) {\r\n    this.lines = lines;\r\n    this.parent = null;\r\n    for (var i = 0, height = 0; i < lines.length; ++i) {\r\n      lines[i].parent = this;\r\n      height += lines[i].height;\r\n    }\r\n    this.height = height;\r\n  }\r\n\r\n  LeafChunk.prototype = {\r\n    chunkSize: function() { return this.lines.length; },\r\n    // Remove the n lines at offset \'at\'.\r\n    removeInner: function(at, n) {\r\n      for (var i = at, e = at + n; i < e; ++i) {\r\n        var line = this.lines[i];\r\n        this.height -= line.height;\r\n        cleanUpLine(line);\r\n        signalLater(line, "delete");\r\n      }\r\n      this.lines.splice(at, n);\r\n    },\r\n    // Helper used to collapse a small branch into a single leaf.\r\n    collapse: function(lines) {\r\n      lines.push.apply(lines, this.lines);\r\n    },\r\n    // Insert the given array of lines at offset \'at\', count them as\r\n    // having the given height.\r\n    insertInner: function(at, lines, height) {\r\n      this.height += height;\r\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\r\n      for (var i = 0; i < lines.length; ++i) lines[i].parent = this;\r\n    },\r\n    // Used to iterate over a part of the tree.\r\n    iterN: function(at, n, op) {\r\n      for (var e = at + n; at < e; ++at)\r\n        if (op(this.lines[at])) return true;\r\n    }\r\n  };\r\n\r\n  function BranchChunk(children) {\r\n    this.children = children;\r\n    var size = 0, height = 0;\r\n    for (var i = 0; i < children.length; ++i) {\r\n      var ch = children[i];\r\n      size += ch.chunkSize(); height += ch.height;\r\n      ch.parent = this;\r\n    }\r\n    this.size = size;\r\n    this.height = height;\r\n    this.parent = null;\r\n  }\r\n\r\n  BranchChunk.prototype = {\r\n    chunkSize: function() { return this.size; },\r\n    removeInner: function(at, n) {\r\n      this.size -= n;\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at < sz) {\r\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\r\n          child.removeInner(at, rm);\r\n          this.height -= oldHeight - child.height;\r\n          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }\r\n          if ((n -= rm) == 0) break;\r\n          at = 0;\r\n        } else at -= sz;\r\n      }\r\n      // If the result is smaller than 25 lines, ensure that it is a\r\n      // single leaf node.\r\n      if (this.size - n < 25 &&\r\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\r\n        var lines = [];\r\n        this.collapse(lines);\r\n        this.children = [new LeafChunk(lines)];\r\n        this.children[0].parent = this;\r\n      }\r\n    },\r\n    collapse: function(lines) {\r\n      for (var i = 0; i < this.children.length; ++i) this.children[i].collapse(lines);\r\n    },\r\n    insertInner: function(at, lines, height) {\r\n      this.size += lines.length;\r\n      this.height += height;\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at <= sz) {\r\n          child.insertInner(at, lines, height);\r\n          if (child.lines && child.lines.length > 50) {\r\n            while (child.lines.length > 50) {\r\n              var spilled = child.lines.splice(child.lines.length - 25, 25);\r\n              var newleaf = new LeafChunk(spilled);\r\n              child.height -= newleaf.height;\r\n              this.children.splice(i + 1, 0, newleaf);\r\n              newleaf.parent = this;\r\n            }\r\n            this.maybeSpill();\r\n          }\r\n          break;\r\n        }\r\n        at -= sz;\r\n      }\r\n    },\r\n    // When a node has grown, check whether it should be split.\r\n    maybeSpill: function() {\r\n      if (this.children.length <= 10) return;\r\n      var me = this;\r\n      do {\r\n        var spilled = me.children.splice(me.children.length - 5, 5);\r\n        var sibling = new BranchChunk(spilled);\r\n        if (!me.parent) { // Become the parent node\r\n          var copy = new BranchChunk(me.children);\r\n          copy.parent = me;\r\n          me.children = [copy, sibling];\r\n          me = copy;\r\n        } else {\r\n          me.size -= sibling.size;\r\n          me.height -= sibling.height;\r\n          var myIndex = indexOf(me.parent.children, me);\r\n          me.parent.children.splice(myIndex + 1, 0, sibling);\r\n        }\r\n        sibling.parent = me.parent;\r\n      } while (me.children.length > 10);\r\n      me.parent.maybeSpill();\r\n    },\r\n    iterN: function(at, n, op) {\r\n      for (var i = 0; i < this.children.length; ++i) {\r\n        var child = this.children[i], sz = child.chunkSize();\r\n        if (at < sz) {\r\n          var used = Math.min(n, sz - at);\r\n          if (child.iterN(at, used, op)) return true;\r\n          if ((n -= used) == 0) break;\r\n          at = 0;\r\n        } else at -= sz;\r\n      }\r\n    }\r\n  };\r\n\r\n  var nextDocId = 0;\r\n  var Doc = CodeMirror.Doc = function(text, mode, firstLine) {\r\n    if (!(this instanceof Doc)) return new Doc(text, mode, firstLine);\r\n    if (firstLine == null) firstLine = 0;\r\n\r\n    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);\r\n    this.first = firstLine;\r\n    this.scrollTop = this.scrollLeft = 0;\r\n    this.cantEdit = false;\r\n    this.cleanGeneration = 1;\r\n    this.frontier = firstLine;\r\n    var start = Pos(firstLine, 0);\r\n    this.sel = simpleSelection(start);\r\n    this.history = new History(null);\r\n    this.id = ++nextDocId;\r\n    this.modeOption = mode;\r\n\r\n    if (typeof text == "string") text = splitLines(text);\r\n    updateDoc(this, {from: start, to: start, text: text});\r\n    setSelection(this, simpleSelection(start), sel_dontScroll);\r\n  };\r\n\r\n  Doc.prototype = createObj(BranchChunk.prototype, {\r\n    constructor: Doc,\r\n    // Iterate over the document. Supports two forms -- with only one\r\n    // argument, it calls that for each line in the document. With\r\n    // three, it iterates over the range given by the first two (with\r\n    // the second being non-inclusive).\r\n    iter: function(from, to, op) {\r\n      if (op) this.iterN(from - this.first, to - from, op);\r\n      else this.iterN(this.first, this.first + this.size, from);\r\n    },\r\n\r\n    // Non-public interface for adding and removing lines.\r\n    insert: function(at, lines) {\r\n      var height = 0;\r\n      for (var i = 0; i < lines.length; ++i) height += lines[i].height;\r\n      this.insertInner(at - this.first, lines, height);\r\n    },\r\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\r\n\r\n    // From here, the methods are part of the public interface. Most\r\n    // are also available from CodeMirror (editor) instances.\r\n\r\n    getValue: function(lineSep) {\r\n      var lines = getLines(this, this.first, this.first + this.size);\r\n      if (lineSep === false) return lines;\r\n      return lines.join(lineSep || "\\n");\r\n    },\r\n    setValue: docMethodOp(function(code) {\r\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\r\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\r\n                        text: splitLines(code), origin: "setValue"}, true);\r\n      setSelection(this, simpleSelection(top));\r\n    }),\r\n    replaceRange: function(code, from, to, origin) {\r\n      from = clipPos(this, from);\r\n      to = to ? clipPos(this, to) : from;\r\n      replaceRange(this, code, from, to, origin);\r\n    },\r\n    getRange: function(from, to, lineSep) {\r\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\r\n      if (lineSep === false) return lines;\r\n      return lines.join(lineSep || "\\n");\r\n    },\r\n\r\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text;},\r\n\r\n    getLineHandle: function(line) {if (isLine(this, line)) return getLine(this, line);},\r\n    getLineNumber: function(line) {return lineNo(line);},\r\n\r\n    getLineHandleVisualStart: function(line) {\r\n      if (typeof line == "number") line = getLine(this, line);\r\n      return visualLine(line);\r\n    },\r\n\r\n    lineCount: function() {return this.size;},\r\n    firstLine: function() {return this.first;},\r\n    lastLine: function() {return this.first + this.size - 1;},\r\n\r\n    clipPos: function(pos) {return clipPos(this, pos);},\r\n\r\n    getCursor: function(start) {\r\n      var range = this.sel.primary(), pos;\r\n      if (start == null || start == "head") pos = range.head;\r\n      else if (start == "anchor") pos = range.anchor;\r\n      else if (start == "end" || start == "to" || start === false) pos = range.to();\r\n      else pos = range.from();\r\n      return pos;\r\n    },\r\n    listSelections: function() { return this.sel.ranges; },\r\n    somethingSelected: function() {return this.sel.somethingSelected();},\r\n\r\n    setCursor: docMethodOp(function(line, ch, options) {\r\n      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);\r\n    }),\r\n    setSelection: docMethodOp(function(anchor, head, options) {\r\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\r\n    }),\r\n    extendSelection: docMethodOp(function(head, other, options) {\r\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\r\n    }),\r\n    extendSelections: docMethodOp(function(heads, options) {\r\n      extendSelections(this, clipPosArray(this, heads, options));\r\n    }),\r\n    extendSelectionsBy: docMethodOp(function(f, options) {\r\n      extendSelections(this, map(this.sel.ranges, f), options);\r\n    }),\r\n    setSelections: docMethodOp(function(ranges, primary, options) {\r\n      if (!ranges.length) return;\r\n      for (var i = 0, out = []; i < ranges.length; i++)\r\n        out[i] = new Range(clipPos(this, ranges[i].anchor),\r\n                           clipPos(this, ranges[i].head));\r\n      if (primary == null) primary = Math.min(ranges.length - 1, this.sel.primIndex);\r\n      setSelection(this, normalizeSelection(out, primary), options);\r\n    }),\r\n    addSelection: docMethodOp(function(anchor, head, options) {\r\n      var ranges = this.sel.ranges.slice(0);\r\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\r\n      setSelection(this, normalizeSelection(ranges, ranges.length - 1), options);\r\n    }),\r\n\r\n    getSelection: function(lineSep) {\r\n      var ranges = this.sel.ranges, lines;\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\r\n        lines = lines ? lines.concat(sel) : sel;\r\n      }\r\n      if (lineSep === false) return lines;\r\n      else return lines.join(lineSep || "\\n");\r\n    },\r\n    getSelections: function(lineSep) {\r\n      var parts = [], ranges = this.sel.ranges;\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var sel = getBetween(this, ranges[i].from(), ranges[i].to());\r\n        if (lineSep !== false) sel = sel.join(lineSep || "\\n");\r\n        parts[i] = sel;\r\n      }\r\n      return parts;\r\n    },\r\n    replaceSelection: function(code, collapse, origin) {\r\n      var dup = [];\r\n      for (var i = 0; i < this.sel.ranges.length; i++)\r\n        dup[i] = code;\r\n      this.replaceSelections(dup, collapse, origin || "+input");\r\n    },\r\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\r\n      var changes = [], sel = this.sel;\r\n      for (var i = 0; i < sel.ranges.length; i++) {\r\n        var range = sel.ranges[i];\r\n        changes[i] = {from: range.from(), to: range.to(), text: splitLines(code[i]), origin: origin};\r\n      }\r\n      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);\r\n      for (var i = changes.length - 1; i >= 0; i--)\r\n        makeChange(this, changes[i]);\r\n      if (newSel) setSelectionReplaceHistory(this, newSel);\r\n      else if (this.cm) ensureCursorVisible(this.cm);\r\n    }),\r\n    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),\r\n    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),\r\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),\r\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),\r\n\r\n    setExtending: function(val) {this.extend = val;},\r\n    getExtending: function() {return this.extend;},\r\n\r\n    historySize: function() {\r\n      var hist = this.history, done = 0, undone = 0;\r\n      for (var i = 0; i < hist.done.length; i++) if (!hist.done[i].ranges) ++done;\r\n      for (var i = 0; i < hist.undone.length; i++) if (!hist.undone[i].ranges) ++undone;\r\n      return {undo: done, redo: undone};\r\n    },\r\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\r\n\r\n    markClean: function() {\r\n      this.cleanGeneration = this.changeGeneration(true);\r\n    },\r\n    changeGeneration: function(forceSplit) {\r\n      if (forceSplit)\r\n        this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;\r\n      return this.history.generation;\r\n    },\r\n    isClean: function (gen) {\r\n      return this.history.generation == (gen || this.cleanGeneration);\r\n    },\r\n\r\n    getHistory: function() {\r\n      return {done: copyHistoryArray(this.history.done),\r\n              undone: copyHistoryArray(this.history.undone)};\r\n    },\r\n    setHistory: function(histData) {\r\n      var hist = this.history = new History(this.history.maxGeneration);\r\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\r\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\r\n    },\r\n\r\n    addLineClass: docMethodOp(function(handle, where, cls) {\r\n      return changeLine(this, handle, "class", function(line) {\r\n        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";\r\n        if (!line[prop]) line[prop] = cls;\r\n        else if (new RegExp("(?:^|\\\\s)" + cls + "(?:$|\\\\s)").test(line[prop])) return false;\r\n        else line[prop] += " " + cls;\r\n        return true;\r\n      });\r\n    }),\r\n    removeLineClass: docMethodOp(function(handle, where, cls) {\r\n      return changeLine(this, handle, "class", function(line) {\r\n        var prop = where == "text" ? "textClass" : where == "background" ? "bgClass" : "wrapClass";\r\n        var cur = line[prop];\r\n        if (!cur) return false;\r\n        else if (cls == null) line[prop] = null;\r\n        else {\r\n          var found = cur.match(new RegExp("(?:^|\\\\s+)" + cls + "(?:$|\\\\s+)"));\r\n          if (!found) return false;\r\n          var end = found.index + found[0].length;\r\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;\r\n        }\r\n        return true;\r\n      });\r\n    }),\r\n\r\n    markText: function(from, to, options) {\r\n      return markText(this, clipPos(this, from), clipPos(this, to), options, "range");\r\n    },\r\n    setBookmark: function(pos, options) {\r\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\r\n                      insertLeft: options && options.insertLeft,\r\n                      clearWhenEmpty: false, shared: options && options.shared};\r\n      pos = clipPos(this, pos);\r\n      return markText(this, pos, pos, realOpts, "bookmark");\r\n    },\r\n    findMarksAt: function(pos) {\r\n      pos = clipPos(this, pos);\r\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\r\n      if (spans) for (var i = 0; i < spans.length; ++i) {\r\n        var span = spans[i];\r\n        if ((span.from == null || span.from <= pos.ch) &&\r\n            (span.to == null || span.to >= pos.ch))\r\n          markers.push(span.marker.parent || span.marker);\r\n      }\r\n      return markers;\r\n    },\r\n    findMarks: function(from, to, filter) {\r\n      from = clipPos(this, from); to = clipPos(this, to);\r\n      var found = [], lineNo = from.line;\r\n      this.iter(from.line, to.line + 1, function(line) {\r\n        var spans = line.markedSpans;\r\n        if (spans) for (var i = 0; i < spans.length; i++) {\r\n          var span = spans[i];\r\n          if (!(lineNo == from.line && from.ch > span.to ||\r\n                span.from == null && lineNo != from.line||\r\n                lineNo == to.line && span.from > to.ch) &&\r\n              (!filter || filter(span.marker)))\r\n            found.push(span.marker.parent || span.marker);\r\n        }\r\n        ++lineNo;\r\n      });\r\n      return found;\r\n    },\r\n    getAllMarks: function() {\r\n      var markers = [];\r\n      this.iter(function(line) {\r\n        var sps = line.markedSpans;\r\n        if (sps) for (var i = 0; i < sps.length; ++i)\r\n          if (sps[i].from != null) markers.push(sps[i].marker);\r\n      });\r\n      return markers;\r\n    },\r\n\r\n    posFromIndex: function(off) {\r\n      var ch, lineNo = this.first;\r\n      this.iter(function(line) {\r\n        var sz = line.text.length + 1;\r\n        if (sz > off) { ch = off; return true; }\r\n        off -= sz;\r\n        ++lineNo;\r\n      });\r\n      return clipPos(this, Pos(lineNo, ch));\r\n    },\r\n    indexFromPos: function (coords) {\r\n      coords = clipPos(this, coords);\r\n      var index = coords.ch;\r\n      if (coords.line < this.first || coords.ch < 0) return 0;\r\n      this.iter(this.first, coords.line, function (line) {\r\n        index += line.text.length + 1;\r\n      });\r\n      return index;\r\n    },\r\n\r\n    copy: function(copyHistory) {\r\n      var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first);\r\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\r\n      doc.sel = this.sel;\r\n      doc.extend = false;\r\n      if (copyHistory) {\r\n        doc.history.undoDepth = this.history.undoDepth;\r\n        doc.setHistory(this.getHistory());\r\n      }\r\n      return doc;\r\n    },\r\n\r\n    linkedDoc: function(options) {\r\n      if (!options) options = {};\r\n      var from = this.first, to = this.first + this.size;\r\n      if (options.from != null && options.from > from) from = options.from;\r\n      if (options.to != null && options.to < to) to = options.to;\r\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from);\r\n      if (options.sharedHist) copy.history = this.history;\r\n      (this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\r\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\r\n      copySharedMarkers(copy, findSharedMarkers(this));\r\n      return copy;\r\n    },\r\n    unlinkDoc: function(other) {\r\n      if (other instanceof CodeMirror) other = other.doc;\r\n      if (this.linked) for (var i = 0; i < this.linked.length; ++i) {\r\n        var link = this.linked[i];\r\n        if (link.doc != other) continue;\r\n        this.linked.splice(i, 1);\r\n        other.unlinkDoc(this);\r\n        detachSharedMarkers(findSharedMarkers(this));\r\n        break;\r\n      }\r\n      // If the histories were shared, split them again\r\n      if (other.history == this.history) {\r\n        var splitIds = [other.id];\r\n        linkedDocs(other, function(doc) {splitIds.push(doc.id);}, true);\r\n        other.history = new History(null);\r\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\r\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\r\n      }\r\n    },\r\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\r\n\r\n    getMode: function() {return this.mode;},\r\n    getEditor: function() {return this.cm;}\r\n  });\r\n\r\n  // Public alias.\r\n  Doc.prototype.eachLine = Doc.prototype.iter;\r\n\r\n  // Set up methods on CodeMirror\'s prototype to redirect to the editor\'s document.\r\n  var dontDelegate = "iter insert remove copy getEditor".split(" ");\r\n  for (var prop in Doc.prototype) if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\r\n    CodeMirror.prototype[prop] = (function(method) {\r\n      return function() {return method.apply(this.doc, arguments);};\r\n    })(Doc.prototype[prop]);\r\n\r\n  eventMixin(Doc);\r\n\r\n  // Call f for all linked documents.\r\n  function linkedDocs(doc, f, sharedHistOnly) {\r\n    function propagate(doc, skip, sharedHist) {\r\n      if (doc.linked) for (var i = 0; i < doc.linked.length; ++i) {\r\n        var rel = doc.linked[i];\r\n        if (rel.doc == skip) continue;\r\n        var shared = sharedHist && rel.sharedHist;\r\n        if (sharedHistOnly && !shared) continue;\r\n        f(rel.doc, shared);\r\n        propagate(rel.doc, doc, shared);\r\n      }\r\n    }\r\n    propagate(doc, null, true);\r\n  }\r\n\r\n  // Attach a document to an editor.\r\n  function attachDoc(cm, doc) {\r\n    if (doc.cm) throw new Error("This document is already in use.");\r\n    cm.doc = doc;\r\n    doc.cm = cm;\r\n    estimateLineHeights(cm);\r\n    loadMode(cm);\r\n    if (!cm.options.lineWrapping) findMaxLine(cm);\r\n    cm.options.mode = doc.modeOption;\r\n    regChange(cm);\r\n  }\r\n\r\n  // LINE UTILITIES\r\n\r\n  // Find the line object corresponding to the given line number.\r\n  function getLine(doc, n) {\r\n    n -= doc.first;\r\n    if (n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");\r\n    for (var chunk = doc; !chunk.lines;) {\r\n      for (var i = 0;; ++i) {\r\n        var child = chunk.children[i], sz = child.chunkSize();\r\n        if (n < sz) { chunk = child; break; }\r\n        n -= sz;\r\n      }\r\n    }\r\n    return chunk.lines[n];\r\n  }\r\n\r\n  // Get the part of a document between two positions, as an array of\r\n  // strings.\r\n  function getBetween(doc, start, end) {\r\n    var out = [], n = start.line;\r\n    doc.iter(start.line, end.line + 1, function(line) {\r\n      var text = line.text;\r\n      if (n == end.line) text = text.slice(0, end.ch);\r\n      if (n == start.line) text = text.slice(start.ch);\r\n      out.push(text);\r\n      ++n;\r\n    });\r\n    return out;\r\n  }\r\n  // Get the lines between from and to, as array of strings.\r\n  function getLines(doc, from, to) {\r\n    var out = [];\r\n    doc.iter(from, to, function(line) { out.push(line.text); });\r\n    return out;\r\n  }\r\n\r\n  // Update the height of a line, propagating the height change\r\n  // upwards to parent nodes.\r\n  function updateLineHeight(line, height) {\r\n    var diff = height - line.height;\r\n    if (diff) for (var n = line; n; n = n.parent) n.height += diff;\r\n  }\r\n\r\n  // Given a line object, find its line number by walking up through\r\n  // its parent links.\r\n  function lineNo(line) {\r\n    if (line.parent == null) return null;\r\n    var cur = line.parent, no = indexOf(cur.lines, line);\r\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\r\n      for (var i = 0;; ++i) {\r\n        if (chunk.children[i] == cur) break;\r\n        no += chunk.children[i].chunkSize();\r\n      }\r\n    }\r\n    return no + cur.first;\r\n  }\r\n\r\n  // Find the line at the given vertical position, using the height\r\n  // information in the document tree.\r\n  function lineAtHeight(chunk, h) {\r\n    var n = chunk.first;\r\n    outer: do {\r\n      for (var i = 0; i < chunk.children.length; ++i) {\r\n        var child = chunk.children[i], ch = child.height;\r\n        if (h < ch) { chunk = child; continue outer; }\r\n        h -= ch;\r\n        n += child.chunkSize();\r\n      }\r\n      return n;\r\n    } while (!chunk.lines);\r\n    for (var i = 0; i < chunk.lines.length; ++i) {\r\n      var line = chunk.lines[i], lh = line.height;\r\n      if (h < lh) break;\r\n      h -= lh;\r\n    }\r\n    return n + i;\r\n  }\r\n\r\n\r\n  // Find the height above the given line.\r\n  function heightAtLine(lineObj) {\r\n    lineObj = visualLine(lineObj);\r\n\r\n    var h = 0, chunk = lineObj.parent;\r\n    for (var i = 0; i < chunk.lines.length; ++i) {\r\n      var line = chunk.lines[i];\r\n      if (line == lineObj) break;\r\n      else h += line.height;\r\n    }\r\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\r\n      for (var i = 0; i < p.children.length; ++i) {\r\n        var cur = p.children[i];\r\n        if (cur == chunk) break;\r\n        else h += cur.height;\r\n      }\r\n    }\r\n    return h;\r\n  }\r\n\r\n  // Get the bidi ordering for the given line (and cache it). Returns\r\n  // false for lines that are fully left-to-right, and an array of\r\n  // BidiSpan objects otherwise.\r\n  function getOrder(line) {\r\n    var order = line.order;\r\n    if (order == null) order = line.order = bidiOrdering(line.text);\r\n    return order;\r\n  }\r\n\r\n  // HISTORY\r\n\r\n  function History(startGen) {\r\n    // Arrays of change events and selections. Doing something adds an\r\n    // event to done and clears undo. Undoing moves events from done\r\n    // to undone, redoing moves them in the other direction.\r\n    this.done = []; this.undone = [];\r\n    this.undoDepth = Infinity;\r\n    // Used to track when changes can be merged into a single undo\r\n    // event\r\n    this.lastModTime = this.lastSelTime = 0;\r\n    this.lastOp = this.lastSelOp = null;\r\n    this.lastOrigin = this.lastSelOrigin = null;\r\n    // Used by the isClean() method\r\n    this.generation = this.maxGeneration = startGen || 1;\r\n  }\r\n\r\n  // Create a history change event from an updateDoc-style change\r\n  // object.\r\n  function historyChangeFromChange(doc, change) {\r\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\r\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\r\n    linkedDocs(doc, function(doc) {attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);}, true);\r\n    return histChange;\r\n  }\r\n\r\n  // Pop all selection events off the end of a history array. Stop at\r\n  // a change event.\r\n  function clearSelectionEvents(array) {\r\n    while (array.length) {\r\n      var last = lst(array);\r\n      if (last.ranges) array.pop();\r\n      else break;\r\n    }\r\n  }\r\n\r\n  // Find the top change event in the history. Pop off selection\r\n  // events that are in the way.\r\n  function lastChangeEvent(hist, force) {\r\n    if (force) {\r\n      clearSelectionEvents(hist.done);\r\n      return lst(hist.done);\r\n    } else if (hist.done.length && !lst(hist.done).ranges) {\r\n      return lst(hist.done);\r\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\r\n      hist.done.pop();\r\n      return lst(hist.done);\r\n    }\r\n  }\r\n\r\n  // Register a change in the history. Merges changes that are within\r\n  // a single operation, ore are close together with an origin that\r\n  // allows merging (starting with "+") into a single event.\r\n  function addChangeToHistory(doc, change, selAfter, opId) {\r\n    var hist = doc.history;\r\n    hist.undone.length = 0;\r\n    var time = +new Date, cur;\r\n\r\n    if ((hist.lastOp == opId ||\r\n         hist.lastOrigin == change.origin && change.origin &&\r\n         ((change.origin.charAt(0) == "+" && doc.cm && hist.lastModTime > time - doc.cm.options.historyEventDelay) ||\r\n          change.origin.charAt(0) == "*")) &&\r\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\r\n      // Merge this change into the last event\r\n      var last = lst(cur.changes);\r\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\r\n        // Optimized case for simple insertion -- don\'t want to add\r\n        // new changesets for every character typed\r\n        last.to = changeEnd(change);\r\n      } else {\r\n        // Add new sub-event\r\n        cur.changes.push(historyChangeFromChange(doc, change));\r\n      }\r\n    } else {\r\n      // Can not be merged, start a new event.\r\n      var before = lst(hist.done);\r\n      if (!before || !before.ranges)\r\n        pushSelectionToHistory(doc.sel, hist.done);\r\n      cur = {changes: [historyChangeFromChange(doc, change)],\r\n             generation: hist.generation};\r\n      hist.done.push(cur);\r\n      while (hist.done.length > hist.undoDepth) {\r\n        hist.done.shift();\r\n        if (!hist.done[0].ranges) hist.done.shift();\r\n      }\r\n    }\r\n    hist.done.push(selAfter);\r\n    hist.generation = ++hist.maxGeneration;\r\n    hist.lastModTime = hist.lastSelTime = time;\r\n    hist.lastOp = hist.lastSelOp = opId;\r\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\r\n\r\n    if (!last) signal(doc, "historyAdded");\r\n  }\r\n\r\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\r\n    var ch = origin.charAt(0);\r\n    return ch == "*" ||\r\n      ch == "+" &&\r\n      prev.ranges.length == sel.ranges.length &&\r\n      prev.somethingSelected() == sel.somethingSelected() &&\r\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);\r\n  }\r\n\r\n  // Called whenever the selection changes, sets the new selection as\r\n  // the pending selection in the history, and pushes the old pending\r\n  // selection into the \'done\' array when it was significantly\r\n  // different (in number of selected ranges, emptiness, or time).\r\n  function addSelectionToHistory(doc, sel, opId, options) {\r\n    var hist = doc.history, origin = options && options.origin;\r\n\r\n    // A new event is started when the previous origin does not match\r\n    // the current, or the origins don\'t allow matching. Origins\r\n    // starting with * are always merged, those starting with + are\r\n    // merged when similar and close together in time.\r\n    if (opId == hist.lastSelOp ||\r\n        (origin && hist.lastSelOrigin == origin &&\r\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\r\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\r\n      hist.done[hist.done.length - 1] = sel;\r\n    else\r\n      pushSelectionToHistory(sel, hist.done);\r\n\r\n    hist.lastSelTime = +new Date;\r\n    hist.lastSelOrigin = origin;\r\n    hist.lastSelOp = opId;\r\n    if (options && options.clearRedo !== false)\r\n      clearSelectionEvents(hist.undone);\r\n  }\r\n\r\n  function pushSelectionToHistory(sel, dest) {\r\n    var top = lst(dest);\r\n    if (!(top && top.ranges && top.equals(sel)))\r\n      dest.push(sel);\r\n  }\r\n\r\n  // Used to store marked span information in the history.\r\n  function attachLocalSpans(doc, change, from, to) {\r\n    var existing = change["spans_" + doc.id], n = 0;\r\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {\r\n      if (line.markedSpans)\r\n        (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;\r\n      ++n;\r\n    });\r\n  }\r\n\r\n  // When un/re-doing restores text containing marked spans, those\r\n  // that have been explicitly cleared should not be restored.\r\n  function removeClearedSpans(spans) {\r\n    if (!spans) return null;\r\n    for (var i = 0, out; i < spans.length; ++i) {\r\n      if (spans[i].marker.explicitlyCleared) { if (!out) out = spans.slice(0, i); }\r\n      else if (out) out.push(spans[i]);\r\n    }\r\n    return !out ? spans : out.length ? out : null;\r\n  }\r\n\r\n  // Retrieve and filter the old marked spans stored in a change event.\r\n  function getOldSpans(doc, change) {\r\n    var found = change["spans_" + doc.id];\r\n    if (!found) return null;\r\n    for (var i = 0, nw = []; i < change.text.length; ++i)\r\n      nw.push(removeClearedSpans(found[i]));\r\n    return nw;\r\n  }\r\n\r\n  // Used both to provide a JSON-safe object in .getHistory, and, when\r\n  // detaching a document, to split the history in two\r\n  function copyHistoryArray(events, newGroup, instantiateSel) {\r\n    for (var i = 0, copy = []; i < events.length; ++i) {\r\n      var event = events[i];\r\n      if (event.ranges) {\r\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\r\n        continue;\r\n      }\r\n      var changes = event.changes, newChanges = [];\r\n      copy.push({changes: newChanges});\r\n      for (var j = 0; j < changes.length; ++j) {\r\n        var change = changes[j], m;\r\n        newChanges.push({from: change.from, to: change.to, text: change.text});\r\n        if (newGroup) for (var prop in change) if (m = prop.match(/^spans_(\\d+)$/)) {\r\n          if (indexOf(newGroup, Number(m[1])) > -1) {\r\n            lst(newChanges)[prop] = change[prop];\r\n            delete change[prop];\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return copy;\r\n  }\r\n\r\n  // Rebasing/resetting history to deal with externally-sourced changes\r\n\r\n  function rebaseHistSelSingle(pos, from, to, diff) {\r\n    if (to < pos.line) {\r\n      pos.line += diff;\r\n    } else if (from < pos.line) {\r\n      pos.line = from;\r\n      pos.ch = 0;\r\n    }\r\n  }\r\n\r\n  // Tries to rebase an array of history events given a change in the\r\n  // document. If the change touches the same lines as the event, the\r\n  // event, and everything \'behind\' it, is discarded. If the change is\r\n  // before the event, the event\'s positions are updated. Uses a\r\n  // copy-on-write scheme for the positions, to avoid having to\r\n  // reallocate them all on every rebase, but also avoid problems with\r\n  // shared position objects being unsafely updated.\r\n  function rebaseHistArray(array, from, to, diff) {\r\n    for (var i = 0; i < array.length; ++i) {\r\n      var sub = array[i], ok = true;\r\n      if (sub.ranges) {\r\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\r\n        for (var j = 0; j < sub.ranges.length; j++) {\r\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\r\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\r\n        }\r\n        continue;\r\n      }\r\n      for (var j = 0; j < sub.changes.length; ++j) {\r\n        var cur = sub.changes[j];\r\n        if (to < cur.from.line) {\r\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\r\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\r\n        } else if (from <= cur.to.line) {\r\n          ok = false;\r\n          break;\r\n        }\r\n      }\r\n      if (!ok) {\r\n        array.splice(0, i + 1);\r\n        i = 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  function rebaseHist(hist, change) {\r\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\r\n    rebaseHistArray(hist.done, from, to, diff);\r\n    rebaseHistArray(hist.undone, from, to, diff);\r\n  }\r\n\r\n  // EVENT UTILITIES\r\n\r\n  // Due to the fact that we still support jurassic IE versions, some\r\n  // compatibility wrappers are needed.\r\n\r\n  var e_preventDefault = CodeMirror.e_preventDefault = function(e) {\r\n    if (e.preventDefault) e.preventDefault();\r\n    else e.returnValue = false;\r\n  };\r\n  var e_stopPropagation = CodeMirror.e_stopPropagation = function(e) {\r\n    if (e.stopPropagation) e.stopPropagation();\r\n    else e.cancelBubble = true;\r\n  };\r\n  function e_defaultPrevented(e) {\r\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;\r\n  }\r\n  var e_stop = CodeMirror.e_stop = function(e) {e_preventDefault(e); e_stopPropagation(e);};\r\n\r\n  function e_target(e) {return e.target || e.srcElement;}\r\n  function e_button(e) {\r\n    var b = e.which;\r\n    if (b == null) {\r\n      if (e.button & 1) b = 1;\r\n      else if (e.button & 2) b = 3;\r\n      else if (e.button & 4) b = 2;\r\n    }\r\n    if (mac && e.ctrlKey && b == 1) b = 3;\r\n    return b;\r\n  }\r\n\r\n  // EVENT HANDLING\r\n\r\n  // Lightweight event framework. on/off also work on DOM nodes,\r\n  // registering native DOM handlers.\r\n\r\n  var on = CodeMirror.on = function(emitter, type, f) {\r\n    if (emitter.addEventListener)\r\n      emitter.addEventListener(type, f, false);\r\n    else if (emitter.attachEvent)\r\n      emitter.attachEvent("on" + type, f);\r\n    else {\r\n      var map = emitter._handlers || (emitter._handlers = {});\r\n      var arr = map[type] || (map[type] = []);\r\n      arr.push(f);\r\n    }\r\n  };\r\n\r\n  var off = CodeMirror.off = function(emitter, type, f) {\r\n    if (emitter.removeEventListener)\r\n      emitter.removeEventListener(type, f, false);\r\n    else if (emitter.detachEvent)\r\n      emitter.detachEvent("on" + type, f);\r\n    else {\r\n      var arr = emitter._handlers && emitter._handlers[type];\r\n      if (!arr) return;\r\n      for (var i = 0; i < arr.length; ++i)\r\n        if (arr[i] == f) { arr.splice(i, 1); break; }\r\n    }\r\n  };\r\n\r\n  var signal = CodeMirror.signal = function(emitter, type /*, values...*/) {\r\n    var arr = emitter._handlers && emitter._handlers[type];\r\n    if (!arr) return;\r\n    var args = Array.prototype.slice.call(arguments, 2);\r\n    for (var i = 0; i < arr.length; ++i) arr[i].apply(null, args);\r\n  };\r\n\r\n  var orphanDelayedCallbacks = null;\r\n\r\n  // Often, we want to signal events at a point where we are in the\r\n  // middle of some work, but don\'t want the handler to start calling\r\n  // other methods on the editor, which might be in an inconsistent\r\n  // state or simply not expect any other events to happen.\r\n  // signalLater looks whether there are any handlers, and schedules\r\n  // them to be executed when the last operation ends, or, if no\r\n  // operation is active, when a timeout fires.\r\n  function signalLater(emitter, type /*, values...*/) {\r\n    var arr = emitter._handlers && emitter._handlers[type];\r\n    if (!arr) return;\r\n    var args = Array.prototype.slice.call(arguments, 2), list;\r\n    if (operationGroup) {\r\n      list = operationGroup.delayedCallbacks;\r\n    } else if (orphanDelayedCallbacks) {\r\n      list = orphanDelayedCallbacks;\r\n    } else {\r\n      list = orphanDelayedCallbacks = [];\r\n      setTimeout(fireOrphanDelayed, 0);\r\n    }\r\n    function bnd(f) {return function(){f.apply(null, args);};};\r\n    for (var i = 0; i < arr.length; ++i)\r\n      list.push(bnd(arr[i]));\r\n  }\r\n\r\n  function fireOrphanDelayed() {\r\n    var delayed = orphanDelayedCallbacks;\r\n    orphanDelayedCallbacks = null;\r\n    for (var i = 0; i < delayed.length; ++i) delayed[i]();\r\n  }\r\n\r\n  // The DOM events that CodeMirror handles can be overridden by\r\n  // registering a (non-DOM) handler on the editor for the event name,\r\n  // and preventDefault-ing the event in that handler.\r\n  function signalDOMEvent(cm, e, override) {\r\n    signal(cm, override || e.type, cm, e);\r\n    return e_defaultPrevented(e) || e.codemirrorIgnore;\r\n  }\r\n\r\n  function signalCursorActivity(cm) {\r\n    var arr = cm._handlers && cm._handlers.cursorActivity;\r\n    if (!arr) return;\r\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\r\n    for (var i = 0; i < arr.length; ++i) if (indexOf(set, arr[i]) == -1)\r\n      set.push(arr[i]);\r\n  }\r\n\r\n  function hasHandler(emitter, type) {\r\n    var arr = emitter._handlers && emitter._handlers[type];\r\n    return arr && arr.length > 0;\r\n  }\r\n\r\n  // Add on and off methods to a constructor\'s prototype, to make\r\n  // registering events on such objects more convenient.\r\n  function eventMixin(ctor) {\r\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\r\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\r\n  }\r\n\r\n  // MISC UTILITIES\r\n\r\n  // Number of pixels added to scroller and sizer to hide scrollbar\r\n  var scrollerCutOff = 30;\r\n\r\n  // Returned or thrown by various protocols to signal \'I\'m not\r\n  // handling this\'.\r\n  var Pass = CodeMirror.Pass = {toString: function(){return "CodeMirror.Pass";}};\r\n\r\n  // Reused option objects for setSelection & friends\r\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};\r\n\r\n  function Delayed() {this.id = null;}\r\n  Delayed.prototype.set = function(ms, f) {\r\n    clearTimeout(this.id);\r\n    this.id = setTimeout(f, ms);\r\n  };\r\n\r\n  // Counts the column offset in a string, taking tabs into account.\r\n  // Used mostly to find indentation.\r\n  var countColumn = CodeMirror.countColumn = function(string, end, tabSize, startIndex, startValue) {\r\n    if (end == null) {\r\n      end = string.search(/[^\\s\\u00a0]/);\r\n      if (end == -1) end = string.length;\r\n    }\r\n    for (var i = startIndex || 0, n = startValue || 0;;) {\r\n      var nextTab = string.indexOf("\\t", i);\r\n      if (nextTab < 0 || nextTab >= end)\r\n        return n + (end - i);\r\n      n += nextTab - i;\r\n      n += tabSize - (n % tabSize);\r\n      i = nextTab + 1;\r\n    }\r\n  };\r\n\r\n  // The inverse of countColumn -- find the offset that corresponds to\r\n  // a particular column.\r\n  function findColumn(string, goal, tabSize) {\r\n    for (var pos = 0, col = 0;;) {\r\n      var nextTab = string.indexOf("\\t", pos);\r\n      if (nextTab == -1) nextTab = string.length;\r\n      var skipped = nextTab - pos;\r\n      if (nextTab == string.length || col + skipped >= goal)\r\n        return pos + Math.min(skipped, goal - col);\r\n      col += nextTab - pos;\r\n      col += tabSize - (col % tabSize);\r\n      pos = nextTab + 1;\r\n      if (col >= goal) return pos;\r\n    }\r\n  }\r\n\r\n  var spaceStrs = [""];\r\n  function spaceStr(n) {\r\n    while (spaceStrs.length <= n)\r\n      spaceStrs.push(lst(spaceStrs) + " ");\r\n    return spaceStrs[n];\r\n  }\r\n\r\n  function lst(arr) { return arr[arr.length-1]; }\r\n\r\n  var selectInput = function(node) { node.select(); };\r\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\r\n    selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; };\r\n  else if (ie) // Suppress mysterious IE10 errors\r\n    selectInput = function(node) { try { node.select(); } catch(_e) {} };\r\n\r\n  function indexOf(array, elt) {\r\n    for (var i = 0; i < array.length; ++i)\r\n      if (array[i] == elt) return i;\r\n    return -1;\r\n  }\r\n  if ([].indexOf) indexOf = function(array, elt) { return array.indexOf(elt); };\r\n  function map(array, f) {\r\n    var out = [];\r\n    for (var i = 0; i < array.length; i++) out[i] = f(array[i], i);\r\n    return out;\r\n  }\r\n  if ([].map) map = function(array, f) { return array.map(f); };\r\n\r\n  function createObj(base, props) {\r\n    var inst;\r\n    if (Object.create) {\r\n      inst = Object.create(base);\r\n    } else {\r\n      var ctor = function() {};\r\n      ctor.prototype = base;\r\n      inst = new ctor();\r\n    }\r\n    if (props) copyObj(props, inst);\r\n    return inst;\r\n  };\r\n\r\n  function copyObj(obj, target, overwrite) {\r\n    if (!target) target = {};\r\n    for (var prop in obj)\r\n      if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\r\n        target[prop] = obj[prop];\r\n    return target;\r\n  }\r\n\r\n  function bind(f) {\r\n    var args = Array.prototype.slice.call(arguments, 1);\r\n    return function(){return f.apply(null, args);};\r\n  }\r\n\r\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0590-\\u05f4\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\r\n  var isWordCharBasic = CodeMirror.isWordChar = function(ch) {\r\n    return /\\w/.test(ch) || ch > "\\x80" &&\r\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));\r\n  };\r\n  function isWordChar(ch, helper) {\r\n    if (!helper) return isWordCharBasic(ch);\r\n    if (helper.source.indexOf("\\\\w") > -1 && isWordCharBasic(ch)) return true;\r\n    return helper.test(ch);\r\n  }\r\n\r\n  function isEmpty(obj) {\r\n    for (var n in obj) if (obj.hasOwnProperty(n) && obj[n]) return false;\r\n    return true;\r\n  }\r\n\r\n  // Extending unicode characters. A series of a non-extending char +\r\n  // any number of extending chars is treated as a single unit as far\r\n  // as editing and measuring is concerned. This is not fully correct,\r\n  // since some scripts/fonts/browsers also treat other configurations\r\n  // of code points as a group.\r\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\r\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch); }\r\n\r\n  // DOM UTILITIES\r\n\r\n  function elt(tag, content, className, style) {\r\n    var e = document.createElement(tag);\r\n    if (className) e.className = className;\r\n    if (style) e.style.cssText = style;\r\n    if (typeof content == "string") e.appendChild(document.createTextNode(content));\r\n    else if (content) for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);\r\n    return e;\r\n  }\r\n\r\n  var range;\r\n  if (document.createRange) range = function(node, start, end) {\r\n    var r = document.createRange();\r\n    r.setEnd(node, end);\r\n    r.setStart(node, start);\r\n    return r;\r\n  };\r\n  else range = function(node, start, end) {\r\n    var r = document.body.createTextRange();\r\n    r.moveToElementText(node.parentNode);\r\n    r.collapse(true);\r\n    r.moveEnd("character", end);\r\n    r.moveStart("character", start);\r\n    return r;\r\n  };\r\n\r\n  function removeChildren(e) {\r\n    for (var count = e.childNodes.length; count > 0; --count)\r\n      e.removeChild(e.firstChild);\r\n    return e;\r\n  }\r\n\r\n  function removeChildrenAndAdd(parent, e) {\r\n    return removeChildren(parent).appendChild(e);\r\n  }\r\n\r\n  function contains(parent, child) {\r\n    if (parent.contains)\r\n      return parent.contains(child);\r\n    while (child = child.parentNode)\r\n      if (child == parent) return true;\r\n  }\r\n\r\n  function activeElt() { return document.activeElement; }\r\n  // Older versions of IE throws unspecified error when touching\r\n  // document.activeElement in some cases (during loading, in iframe)\r\n  if (ie && ie_version < 11) activeElt = function() {\r\n    try { return document.activeElement; }\r\n    catch(e) { return document.body; }\r\n  };\r\n\r\n  function classTest(cls) { return new RegExp("\\\\b" + cls + "\\\\b\\\\s*"); }\r\n  function rmClass(node, cls) {\r\n    var test = classTest(cls);\r\n    if (test.test(node.className)) node.className = node.className.replace(test, "");\r\n  }\r\n  function addClass(node, cls) {\r\n    if (!classTest(cls).test(node.className)) node.className += " " + cls;\r\n  }\r\n  function joinClasses(a, b) {\r\n    var as = a.split(" ");\r\n    for (var i = 0; i < as.length; i++)\r\n      if (as[i] && !classTest(as[i]).test(b)) b += " " + as[i];\r\n    return b;\r\n  }\r\n\r\n  // WINDOW-WIDE EVENTS\r\n\r\n  // These must be handled carefully, because naively registering a\r\n  // handler for each editor will cause the editors to never be\r\n  // garbage collected.\r\n\r\n  function forEachCodeMirror(f) {\r\n    if (!document.body.getElementsByClassName) return;\r\n    var byClass = document.body.getElementsByClassName("CodeMirror");\r\n    for (var i = 0; i < byClass.length; i++) {\r\n      var cm = byClass[i].CodeMirror;\r\n      if (cm) f(cm);\r\n    }\r\n  }\r\n\r\n  var globalsRegistered = false;\r\n  function ensureGlobalHandlers() {\r\n    if (globalsRegistered) return;\r\n    registerGlobalHandlers();\r\n    globalsRegistered = true;\r\n  }\r\n  function registerGlobalHandlers() {\r\n    // When the window resizes, we need to refresh active editors.\r\n    var resizeTimer;\r\n    on(window, "resize", function() {\r\n      if (resizeTimer == null) resizeTimer = setTimeout(function() {\r\n        resizeTimer = null;\r\n        knownScrollbarWidth = null;\r\n        forEachCodeMirror(onResize);\r\n      }, 100);\r\n    });\r\n    // When the window loses focus, we want to show the editor as blurred\r\n    on(window, "blur", function() {\r\n      forEachCodeMirror(onBlur);\r\n    });\r\n  }\r\n\r\n  // FEATURE DETECTION\r\n\r\n  // Detect drag-and-drop\r\n  var dragAndDrop = function() {\r\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\r\n    // couldn\'t get it to work yet.\r\n    if (ie && ie_version < 9) return false;\r\n    var div = elt(\'div\');\r\n    return "draggable" in div || "dragDrop" in div;\r\n  }();\r\n\r\n  var knownScrollbarWidth;\r\n  function scrollbarWidth(measure) {\r\n    if (knownScrollbarWidth != null) return knownScrollbarWidth;\r\n    var test = elt("div", null, null, "width: 50px; height: 50px; overflow-x: scroll");\r\n    removeChildrenAndAdd(measure, test);\r\n    if (test.offsetWidth)\r\n      knownScrollbarWidth = test.offsetHeight - test.clientHeight;\r\n    return knownScrollbarWidth || 0;\r\n  }\r\n\r\n  var zwspSupported;\r\n  function zeroWidthElement(measure) {\r\n    if (zwspSupported == null) {\r\n      var test = elt("span", "\\u200b");\r\n      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));\r\n      if (measure.firstChild.offsetHeight != 0)\r\n        zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);\r\n    }\r\n    if (zwspSupported) return elt("span", "\\u200b");\r\n    else return elt("span", "\\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");\r\n  }\r\n\r\n  // Feature-detect IE\'s crummy client rect reporting for bidi text\r\n  var badBidiRects;\r\n  function hasBadBidiRects(measure) {\r\n    if (badBidiRects != null) return badBidiRects;\r\n    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\\u062eA"));\r\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\r\n    if (!r0 || r0.left == r0.right) return false; // Safari returns null in some cases (#2780)\r\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\r\n    return badBidiRects = (r1.right - r0.right < 3);\r\n  }\r\n\r\n  // See if "".split is the broken IE version, if so, provide an\r\n  // alternative way to split lines.\r\n  var splitLines = CodeMirror.splitLines = "\\n\\nb".split(/\\n/).length != 3 ? function(string) {\r\n    var pos = 0, result = [], l = string.length;\r\n    while (pos <= l) {\r\n      var nl = string.indexOf("\\n", pos);\r\n      if (nl == -1) nl = string.length;\r\n      var line = string.slice(pos, string.charAt(nl - 1) == "\\r" ? nl - 1 : nl);\r\n      var rt = line.indexOf("\\r");\r\n      if (rt != -1) {\r\n        result.push(line.slice(0, rt));\r\n        pos += rt + 1;\r\n      } else {\r\n        result.push(line);\r\n        pos = nl + 1;\r\n      }\r\n    }\r\n    return result;\r\n  } : function(string){return string.split(/\\r\\n?|\\n/);};\r\n\r\n  var hasSelection = window.getSelection ? function(te) {\r\n    try { return te.selectionStart != te.selectionEnd; }\r\n    catch(e) { return false; }\r\n  } : function(te) {\r\n    try {var range = te.ownerDocument.selection.createRange();}\r\n    catch(e) {}\r\n    if (!range || range.parentElement() != te) return false;\r\n    return range.compareEndPoints("StartToEnd", range) != 0;\r\n  };\r\n\r\n  var hasCopyEvent = (function() {\r\n    var e = elt("div");\r\n    if ("oncopy" in e) return true;\r\n    e.setAttribute("oncopy", "return;");\r\n    return typeof e.oncopy == "function";\r\n  })();\r\n\r\n  var badZoomedRects = null;\r\n  function hasBadZoomedRects(measure) {\r\n    if (badZoomedRects != null) return badZoomedRects;\r\n    var node = removeChildrenAndAdd(measure, elt("span", "x"));\r\n    var normal = node.getBoundingClientRect();\r\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\r\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;\r\n  }\r\n\r\n  // KEY NAMES\r\n\r\n  var keyNames = {3: "Enter", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",\r\n                  19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",\r\n                  36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",\r\n                  46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod", 107: "=", 109: "-", 127: "Delete",\r\n                  173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\\\",\r\n                  221: "]", 222: "\'", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",\r\n                  63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"};\r\n  CodeMirror.keyNames = keyNames;\r\n  (function() {\r\n    // Number keys\r\n    for (var i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);\r\n    // Alphabetic keys\r\n    for (var i = 65; i <= 90; i++) keyNames[i] = String.fromCharCode(i);\r\n    // Function keys\r\n    for (var i = 1; i <= 12; i++) keyNames[i + 111] = keyNames[i + 63235] = "F" + i;\r\n  })();\r\n\r\n  // BIDI HELPERS\r\n\r\n  function iterateBidiSections(order, from, to, f) {\r\n    if (!order) return f(from, to, "ltr");\r\n    var found = false;\r\n    for (var i = 0; i < order.length; ++i) {\r\n      var part = order[i];\r\n      if (part.from < to && part.to > from || from == to && part.to == from) {\r\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr");\r\n        found = true;\r\n      }\r\n    }\r\n    if (!found) f(from, to, "ltr");\r\n  }\r\n\r\n  function bidiLeft(part) { return part.level % 2 ? part.to : part.from; }\r\n  function bidiRight(part) { return part.level % 2 ? part.from : part.to; }\r\n\r\n  function lineLeft(line) { var order = getOrder(line); return order ? bidiLeft(order[0]) : 0; }\r\n  function lineRight(line) {\r\n    var order = getOrder(line);\r\n    if (!order) return line.text.length;\r\n    return bidiRight(lst(order));\r\n  }\r\n\r\n  function lineStart(cm, lineN) {\r\n    var line = getLine(cm.doc, lineN);\r\n    var visual = visualLine(line);\r\n    if (visual != line) lineN = lineNo(visual);\r\n    var order = getOrder(visual);\r\n    var ch = !order ? 0 : order[0].level % 2 ? lineRight(visual) : lineLeft(visual);\r\n    return Pos(lineN, ch);\r\n  }\r\n  function lineEnd(cm, lineN) {\r\n    var merged, line = getLine(cm.doc, lineN);\r\n    while (merged = collapsedSpanAtEnd(line)) {\r\n      line = merged.find(1, true).line;\r\n      lineN = null;\r\n    }\r\n    var order = getOrder(line);\r\n    var ch = !order ? line.text.length : order[0].level % 2 ? lineLeft(line) : lineRight(line);\r\n    return Pos(lineN == null ? lineNo(line) : lineN, ch);\r\n  }\r\n  function lineStartSmart(cm, pos) {\r\n    var start = lineStart(cm, pos.line);\r\n    var line = getLine(cm.doc, start.line);\r\n    var order = getOrder(line);\r\n    if (!order || order[0].level == 0) {\r\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\r\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\r\n      return Pos(start.line, inWS ? 0 : firstNonWS);\r\n    }\r\n    return start;\r\n  }\r\n\r\n  function compareBidiLevel(order, a, b) {\r\n    var linedir = order[0].level;\r\n    if (a == linedir) return true;\r\n    if (b == linedir) return false;\r\n    return a < b;\r\n  }\r\n  var bidiOther;\r\n  function getBidiPartAt(order, pos) {\r\n    bidiOther = null;\r\n    for (var i = 0, found; i < order.length; ++i) {\r\n      var cur = order[i];\r\n      if (cur.from < pos && cur.to > pos) return i;\r\n      if ((cur.from == pos || cur.to == pos)) {\r\n        if (found == null) {\r\n          found = i;\r\n        } else if (compareBidiLevel(order, cur.level, order[found].level)) {\r\n          if (cur.from != cur.to) bidiOther = found;\r\n          return i;\r\n        } else {\r\n          if (cur.from != cur.to) bidiOther = i;\r\n          return found;\r\n        }\r\n      }\r\n    }\r\n    return found;\r\n  }\r\n\r\n  function moveInLine(line, pos, dir, byUnit) {\r\n    if (!byUnit) return pos + dir;\r\n    do pos += dir;\r\n    while (pos > 0 && isExtendingChar(line.text.charAt(pos)));\r\n    return pos;\r\n  }\r\n\r\n  // This is needed in order to move \'visually\' through bi-directional\r\n  // text -- i.e., pressing left should make the cursor go left, even\r\n  // when in RTL text. The tricky part is the \'jumps\', where RTL and\r\n  // LTR text touch each other. This often requires the cursor offset\r\n  // to move more than one unit, in order to visually move one unit.\r\n  function moveVisually(line, start, dir, byUnit) {\r\n    var bidi = getOrder(line);\r\n    if (!bidi) return moveLogically(line, start, dir, byUnit);\r\n    var pos = getBidiPartAt(bidi, start), part = bidi[pos];\r\n    var target = moveInLine(line, start, part.level % 2 ? -dir : dir, byUnit);\r\n\r\n    for (;;) {\r\n      if (target > part.from && target < part.to) return target;\r\n      if (target == part.from || target == part.to) {\r\n        if (getBidiPartAt(bidi, target) == pos) return target;\r\n        part = bidi[pos += dir];\r\n        return (dir > 0) == part.level % 2 ? part.to : part.from;\r\n      } else {\r\n        part = bidi[pos += dir];\r\n        if (!part) return null;\r\n        if ((dir > 0) == part.level % 2)\r\n          target = moveInLine(line, part.to, -1, byUnit);\r\n        else\r\n          target = moveInLine(line, part.from, 1, byUnit);\r\n      }\r\n    }\r\n  }\r\n\r\n  function moveLogically(line, start, dir, byUnit) {\r\n    var target = start + dir;\r\n    if (byUnit) while (target > 0 && isExtendingChar(line.text.charAt(target))) target += dir;\r\n    return target < 0 || target > line.text.length ? null : target;\r\n  }\r\n\r\n  // Bidirectional ordering algorithm\r\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\r\n  // that this (partially) implements.\r\n\r\n  // One-char codes used for character types:\r\n  // L (L):   Left-to-Right\r\n  // R (R):   Right-to-Left\r\n  // r (AL):  Right-to-Left Arabic\r\n  // 1 (EN):  European Number\r\n  // + (ES):  European Number Separator\r\n  // % (ET):  European Number Terminator\r\n  // n (AN):  Arabic Number\r\n  // , (CS):  Common Number Separator\r\n  // m (NSM): Non-Spacing Mark\r\n  // b (BN):  Boundary Neutral\r\n  // s (B):   Paragraph Separator\r\n  // t (S):   Segment Separator\r\n  // w (WS):  Whitespace\r\n  // N (ON):  Other Neutrals\r\n\r\n  // Returns null if characters are ordered as they appear\r\n  // (left-to-right), or an array of sections ({from, to, level}\r\n  // objects) in the order in which they occur visually.\r\n  var bidiOrdering = (function() {\r\n    // Character types for codepoints 0 to 0xff\r\n    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";\r\n    // Character types for codepoints 0x600 to 0x6ff\r\n    var arabicTypes = "rrrrrrrrrrrr,rNNmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmrrrrrrrnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmNmmmm";\r\n    function charType(code) {\r\n      if (code <= 0xf7) return lowTypes.charAt(code);\r\n      else if (0x590 <= code && code <= 0x5f4) return "R";\r\n      else if (0x600 <= code && code <= 0x6ed) return arabicTypes.charAt(code - 0x600);\r\n      else if (0x6ee <= code && code <= 0x8ac) return "r";\r\n      else if (0x2000 <= code && code <= 0x200b) return "w";\r\n      else if (code == 0x200c) return "b";\r\n      else return "L";\r\n    }\r\n\r\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\r\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\r\n    // Browsers seem to always treat the boundaries of block elements as being L.\r\n    var outerType = "L";\r\n\r\n    function BidiSpan(level, from, to) {\r\n      this.level = level;\r\n      this.from = from; this.to = to;\r\n    }\r\n\r\n    return function(str) {\r\n      if (!bidiRE.test(str)) return false;\r\n      var len = str.length, types = [];\r\n      for (var i = 0, type; i < len; ++i)\r\n        types.push(type = charType(str.charCodeAt(i)));\r\n\r\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\r\n      // change the type of the NSM to the type of the previous\r\n      // character. If the NSM is at the start of the level run, it will\r\n      // get the type of sor.\r\n      for (var i = 0, prev = outerType; i < len; ++i) {\r\n        var type = types[i];\r\n        if (type == "m") types[i] = prev;\r\n        else prev = type;\r\n      }\r\n\r\n      // W2. Search backwards from each instance of a European number\r\n      // until the first strong type (R, L, AL, or sor) is found. If an\r\n      // AL is found, change the type of the European number to Arabic\r\n      // number.\r\n      // W3. Change all ALs to R.\r\n      for (var i = 0, cur = outerType; i < len; ++i) {\r\n        var type = types[i];\r\n        if (type == "1" && cur == "r") types[i] = "n";\r\n        else if (isStrong.test(type)) { cur = type; if (type == "r") types[i] = "R"; }\r\n      }\r\n\r\n      // W4. A single European separator between two European numbers\r\n      // changes to a European number. A single common separator between\r\n      // two numbers of the same type changes to that type.\r\n      for (var i = 1, prev = types[0]; i < len - 1; ++i) {\r\n        var type = types[i];\r\n        if (type == "+" && prev == "1" && types[i+1] == "1") types[i] = "1";\r\n        else if (type == "," && prev == types[i+1] &&\r\n                 (prev == "1" || prev == "n")) types[i] = prev;\r\n        prev = type;\r\n      }\r\n\r\n      // W5. A sequence of European terminators adjacent to European\r\n      // numbers changes to all European numbers.\r\n      // W6. Otherwise, separators and terminators change to Other\r\n      // Neutral.\r\n      for (var i = 0; i < len; ++i) {\r\n        var type = types[i];\r\n        if (type == ",") types[i] = "N";\r\n        else if (type == "%") {\r\n          for (var end = i + 1; end < len && types[end] == "%"; ++end) {}\r\n          var replace = (i && types[i-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";\r\n          for (var j = i; j < end; ++j) types[j] = replace;\r\n          i = end - 1;\r\n        }\r\n      }\r\n\r\n      // W7. Search backwards from each instance of a European number\r\n      // until the first strong type (R, L, or sor) is found. If an L is\r\n      // found, then change the type of the European number to L.\r\n      for (var i = 0, cur = outerType; i < len; ++i) {\r\n        var type = types[i];\r\n        if (cur == "L" && type == "1") types[i] = "L";\r\n        else if (isStrong.test(type)) cur = type;\r\n      }\r\n\r\n      // N1. A sequence of neutrals takes the direction of the\r\n      // surrounding strong text if the text on both sides has the same\r\n      // direction. European and Arabic numbers act as if they were R in\r\n      // terms of their influence on neutrals. Start-of-level-run (sor)\r\n      // and end-of-level-run (eor) are used at level run boundaries.\r\n      // N2. Any remaining neutrals take the embedding direction.\r\n      for (var i = 0; i < len; ++i) {\r\n        if (isNeutral.test(types[i])) {\r\n          for (var end = i + 1; end < len && isNeutral.test(types[end]); ++end) {}\r\n          var before = (i ? types[i-1] : outerType) == "L";\r\n          var after = (end < len ? types[end] : outerType) == "L";\r\n          var replace = before || after ? "L" : "R";\r\n          for (var j = i; j < end; ++j) types[j] = replace;\r\n          i = end - 1;\r\n        }\r\n      }\r\n\r\n      // Here we depart from the documented algorithm, in order to avoid\r\n      // building up an actual levels array. Since there are only three\r\n      // levels (0, 1, 2) in an implementation that doesn\'t take\r\n      // explicit embedding into account, we can build up the order on\r\n      // the fly, without following the level-based algorithm.\r\n      var order = [], m;\r\n      for (var i = 0; i < len;) {\r\n        if (countsAsLeft.test(types[i])) {\r\n          var start = i;\r\n          for (++i; i < len && countsAsLeft.test(types[i]); ++i) {}\r\n          order.push(new BidiSpan(0, start, i));\r\n        } else {\r\n          var pos = i, at = order.length;\r\n          for (++i; i < len && types[i] != "L"; ++i) {}\r\n          for (var j = pos; j < i;) {\r\n            if (countsAsNum.test(types[j])) {\r\n              if (pos < j) order.splice(at, 0, new BidiSpan(1, pos, j));\r\n              var nstart = j;\r\n              for (++j; j < i && countsAsNum.test(types[j]); ++j) {}\r\n              order.splice(at, 0, new BidiSpan(2, nstart, j));\r\n              pos = j;\r\n            } else ++j;\r\n          }\r\n          if (pos < i) order.splice(at, 0, new BidiSpan(1, pos, i));\r\n        }\r\n      }\r\n      if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\r\n        order[0].from = m[0].length;\r\n        order.unshift(new BidiSpan(0, 0, m[0].length));\r\n      }\r\n      if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\r\n        lst(order).to -= m[0].length;\r\n        order.push(new BidiSpan(0, len - m[0].length, len));\r\n      }\r\n      if (order[0].level != lst(order).level)\r\n        order.push(new BidiSpan(order[0].level, len, len));\r\n\r\n      return order;\r\n    };\r\n  })();\r\n\r\n  // THE END\r\n\r\n  CodeMirror.version = "4.5.1";\r\n\r\n  return CodeMirror;\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/lib/codemirror.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/fold/xml-fold\',["../../lib/codemirror"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  "use strict";\r\n\r\n  var Pos = CodeMirror.Pos;\r\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch; }\r\n\r\n  var nameStartChar = "A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD";\r\n  var nameChar = nameStartChar + "\\-\\:\\.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040";\r\n  var xmlTagStart = new RegExp("<(/?)([" + nameStartChar + "][" + nameChar + "]*)", "g");\r\n\r\n  function Iter(cm, line, ch, range) {\r\n    this.line = line; this.ch = ch;\r\n    this.cm = cm; this.text = cm.getLine(line);\r\n    this.min = range ? range.from : cm.firstLine();\r\n    this.max = range ? range.to - 1 : cm.lastLine();\r\n  }\r\n\r\n  function tagAt(iter, ch) {\r\n    var type = iter.cm.getTokenTypeAt(Pos(iter.line, ch));\r\n    return type && /\\btag\\b/.test(type);\r\n  }\r\n\r\n  function nextLine(iter) {\r\n    if (iter.line >= iter.max) return;\r\n    iter.ch = 0;\r\n    iter.text = iter.cm.getLine(++iter.line);\r\n    return true;\r\n  }\r\n  function prevLine(iter) {\r\n    if (iter.line <= iter.min) return;\r\n    iter.text = iter.cm.getLine(--iter.line);\r\n    iter.ch = iter.text.length;\r\n    return true;\r\n  }\r\n\r\n  function toTagEnd(iter) {\r\n    for (;;) {\r\n      var gt = iter.text.indexOf(">", iter.ch);\r\n      if (gt == -1) { if (nextLine(iter)) continue; else return; }\r\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt + 1; continue; }\r\n      var lastSlash = iter.text.lastIndexOf("/", gt);\r\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\r\n      iter.ch = gt + 1;\r\n      return selfClose ? "selfClose" : "regular";\r\n    }\r\n  }\r\n  function toTagStart(iter) {\r\n    for (;;) {\r\n      var lt = iter.ch ? iter.text.lastIndexOf("<", iter.ch - 1) : -1;\r\n      if (lt == -1) { if (prevLine(iter)) continue; else return; }\r\n      if (!tagAt(iter, lt + 1)) { iter.ch = lt; continue; }\r\n      xmlTagStart.lastIndex = lt;\r\n      iter.ch = lt;\r\n      var match = xmlTagStart.exec(iter.text);\r\n      if (match && match.index == lt) return match;\r\n    }\r\n  }\r\n\r\n  function toNextTag(iter) {\r\n    for (;;) {\r\n      xmlTagStart.lastIndex = iter.ch;\r\n      var found = xmlTagStart.exec(iter.text);\r\n      if (!found) { if (nextLine(iter)) continue; else return; }\r\n      if (!tagAt(iter, found.index + 1)) { iter.ch = found.index + 1; continue; }\r\n      iter.ch = found.index + found[0].length;\r\n      return found;\r\n    }\r\n  }\r\n  function toPrevTag(iter) {\r\n    for (;;) {\r\n      var gt = iter.ch ? iter.text.lastIndexOf(">", iter.ch - 1) : -1;\r\n      if (gt == -1) { if (prevLine(iter)) continue; else return; }\r\n      if (!tagAt(iter, gt + 1)) { iter.ch = gt; continue; }\r\n      var lastSlash = iter.text.lastIndexOf("/", gt);\r\n      var selfClose = lastSlash > -1 && !/\\S/.test(iter.text.slice(lastSlash + 1, gt));\r\n      iter.ch = gt + 1;\r\n      return selfClose ? "selfClose" : "regular";\r\n    }\r\n  }\r\n\r\n  function findMatchingClose(iter, tag) {\r\n    var stack = [];\r\n    for (;;) {\r\n      var next = toNextTag(iter), end, startLine = iter.line, startCh = iter.ch - (next ? next[0].length : 0);\r\n      if (!next || !(end = toTagEnd(iter))) return;\r\n      if (end == "selfClose") continue;\r\n      if (next[1]) { // closing tag\r\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == next[2]) {\r\n          stack.length = i;\r\n          break;\r\n        }\r\n        if (i < 0 && (!tag || tag == next[2])) return {\r\n          tag: next[2],\r\n          from: Pos(startLine, startCh),\r\n          to: Pos(iter.line, iter.ch)\r\n        };\r\n      } else { // opening tag\r\n        stack.push(next[2]);\r\n      }\r\n    }\r\n  }\r\n  function findMatchingOpen(iter, tag) {\r\n    var stack = [];\r\n    for (;;) {\r\n      var prev = toPrevTag(iter);\r\n      if (!prev) return;\r\n      if (prev == "selfClose") { toTagStart(iter); continue; }\r\n      var endLine = iter.line, endCh = iter.ch;\r\n      var start = toTagStart(iter);\r\n      if (!start) return;\r\n      if (start[1]) { // closing tag\r\n        stack.push(start[2]);\r\n      } else { // opening tag\r\n        for (var i = stack.length - 1; i >= 0; --i) if (stack[i] == start[2]) {\r\n          stack.length = i;\r\n          break;\r\n        }\r\n        if (i < 0 && (!tag || tag == start[2])) return {\r\n          tag: start[2],\r\n          from: Pos(iter.line, iter.ch),\r\n          to: Pos(endLine, endCh)\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  CodeMirror.registerHelper("fold", "xml", function(cm, start) {\r\n    var iter = new Iter(cm, start.line, 0);\r\n    for (;;) {\r\n      var openTag = toNextTag(iter), end;\r\n      if (!openTag || iter.line != start.line || !(end = toTagEnd(iter))) return;\r\n      if (!openTag[1] && end != "selfClose") {\r\n        var start = Pos(iter.line, iter.ch);\r\n        var close = findMatchingClose(iter, openTag[2]);\r\n        return close && {from: start, to: close.from};\r\n      }\r\n    }\r\n  });\r\n  CodeMirror.findMatchingTag = function(cm, pos, range) {\r\n    var iter = new Iter(cm, pos.line, pos.ch, range);\r\n    if (iter.text.indexOf(">") == -1 && iter.text.indexOf("<") == -1) return;\r\n    var end = toTagEnd(iter), to = end && Pos(iter.line, iter.ch);\r\n    var start = end && toTagStart(iter);\r\n    if (!end || !start || cmp(iter, pos) > 0) return;\r\n    var here = {from: Pos(iter.line, iter.ch), to: to, tag: start[2]};\r\n    if (end == "selfClose") return {open: here, close: null, at: "open"};\r\n\r\n    if (start[1]) { // closing tag\r\n      return {open: findMatchingOpen(iter, start[2]), close: here, at: "close"};\r\n    } else { // opening tag\r\n      iter = new Iter(cm, to.line, to.ch, range);\r\n      return {open: here, close: findMatchingClose(iter, start[2]), at: "open"};\r\n    }\r\n  };\r\n\r\n  CodeMirror.findEnclosingTag = function(cm, pos, range) {\r\n    var iter = new Iter(cm, pos.line, pos.ch, range);\r\n    for (;;) {\r\n      var open = findMatchingOpen(iter);\r\n      if (!open) break;\r\n      var forward = new Iter(cm, pos.line, pos.ch, range);\r\n      var close = findMatchingClose(forward, open.tag);\r\n      if (close) return {open: open, close: close};\r\n    }\r\n  };\r\n\r\n  // Used by addon/edit/closetag.js\r\n  CodeMirror.scanForClosingTag = function(cm, pos, name, end) {\r\n    var iter = new Iter(cm, pos.line, pos.ch, end ? {from: 0, to: end} : null);\r\n    return findMatchingClose(iter, name);\r\n  };\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/fold/xml-fold.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"), require("../fold/xml-fold"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/edit/matchtags\',["../../lib/codemirror", "../fold/xml-fold"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  "use strict";\r\n\r\n  CodeMirror.defineOption("matchTags", false, function(cm, val, old) {\r\n    if (old && old != CodeMirror.Init) {\r\n      cm.off("cursorActivity", doMatchTags);\r\n      cm.off("viewportChange", maybeUpdateMatch);\r\n      clear(cm);\r\n    }\r\n    if (val) {\r\n      cm.state.matchBothTags = typeof val == "object" && val.bothTags;\r\n      cm.on("cursorActivity", doMatchTags);\r\n      cm.on("viewportChange", maybeUpdateMatch);\r\n      doMatchTags(cm);\r\n    }\r\n  });\r\n\r\n  function clear(cm) {\r\n    if (cm.state.tagHit) cm.state.tagHit.clear();\r\n    if (cm.state.tagOther) cm.state.tagOther.clear();\r\n    cm.state.tagHit = cm.state.tagOther = null;\r\n  }\r\n\r\n  function doMatchTags(cm) {\r\n    cm.state.failedTagMatch = false;\r\n    cm.operation(function() {\r\n      clear(cm);\r\n      if (cm.somethingSelected()) return;\r\n      var cur = cm.getCursor(), range = cm.getViewport();\r\n      range.from = Math.min(range.from, cur.line); range.to = Math.max(cur.line + 1, range.to);\r\n      var match = CodeMirror.findMatchingTag(cm, cur, range);\r\n      if (!match) return;\r\n      if (cm.state.matchBothTags) {\r\n        var hit = match.at == "open" ? match.open : match.close;\r\n        if (hit) cm.state.tagHit = cm.markText(hit.from, hit.to, {className: "CodeMirror-matchingtag"});\r\n      }\r\n      var other = match.at == "close" ? match.open : match.close;\r\n      if (other)\r\n        cm.state.tagOther = cm.markText(other.from, other.to, {className: "CodeMirror-matchingtag"});\r\n      else\r\n        cm.state.failedTagMatch = true;\r\n    });\r\n  }\r\n\r\n  function maybeUpdateMatch(cm) {\r\n    if (cm.state.failedTagMatch) doMatchTags(cm);\r\n  }\r\n\r\n  CodeMirror.commands.toMatchingTag = function(cm) {\r\n    var found = CodeMirror.findMatchingTag(cm, cm.getCursor());\r\n    if (found) {\r\n      var other = found.at == "close" ? found.open : found.close;\r\n      if (other) cm.extendSelection(other.to, other.from);\r\n    }\r\n  };\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/edit/matchtags.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/edit/matchbrackets\',["../../lib/codemirror"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  var ie_lt8 = /MSIE \\d/.test(navigator.userAgent) &&\r\n    (document.documentMode == null || document.documentMode < 8);\r\n\r\n  var Pos = CodeMirror.Pos;\r\n\r\n  var matching = {"(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<"};\r\n\r\n  function findMatchingBracket(cm, where, strict, config) {\r\n    var line = cm.getLineHandle(where.line), pos = where.ch - 1;\r\n    var match = (pos >= 0 && matching[line.text.charAt(pos)]) || matching[line.text.charAt(++pos)];\r\n    if (!match) return null;\r\n    var dir = match.charAt(1) == ">" ? 1 : -1;\r\n    if (strict && (dir > 0) != (pos == where.ch)) return null;\r\n    var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));\r\n\r\n    var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style || null, config);\r\n    if (found == null) return null;\r\n    return {from: Pos(where.line, pos), to: found && found.pos,\r\n            match: found && found.ch == match.charAt(0), forward: dir > 0};\r\n  }\r\n\r\n  // bracketRegex is used to specify which type of bracket to scan\r\n  // should be a regexp, e.g. /[[\\]]/\r\n  //\r\n  // Note: If "where" is on an open bracket, then this bracket is ignored.\r\n  //\r\n  // Returns false when no bracket was found, null when it reached\r\n  // maxScanLines and gave up\r\n  function scanForBracket(cm, where, dir, style, config) {\r\n    var maxScanLen = (config && config.maxScanLineLength) || 10000;\r\n    var maxScanLines = (config && config.maxScanLines) || 1000;\r\n\r\n    var stack = [];\r\n    var re = config && config.bracketRegex ? config.bracketRegex : /[(){}[\\]]/;\r\n    var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1)\r\n                          : Math.max(cm.firstLine() - 1, where.line - maxScanLines);\r\n    for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {\r\n      var line = cm.getLine(lineNo);\r\n      if (!line) continue;\r\n      var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;\r\n      if (line.length > maxScanLen) continue;\r\n      if (lineNo == where.line) pos = where.ch - (dir < 0 ? 1 : 0);\r\n      for (; pos != end; pos += dir) {\r\n        var ch = line.charAt(pos);\r\n        if (re.test(ch) && (style === undefined || cm.getTokenTypeAt(Pos(lineNo, pos + 1)) == style)) {\r\n          var match = matching[ch];\r\n          if ((match.charAt(1) == ">") == (dir > 0)) stack.push(ch);\r\n          else if (!stack.length) return {pos: Pos(lineNo, pos), ch: ch};\r\n          else stack.pop();\r\n        }\r\n      }\r\n    }\r\n    return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;\r\n  }\r\n\r\n  function matchBrackets(cm, autoclear, config) {\r\n    // Disable brace matching in long lines, since it\'ll cause hugely slow updates\r\n    var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1000;\r\n    var marks = [], ranges = cm.listSelections();\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, false, config);\r\n      if (match && cm.getLine(match.from.line).length <= maxHighlightLen) {\r\n        var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";\r\n        marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), {className: style}));\r\n        if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)\r\n          marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), {className: style}));\r\n      }\r\n    }\r\n\r\n    if (marks.length) {\r\n      // Kludge to work around the IE bug from issue #1193, where text\r\n      // input stops going to the textare whever this fires.\r\n      if (ie_lt8 && cm.state.focused) cm.display.input.focus();\r\n\r\n      var clear = function() {\r\n        cm.operation(function() {\r\n          for (var i = 0; i < marks.length; i++) marks[i].clear();\r\n        });\r\n      };\r\n      if (autoclear) setTimeout(clear, 800);\r\n      else return clear;\r\n    }\r\n  }\r\n\r\n  var currentlyHighlighted = null;\r\n  function doMatchBrackets(cm) {\r\n    cm.operation(function() {\r\n      if (currentlyHighlighted) {currentlyHighlighted(); currentlyHighlighted = null;}\r\n      currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);\r\n    });\r\n  }\r\n\r\n  CodeMirror.defineOption("matchBrackets", false, function(cm, val, old) {\r\n    if (old && old != CodeMirror.Init)\r\n      cm.off("cursorActivity", doMatchBrackets);\r\n    if (val) {\r\n      cm.state.matchBrackets = typeof val == "object" ? val : {};\r\n      cm.on("cursorActivity", doMatchBrackets);\r\n    }\r\n  });\r\n\r\n  CodeMirror.defineExtension("matchBrackets", function() {matchBrackets(this, true);});\r\n  CodeMirror.defineExtension("findMatchingBracket", function(pos, strict, config){\r\n    return findMatchingBracket(this, pos, strict, config);\r\n  });\r\n  CodeMirror.defineExtension("scanForBracket", function(pos, dir, style, config){\r\n    return scanForBracket(this, pos, dir, style, config);\r\n  });\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/edit/matchbrackets.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/edit/closebrackets\',["../../lib/codemirror"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  var DEFAULT_BRACKETS = "()[]{}\'\'\\"\\"";\r\n  var DEFAULT_EXPLODE_ON_ENTER = "[]{}";\r\n  var SPACE_CHAR_REGEX = /\\s/;\r\n\r\n  var Pos = CodeMirror.Pos;\r\n\r\n  CodeMirror.defineOption("autoCloseBrackets", false, function(cm, val, old) {\r\n    if (old != CodeMirror.Init && old)\r\n      cm.removeKeyMap("autoCloseBrackets");\r\n    if (!val) return;\r\n    var pairs = DEFAULT_BRACKETS, explode = DEFAULT_EXPLODE_ON_ENTER;\r\n    if (typeof val == "string") pairs = val;\r\n    else if (typeof val == "object") {\r\n      if (val.pairs != null) pairs = val.pairs;\r\n      if (val.explode != null) explode = val.explode;\r\n    }\r\n    var map = buildKeymap(pairs);\r\n    if (explode) map.Enter = buildExplodeHandler(explode);\r\n    cm.addKeyMap(map);\r\n  });\r\n\r\n  function charsAround(cm, pos) {\r\n    var str = cm.getRange(Pos(pos.line, pos.ch - 1),\r\n                          Pos(pos.line, pos.ch + 1));\r\n    return str.length == 2 ? str : null;\r\n  }\r\n\r\n  // Project the token type that will exists after the given char is\r\n  // typed, and use it to determine whether it would cause the start\r\n  // of a string token.\r\n  function enteringString(cm, pos, ch) {\r\n    var line = cm.getLine(pos.line);\r\n    var token = cm.getTokenAt(pos);\r\n    if (/\\bstring2?\\b/.test(token.type)) return false;\r\n    var stream = new CodeMirror.StringStream(line.slice(0, pos.ch) + ch + line.slice(pos.ch), 4);\r\n    stream.pos = stream.start = token.start;\r\n    for (;;) {\r\n      var type1 = cm.getMode().token(stream, token.state);\r\n      if (stream.pos >= pos.ch + 1) return /\\bstring2?\\b/.test(type1);\r\n      stream.start = stream.pos;\r\n    }\r\n  }\r\n\r\n  function buildKeymap(pairs) {\r\n    var map = {\r\n      name : "autoCloseBrackets",\r\n      Backspace: function(cm) {\r\n        if (cm.getOption("disableInput")) return CodeMirror.Pass;\r\n        var ranges = cm.listSelections();\r\n        for (var i = 0; i < ranges.length; i++) {\r\n          if (!ranges[i].empty()) return CodeMirror.Pass;\r\n          var around = charsAround(cm, ranges[i].head);\r\n          if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;\r\n        }\r\n        for (var i = ranges.length - 1; i >= 0; i--) {\r\n          var cur = ranges[i].head;\r\n          cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1));\r\n        }\r\n      }\r\n    };\r\n    var closingBrackets = "";\r\n    for (var i = 0; i < pairs.length; i += 2) (function(left, right) {\r\n      if (left != right) closingBrackets += right;\r\n      map["\'" + left + "\'"] = function(cm) {\r\n        if (cm.getOption("disableInput")) return CodeMirror.Pass;\r\n        var ranges = cm.listSelections(), type, next;\r\n        for (var i = 0; i < ranges.length; i++) {\r\n          var range = ranges[i], cur = range.head, curType;\r\n          var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));\r\n          if (!range.empty())\r\n            curType = "surround";\r\n          else if (left == right && next == right) {\r\n            if (cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == left + left + left)\r\n              curType = "skipThree";\r\n            else\r\n              curType = "skip";\r\n          } else if (left == right && cur.ch > 1 &&\r\n                     cm.getRange(Pos(cur.line, cur.ch - 2), cur) == left + left &&\r\n                     (cur.ch <= 2 || cm.getRange(Pos(cur.line, cur.ch - 3), Pos(cur.line, cur.ch - 2)) != left))\r\n            curType = "addFour";\r\n          else if (left == \'"\' || left == "\'") {\r\n            if (!CodeMirror.isWordChar(next) && enteringString(cm, cur, left)) curType = "both";\r\n            else return CodeMirror.Pass;\r\n          } else if (cm.getLine(cur.line).length == cur.ch || closingBrackets.indexOf(next) >= 0 || SPACE_CHAR_REGEX.test(next))\r\n            curType = "both";\r\n          else\r\n            return CodeMirror.Pass;\r\n          if (!type) type = curType;\r\n          else if (type != curType) return CodeMirror.Pass;\r\n        }\r\n\r\n        cm.operation(function() {\r\n          if (type == "skip") {\r\n            cm.execCommand("goCharRight");\r\n          } else if (type == "skipThree") {\r\n            for (var i = 0; i < 3; i++)\r\n              cm.execCommand("goCharRight");\r\n          } else if (type == "surround") {\r\n            var sels = cm.getSelections();\r\n            for (var i = 0; i < sels.length; i++)\r\n              sels[i] = left + sels[i] + right;\r\n            cm.replaceSelections(sels, "around");\r\n          } else if (type == "both") {\r\n            cm.replaceSelection(left + right, null);\r\n            cm.execCommand("goCharLeft");\r\n          } else if (type == "addFour") {\r\n            cm.replaceSelection(left + left + left + left, "before");\r\n            cm.execCommand("goCharRight");\r\n          }\r\n        });\r\n      };\r\n      if (left != right) map["\'" + right + "\'"] = function(cm) {\r\n        var ranges = cm.listSelections();\r\n        for (var i = 0; i < ranges.length; i++) {\r\n          var range = ranges[i];\r\n          if (!range.empty() ||\r\n              cm.getRange(range.head, Pos(range.head.line, range.head.ch + 1)) != right)\r\n            return CodeMirror.Pass;\r\n        }\r\n        cm.execCommand("goCharRight");\r\n      };\r\n    })(pairs.charAt(i), pairs.charAt(i + 1));\r\n    return map;\r\n  }\r\n\r\n  function buildExplodeHandler(pairs) {\r\n    return function(cm) {\r\n      if (cm.getOption("disableInput")) return CodeMirror.Pass;\r\n      var ranges = cm.listSelections();\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        if (!ranges[i].empty()) return CodeMirror.Pass;\r\n        var around = charsAround(cm, ranges[i].head);\r\n        if (!around || pairs.indexOf(around) % 2 != 0) return CodeMirror.Pass;\r\n      }\r\n      cm.operation(function() {\r\n        cm.replaceSelection("\\n\\n", null);\r\n        cm.execCommand("goCharLeft");\r\n        ranges = cm.listSelections();\r\n        for (var i = 0; i < ranges.length; i++) {\r\n          var line = ranges[i].head.line;\r\n          cm.indentLine(line, null, true);\r\n          cm.indentLine(line + 1, null, true);\r\n        }\r\n      });\r\n    };\r\n  }\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/edit/closebrackets.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n/**\r\n * Tag-closer extension for CodeMirror.\r\n *\r\n * This extension adds an "autoCloseTags" option that can be set to\r\n * either true to get the default behavior, or an object to further\r\n * configure its behavior.\r\n *\r\n * These are supported options:\r\n *\r\n * `whenClosing` (default true)\r\n *   Whether to autoclose when the \'/\' of a closing tag is typed.\r\n * `whenOpening` (default true)\r\n *   Whether to autoclose the tag when the final \'>\' of an opening\r\n *   tag is typed.\r\n * `dontCloseTags` (default is empty tags for HTML, none for XML)\r\n *   An array of tag names that should not be autoclosed.\r\n * `indentTags` (default is block tags for HTML, none for XML)\r\n *   An array of tag names that should, when opened, cause a\r\n *   blank line to be added inside the tag, and the blank line and\r\n *   closing line to be indented.\r\n *\r\n * See demos/closetag.html for a usage example.\r\n */\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"), require("../fold/xml-fold"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/edit/closetag\',["../../lib/codemirror", "../fold/xml-fold"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  CodeMirror.defineOption("autoCloseTags", false, function(cm, val, old) {\r\n    if (old != CodeMirror.Init && old)\r\n      cm.removeKeyMap("autoCloseTags");\r\n    if (!val) return;\r\n    var map = {name: "autoCloseTags"};\r\n    if (typeof val != "object" || val.whenClosing)\r\n      map["\'/\'"] = function(cm) { return autoCloseSlash(cm); };\r\n    if (typeof val != "object" || val.whenOpening)\r\n      map["\'>\'"] = function(cm) { return autoCloseGT(cm); };\r\n    cm.addKeyMap(map);\r\n  });\r\n\r\n  var htmlDontClose = ["area", "base", "br", "col", "command", "embed", "hr", "img", "input", "keygen", "link", "meta", "param",\r\n                       "source", "track", "wbr"];\r\n  var htmlIndent = ["applet", "blockquote", "body", "button", "div", "dl", "fieldset", "form", "frameset", "h1", "h2", "h3", "h4",\r\n                    "h5", "h6", "head", "html", "iframe", "layer", "legend", "object", "ol", "p", "select", "table", "ul"];\r\n\r\n  function autoCloseGT(cm) {\r\n    if (cm.getOption("disableInput")) return CodeMirror.Pass;\r\n    var ranges = cm.listSelections(), replacements = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      if (!ranges[i].empty()) return CodeMirror.Pass;\r\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\r\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\r\n      if (inner.mode.name != "xml" || !state.tagName) return CodeMirror.Pass;\r\n\r\n      var opt = cm.getOption("autoCloseTags"), html = inner.mode.configuration == "html";\r\n      var dontCloseTags = (typeof opt == "object" && opt.dontCloseTags) || (html && htmlDontClose);\r\n      var indentTags = (typeof opt == "object" && opt.indentTags) || (html && htmlIndent);\r\n\r\n      var tagName = state.tagName;\r\n      if (tok.end > pos.ch) tagName = tagName.slice(0, tagName.length - tok.end + pos.ch);\r\n      var lowerTagName = tagName.toLowerCase();\r\n      // Don\'t process the \'>\' at the end of an end-tag or self-closing tag\r\n      if (!tagName ||\r\n          tok.type == "string" && (tok.end != pos.ch || !/[\\"\\\']/.test(tok.string.charAt(tok.string.length - 1)) || tok.string.length == 1) ||\r\n          tok.type == "tag" && state.type == "closeTag" ||\r\n          tok.string.indexOf("/") == (tok.string.length - 1) || // match something like <someTagName />\r\n          dontCloseTags && indexOf(dontCloseTags, lowerTagName) > -1 ||\r\n          closingTagExists(cm, tagName, pos, state, true))\r\n        return CodeMirror.Pass;\r\n\r\n      var indent = indentTags && indexOf(indentTags, lowerTagName) > -1;\r\n      replacements[i] = {indent: indent,\r\n                         text: ">" + (indent ? "\\n\\n" : "") + "</" + tagName + ">",\r\n                         newPos: indent ? CodeMirror.Pos(pos.line + 1, 0) : CodeMirror.Pos(pos.line, pos.ch + 1)};\r\n    }\r\n\r\n    for (var i = ranges.length - 1; i >= 0; i--) {\r\n      var info = replacements[i];\r\n      cm.replaceRange(info.text, ranges[i].head, ranges[i].anchor, "+insert");\r\n      var sel = cm.listSelections().slice(0);\r\n      sel[i] = {head: info.newPos, anchor: info.newPos};\r\n      cm.setSelections(sel);\r\n      if (info.indent) {\r\n        cm.indentLine(info.newPos.line, null, true);\r\n        cm.indentLine(info.newPos.line + 1, null, true);\r\n      }\r\n    }\r\n  }\r\n\r\n  function autoCloseSlash(cm) {\r\n    if (cm.getOption("disableInput")) return CodeMirror.Pass;\r\n    var ranges = cm.listSelections(), replacements = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      if (!ranges[i].empty()) return CodeMirror.Pass;\r\n      var pos = ranges[i].head, tok = cm.getTokenAt(pos);\r\n      var inner = CodeMirror.innerMode(cm.getMode(), tok.state), state = inner.state;\r\n      if (tok.type == "string" || tok.string.charAt(0) != "<" ||\r\n          tok.start != pos.ch - 1 || inner.mode.name != "xml" ||\r\n          !state.context || !state.context.tagName ||\r\n          closingTagExists(cm, state.context.tagName, pos, state))\r\n        return CodeMirror.Pass;\r\n      replacements[i] = "/" + state.context.tagName + ">";\r\n    }\r\n    cm.replaceSelections(replacements);\r\n    ranges = cm.listSelections();\r\n    for (var i = 0; i < ranges.length; i++)\r\n      if (i == ranges.length - 1 || ranges[i].head.line < ranges[i + 1].head.line)\r\n        cm.indentLine(ranges[i].head.line);\r\n  }\r\n\r\n  function indexOf(collection, elt) {\r\n    if (collection.indexOf) return collection.indexOf(elt);\r\n    for (var i = 0, e = collection.length; i < e; ++i)\r\n      if (collection[i] == elt) return i;\r\n    return -1;\r\n  }\r\n\r\n  // If xml-fold is loaded, we use its functionality to try and verify\r\n  // whether a given tag is actually unclosed.\r\n  function closingTagExists(cm, tagName, pos, state, newTag) {\r\n    if (!CodeMirror.scanForClosingTag) return false;\r\n    var end = Math.min(cm.lastLine() + 1, pos.line + 500);\r\n    var nextClose = CodeMirror.scanForClosingTag(cm, pos, null, end);\r\n    if (!nextClose || nextClose.tag != tagName) return false;\r\n    var cx = state.context;\r\n    // If the immediate wrapping context contains onCx instances of\r\n    // the same tag, a closing tag only exists if there are at least\r\n    // that many closing tags of that type following.\r\n    for (var onCx = newTag ? 1 : 0; cx && cx.tagName == tagName; cx = cx.prev) ++onCx;\r\n    pos = nextClose.to;\r\n    for (var i = 1; i < onCx; i++) {\r\n      var next = CodeMirror.scanForClosingTag(cm, pos, null, end);\r\n      if (!next || next.tag != tagName) return false;\r\n      pos = next.to;\r\n    }\r\n    return true;\r\n  }\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/edit/closetag.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/scroll/scrollpastend\',["../../lib/codemirror"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  "use strict";\r\n\r\n  CodeMirror.defineOption("scrollPastEnd", false, function(cm, val, old) {\r\n    if (old && old != CodeMirror.Init) {\r\n      cm.off("change", onChange);\r\n      cm.off("refresh", updateBottomMargin);\r\n      cm.display.lineSpace.parentNode.style.paddingBottom = "";\r\n      cm.state.scrollPastEndPadding = null;\r\n    }\r\n    if (val) {\r\n      cm.on("change", onChange);\r\n      cm.on("refresh", updateBottomMargin);\r\n      updateBottomMargin(cm);\r\n    }\r\n  });\r\n\r\n  function onChange(cm, change) {\r\n    if (CodeMirror.changeEnd(change).line == cm.lastLine())\r\n      updateBottomMargin(cm);\r\n  }\r\n\r\n  function updateBottomMargin(cm) {\r\n    var padding = "";\r\n    if (cm.lineCount() > 1) {\r\n      var totalH = cm.display.scroller.clientHeight - 30,\r\n          lastLineH = cm.getLineHandle(cm.lastLine()).height;\r\n      padding = (totalH - lastLineH) + "px";\r\n    }\r\n    if (cm.state.scrollPastEndPadding != padding) {\r\n      cm.state.scrollPastEndPadding = padding;\r\n      cm.display.lineSpace.parentNode.style.paddingBottom = padding;\r\n      cm.setSize();\r\n    }\r\n  }\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/scroll/scrollpastend.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// Because sometimes you need to style the cursor\'s line.\r\n//\r\n// Adds an option \'styleActiveLine\' which, when enabled, gives the\r\n// active line\'s wrapping <div> the CSS class "CodeMirror-activeline",\r\n// and gives its background <div> the class "CodeMirror-activeline-background".\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/selection/active-line\',["../../lib/codemirror"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  "use strict";\r\n  var WRAP_CLASS = "CodeMirror-activeline";\r\n  var BACK_CLASS = "CodeMirror-activeline-background";\r\n\r\n  CodeMirror.defineOption("styleActiveLine", false, function(cm, val, old) {\r\n    var prev = old && old != CodeMirror.Init;\r\n    if (val && !prev) {\r\n      cm.state.activeLines = [];\r\n      updateActiveLines(cm, cm.listSelections());\r\n      cm.on("beforeSelectionChange", selectionChange);\r\n    } else if (!val && prev) {\r\n      cm.off("beforeSelectionChange", selectionChange);\r\n      clearActiveLines(cm);\r\n      delete cm.state.activeLines;\r\n    }\r\n  });\r\n\r\n  function clearActiveLines(cm) {\r\n    for (var i = 0; i < cm.state.activeLines.length; i++) {\r\n      cm.removeLineClass(cm.state.activeLines[i], "wrap", WRAP_CLASS);\r\n      cm.removeLineClass(cm.state.activeLines[i], "background", BACK_CLASS);\r\n    }\r\n  }\r\n\r\n  function sameArray(a, b) {\r\n    if (a.length != b.length) return false;\r\n    for (var i = 0; i < a.length; i++)\r\n      if (a[i] != b[i]) return false;\r\n    return true;\r\n  }\r\n\r\n  function updateActiveLines(cm, ranges) {\r\n    var active = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var range = ranges[i];\r\n      if (!range.empty()) continue;\r\n      var line = cm.getLineHandleVisualStart(range.head.line);\r\n      if (active[active.length - 1] != line) active.push(line);\r\n    }\r\n    if (sameArray(cm.state.activeLines, active)) return;\r\n    cm.operation(function() {\r\n      clearActiveLines(cm);\r\n      for (var i = 0; i < active.length; i++) {\r\n        cm.addLineClass(active[i], "wrap", WRAP_CLASS);\r\n        cm.addLineClass(active[i], "background", BACK_CLASS);\r\n      }\r\n      cm.state.activeLines = active;\r\n    });\r\n  }\r\n\r\n  function selectionChange(cm, sel) {\r\n    updateActiveLines(cm, sel.ranges);\r\n  }\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/selection/active-line.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// Because sometimes you need to mark the selected *text*.\r\n//\r\n// Adds an option \'styleSelectedText\' which, when enabled, gives\r\n// selected text the CSS class given as option value, or\r\n// "CodeMirror-selectedtext" when the value is not a string.\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/selection/mark-selection\',["../../lib/codemirror"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  "use strict";\r\n\r\n  CodeMirror.defineOption("styleSelectedText", false, function(cm, val, old) {\r\n    var prev = old && old != CodeMirror.Init;\r\n    if (val && !prev) {\r\n      cm.state.markedSelection = [];\r\n      cm.state.markedSelectionStyle = typeof val == "string" ? val : "CodeMirror-selectedtext";\r\n      reset(cm);\r\n      cm.on("cursorActivity", onCursorActivity);\r\n      cm.on("change", onChange);\r\n    } else if (!val && prev) {\r\n      cm.off("cursorActivity", onCursorActivity);\r\n      cm.off("change", onChange);\r\n      clear(cm);\r\n      cm.state.markedSelection = cm.state.markedSelectionStyle = null;\r\n    }\r\n  });\r\n\r\n  function onCursorActivity(cm) {\r\n    cm.operation(function() { update(cm); });\r\n  }\r\n\r\n  function onChange(cm) {\r\n    if (cm.state.markedSelection.length)\r\n      cm.operation(function() { clear(cm); });\r\n  }\r\n\r\n  var CHUNK_SIZE = 8;\r\n  var Pos = CodeMirror.Pos;\r\n  var cmp = CodeMirror.cmpPos;\r\n\r\n  function coverRange(cm, from, to, addAt) {\r\n    if (cmp(from, to) == 0) return;\r\n    var array = cm.state.markedSelection;\r\n    var cls = cm.state.markedSelectionStyle;\r\n    for (var line = from.line;;) {\r\n      var start = line == from.line ? from : Pos(line, 0);\r\n      var endLine = line + CHUNK_SIZE, atEnd = endLine >= to.line;\r\n      var end = atEnd ? to : Pos(endLine, 0);\r\n      var mark = cm.markText(start, end, {className: cls});\r\n      if (addAt == null) array.push(mark);\r\n      else array.splice(addAt++, 0, mark);\r\n      if (atEnd) break;\r\n      line = endLine;\r\n    }\r\n  }\r\n\r\n  function clear(cm) {\r\n    var array = cm.state.markedSelection;\r\n    for (var i = 0; i < array.length; ++i) array[i].clear();\r\n    array.length = 0;\r\n  }\r\n\r\n  function reset(cm) {\r\n    clear(cm);\r\n    var ranges = cm.listSelections();\r\n    for (var i = 0; i < ranges.length; i++)\r\n      coverRange(cm, ranges[i].from(), ranges[i].to());\r\n  }\r\n\r\n  function update(cm) {\r\n    if (!cm.somethingSelected()) return clear(cm);\r\n    if (cm.listSelections().length > 1) return reset(cm);\r\n\r\n    var from = cm.getCursor("start"), to = cm.getCursor("end");\r\n\r\n    var array = cm.state.markedSelection;\r\n    if (!array.length) return coverRange(cm, from, to);\r\n\r\n    var coverStart = array[0].find(), coverEnd = array[array.length - 1].find();\r\n    if (!coverStart || !coverEnd || to.line - from.line < CHUNK_SIZE ||\r\n        cmp(from, coverEnd.to) >= 0 || cmp(to, coverStart.from) <= 0)\r\n      return reset(cm);\r\n\r\n    while (cmp(from, coverStart.from) > 0) {\r\n      array.shift().clear();\r\n      coverStart = array[0].find();\r\n    }\r\n    if (cmp(from, coverStart.from) < 0) {\r\n      if (coverStart.to.line - from.line < CHUNK_SIZE) {\r\n        array.shift().clear();\r\n        coverRange(cm, from, coverStart.to, 0);\r\n      } else {\r\n        coverRange(cm, from, coverStart.from, 0);\r\n      }\r\n    }\r\n\r\n    while (cmp(to, coverEnd.to) < 0) {\r\n      array.pop().clear();\r\n      coverEnd = array[array.length - 1].find();\r\n    }\r\n    if (cmp(to, coverEnd.to) > 0) {\r\n      if (to.line - coverEnd.from.line < CHUNK_SIZE) {\r\n        array.pop().clear();\r\n        coverRange(cm, coverEnd.from, to);\r\n      } else {\r\n        coverRange(cm, coverEnd.to, to);\r\n      }\r\n    }\r\n  }\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/selection/mark-selection.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/mode/multiplex\',["../../lib/codemirror"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n"use strict";\r\n\r\nCodeMirror.multiplexingMode = function(outer /*, others */) {\r\n  // Others should be {open, close, mode [, delimStyle] [, innerStyle]} objects\r\n  var others = Array.prototype.slice.call(arguments, 1);\r\n  var n_others = others.length;\r\n\r\n  function indexOf(string, pattern, from) {\r\n    if (typeof pattern == "string") return string.indexOf(pattern, from);\r\n    var m = pattern.exec(from ? string.slice(from) : string);\r\n    return m ? m.index + from : -1;\r\n  }\r\n\r\n  return {\r\n    startState: function() {\r\n      return {\r\n        outer: CodeMirror.startState(outer),\r\n        innerActive: null,\r\n        inner: null\r\n      };\r\n    },\r\n\r\n    copyState: function(state) {\r\n      return {\r\n        outer: CodeMirror.copyState(outer, state.outer),\r\n        innerActive: state.innerActive,\r\n        inner: state.innerActive && CodeMirror.copyState(state.innerActive.mode, state.inner)\r\n      };\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      if (!state.innerActive) {\r\n        var cutOff = Infinity, oldContent = stream.string;\r\n        for (var i = 0; i < n_others; ++i) {\r\n          var other = others[i];\r\n          var found = indexOf(oldContent, other.open, stream.pos);\r\n          if (found == stream.pos) {\r\n            stream.match(other.open);\r\n            state.innerActive = other;\r\n            state.inner = CodeMirror.startState(other.mode, outer.indent ? outer.indent(state.outer, "") : 0);\r\n            return other.delimStyle;\r\n          } else if (found != -1 && found < cutOff) {\r\n            cutOff = found;\r\n          }\r\n        }\r\n        if (cutOff != Infinity) stream.string = oldContent.slice(0, cutOff);\r\n        var outerToken = outer.token(stream, state.outer);\r\n        if (cutOff != Infinity) stream.string = oldContent;\r\n        return outerToken;\r\n      } else {\r\n        var curInner = state.innerActive, oldContent = stream.string;\r\n        if (!curInner.close && stream.sol()) {\r\n          state.innerActive = state.inner = null;\r\n          return this.token(stream, state);\r\n        }\r\n        var found = curInner.close ? indexOf(oldContent, curInner.close, stream.pos) : -1;\r\n        if (found == stream.pos) {\r\n          stream.match(curInner.close);\r\n          state.innerActive = state.inner = null;\r\n          return curInner.delimStyle;\r\n        }\r\n        if (found > -1) stream.string = oldContent.slice(0, found);\r\n        var innerToken = curInner.mode.token(stream, state.inner);\r\n        if (found > -1) stream.string = oldContent;\r\n\r\n        if (curInner.innerStyle) {\r\n          if (innerToken) innerToken = innerToken + \' \' + curInner.innerStyle;\r\n          else innerToken = curInner.innerStyle;\r\n        }\r\n\r\n        return innerToken;\r\n      }\r\n    },\r\n\r\n    indent: function(state, textAfter) {\r\n      var mode = state.innerActive ? state.innerActive.mode : outer;\r\n      if (!mode.indent) return CodeMirror.Pass;\r\n      return mode.indent(state.innerActive ? state.inner : state.outer, textAfter);\r\n    },\r\n\r\n    blankLine: function(state) {\r\n      var mode = state.innerActive ? state.innerActive.mode : outer;\r\n      if (mode.blankLine) {\r\n        mode.blankLine(state.innerActive ? state.inner : state.outer);\r\n      }\r\n      if (!state.innerActive) {\r\n        for (var i = 0; i < n_others; ++i) {\r\n          var other = others[i];\r\n          if (other.open === "\\n") {\r\n            state.innerActive = other;\r\n            state.inner = CodeMirror.startState(other.mode, mode.indent ? mode.indent(state.outer, "") : 0);\r\n          }\r\n        }\r\n      } else if (state.innerActive.close === "\\n") {\r\n        state.innerActive = state.inner = null;\r\n      }\r\n    },\r\n\r\n    electricChars: outer.electricChars,\r\n\r\n    innerMode: function(state) {\r\n      return state.inner ? {state: state.inner, mode: state.innerActive.mode} : {state: state.outer, mode: outer};\r\n    }\r\n  };\r\n};\r\n\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/mode/multiplex.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// Utility function that allows modes to be combined. The mode given\r\n// as the base argument takes care of most of the normal mode\r\n// functionality, but a second (typically simple) mode is used, which\r\n// can override the style of text. Both modes get to parse all of the\r\n// text, but when both assign a non-null style to a piece of code, the\r\n// overlay wins, unless the combine argument was true and not overridden,\r\n// or state.overlay.combineTokens was true, in which case the styles are\r\n// combined.\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/mode/overlay\',["../../lib/codemirror"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n"use strict";\r\n\r\nCodeMirror.overlayMode = function(base, overlay, combine) {\r\n  return {\r\n    startState: function() {\r\n      return {\r\n        base: CodeMirror.startState(base),\r\n        overlay: CodeMirror.startState(overlay),\r\n        basePos: 0, baseCur: null,\r\n        overlayPos: 0, overlayCur: null,\r\n        lineSeen: null\r\n      };\r\n    },\r\n    copyState: function(state) {\r\n      return {\r\n        base: CodeMirror.copyState(base, state.base),\r\n        overlay: CodeMirror.copyState(overlay, state.overlay),\r\n        basePos: state.basePos, baseCur: null,\r\n        overlayPos: state.overlayPos, overlayCur: null\r\n      };\r\n    },\r\n\r\n    token: function(stream, state) {\r\n      if (stream.sol() || stream.string != state.lineSeen ||\r\n          Math.min(state.basePos, state.overlayPos) < stream.start) {\r\n        state.lineSeen = stream.string;\r\n        state.basePos = state.overlayPos = stream.start;\r\n      }\r\n\r\n      if (stream.start == state.basePos) {\r\n        state.baseCur = base.token(stream, state.base);\r\n        state.basePos = stream.pos;\r\n      }\r\n      if (stream.start == state.overlayPos) {\r\n        stream.pos = stream.start;\r\n        state.overlayCur = overlay.token(stream, state.overlay);\r\n        state.overlayPos = stream.pos;\r\n      }\r\n      stream.pos = Math.min(state.basePos, state.overlayPos);\r\n\r\n      // state.overlay.combineTokens always takes precedence over combine,\r\n      // unless set to null\r\n      if (state.overlayCur == null) return state.baseCur;\r\n      else if (state.baseCur != null &&\r\n               state.overlay.combineTokens ||\r\n               combine && state.overlay.combineTokens == null)\r\n        return state.baseCur + " " + state.overlayCur;\r\n      else return state.overlayCur;\r\n    },\r\n\r\n    indent: base.indent && function(state, textAfter) {\r\n      return base.indent(state.base, textAfter);\r\n    },\r\n    electricChars: base.electricChars,\r\n\r\n    innerMode: function(state) { return {state: state.base, mode: base}; },\r\n\r\n    blankLine: function(state) {\r\n      if (base.blankLine) base.blankLine(state.base);\r\n      if (overlay.blankLine) overlay.blankLine(state.overlay);\r\n    }\r\n  };\r\n};\r\n\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/mode/overlay.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// Highlighting text that matches the selection\r\n//\r\n// Defines an option highlightSelectionMatches, which, when enabled,\r\n// will style strings that match the selection throughout the\r\n// document.\r\n//\r\n// The option can be set to true to simply enable it, or to a\r\n// {minChars, style, showToken} object to explicitly configure it.\r\n// minChars is the minimum amount of characters that should be\r\n// selected for the behavior to occur, and style is the token style to\r\n// apply to the matches. This will be prefixed by "cm-" to create an\r\n// actual CSS class name. showToken, when enabled, will cause the\r\n// current token to be highlighted when nothing is selected.\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/search/match-highlighter\',["../../lib/codemirror"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  "use strict";\r\n\r\n  var DEFAULT_MIN_CHARS = 2;\r\n  var DEFAULT_TOKEN_STYLE = "matchhighlight";\r\n  var DEFAULT_DELAY = 100;\r\n\r\n  function State(options) {\r\n    if (typeof options == "object") {\r\n      this.minChars = options.minChars;\r\n      this.style = options.style;\r\n      this.showToken = options.showToken;\r\n      this.delay = options.delay;\r\n    }\r\n    if (this.style == null) this.style = DEFAULT_TOKEN_STYLE;\r\n    if (this.minChars == null) this.minChars = DEFAULT_MIN_CHARS;\r\n    if (this.delay == null) this.delay = DEFAULT_DELAY;\r\n    this.overlay = this.timeout = null;\r\n  }\r\n\r\n  CodeMirror.defineOption("highlightSelectionMatches", false, function(cm, val, old) {\r\n    if (old && old != CodeMirror.Init) {\r\n      var over = cm.state.matchHighlighter.overlay;\r\n      if (over) cm.removeOverlay(over);\r\n      clearTimeout(cm.state.matchHighlighter.timeout);\r\n      cm.state.matchHighlighter = null;\r\n      cm.off("cursorActivity", cursorActivity);\r\n    }\r\n    if (val) {\r\n      cm.state.matchHighlighter = new State(val);\r\n      highlightMatches(cm);\r\n      cm.on("cursorActivity", cursorActivity);\r\n    }\r\n  });\r\n\r\n  function cursorActivity(cm) {\r\n    var state = cm.state.matchHighlighter;\r\n    clearTimeout(state.timeout);\r\n    state.timeout = setTimeout(function() {highlightMatches(cm);}, state.delay);\r\n  }\r\n\r\n  function highlightMatches(cm) {\r\n    cm.operation(function() {\r\n      var state = cm.state.matchHighlighter;\r\n      if (state.overlay) {\r\n        cm.removeOverlay(state.overlay);\r\n        state.overlay = null;\r\n      }\r\n      if (!cm.somethingSelected() && state.showToken) {\r\n        var re = state.showToken === true ? /[\\w$]/ : state.showToken;\r\n        var cur = cm.getCursor(), line = cm.getLine(cur.line), start = cur.ch, end = start;\r\n        while (start && re.test(line.charAt(start - 1))) --start;\r\n        while (end < line.length && re.test(line.charAt(end))) ++end;\r\n        if (start < end)\r\n          cm.addOverlay(state.overlay = makeOverlay(line.slice(start, end), re, state.style));\r\n        return;\r\n      }\r\n      var from = cm.getCursor("from"), to = cm.getCursor("to");\r\n      if (from.line != to.line) return;\r\n      var selection = cm.getRange(from, to).replace(/^\\s+|\\s+$/g, "");\r\n      if (selection.length >= state.minChars)\r\n        cm.addOverlay(state.overlay = makeOverlay(selection, false, state.style));\r\n    });\r\n  }\r\n\r\n  function boundariesAround(stream, re) {\r\n    return (!stream.start || !re.test(stream.string.charAt(stream.start - 1))) &&\r\n      (stream.pos == stream.string.length || !re.test(stream.string.charAt(stream.pos)));\r\n  }\r\n\r\n  function makeOverlay(query, hasBoundary, style) {\r\n    return {token: function(stream) {\r\n      if (stream.match(query) &&\r\n          (!hasBoundary || boundariesAround(stream, hasBoundary)))\r\n        return style;\r\n      stream.next();\r\n      stream.skipTo(query.charAt(0)) || stream.skipToEnd();\r\n    }};\r\n  }\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/search/match-highlighter.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../../lib/codemirror"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/addon/search/searchcursor\',["../../lib/codemirror"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  "use strict";\r\n  var Pos = CodeMirror.Pos;\r\n\r\n  function SearchCursor(doc, query, pos, caseFold) {\r\n    this.atOccurrence = false; this.doc = doc;\r\n    if (caseFold == null && typeof query == "string") caseFold = false;\r\n\r\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0);\r\n    this.pos = {from: pos, to: pos};\r\n\r\n    // The matches method is filled in based on the type of query.\r\n    // It takes a position and a direction, and returns an object\r\n    // describing the next occurrence of the query, or null if no\r\n    // more matches were found.\r\n    if (typeof query != "string") { // Regexp match\r\n      if (!query.global) query = new RegExp(query.source, query.ignoreCase ? "ig" : "g");\r\n      this.matches = function(reverse, pos) {\r\n        if (reverse) {\r\n          query.lastIndex = 0;\r\n          var line = doc.getLine(pos.line).slice(0, pos.ch), cutOff = 0, match, start;\r\n          for (;;) {\r\n            query.lastIndex = cutOff;\r\n            var newMatch = query.exec(line);\r\n            if (!newMatch) break;\r\n            match = newMatch;\r\n            start = match.index;\r\n            cutOff = match.index + (match[0].length || 1);\r\n            if (cutOff == line.length) break;\r\n          }\r\n          var matchLen = (match && match[0].length) || 0;\r\n          if (!matchLen) {\r\n            if (start == 0 && line.length == 0) {match = undefined;}\r\n            else if (start != doc.getLine(pos.line).length) {\r\n              matchLen++;\r\n            }\r\n          }\r\n        } else {\r\n          query.lastIndex = pos.ch;\r\n          var line = doc.getLine(pos.line), match = query.exec(line);\r\n          var matchLen = (match && match[0].length) || 0;\r\n          var start = match && match.index;\r\n          if (start + matchLen != line.length && !matchLen) matchLen = 1;\r\n        }\r\n        if (match && matchLen)\r\n          return {from: Pos(pos.line, start),\r\n                  to: Pos(pos.line, start + matchLen),\r\n                  match: match};\r\n      };\r\n    } else { // String query\r\n      var origQuery = query;\r\n      if (caseFold) query = query.toLowerCase();\r\n      var fold = caseFold ? function(str){return str.toLowerCase();} : function(str){return str;};\r\n      var target = query.split("\\n");\r\n      // Different methods for single-line and multi-line queries\r\n      if (target.length == 1) {\r\n        if (!query.length) {\r\n          // Empty string would match anything and never progress, so\r\n          // we define it to match nothing instead.\r\n          this.matches = function() {};\r\n        } else {\r\n          this.matches = function(reverse, pos) {\r\n            if (reverse) {\r\n              var orig = doc.getLine(pos.line).slice(0, pos.ch), line = fold(orig);\r\n              var match = line.lastIndexOf(query);\r\n              if (match > -1) {\r\n                match = adjustPos(orig, line, match);\r\n                return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\r\n              }\r\n             } else {\r\n               var orig = doc.getLine(pos.line).slice(pos.ch), line = fold(orig);\r\n               var match = line.indexOf(query);\r\n               if (match > -1) {\r\n                 match = adjustPos(orig, line, match) + pos.ch;\r\n                 return {from: Pos(pos.line, match), to: Pos(pos.line, match + origQuery.length)};\r\n               }\r\n            }\r\n          };\r\n        }\r\n      } else {\r\n        var origTarget = origQuery.split("\\n");\r\n        this.matches = function(reverse, pos) {\r\n          var last = target.length - 1;\r\n          if (reverse) {\r\n            if (pos.line - (target.length - 1) < doc.firstLine()) return;\r\n            if (fold(doc.getLine(pos.line).slice(0, origTarget[last].length)) != target[target.length - 1]) return;\r\n            var to = Pos(pos.line, origTarget[last].length);\r\n            for (var ln = pos.line - 1, i = last - 1; i >= 1; --i, --ln)\r\n              if (target[i] != fold(doc.getLine(ln))) return;\r\n            var line = doc.getLine(ln), cut = line.length - origTarget[0].length;\r\n            if (fold(line.slice(cut)) != target[0]) return;\r\n            return {from: Pos(ln, cut), to: to};\r\n          } else {\r\n            if (pos.line + (target.length - 1) > doc.lastLine()) return;\r\n            var line = doc.getLine(pos.line), cut = line.length - origTarget[0].length;\r\n            if (fold(line.slice(cut)) != target[0]) return;\r\n            var from = Pos(pos.line, cut);\r\n            for (var ln = pos.line + 1, i = 1; i < last; ++i, ++ln)\r\n              if (target[i] != fold(doc.getLine(ln))) return;\r\n            if (fold(doc.getLine(ln).slice(0, origTarget[last].length)) != target[last]) return;\r\n            return {from: from, to: Pos(ln, origTarget[last].length)};\r\n          }\r\n        };\r\n      }\r\n    }\r\n  }\r\n\r\n  SearchCursor.prototype = {\r\n    findNext: function() {return this.find(false);},\r\n    findPrevious: function() {return this.find(true);},\r\n\r\n    find: function(reverse) {\r\n      var self = this, pos = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);\r\n      function savePosAndFail(line) {\r\n        var pos = Pos(line, 0);\r\n        self.pos = {from: pos, to: pos};\r\n        self.atOccurrence = false;\r\n        return false;\r\n      }\r\n\r\n      for (;;) {\r\n        if (this.pos = this.matches(reverse, pos)) {\r\n          this.atOccurrence = true;\r\n          return this.pos.match || true;\r\n        }\r\n        if (reverse) {\r\n          if (!pos.line) return savePosAndFail(0);\r\n          pos = Pos(pos.line-1, this.doc.getLine(pos.line-1).length);\r\n        }\r\n        else {\r\n          var maxLine = this.doc.lineCount();\r\n          if (pos.line == maxLine - 1) return savePosAndFail(maxLine);\r\n          pos = Pos(pos.line + 1, 0);\r\n        }\r\n      }\r\n    },\r\n\r\n    from: function() {if (this.atOccurrence) return this.pos.from;},\r\n    to: function() {if (this.atOccurrence) return this.pos.to;},\r\n\r\n    replace: function(newText) {\r\n      if (!this.atOccurrence) return;\r\n      var lines = CodeMirror.splitLines(newText);\r\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to);\r\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\r\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));\r\n    }\r\n  };\r\n\r\n  // Maps a position in a case-folded line back to a position in the original line\r\n  // (compensating for codepoints increasing in number during folding)\r\n  function adjustPos(orig, folded, pos) {\r\n    if (orig.length == folded.length) return pos;\r\n    for (var pos1 = Math.min(pos, orig.length);;) {\r\n      var len1 = orig.slice(0, pos1).toLowerCase().length;\r\n      if (len1 < pos) ++pos1;\r\n      else if (len1 > pos) --pos1;\r\n      else return pos1;\r\n    }\r\n  }\r\n\r\n  CodeMirror.defineExtension("getSearchCursor", function(query, pos, caseFold) {\r\n    return new SearchCursor(this.doc, query, pos, caseFold);\r\n  });\r\n  CodeMirror.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {\r\n    return new SearchCursor(this, query, pos, caseFold);\r\n  });\r\n\r\n  CodeMirror.defineExtension("selectMatches", function(query, caseFold) {\r\n    var ranges = [], next;\r\n    var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);\r\n    while (next = cur.findNext()) {\r\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor("to")) > 0) break;\r\n      ranges.push({anchor: cur.from(), head: cur.to()});\r\n    }\r\n    if (ranges.length)\r\n      this.setSelections(ranges, 0);\r\n  });\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/addon/search/searchcursor.js'),eval('// CodeMirror, copyright (c) by Marijn Haverbeke and others\r\n// Distributed under an MIT license: http://codemirror.net/LICENSE\r\n\r\n// A rough approximation of Sublime Text\'s keybindings\r\n// Depends on addon/search/searchcursor.js and optionally addon/dialog/dialogs.js\r\n\r\n(function(mod) {\r\n  if (typeof exports == "object" && typeof module == "object") // CommonJS\r\n    mod(require("../lib/codemirror"), require("../addon/search/searchcursor"), require("../addon/edit/matchbrackets"));\r\n  else if (typeof define == "function" && define.amd) // AMD\r\n    define(\'thirdparty/CodeMirror2/keymap/sublime\',["../lib/codemirror", "../addon/search/searchcursor", "../addon/edit/matchbrackets"], mod);\r\n  else // Plain browser env\r\n    mod(CodeMirror);\r\n})(function(CodeMirror) {\r\n  "use strict";\r\n\r\n  var map = CodeMirror.keyMap.sublime = {fallthrough: "default"};\r\n  var cmds = CodeMirror.commands;\r\n  var Pos = CodeMirror.Pos;\r\n  var mac = CodeMirror.keyMap["default"] == CodeMirror.keyMap.macDefault;\r\n  var ctrl = mac ? "Cmd-" : "Ctrl-";\r\n\r\n  // This is not exactly Sublime\'s algorithm. I couldn\'t make heads or tails of that.\r\n  function findPosSubword(doc, start, dir) {\r\n    if (dir < 0 && start.ch == 0) return doc.clipPos(Pos(start.line - 1));\r\n    var line = doc.getLine(start.line);\r\n    if (dir > 0 && start.ch >= line.length) return doc.clipPos(Pos(start.line + 1, 0));\r\n    var state = "start", type;\r\n    for (var pos = start.ch, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {\r\n      var next = line.charAt(dir < 0 ? pos - 1 : pos);\r\n      var cat = next != "_" && CodeMirror.isWordChar(next) ? "w" : "o";\r\n      if (cat == "w" && next.toUpperCase() == next) cat = "W";\r\n      if (state == "start") {\r\n        if (cat != "o") { state = "in"; type = cat; }\r\n      } else if (state == "in") {\r\n        if (type != cat) {\r\n          if (type == "w" && cat == "W" && dir < 0) pos--;\r\n          if (type == "W" && cat == "w" && dir > 0) { type = "w"; continue; }\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return Pos(start.line, pos);\r\n  }\r\n\r\n  function moveSubword(cm, dir) {\r\n    cm.extendSelectionsBy(function(range) {\r\n      if (cm.display.shift || cm.doc.extend || range.empty())\r\n        return findPosSubword(cm.doc, range.head, dir);\r\n      else\r\n        return dir < 0 ? range.from() : range.to();\r\n    });\r\n  }\r\n\r\n  cmds[map["Alt-Left"] = "goSubwordLeft"] = function(cm) { moveSubword(cm, -1); };\r\n  cmds[map["Alt-Right"] = "goSubwordRight"] = function(cm) { moveSubword(cm, 1); };\r\n\r\n  cmds[map[ctrl + "Up"] = "scrollLineUp"] = function(cm) {\r\n    var info = cm.getScrollInfo();\r\n    if (!cm.somethingSelected()) {\r\n      var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, "local");\r\n      if (cm.getCursor().line >= visibleBottomLine)\r\n        cm.execCommand("goLineUp");\r\n    }\r\n    cm.scrollTo(null, info.top - cm.defaultTextHeight());\r\n  };\r\n  cmds[map[ctrl + "Down"] = "scrollLineDown"] = function(cm) {\r\n    var info = cm.getScrollInfo();\r\n    if (!cm.somethingSelected()) {\r\n      var visibleTopLine = cm.lineAtHeight(info.top, "local")+1;\r\n      if (cm.getCursor().line <= visibleTopLine)\r\n        cm.execCommand("goLineDown");\r\n    }\r\n    cm.scrollTo(null, info.top + cm.defaultTextHeight());\r\n  };\r\n\r\n  cmds[map["Shift-" + ctrl + "L"] = "splitSelectionByLine"] = function(cm) {\r\n    var ranges = cm.listSelections(), lineRanges = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var from = ranges[i].from(), to = ranges[i].to();\r\n      for (var line = from.line; line <= to.line; ++line)\r\n        if (!(to.line > from.line && line == to.line && to.ch == 0))\r\n          lineRanges.push({anchor: line == from.line ? from : Pos(line, 0),\r\n                           head: line == to.line ? to : Pos(line)});\r\n    }\r\n    cm.setSelections(lineRanges, 0);\r\n  };\r\n\r\n  map["Shift-Tab"] = "indentLess";\r\n\r\n  cmds[map["Esc"] = "singleSelectionTop"] = function(cm) {\r\n    var range = cm.listSelections()[0];\r\n    cm.setSelection(range.anchor, range.head, {scroll: false});\r\n  };\r\n\r\n  cmds[map[ctrl + "L"] = "selectLine"] = function(cm) {\r\n    var ranges = cm.listSelections(), extended = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var range = ranges[i];\r\n      extended.push({anchor: Pos(range.from().line, 0),\r\n                     head: Pos(range.to().line + 1, 0)});\r\n    }\r\n    cm.setSelections(extended);\r\n  };\r\n\r\n  map["Shift-" + ctrl + "K"] = "deleteLine";\r\n\r\n  function insertLine(cm, above) {\r\n    cm.operation(function() {\r\n      var len = cm.listSelections().length, newSelection = [], last = -1;\r\n      for (var i = 0; i < len; i++) {\r\n        var head = cm.listSelections()[i].head;\r\n        if (head.line <= last) continue;\r\n        var at = Pos(head.line + (above ? 0 : 1), 0);\r\n        cm.replaceRange("\\n", at, null, "+insertLine");\r\n        cm.indentLine(at.line, null, true);\r\n        newSelection.push({head: at, anchor: at});\r\n        last = head.line + 1;\r\n      }\r\n      cm.setSelections(newSelection);\r\n    });\r\n  }\r\n\r\n  cmds[map[ctrl + "Enter"] = "insertLineAfter"] = function(cm) { insertLine(cm, false); };\r\n\r\n  cmds[map["Shift-" + ctrl + "Enter"] = "insertLineBefore"] = function(cm) { insertLine(cm, true); };\r\n\r\n  function wordAt(cm, pos) {\r\n    var start = pos.ch, end = start, line = cm.getLine(pos.line);\r\n    while (start && CodeMirror.isWordChar(line.charAt(start - 1))) --start;\r\n    while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) ++end;\r\n    return {from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end)};\r\n  }\r\n\r\n  cmds[map[ctrl + "D"] = "selectNextOccurrence"] = function(cm) {\r\n    var from = cm.getCursor("from"), to = cm.getCursor("to");\r\n    var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;\r\n    if (CodeMirror.cmpPos(from, to) == 0) {\r\n      var word = wordAt(cm, from);\r\n      if (!word.word) return;\r\n      cm.setSelection(word.from, word.to);\r\n      fullWord = true;\r\n    } else {\r\n      var text = cm.getRange(from, to);\r\n      var query = fullWord ? new RegExp("\\\\b" + text + "\\\\b") : text;\r\n      var cur = cm.getSearchCursor(query, to);\r\n      if (cur.findNext()) {\r\n        cm.addSelection(cur.from(), cur.to());\r\n      } else {\r\n        cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));\r\n        if (cur.findNext())\r\n          cm.addSelection(cur.from(), cur.to());\r\n      }\r\n    }\r\n    if (fullWord)\r\n      cm.state.sublimeFindFullWord = cm.doc.sel;\r\n  };\r\n\r\n  var mirror = "(){}[]";\r\n  function selectBetweenBrackets(cm) {\r\n    var pos = cm.getCursor(), opening = cm.scanForBracket(pos, -1);\r\n    if (!opening) return;\r\n    for (;;) {\r\n      var closing = cm.scanForBracket(pos, 1);\r\n      if (!closing) return;\r\n      if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {\r\n        cm.setSelection(Pos(opening.pos.line, opening.pos.ch + 1), closing.pos, false);\r\n        return true;\r\n      }\r\n      pos = Pos(closing.pos.line, closing.pos.ch + 1);\r\n    }\r\n  }\r\n\r\n  cmds[map["Shift-" + ctrl + "Space"] = "selectScope"] = function(cm) {\r\n    selectBetweenBrackets(cm) || cm.execCommand("selectAll");\r\n  };\r\n  cmds[map["Shift-" + ctrl + "M"] = "selectBetweenBrackets"] = function(cm) {\r\n    if (!selectBetweenBrackets(cm)) return CodeMirror.Pass;\r\n  };\r\n\r\n  cmds[map[ctrl + "M"] = "goToBracket"] = function(cm) {\r\n    cm.extendSelectionsBy(function(range) {\r\n      var next = cm.scanForBracket(range.head, 1);\r\n      if (next && CodeMirror.cmpPos(next.pos, range.head) != 0) return next.pos;\r\n      var prev = cm.scanForBracket(range.head, -1);\r\n      return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;\r\n    });\r\n  };\r\n\r\n  var swapLineCombo = mac ? "Cmd-Ctrl-" : "Shift-Ctrl-";\r\n\r\n  cmds[map[swapLineCombo + "Up"] = "swapLineUp"] = function(cm) {\r\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var range = ranges[i], from = range.from().line - 1, to = range.to().line;\r\n      newSels.push({anchor: Pos(range.anchor.line - 1, range.anchor.ch),\r\n                    head: Pos(range.head.line - 1, range.head.ch)});\r\n      if (range.to().ch == 0 && !range.empty()) --to;\r\n      if (from > at) linesToMove.push(from, to);\r\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\r\n      at = to;\r\n    }\r\n    cm.operation(function() {\r\n      for (var i = 0; i < linesToMove.length; i += 2) {\r\n        var from = linesToMove[i], to = linesToMove[i + 1];\r\n        var line = cm.getLine(from);\r\n        cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");\r\n        if (to > cm.lastLine())\r\n          cm.replaceRange("\\n" + line, Pos(cm.lastLine()), null, "+swapLine");\r\n        else\r\n          cm.replaceRange(line + "\\n", Pos(to, 0), null, "+swapLine");\r\n      }\r\n      cm.setSelections(newSels);\r\n      cm.scrollIntoView();\r\n    });\r\n  };\r\n\r\n  cmds[map[swapLineCombo + "Down"] = "swapLineDown"] = function(cm) {\r\n    var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;\r\n    for (var i = ranges.length - 1; i >= 0; i--) {\r\n      var range = ranges[i], from = range.to().line + 1, to = range.from().line;\r\n      if (range.to().ch == 0 && !range.empty()) from--;\r\n      if (from < at) linesToMove.push(from, to);\r\n      else if (linesToMove.length) linesToMove[linesToMove.length - 1] = to;\r\n      at = to;\r\n    }\r\n    cm.operation(function() {\r\n      for (var i = linesToMove.length - 2; i >= 0; i -= 2) {\r\n        var from = linesToMove[i], to = linesToMove[i + 1];\r\n        var line = cm.getLine(from);\r\n        if (from == cm.lastLine())\r\n          cm.replaceRange("", Pos(from - 1), Pos(from), "+swapLine");\r\n        else\r\n          cm.replaceRange("", Pos(from, 0), Pos(from + 1, 0), "+swapLine");\r\n        cm.replaceRange(line + "\\n", Pos(to, 0), null, "+swapLine");\r\n      }\r\n      cm.scrollIntoView();\r\n    });\r\n  };\r\n\r\n  map[ctrl + "/"] = "toggleComment";\r\n\r\n  cmds[map[ctrl + "J"] = "joinLines"] = function(cm) {\r\n    var ranges = cm.listSelections(), joined = [];\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var range = ranges[i], from = range.from();\r\n      var start = from.line, end = range.to().line;\r\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == end)\r\n        end = ranges[++i].to().line;\r\n      joined.push({start: start, end: end, anchor: !range.empty() && from});\r\n    }\r\n    cm.operation(function() {\r\n      var offset = 0, ranges = [];\r\n      for (var i = 0; i < joined.length; i++) {\r\n        var obj = joined[i];\r\n        var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;\r\n        for (var line = obj.start; line <= obj.end; line++) {\r\n          var actual = line - offset;\r\n          if (line == obj.end) head = Pos(actual, cm.getLine(actual).length + 1);\r\n          if (actual < cm.lastLine()) {\r\n            cm.replaceRange(" ", Pos(actual), Pos(actual + 1, /^\\s*/.exec(cm.getLine(actual + 1))[0].length));\r\n            ++offset;\r\n          }\r\n        }\r\n        ranges.push({anchor: anchor || head, head: head});\r\n      }\r\n      cm.setSelections(ranges, 0);\r\n    });\r\n  };\r\n\r\n  cmds[map["Shift-" + ctrl + "D"] = "duplicateLine"] = function(cm) {\r\n    cm.operation(function() {\r\n      var rangeCount = cm.listSelections().length;\r\n      for (var i = 0; i < rangeCount; i++) {\r\n        var range = cm.listSelections()[i];\r\n        if (range.empty())\r\n          cm.replaceRange(cm.getLine(range.head.line) + "\\n", Pos(range.head.line, 0));\r\n        else\r\n          cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());\r\n      }\r\n      cm.scrollIntoView();\r\n    });\r\n  };\r\n\r\n  map[ctrl + "T"] = "transposeChars";\r\n\r\n  function sortLines(cm, caseSensitive) {\r\n    var ranges = cm.listSelections(), toSort = [], selected;\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var range = ranges[i];\r\n      if (range.empty()) continue;\r\n      var from = range.from().line, to = range.to().line;\r\n      while (i < ranges.length - 1 && ranges[i + 1].from().line == to)\r\n        to = range[++i].to().line;\r\n      toSort.push(from, to);\r\n    }\r\n    if (toSort.length) selected = true;\r\n    else toSort.push(cm.firstLine(), cm.lastLine());\r\n\r\n    cm.operation(function() {\r\n      var ranges = [];\r\n      for (var i = 0; i < toSort.length; i += 2) {\r\n        var from = toSort[i], to = toSort[i + 1];\r\n        var start = Pos(from, 0), end = Pos(to);\r\n        var lines = cm.getRange(start, end, false);\r\n        if (caseSensitive)\r\n          lines.sort();\r\n        else\r\n          lines.sort(function(a, b) {\r\n            var au = a.toUpperCase(), bu = b.toUpperCase();\r\n            if (au != bu) { a = au; b = bu; }\r\n            return a < b ? -1 : a == b ? 0 : 1;\r\n          });\r\n        cm.replaceRange(lines, start, end);\r\n        if (selected) ranges.push({anchor: start, head: end});\r\n      }\r\n      if (selected) cm.setSelections(ranges, 0);\r\n    });\r\n  }\r\n\r\n  cmds[map["F9"] = "sortLines"] = function(cm) { sortLines(cm, true); };\r\n  cmds[map[ctrl + "F9"] = "sortLinesInsensitive"] = function(cm) { sortLines(cm, false); };\r\n\r\n  cmds[map["F2"] = "nextBookmark"] = function(cm) {\r\n    var marks = cm.state.sublimeBookmarks;\r\n    if (marks) while (marks.length) {\r\n      var current = marks.shift();\r\n      var found = current.find();\r\n      if (found) {\r\n        marks.push(current);\r\n        return cm.setSelection(found.from, found.to);\r\n      }\r\n    }\r\n  };\r\n\r\n  cmds[map["Shift-F2"] = "prevBookmark"] = function(cm) {\r\n    var marks = cm.state.sublimeBookmarks;\r\n    if (marks) while (marks.length) {\r\n      marks.unshift(marks.pop());\r\n      var found = marks[marks.length - 1].find();\r\n      if (!found)\r\n        marks.pop();\r\n      else\r\n        return cm.setSelection(found.from, found.to);\r\n    }\r\n  };\r\n\r\n  cmds[map[ctrl + "F2"] = "toggleBookmark"] = function(cm) {\r\n    var ranges = cm.listSelections();\r\n    var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);\r\n    for (var i = 0; i < ranges.length; i++) {\r\n      var from = ranges[i].from(), to = ranges[i].to();\r\n      var found = cm.findMarks(from, to);\r\n      for (var j = 0; j < found.length; j++) {\r\n        if (found[j].sublimeBookmark) {\r\n          found[j].clear();\r\n          for (var k = 0; k < marks.length; k++)\r\n            if (marks[k] == found[j])\r\n              marks.splice(k--, 1);\r\n          break;\r\n        }\r\n      }\r\n      if (j == found.length)\r\n        marks.push(cm.markText(from, to, {sublimeBookmark: true, clearWhenEmpty: false}));\r\n    }\r\n  };\r\n\r\n  cmds[map["Shift-" + ctrl + "F2"] = "clearBookmarks"] = function(cm) {\r\n    var marks = cm.state.sublimeBookmarks;\r\n    if (marks) for (var i = 0; i < marks.length; i++) marks[i].clear();\r\n    marks.length = 0;\r\n  };\r\n\r\n  cmds[map["Alt-F2"] = "selectBookmarks"] = function(cm) {\r\n    var marks = cm.state.sublimeBookmarks, ranges = [];\r\n    if (marks) for (var i = 0; i < marks.length; i++) {\r\n      var found = marks[i].find();\r\n      if (!found)\r\n        marks.splice(i--, 0);\r\n      else\r\n        ranges.push({anchor: found.from, head: found.to});\r\n    }\r\n    if (ranges.length)\r\n      cm.setSelections(ranges, 0);\r\n  };\r\n\r\n  map["Alt-Q"] = "wrapLines";\r\n\r\n  var mapK = CodeMirror.keyMap["sublime-Ctrl-K"] = {auto: "sublime", nofallthrough: true};\r\n\r\n  map[ctrl + "K"] = function(cm) {cm.setOption("keyMap", "sublime-Ctrl-K");};\r\n\r\n  function modifyWordOrSelection(cm, mod) {\r\n    cm.operation(function() {\r\n      var ranges = cm.listSelections(), indices = [], replacements = [];\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var range = ranges[i];\r\n        if (range.empty()) { indices.push(i); replacements.push(""); }\r\n        else replacements.push(mod(cm.getRange(range.from(), range.to())));\r\n      }\r\n      cm.replaceSelections(replacements, "around", "case");\r\n      for (var i = indices.length - 1, at; i >= 0; i--) {\r\n        var range = ranges[indices[i]];\r\n        if (at && CodeMirror.cmpPos(range.head, at) > 0) continue;\r\n        var word = wordAt(cm, range.head);\r\n        at = word.from;\r\n        cm.replaceRange(mod(word.word), word.from, word.to);\r\n      }\r\n    });\r\n  }\r\n\r\n  mapK[ctrl + "Backspace"] = "delLineLeft";\r\n\r\n  cmds[mapK[ctrl + "K"] = "delLineRight"] = function(cm) {\r\n    cm.operation(function() {\r\n      var ranges = cm.listSelections();\r\n      for (var i = ranges.length - 1; i >= 0; i--)\r\n        cm.replaceRange("", ranges[i].anchor, Pos(ranges[i].to().line), "+delete");\r\n      cm.scrollIntoView();\r\n    });\r\n  };\r\n\r\n  cmds[mapK[ctrl + "U"] = "upcaseAtCursor"] = function(cm) {\r\n    modifyWordOrSelection(cm, function(str) { return str.toUpperCase(); });\r\n  };\r\n  cmds[mapK[ctrl + "L"] = "downcaseAtCursor"] = function(cm) {\r\n    modifyWordOrSelection(cm, function(str) { return str.toLowerCase(); });\r\n  };\r\n\r\n  cmds[mapK[ctrl + "Space"] = "setSublimeMark"] = function(cm) {\r\n    if (cm.state.sublimeMark) cm.state.sublimeMark.clear();\r\n    cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\r\n  };\r\n  cmds[mapK[ctrl + "A"] = "selectToSublimeMark"] = function(cm) {\r\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\r\n    if (found) cm.setSelection(cm.getCursor(), found);\r\n  };\r\n  cmds[mapK[ctrl + "W"] = "deleteToSublimeMark"] = function(cm) {\r\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\r\n    if (found) {\r\n      var from = cm.getCursor(), to = found;\r\n      if (CodeMirror.cmpPos(from, to) > 0) { var tmp = to; to = from; from = tmp; }\r\n      cm.state.sublimeKilled = cm.getRange(from, to);\r\n      cm.replaceRange("", from, to);\r\n    }\r\n  };\r\n  cmds[mapK[ctrl + "X"] = "swapWithSublimeMark"] = function(cm) {\r\n    var found = cm.state.sublimeMark && cm.state.sublimeMark.find();\r\n    if (found) {\r\n      cm.state.sublimeMark.clear();\r\n      cm.state.sublimeMark = cm.setBookmark(cm.getCursor());\r\n      cm.setCursor(found);\r\n    }\r\n  };\r\n  cmds[mapK[ctrl + "Y"] = "sublimeYank"] = function(cm) {\r\n    if (cm.state.sublimeKilled != null)\r\n      cm.replaceSelection(cm.state.sublimeKilled, null, "paste");\r\n  };\r\n\r\n  mapK[ctrl + "G"] = "clearBookmarks";\r\n  cmds[mapK[ctrl + "C"] = "showInCenter"] = function(cm) {\r\n    var pos = cm.cursorCoords(null, "local");\r\n    cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);\r\n  };\r\n\r\n  cmds[map["Shift-Alt-Up"] = "selectLinesUpward"] = function(cm) {\r\n    cm.operation(function() {\r\n      var ranges = cm.listSelections();\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var range = ranges[i];\r\n        if (range.head.line > cm.firstLine())\r\n          cm.addSelection(Pos(range.head.line - 1, range.head.ch));\r\n      }\r\n    });\r\n  };\r\n  cmds[map["Shift-Alt-Down"] = "selectLinesDownward"] = function(cm) {\r\n    cm.operation(function() {\r\n      var ranges = cm.listSelections();\r\n      for (var i = 0; i < ranges.length; i++) {\r\n        var range = ranges[i];\r\n        if (range.head.line < cm.lastLine())\r\n          cm.addSelection(Pos(range.head.line + 1, range.head.ch));\r\n      }\r\n    });\r\n  };\r\n\r\n  function getTarget(cm) {\r\n    var from = cm.getCursor("from"), to = cm.getCursor("to");\r\n    if (CodeMirror.cmpPos(from, to) == 0) {\r\n      var word = wordAt(cm, from);\r\n      if (!word.word) return;\r\n      from = word.from;\r\n      to = word.to;\r\n    }\r\n    return {from: from, to: to, query: cm.getRange(from, to), word: word};\r\n  }\r\n\r\n  function findAndGoTo(cm, forward) {\r\n    var target = getTarget(cm);\r\n    if (!target) return;\r\n    var query = target.query;\r\n    var cur = cm.getSearchCursor(query, forward ? target.to : target.from);\r\n\r\n    if (forward ? cur.findNext() : cur.findPrevious()) {\r\n      cm.setSelection(cur.from(), cur.to());\r\n    } else {\r\n      cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0)\r\n                                              : cm.clipPos(Pos(cm.lastLine())));\r\n      if (forward ? cur.findNext() : cur.findPrevious())\r\n        cm.setSelection(cur.from(), cur.to());\r\n      else if (target.word)\r\n        cm.setSelection(target.from, target.to);\r\n    }\r\n  };\r\n  cmds[map[ctrl + "F3"] = "findUnder"] = function(cm) { findAndGoTo(cm, true); };\r\n  cmds[map["Shift-" + ctrl + "F3"] = "findUnderPrevious"] = function(cm) { findAndGoTo(cm,false); };\r\n  cmds[map["Alt-F3"] = "findAllUnder"] = function(cm) {\r\n    var target = getTarget(cm);\r\n    if (!target) return;\r\n    var cur = cm.getSearchCursor(target.query);\r\n    var matches = [];\r\n    var primaryIndex = -1;\r\n    while (cur.findNext()) {\r\n      matches.push({anchor: cur.from(), head: cur.to()});\r\n      if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)\r\n        primaryIndex++;\r\n    }\r\n    cm.setSelections(matches, primaryIndex);\r\n  };\r\n\r\n  map["Shift-" + ctrl + "["] = "fold";\r\n  map["Shift-" + ctrl + "]"] = "unfold";\r\n  mapK[ctrl + "0"] = mapK[ctrl + "j"] = "unfoldAll";\r\n\r\n  map[ctrl + "I"] = "findIncremental";\r\n  map["Shift-" + ctrl + "I"] = "findIncrementalReverse";\r\n  map[ctrl + "H"] = "replace";\r\n  map["F3"] = "findNext";\r\n  map["Shift-F3"] = "findPrev";\r\n\r\n});\r\n\n//# sourceURL=/thirdparty/CodeMirror2/keymap/sublime.js'),eval('/**\r\n * @license\r\n * Lo-Dash 2.2.0 (Custom Build) lodash.com/license | Underscore.js 1.5.2 underscorejs.org/LICENSE\r\n * Build: `lodash modern -m exports="amd"`\r\n */\r\n;(function(){function n(n,t,e){e=(e||0)-1;for(var r=n?n.length:0;++e<r;)if(n[e]===t)return e;return-1}function t(t,e){var r=typeof e;if(t=t.l,"boolean"==r||null==e)return t[e]?0:-1;"number"!=r&&"string"!=r&&(r="object");var u="number"==r?e:b+e;return t=(t=t[r])&&t[u],"object"==r?t&&-1<n(t,e)?0:-1:t?0:-1}function e(n){var t=this.l,e=typeof n;if("boolean"==e||null==n)t[n]=!0;else{"number"!=e&&"string"!=e&&(e="object");var r="number"==e?n:b+n,t=t[e]||(t[e]={});"object"==e?(t[r]||(t[r]=[])).push(n):t[r]=!0\r\n}}function r(n){return n.charCodeAt(0)}function u(n,t){var e=n.m,r=t.m;if(e!==r){if(e>r||typeof e=="undefined")return 1;if(e<r||typeof r=="undefined")return-1}return n.n-t.n}function o(n){var t=-1,r=n.length,u=n[0],o=n[0|r/2],a=n[r-1];if(u&&typeof u=="object"&&o&&typeof o=="object"&&a&&typeof a=="object")return!1;for(u=f(),u["false"]=u["null"]=u["true"]=u.undefined=!1,o=f(),o.k=n,o.l=u,o.push=e;++t<r;)o.push(n[t]);return o}function a(n){return"\\\\"+G[n]}function i(){return g.pop()||[]}function f(){return y.pop()||{k:null,l:null,m:null,"false":!1,n:0,"null":!1,number:null,object:null,push:null,string:null,"true":!1,undefined:!1,o:null}\r\n}function l(){}function c(n){n.length=0,g.length<_&&g.push(n)}function p(n){var t=n.l;t&&p(t),n.k=n.l=n.m=n.object=n.number=n.string=n.o=null,y.length<_&&y.push(n)}function s(n,t,e){t||(t=0),typeof e=="undefined"&&(e=n?n.length:0);var r=-1;e=e-t||0;for(var u=Array(0>e?0:e);++r<e;)u[r]=n[t+r];return u}function v(e){function g(n){if(!n||we.call(n)!=z)return!1;var t=n.valueOf,e=typeof t=="function"&&(e=he(t))&&he(e);return e?n==e||he(n)==e:pt(n)}function y(n,t,e){if(!n||!V[typeof n])return n;t=t&&typeof e=="undefined"?t:et(t,e,3);\r\nfor(var r=-1,u=V[typeof n]&&Pe(n),o=u?u.length:0;++r<o&&(e=u[r],false!==t(n[e],e,n)););return n}function _(n,t,e){var r;if(!n||!V[typeof n])return n;t=t&&typeof e=="undefined"?t:et(t,e,3);for(r in n)if(false===t(n[r],r,n))break;return n}function G(n,t,e){var r,u=n,o=u;if(!u)return o;for(var a=arguments,i=0,f=typeof e=="number"?2:a.length;++i<f;)if((u=a[i])&&V[typeof u])for(var l=-1,c=V[typeof u]&&Pe(u),p=c?c.length:0;++l<p;)r=c[l],"undefined"==typeof o[r]&&(o[r]=u[r]);return o}function J(n,t,e){var r,u=n,o=u;\r\nif(!u)return o;var a=arguments,i=0,f=typeof e=="number"?2:a.length;if(3<f&&"function"==typeof a[f-2])var l=et(a[--f-1],a[f--],2);else 2<f&&"function"==typeof a[f-1]&&(l=a[--f]);for(;++i<f;)if((u=a[i])&&V[typeof u])for(var c=-1,p=V[typeof u]&&Pe(u),s=p?p.length:0;++c<s;)r=p[c],o[r]=l?l(o[r],u[r]):u[r];return o}function Q(n){var t,e=[];if(!n||!V[typeof n])return e;for(t in n)ge.call(n,t)&&e.push(t);return e}function Z(n){return n&&typeof n=="object"&&!ze(n)&&ge.call(n,"__wrapped__")?n:new nt(n)}function nt(n,t){this.__chain__=!!t,this.__wrapped__=n\r\n}function tt(n,t,e,r,u){if(e){var o=e(n);if(typeof o!="undefined")return o}if(!bt(n))return n;var a=we.call(n);if(!L[a])return n;var f=Te[a];switch(a){case F:case T:return new f(+n);case q:case K:return new f(n);case P:return o=f(n.source,O.exec(n)),o.lastIndex=n.lastIndex,o}if(a=ze(n),t){var l=!r;r||(r=i()),u||(u=i());for(var p=r.length;p--;)if(r[p]==n)return u[p];o=a?f(n.length):{}}else o=a?s(n):J({},n);return a&&(ge.call(n,"index")&&(o.index=n.index),ge.call(n,"input")&&(o.input=n.input)),t?(r.push(n),u.push(o),(a?Ot:y)(n,function(n,a){o[a]=tt(n,t,e,r,u)\r\n}),l&&(c(r),c(u)),o):o}function et(n,t,e){if(typeof n!="function")return Vt;if(typeof t=="undefined")return n;var r=n.__bindData__||We.funcNames&&!n.name;if(typeof r=="undefined"){var u=R&&ve.call(n);We.funcNames||!u||I.test(u)||(r=!0),(We.funcNames||!r)&&(r=!We.funcDecomp||R.test(u),qe(n,r))}if(true!==r&&r&&1&r[1])return n;switch(e){case 1:return function(e){return n.call(t,e)};case 2:return function(e,r){return n.call(t,e,r)};case 3:return function(e,r,u){return n.call(t,e,r,u)};case 4:return function(e,r,u,o){return n.call(t,e,r,u,o)\r\n}}return Lt(n,t)}function rt(n,t,e,r){r=(r||0)-1;for(var u=n?n.length:0,o=[];++r<u;){var a=n[r];if(a&&typeof a=="object"&&typeof a.length=="number"&&(ze(a)||vt(a))){t||(a=rt(a,t,e));var i=-1,f=a.length,l=o.length;for(o.length+=f;++i<f;)o[l++]=a[i]}else e||o.push(a)}return o}function ut(n,t,e,r,u,o){if(e){var a=e(n,t);if(typeof a!="undefined")return!!a}if(n===t)return 0!==n||1/n==1/t;if(n===n&&!(n&&V[typeof n]||t&&V[typeof t]))return!1;if(null==n||null==t)return n===t;var f=we.call(n),l=we.call(t);\r\nif(f==B&&(f=z),l==B&&(l=z),f!=l)return!1;switch(f){case F:case T:return+n==+t;case q:return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case P:case K:return n==ue(t)}if(l=f==$,!l){if(ge.call(n,"__wrapped__")||ge.call(t,"__wrapped__"))return ut(n.__wrapped__||n,t.__wrapped__||t,e,r,u,o);if(f!=z)return!1;var f=n.constructor,p=t.constructor;if(f!=p&&!(mt(f)&&f instanceof f&&mt(p)&&p instanceof p))return!1}for(p=!u,u||(u=i()),o||(o=i()),f=u.length;f--;)if(u[f]==n)return o[f]==t;var s=0,a=!0;if(u.push(n),o.push(t),l){if(f=n.length,s=t.length,a=s==n.length,!a&&!r)return a;\r\nfor(;s--;)if(l=f,p=t[s],r)for(;l--&&!(a=ut(n[l],p,e,r,u,o)););else if(!(a=ut(n[s],p,e,r,u,o)))break;return a}return _(t,function(t,i,f){return ge.call(f,i)?(s++,a=ge.call(n,i)&&ut(n[i],t,e,r,u,o)):void 0}),a&&!r&&_(n,function(n,t,e){return ge.call(e,t)?a=-1<--s:void 0}),p&&(c(u),c(o)),a}function ot(n,t,e,r,u){(ze(t)?Ot:y)(t,function(t,o){var a,i,f=t,l=n[o];if(t&&((i=ze(t))||g(t))){for(f=r.length;f--;)if(a=r[f]==t){l=u[f];break}if(!a){var c;e&&(f=e(l,t),c=typeof f!="undefined")&&(l=f),c||(l=i?ze(l)?l:[]:g(l)?l:{}),r.push(t),u.push(l),c||ot(l,t,e,r,u)\r\n}}else e&&(f=e(l,t),typeof f=="undefined"&&(f=t)),typeof f!="undefined"&&(l=f);n[o]=l})}function at(e,r,u){var a=-1,f=ct(),l=e?e.length:0,s=[],v=!r&&l>=d&&f===n,h=u||v?i():s;if(v){var g=o(h);g?(f=t,h=g):(v=!1,h=u?h:(c(h),s))}for(;++a<l;){var g=e[a],y=u?u(g,a,e):g;(r?!a||h[h.length-1]!==y:0>f(h,y))&&((u||v)&&h.push(y),s.push(g))}return v?(c(h.k),p(h)):u&&c(h),s}function it(n){return function(t,e,r){var u={};e=Z.createCallback(e,r,3),r=-1;var o=t?t.length:0;if(typeof o=="number")for(;++r<o;){var a=t[r];\r\nn(u,a,e(a,r,t),t)}else y(t,function(t,r,o){n(u,t,e(t,r,o),o)});return u}}function ft(n,t,e,r,u,o){var a=1&t,i=2&t,f=4&t,l=8&t,c=16&t,p=32&t,s=n;if(!i&&!mt(n))throw new oe;c&&!e.length&&(t&=-17,c=e=!1),p&&!r.length&&(t&=-33,p=r=!1);var v=n&&n.__bindData__;if(v)return!a||1&v[1]||(v[4]=u),!a&&1&v[1]&&(t|=8),!f||4&v[1]||(v[5]=o),c&&me.apply(v[2]||(v[2]=[]),e),p&&me.apply(v[3]||(v[3]=[]),r),v[1]|=t,ft.apply(null,v);if(!a||i||f||p||!(We.fastBind||xe&&c))g=function(){var v=arguments,h=a?u:this;return(f||c||p)&&(v=Be.call(v),c&&je.apply(v,e),p&&me.apply(v,r),f&&v.length<o)?(t|=16,ft(n,l?t:-4&t,v,null,u,o)):(i&&(n=h[s]),this instanceof g?(h=bt(n.prototype)?Ce(n.prototype):{},v=n.apply(h,v),bt(v)?v:h):n.apply(h,v))\r\n};else{if(c){var h=[u];me.apply(h,e)}var g=c?xe.apply(n,h):xe.call(n,u)}return qe(g,Be.call(arguments)),g}function lt(n){return Ke[n]}function ct(){var t=(t=Z.indexOf)===Tt?n:t;return t}function pt(n){var t,e;return n&&we.call(n)==z&&(t=n.constructor,!mt(t)||t instanceof t)?(_(n,function(n,t){e=t}),typeof e=="undefined"||ge.call(n,e)):!1}function st(n){return Le[n]}function vt(n){return n&&typeof n=="object"&&typeof n.length=="number"&&we.call(n)==B||!1}function ht(n,t,e){var r=Pe(n),u=r.length;for(t=et(t,e,3);u--&&(e=r[u],false!==t(n[e],e,n)););return n\r\n}function gt(n){var t=[];return _(n,function(n,e){mt(n)&&t.push(e)}),t.sort()}function yt(n){for(var t=-1,e=Pe(n),r=e.length,u={};++t<r;){var o=e[t];u[n[o]]=o}return u}function mt(n){return typeof n=="function"}function bt(n){return!(!n||!V[typeof n])}function dt(n){return typeof n=="number"||we.call(n)==q}function _t(n){return typeof n=="string"||we.call(n)==K}function wt(n){for(var t=-1,e=Pe(n),r=e.length,u=Qt(r);++t<r;)u[t]=n[e[t]];return u}function jt(n,t,e){var r=-1,u=ct(),o=n?n.length:0,a=!1;return e=(0>e?Se(0,o+e):e)||0,ze(n)?a=-1<u(n,t,e):typeof o=="number"?a=-1<(_t(n)?n.indexOf(t,e):u(n,t,e)):y(n,function(n){return++r<e?void 0:!(a=n===t)\r\n}),a}function kt(n,t,e){var r=!0;t=Z.createCallback(t,e,3),e=-1;var u=n?n.length:0;if(typeof u=="number")for(;++e<u&&(r=!!t(n[e],e,n)););else y(n,function(n,e,u){return r=!!t(n,e,u)});return r}function xt(n,t,e){var r=[];t=Z.createCallback(t,e,3),e=-1;var u=n?n.length:0;if(typeof u=="number")for(;++e<u;){var o=n[e];t(o,e,n)&&r.push(o)}else y(n,function(n,e,u){t(n,e,u)&&r.push(n)});return r}function Ct(n,t,e){t=Z.createCallback(t,e,3),e=-1;var r=n?n.length:0;if(typeof r!="number"){var u;return y(n,function(n,e,r){return t(n,e,r)?(u=n,!1):void 0\r\n}),u}for(;++e<r;){var o=n[e];if(t(o,e,n))return o}}function Ot(n,t,e){var r=-1,u=n?n.length:0;if(t=t&&typeof e=="undefined"?t:et(t,e,3),typeof u=="number")for(;++r<u&&false!==t(n[r],r,n););else y(n,t);return n}function It(n,t,e){var r=n?n.length:0;if(t=t&&typeof e=="undefined"?t:et(t,e,3),typeof r=="number")for(;r--&&false!==t(n[r],r,n););else{var u=Pe(n),r=u.length;y(n,function(n,e,o){return e=u?u[--r]:--r,t(o[e],e,o)})}return n}function Nt(n,t,e){var r=-1,u=n?n.length:0;if(t=Z.createCallback(t,e,3),typeof u=="number")for(var o=Qt(u);++r<u;)o[r]=t(n[r],r,n);\r\nelse o=[],y(n,function(n,e,u){o[++r]=t(n,e,u)});return o}function Et(n,t,e){var u=-1/0,o=u;if(!t&&ze(n)){e=-1;for(var a=n.length;++e<a;){var i=n[e];i>o&&(o=i)}}else t=!t&&_t(n)?r:Z.createCallback(t,e,3),Ot(n,function(n,e,r){e=t(n,e,r),e>u&&(u=e,o=n)});return o}function St(n,t){var e=-1,r=n?n.length:0;if(typeof r=="number")for(var u=Qt(r);++e<r;)u[e]=n[e][t];return u||Nt(n,t)}function Rt(n,t,e,r){if(!n)return e;var u=3>arguments.length;t=et(t,r,4);var o=-1,a=n.length;if(typeof a=="number")for(u&&(e=n[++o]);++o<a;)e=t(e,n[o],o,n);\r\nelse y(n,function(n,r,o){e=u?(u=!1,n):t(e,n,r,o)});return e}function At(n,t,e,r){var u=3>arguments.length;return t=et(t,r,4),It(n,function(n,r,o){e=u?(u=!1,n):t(e,n,r,o)}),e}function Dt(n){var t=-1,e=n?n.length:0,r=Qt(typeof e=="number"?e:0);return Ot(n,function(n){var e=Ht(++t);r[t]=r[e],r[e]=n}),r}function Bt(n,t,e){var r;t=Z.createCallback(t,e,3),e=-1;var u=n?n.length:0;if(typeof u=="number")for(;++e<u&&!(r=t(n[e],e,n)););else y(n,function(n,e,u){return!(r=t(n,e,u))});return!!r}function $t(e){var r=-1,u=ct(),a=e?e.length:0,i=rt(arguments,!0,!0,1),f=[],l=a>=d&&u===n;\r\nif(l){var c=o(i);c?(u=t,i=c):l=!1}for(;++r<a;)c=e[r],0>u(i,c)&&f.push(c);return l&&p(i),f}function Ft(n,t,e){var r=0,u=n?n.length:0;if(typeof t!="number"&&null!=t){var o=-1;for(t=Z.createCallback(t,e,3);++o<u&&t(n[o],o,n);)r++}else if(r=t,null==r||e)return n?n[0]:h;return s(n,0,Re(Se(0,r),u))}function Tt(t,e,r){if(typeof r=="number"){var u=t?t.length:0;r=0>r?Se(0,u+r):r||0}else if(r)return r=qt(t,e),t[r]===e?r:-1;return n(t,e,r)}function Wt(n,t,e){if(typeof t!="number"&&null!=t){var r=0,u=-1,o=n?n.length:0;\r\nfor(t=Z.createCallback(t,e,3);++u<o&&t(n[u],u,n);)r++}else r=null==t||e?1:Se(0,t);return s(n,r)}function qt(n,t,e,r){var u=0,o=n?n.length:u;for(e=e?Z.createCallback(e,r,1):Vt,t=e(t);u<o;)r=u+o>>>1,e(n[r])<t?u=r+1:o=r;return u}function zt(n,t,e,r){return typeof t!="boolean"&&null!=t&&(e=(r=e)&&r[t]===n?null:t,t=!1),null!=e&&(e=Z.createCallback(e,r,3)),at(n,t,e)}function Pt(){for(var n=1<arguments.length?arguments:arguments[0],t=-1,e=n?Et(St(n,"length")):0,r=Qt(0>e?0:e);++t<e;)r[t]=St(n,t);return r}function Kt(n,t){for(var e=-1,r=n?n.length:0,u={};++e<r;){var o=n[e];\r\nt?u[o]=t[e]:o&&(u[o[0]]=o[1])}return u}function Lt(n,t){return 2<arguments.length?ft(n,17,Be.call(arguments,2),null,t):ft(n,1,null,null,t)}function Mt(n,t,e){function r(){c&&pe(c),a=c=p=h,(g||v!==t)&&(s=ye(),i=n.apply(l,o))}function u(){var e=t-(ye()-f);0<e?c=de(u,e):(a&&pe(a),e=p,a=c=p=h,e&&(s=ye(),i=n.apply(l,o)))}var o,a,i,f,l,c,p,s=0,v=!1,g=!0;if(!mt(n))throw new oe;if(t=Se(0,t)||0,true===e)var y=!0,g=!1;else bt(e)&&(y=e.leading,v="maxWait"in e&&(Se(t,e.maxWait)||0),g="trailing"in e?e.trailing:g);\r\nreturn function(){if(o=arguments,f=ye(),l=this,p=g&&(c||!y),false===v)var e=y&&!c;else{a||y||(s=f);var h=v-(f-s);0<h?a||(a=de(r,h)):(a&&(a=pe(a)),s=f,i=n.apply(l,o))}return c||t===v||(c=de(u,t)),e&&(i=n.apply(l,o)),i}}function Ut(n){if(!mt(n))throw new oe;var t=Be.call(arguments,1);return de(function(){n.apply(h,t)},1)}function Vt(n){return n}function Gt(n,t){var e=n,r=!t||mt(e);t||(e=nt,t=n,n=Z),Ot(gt(t),function(u){var o=n[u]=t[u];r&&(e.prototype[u]=function(){var t=this.__wrapped__,r=[t];return me.apply(r,arguments),r=o.apply(n,r),t&&typeof t=="object"&&t===r?this:new e(r)\r\n})})}function Ht(n,t,e){var r=null==n,u=null==t;return null==e&&(typeof n=="boolean"&&u?(e=n,n=1):u||typeof t!="boolean"||(e=t,u=!0)),r&&u&&(t=1),n=+n||0,u?(t=n,n=0):t=+t||0,r=De(),e||n%1||t%1?Re(n+r*(t-n+parseFloat("1e-"+((r+"").length-1))),t):n+se(r*(t-n+1))}function Jt(){return this.__wrapped__}e=e?Y.defaults(H.Object(),e,Y.pick(H,D)):H;var Qt=e.Array,Xt=e.Boolean,Yt=e.Date,Zt=e.Function,ne=e.Math,te=e.Number,ee=e.Object,re=e.RegExp,ue=e.String,oe=e.TypeError,ae=[],ie=ee.prototype,fe=e._,le=re("^"+ue(ie.valueOf).replace(/[.*+?^${}()|[\\]\\\\]/g,"\\\\$&").replace(/valueOf|for [^\\]]+/g,".+?")+"$"),ce=ne.ceil,pe=e.clearTimeout,se=ne.floor,ve=Zt.prototype.toString,he=le.test(he=ee.getPrototypeOf)&&he,ge=ie.hasOwnProperty,ye=le.test(ye=Yt.now)&&ye||function(){return+new Yt\r\n},me=ae.push,be=e.setImmediate,de=e.setTimeout,_e=ae.splice,we=ie.toString,je=ae.unshift,ke=function(){try{var n={},t=le.test(t=ee.defineProperty)&&t,e=t(n,n,n)&&t}catch(r){}return e}(),xe=le.test(xe=we.bind)&&xe,Ce=le.test(Ce=ee.create)&&Ce,Oe=le.test(Oe=Qt.isArray)&&Oe,Ie=e.isFinite,Ne=e.isNaN,Ee=le.test(Ee=ee.keys)&&Ee,Se=ne.max,Re=ne.min,Ae=e.parseInt,De=ne.random,Be=ae.slice,$e=le.test(e.attachEvent),Fe=xe&&!/\\n|true/.test(xe+$e),Te={};Te[$]=Qt,Te[F]=Xt,Te[T]=Yt,Te[W]=Zt,Te[z]=ee,Te[q]=te,Te[P]=re,Te[K]=ue,nt.prototype=Z.prototype;\r\nvar We=Z.support={};We.fastBind=xe&&!Fe,We.funcDecomp=!le.test(e.a)&&R.test(v),We.funcNames=typeof Zt.name=="string",Z.templateSettings={escape:/<%-([\\s\\S]+?)%>/g,evaluate:/<%([\\s\\S]+?)%>/g,interpolate:N,variable:"",imports:{_:Z}};var qe=ke?function(n,t){U.value=t,ke(n,"__bindData__",U)}:l,ze=Oe||function(n){return n&&typeof n=="object"&&typeof n.length=="number"&&we.call(n)==$||!1},Pe=Ee?function(n){return bt(n)?Ee(n):[]}:Q,Ke={"&":"&amp;","<":"&lt;",">":"&gt;",\'"\':"&quot;","\'":"&#39;"},Le=yt(Ke),Me=re("("+Pe(Le).join("|")+")","g"),Ue=re("["+Pe(Ke).join("")+"]","g"),Ve=it(function(n,t,e){ge.call(n,e)?n[e]++:n[e]=1\r\n}),Ge=it(function(n,t,e){(ge.call(n,e)?n[e]:n[e]=[]).push(t)}),He=it(function(n,t,e){n[e]=t});Fe&&X&&typeof be=="function"&&(Ut=function(n){if(!mt(n))throw new oe;return be.apply(e,arguments)});var Je=8==Ae(w+"08")?Ae:function(n,t){return Ae(_t(n)?n.replace(E,""):n,t||0)};return Z.after=function(n,t){if(!mt(t))throw new oe;return function(){return 1>--n?t.apply(this,arguments):void 0}},Z.assign=J,Z.at=function(n){for(var t=arguments,e=-1,r=rt(t,!0,!1,1),t=t[2]&&t[2][t[1]]===n?1:r.length,u=Qt(t);++e<t;)u[e]=n[r[e]];\r\nreturn u},Z.bind=Lt,Z.bindAll=function(n){for(var t=1<arguments.length?rt(arguments,!0,!1,1):gt(n),e=-1,r=t.length;++e<r;){var u=t[e];n[u]=ft(n[u],1,null,null,n)}return n},Z.bindKey=function(n,t){return 2<arguments.length?ft(t,19,Be.call(arguments,2),null,n):ft(t,3,null,null,n)},Z.chain=function(n){return n=new nt(n),n.__chain__=!0,n},Z.compact=function(n){for(var t=-1,e=n?n.length:0,r=[];++t<e;){var u=n[t];u&&r.push(u)}return r},Z.compose=function(){for(var n=arguments,t=n.length;t--;)if(!mt(n[t]))throw new oe;\r\nreturn function(){for(var t=arguments,e=n.length;e--;)t=[n[e].apply(this,t)];return t[0]}},Z.countBy=Ve,Z.createCallback=function(n,t,e){var r=typeof n;if(null==n||"function"==r)return et(n,t,e);if("object"!=r)return function(t){return t[n]};var u=Pe(n),o=u[0],a=n[o];return 1!=u.length||a!==a||bt(a)?function(t){for(var e=u.length,r=!1;e--&&(r=ut(t[u[e]],n[u[e]],null,!0)););return r}:function(n){return n=n[o],a===n&&(0!==a||1/a==1/n)}},Z.curry=function(n,t){return t=typeof t=="number"?t:+t||n.length,ft(n,4,null,null,null,t)\r\n},Z.debounce=Mt,Z.defaults=G,Z.defer=Ut,Z.delay=function(n,t){if(!mt(n))throw new oe;var e=Be.call(arguments,2);return de(function(){n.apply(h,e)},t)},Z.difference=$t,Z.filter=xt,Z.flatten=function(n,t,e,r){return typeof t!="boolean"&&null!=t&&(e=(r=e)&&r[t]===n?null:t,t=!1),null!=e&&(n=Nt(n,e,r)),rt(n,t)},Z.forEach=Ot,Z.forEachRight=It,Z.forIn=_,Z.forInRight=function(n,t,e){var r=[];_(n,function(n,t){r.push(t,n)});var u=r.length;for(t=et(t,e,3);u--&&false!==t(r[u--],r[u],n););return n},Z.forOwn=y,Z.forOwnRight=ht,Z.functions=gt,Z.groupBy=Ge,Z.indexBy=He,Z.initial=function(n,t,e){var r=0,u=n?n.length:0;\r\nif(typeof t!="number"&&null!=t){var o=u;for(t=Z.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else r=null==t||e?1:t||r;return s(n,0,Re(Se(0,u-r),u))},Z.intersection=function(e){for(var r=arguments,u=r.length,a=-1,f=i(),l=-1,s=ct(),v=e?e.length:0,h=[],g=i();++a<u;){var y=r[a];f[a]=s===n&&(y?y.length:0)>=d&&o(a?r[a]:g)}n:for(;++l<v;){var m=f[0],y=e[l];if(0>(m?t(m,y):s(g,y))){for(a=u,(m||g).push(y);--a;)if(m=f[a],0>(m?t(m,y):s(r[a],y)))continue n;h.push(y)}}for(;u--;)(m=f[u])&&p(m);return c(f),c(g),h},Z.invert=yt,Z.invoke=function(n,t){var e=Be.call(arguments,2),r=-1,u=typeof t=="function",o=n?n.length:0,a=Qt(typeof o=="number"?o:0);\r\nreturn Ot(n,function(n){a[++r]=(u?t:n[t]).apply(n,e)}),a},Z.keys=Pe,Z.map=Nt,Z.max=Et,Z.memoize=function(n,t){function e(){var r=e.cache,u=t?t.apply(this,arguments):b+arguments[0];return ge.call(r,u)?r[u]:r[u]=n.apply(this,arguments)}if(!mt(n))throw new oe;return e.cache={},e},Z.merge=function(n){var t=arguments,e=2;if(!bt(n))return n;if("number"!=typeof t[2]&&(e=t.length),3<e&&"function"==typeof t[e-2])var r=et(t[--e-1],t[e--],2);else 2<e&&"function"==typeof t[e-1]&&(r=t[--e]);for(var t=Be.call(arguments,1,e),u=-1,o=i(),a=i();++u<e;)ot(n,t[u],r,o,a);\r\nreturn c(o),c(a),n},Z.min=function(n,t,e){var u=1/0,o=u;if(!t&&ze(n)){e=-1;for(var a=n.length;++e<a;){var i=n[e];i<o&&(o=i)}}else t=!t&&_t(n)?r:Z.createCallback(t,e,3),Ot(n,function(n,e,r){e=t(n,e,r),e<u&&(u=e,o=n)});return o},Z.omit=function(n,t,e){var r=ct(),u=typeof t=="function",o={};if(u)t=Z.createCallback(t,e,3);else var a=rt(arguments,!0,!1,1);return _(n,function(n,e,i){(u?!t(n,e,i):0>r(a,e))&&(o[e]=n)}),o},Z.once=function(n){var t,e;if(!mt(n))throw new oe;return function(){return t?e:(t=!0,e=n.apply(this,arguments),n=null,e)\r\n}},Z.pairs=function(n){for(var t=-1,e=Pe(n),r=e.length,u=Qt(r);++t<r;){var o=e[t];u[t]=[o,n[o]]}return u},Z.partial=function(n){return ft(n,16,Be.call(arguments,1))},Z.partialRight=function(n){return ft(n,32,null,Be.call(arguments,1))},Z.pick=function(n,t,e){var r={};if(typeof t!="function")for(var u=-1,o=rt(arguments,!0,!1,1),a=bt(n)?o.length:0;++u<a;){var i=o[u];i in n&&(r[i]=n[i])}else t=Z.createCallback(t,e,3),_(n,function(n,e,u){t(n,e,u)&&(r[e]=n)});return r},Z.pluck=St,Z.pull=function(n){for(var t=arguments,e=0,r=t.length,u=n?n.length:0;++e<r;)for(var o=-1,a=t[e];++o<u;)n[o]===a&&(_e.call(n,o--,1),u--);\r\nreturn n},Z.range=function(n,t,e){n=+n||0,e=typeof e=="number"?e:+e||1,null==t&&(t=n,n=0);var r=-1;t=Se(0,ce((t-n)/(e||1)));for(var u=Qt(t);++r<t;)u[r]=n,n+=e;return u},Z.reject=function(n,t,e){return t=Z.createCallback(t,e,3),xt(n,function(n,e,r){return!t(n,e,r)})},Z.remove=function(n,t,e){var r=-1,u=n?n.length:0,o=[];for(t=Z.createCallback(t,e,3);++r<u;)e=n[r],t(e,r,n)&&(o.push(e),_e.call(n,r--,1),u--);return o},Z.rest=Wt,Z.shuffle=Dt,Z.sortBy=function(n,t,e){var r=-1,o=n?n.length:0,a=Qt(typeof o=="number"?o:0);\r\nfor(t=Z.createCallback(t,e,3),Ot(n,function(n,e,u){var o=a[++r]=f();o.m=t(n,e,u),o.n=r,o.o=n}),o=a.length,a.sort(u);o--;)n=a[o],a[o]=n.o,p(n);return a},Z.tap=function(n,t){return t(n),n},Z.throttle=function(n,t,e){var r=!0,u=!0;if(!mt(n))throw new oe;return false===e?r=!1:bt(e)&&(r="leading"in e?e.leading:r,u="trailing"in e?e.trailing:u),M.leading=r,M.maxWait=t,M.trailing=u,Mt(n,t,M)},Z.times=function(n,t,e){n=-1<(n=+n)?n:0;var r=-1,u=Qt(n);for(t=et(t,e,1);++r<n;)u[r]=t(r);return u},Z.toArray=function(n){return n&&typeof n.length=="number"?s(n):wt(n)\r\n},Z.transform=function(n,t,e,r){var u=ze(n);return t=et(t,r,4),null==e&&(u?e=[]:(r=n&&n.constructor,e=bt(r&&r.prototype)?Ce(r&&r.prototype):{})),(u?Ot:y)(n,function(n,r,u){return t(e,n,r,u)}),e},Z.union=function(){return at(rt(arguments,!0,!0))},Z.uniq=zt,Z.values=wt,Z.where=xt,Z.without=function(n){return $t(n,Be.call(arguments,1))},Z.wrap=function(n,t){if(!mt(t))throw new oe;return function(){var e=[n];return me.apply(e,arguments),t.apply(this,e)}},Z.zip=Pt,Z.zipObject=Kt,Z.collect=Nt,Z.drop=Wt,Z.each=Ot,Z.b=It,Z.extend=J,Z.methods=gt,Z.object=Kt,Z.select=xt,Z.tail=Wt,Z.unique=zt,Z.unzip=Pt,Gt(Z),Z.clone=function(n,t,e,r){return typeof t!="boolean"&&null!=t&&(r=e,e=t,t=!1),tt(n,t,typeof e=="function"&&et(e,r,1))\r\n},Z.cloneDeep=function(n,t,e){return tt(n,!0,typeof t=="function"&&et(t,e,1))},Z.contains=jt,Z.escape=function(n){return null==n?"":ue(n).replace(Ue,lt)},Z.every=kt,Z.find=Ct,Z.findIndex=function(n,t,e){var r=-1,u=n?n.length:0;for(t=Z.createCallback(t,e,3);++r<u;)if(t(n[r],r,n))return r;return-1},Z.findKey=function(n,t,e){var r;return t=Z.createCallback(t,e,3),y(n,function(n,e,u){return t(n,e,u)?(r=e,!1):void 0}),r},Z.findLast=function(n,t,e){var r;return t=Z.createCallback(t,e,3),It(n,function(n,e,u){return t(n,e,u)?(r=n,!1):void 0\r\n}),r},Z.findLastIndex=function(n,t,e){var r=n?n.length:0;for(t=Z.createCallback(t,e,3);r--;)if(t(n[r],r,n))return r;return-1},Z.findLastKey=function(n,t,e){var r;return t=Z.createCallback(t,e,3),ht(n,function(n,e,u){return t(n,e,u)?(r=e,!1):void 0}),r},Z.has=function(n,t){return n?ge.call(n,t):!1},Z.identity=Vt,Z.indexOf=Tt,Z.isArguments=vt,Z.isArray=ze,Z.isBoolean=function(n){return true===n||false===n||we.call(n)==F},Z.isDate=function(n){return n?typeof n=="object"&&we.call(n)==T:!1},Z.isElement=function(n){return n?1===n.nodeType:!1\r\n},Z.isEmpty=function(n){var t=!0;if(!n)return t;var e=we.call(n),r=n.length;return e==$||e==K||e==B||e==z&&typeof r=="number"&&mt(n.splice)?!r:(y(n,function(){return t=!1}),t)},Z.isEqual=function(n,t,e,r){return ut(n,t,typeof e=="function"&&et(e,r,2))},Z.isFinite=function(n){return Ie(n)&&!Ne(parseFloat(n))},Z.isFunction=mt,Z.isNaN=function(n){return dt(n)&&n!=+n},Z.isNull=function(n){return null===n},Z.isNumber=dt,Z.isObject=bt,Z.isPlainObject=g,Z.isRegExp=function(n){return n?typeof n=="object"&&we.call(n)==P:!1\r\n},Z.isString=_t,Z.isUndefined=function(n){return typeof n=="undefined"},Z.lastIndexOf=function(n,t,e){var r=n?n.length:0;for(typeof e=="number"&&(r=(0>e?Se(0,r+e):Re(e,r-1))+1);r--;)if(n[r]===t)return r;return-1},Z.mixin=Gt,Z.noConflict=function(){return e._=fe,this},Z.parseInt=Je,Z.random=Ht,Z.reduce=Rt,Z.reduceRight=At,Z.result=function(n,t){if(n){var e=n[t];return mt(e)?n[t]():e}},Z.runInContext=v,Z.size=function(n){var t=n?n.length:0;return typeof t=="number"?t:Pe(n).length},Z.some=Bt,Z.sortedIndex=qt,Z.template=function(n,t,e){var r=Z.templateSettings;\r\nn||(n=""),e=G({},e,r);var u,o=G({},e.imports,r.imports),r=Pe(o),o=wt(o),i=0,f=e.interpolate||S,l="__p+=\'",f=re((e.escape||S).source+"|"+f.source+"|"+(f===N?C:S).source+"|"+(e.evaluate||S).source+"|$","g");n.replace(f,function(t,e,r,o,f,c){return r||(r=o),l+=n.slice(i,c).replace(A,a),e&&(l+="\'+__e("+e+")+\'"),f&&(u=!0,l+="\';"+f+";__p+=\'"),r&&(l+="\'+((__t=("+r+"))==null?\'\':__t)+\'"),i=c+t.length,t}),l+="\';\\n",f=e=e.variable,f||(e="obj",l="with("+e+"){"+l+"}"),l=(u?l.replace(j,""):l).replace(k,"$1").replace(x,"$1;"),l="function("+e+"){"+(f?"":e+"||("+e+"={});")+"var __t,__p=\'\',__e=_.escape"+(u?",__j=Array.prototype.join;function print(){__p+=__j.call(arguments,\'\')}":";")+l+"return __p}";\r\ntry{var c=Zt(r,"return "+l).apply(h,o)}catch(p){throw p.source=l,p}return t?c(t):(c.source=l,c)},Z.unescape=function(n){return null==n?"":ue(n).replace(Me,st)},Z.uniqueId=function(n){var t=++m;return ue(null==n?"":n)+t},Z.all=kt,Z.any=Bt,Z.detect=Ct,Z.findWhere=Ct,Z.foldl=Rt,Z.foldr=At,Z.include=jt,Z.inject=Rt,y(Z,function(n,t){Z.prototype[t]||(Z.prototype[t]=function(){var t=[this.__wrapped__],e=this.__chain__;return me.apply(t,arguments),t=n.apply(Z,t),e?new nt(t,e):t})}),Z.first=Ft,Z.last=function(n,t,e){var r=0,u=n?n.length:0;\r\nif(typeof t!="number"&&null!=t){var o=u;for(t=Z.createCallback(t,e,3);o--&&t(n[o],o,n);)r++}else if(r=t,null==r||e)return n?n[u-1]:h;return s(n,Se(0,u-r))},Z.sample=function(n,t,e){var r=n?n.length:0;return typeof r!="number"&&(n=wt(n)),null==t||e?n?n[Ht(r-1)]:h:(n=Dt(n),n.length=Re(Se(0,t),n.length),n)},Z.take=Ft,Z.head=Ft,y(Z,function(n,t){var e="sample"!==t;Z.prototype[t]||(Z.prototype[t]=function(t,r){var u=this.__chain__,o=n(this.__wrapped__,t,r);return u||null!=t&&(!r||e&&typeof t=="function")?new nt(o,u):o\r\n})}),Z.VERSION="2.2.0",Z.prototype.chain=function(){return this.__chain__=!0,this},Z.prototype.toString=function(){return ue(this.__wrapped__)},Z.prototype.value=Jt,Z.prototype.valueOf=Jt,Ot(["join","pop","shift"],function(n){var t=ae[n];Z.prototype[n]=function(){var n=this.__chain__,e=t.apply(this.__wrapped__,arguments);return n?new nt(e,n):e}}),Ot(["push","reverse","sort","unshift"],function(n){var t=ae[n];Z.prototype[n]=function(){return t.apply(this.__wrapped__,arguments),this}}),Ot(["concat","slice","splice"],function(n){var t=ae[n];\r\nZ.prototype[n]=function(){return new nt(t.apply(this.__wrapped__,arguments),this.__chain__)}}),Z}var h,g=[],y=[],m=0,b=+new Date+"",d=75,_=40,w=" \\t\\x0B\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",j=/\\b__p\\+=\'\';/g,k=/\\b(__p\\+=)\'\'\\+/g,x=/(__e\\(.*?\\)|\\b__t\\))\\+\'\';/g,C=/\\$\\{([^\\\\}]*(?:\\\\.[^\\\\}]*)*)\\}/g,O=/\\w*$/,I=/^function[ \\n\\r\\t]+\\w/,N=/<%=([\\s\\S]+?)%>/g,E=RegExp("^["+w+"]*0+(?=.$)"),S=/($^)/,R=/\\bthis\\b/,A=/[\'\\n\\r\\t\\u2028\\u2029\\\\]/g,D="Array Boolean Date Function Math Number Object RegExp String _ attachEvent clearTimeout isFinite isNaN parseInt setImmediate setTimeout".split(" "),B="[object Arguments]",$="[object Array]",F="[object Boolean]",T="[object Date]",W="[object Function]",q="[object Number]",z="[object Object]",P="[object RegExp]",K="[object String]",L={};\r\nL[W]=!1,L[B]=L[$]=L[F]=L[T]=L[q]=L[z]=L[P]=L[K]=!0;var M={leading:!1,maxWait:0,trailing:!1},U={configurable:!1,enumerable:!1,value:null,writable:!1},V={"boolean":!1,"function":!0,object:!0,number:!1,string:!1,undefined:!1},G={"\\\\":"\\\\","\'":"\'","\\n":"n","\\r":"r","\\t":"t","\\u2028":"u2028","\\u2029":"u2029"},H=V[typeof window]&&window||this,J=V[typeof exports]&&exports&&!exports.nodeType&&exports,Q=V[typeof module]&&module&&!module.nodeType&&module,X=Q&&Q.exports===J&&J,Y=v();typeof define=="function"&&typeof define.amd=="object"&&define.amd&& define(\'thirdparty/lodash\',[],function(){return Y\r\n})}).call(this);\n//# sourceURL=/thirdparty/lodash.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, window */\r\n\r\ndefine(\'utils/UrlParams\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n    \r\n    /**\r\n     * Convert between URL querystring and name/value pairs. Decodes and encodes URL parameters.\r\n     */\r\n    function UrlParams() {\r\n        this._store = {};\r\n    }\r\n    \r\n    /**\r\n     * Parse the window location by default. Optionally specify a URL to parse.\r\n     * @param {string} url\r\n     */\r\n    UrlParams.prototype.parse = function (url) {\r\n        var queryString = "",\r\n            urlParams,\r\n            p,\r\n            self = this;\r\n        \r\n        self._store = {};\r\n        \r\n        if (!url) {\r\n            queryString = window.document.location.search.substring(1);\r\n        } else if (url.indexOf("?") !== -1) {\r\n            queryString = url.substring(url.indexOf("?") + 1);\r\n        }\r\n        \r\n        queryString = queryString.trimRight();\r\n        \r\n        if (queryString) {\r\n            urlParams = queryString.split("&");\r\n            \r\n            urlParams.forEach(function (param) {\r\n                p = param.split("=");\r\n                p[1] = p[1] || "";\r\n                self._store[decodeURIComponent(p[0])] = decodeURIComponent(p[1]);\r\n            });\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Store a name/value string pair\r\n     * @param {!string} name\r\n     * @param {!string} value\r\n     */\r\n    UrlParams.prototype.put = function (name, value) {\r\n        this._store[name] = value;\r\n    };\r\n    \r\n    /**\r\n     * Retrieve a value by name\r\n     * @param {!string} name\r\n     * @return {string}\r\n     */\r\n    UrlParams.prototype.get = function (name) {\r\n        return this._store[name];\r\n    };\r\n    \r\n    /**\r\n     * Remove a name/value string pair\r\n     * @param {!string} name\r\n     */\r\n    UrlParams.prototype.remove = function (name) {\r\n        delete this._store[name];\r\n    };\r\n    \r\n    /**\r\n     * Returns true if the parameter list is empty, else returns false.\r\n     * @return {boolean}\r\n     */\r\n    UrlParams.prototype.isEmpty = function (name) {\r\n        return _.isEmpty(this._store);\r\n    };\r\n    \r\n    /**\r\n     * Encode name/value pairs as URI components.\r\n     * @return {string}\r\n     */\r\n    UrlParams.prototype.toString = function () {\r\n        var strs = [],\r\n            self = this;\r\n        \r\n        _.forEach(self._store, function (value, key) {\r\n            strs.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));\r\n        });\r\n        \r\n        return strs.join("&");\r\n    };\r\n    \r\n    // Define public API\r\n    exports.UrlParams = UrlParams;\r\n});\n//# sourceURL=/utils/UrlParams.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\n/**\r\n * Defines hooks to assist with module initialization.\r\n *\r\n * This module defines 2 methods for client modules to attach callbacks:\r\n *    - htmlReady - When the main application template is rendered\r\n *    - extensionsRead - When the extension manager has loaded all extensions\r\n *    - appReady - When Brackets completes loading all modules and extensions\r\n *\r\n * These are *not* jQuery events. Each method is similar to $(document).ready\r\n * in that it will call the handler immediately if brackets is already done\r\n * loading.\r\n */\r\ndefine(\'utils/AppInit\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    /*\r\n     * Fires when the base htmlContent/main-view.html is loaded\r\n     * @type {string}\r\n     * @const\r\n     */\r\n    var HTML_READY  = "htmlReady";\r\n\r\n    /*\r\n     * Fires when all extensions are loaded\r\n     * @type {string}\r\n     * @const\r\n     */\r\n    var APP_READY   = "appReady";\r\n    \r\n    /*\r\n     * Fires after extensions have been loaded\r\n     * @type {string}\r\n     * @const\r\n     */\r\n    var EXTENSIONS_LOADED = "extensionsLoaded";\r\n\r\n    /*\r\n     * Map of each state\'s trigger\r\n     * @type {Object.<string, boolean>}\r\n     * @private\r\n     */\r\n    var _status      = { HTML_READY : false, APP_READY : false, EXTENSIONS_LOADED: false };\r\n    \r\n    /*\r\n     * Map of callbacks to states\r\n     * @type {Object.<string, Array.<function()>>}\r\n     * @private\r\n     */\r\n    var _callbacks   = {};\r\n\r\n    _callbacks[HTML_READY]        = [];\r\n    _callbacks[APP_READY]         = [];\r\n    _callbacks[EXTENSIONS_LOADED] = [];\r\n\r\n    \r\n    /*\r\n     * calls the specified handler inside a try/catch handler\r\n     * @param {function()} handler - the callback to call\r\n     * @private\r\n     */\r\n    function _callHandler(handler) {\r\n        try {\r\n            // TODO (issue 1034): We *could* use a $.Deferred for this, except deferred objects enter a broken\r\n            // state if any resolution callback throws an exception. Since third parties (e.g. extensions) may\r\n            // add callbacks to this, we need to be robust to exceptions\r\n            handler();\r\n        } catch (e) {\r\n            console.error("Exception when calling a \'brackets done loading\' handler:");\r\n            console.log(e.stack);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * dispatches the event by calling all handlers registered for that type\r\n     * @param {string} type - the event type to dispatch (APP_READY, EXTENSIONS_READY, HTML_READY)\r\n     * @private\r\n     */\r\n    function _dispatchReady(type) {\r\n        var i,\r\n            myHandlers = _callbacks[type];\r\n\r\n        // mark this status complete\r\n        _status[type] = true;\r\n\r\n        for (i = 0; i < myHandlers.length; i++) {\r\n            _callHandler(myHandlers[i]);\r\n        }\r\n\r\n        // clear all callbacks after being called\r\n        _callbacks[type] = [];\r\n    }\r\n\r\n    /*\r\n     * adds a callback to the list of functions to call for the specified event type\r\n     * @param {string} type - the event type to dispatch (APP_READY, EXTENSIONS_READY, HTML_READY)\r\n     * @param {function} handler - callback funciton to call when the event is triggered\r\n     * @private\r\n     */\r\n    function _addListener(type, handler) {\r\n        if (_status[type]) {\r\n            _callHandler(handler);\r\n        } else {\r\n            _callbacks[type].push(handler);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a callback for the ready hook. Handlers are called after\r\n     * htmlReady is done, the initial project is loaded, and all extensions are\r\n     * loaded.\r\n     * @param {function} handler - callback function to call when the event is fired\r\n     */\r\n    function appReady(handler) {\r\n        _addListener(APP_READY, handler);\r\n    }\r\n\r\n    /**\r\n     * Adds a callback for the htmlReady hook. Handlers are called after the\r\n     * main application html template is rendered.\r\n     * @param {function} handler - callback function to call when the event is fired\r\n     */\r\n    function htmlReady(handler) {\r\n        _addListener(HTML_READY, handler);\r\n    }\r\n    \r\n    /**\r\n     * Adds a callback for the extensionsLoaded hook. Handlers are called after the\r\n     * extensions have been loaded\r\n     * @param {function} handler - callback function to call when the event is fired\r\n     */\r\n    function extensionsLoaded(handler) {\r\n        _addListener(EXTENSIONS_LOADED, handler);\r\n    }\r\n\r\n    // Public API\r\n    exports.appReady = appReady;\r\n    exports.htmlReady = htmlReady;\r\n    exports.extensionsLoaded = extensionsLoaded;\r\n    \r\n    exports.HTML_READY = HTML_READY;\r\n    exports.APP_READY = APP_READY;\r\n    exports.EXTENSIONS_LOADED = EXTENSIONS_LOADED;\r\n\r\n    // Unit Test API\r\n    exports._dispatchReady = _dispatchReady;\r\n});\n//# sourceURL=/utils/AppInit.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n /**\r\n  * Manages global application commands that can be called from menu items, key bindings, or subparts\r\n  * of the application.\r\n  *\r\n  * This module dispatches these event(s):\r\n  *    - commandRegistered  -- when a new command is registered\r\n  *    - beforeExecuteCommand -- before dispatching a command\r\n  */\r\ndefine(\'command/CommandManager\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    /**\r\n     * Map of all registered global commands\r\n     * @type {Object.<commandID: string, Command>}\r\n     */\r\n    var _commands = {};\r\n    \r\n    /**\r\n     * Temporary copy of commands map for restoring after testing\r\n     * TODO (issue #1039): implement separate require contexts for unit tests\r\n     * @type {Object.<commandID: string, Command>}\r\n     */\r\n    var _commandsOriginal = {};\r\n    \r\n    /**\r\n     * Events:\r\n     * - enabledStateChange\r\n     * - checkedStateChange\r\n     * - keyBindingAdded\r\n     * - keyBindingRemoved\r\n     *\r\n     * @constructor\r\n     * @private\r\n     * @param {string} name - text that will be displayed in the UI to represent command\r\n     * @param {string} id\r\n     * @param {function} commandFn - the function that is called when the command is executed.\r\n     *\r\n     * TODO: where should this be triggered, The Command or Exports?\r\n     */\r\n    function Command(name, id, commandFn) {\r\n        this._name = name;\r\n        this._id = id;\r\n        this._commandFn = commandFn;\r\n        this._checked = undefined;\r\n        this._enabled = true;\r\n    }\r\n\r\n    /**\r\n     * Get command id\r\n     * @return {string}\r\n     */\r\n    Command.prototype.getID = function () {\r\n        return this._id;\r\n    };\r\n\r\n    /**\r\n     * Executes the command. Additional arguments are passed to the executing function\r\n     *\r\n     * @return {$.Promise} a jQuery promise that will be resolved when the command completes.\r\n     */\r\n    Command.prototype.execute = function () {\r\n        if (!this._enabled) {\r\n            return (new $.Deferred()).reject().promise();\r\n        }\r\n        \r\n        var result = this._commandFn.apply(this, arguments);\r\n        if (!result) {\r\n            // If command does not return a promise, assume that it handled the\r\n            // command and return a resolved promise\r\n            return (new $.Deferred()).resolve().promise();\r\n        } else {\r\n            return result;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Is command enabled?\r\n     * @return {boolean}\r\n     */\r\n    Command.prototype.getEnabled = function () {\r\n        return this._enabled;\r\n    };\r\n\r\n    /**\r\n     * Sets enabled state of Command and dispatches "enabledStateChange"\r\n     * when the enabled state changes.\r\n     * @param {boolean} enabled\r\n     */\r\n    Command.prototype.setEnabled = function (enabled) {\r\n        var changed = this._enabled !== enabled;\r\n        this._enabled = enabled;\r\n\r\n        if (changed) {\r\n            $(this).triggerHandler("enabledStateChange");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets enabled state of Command and dispatches "checkedStateChange"\r\n     * when the enabled state changes.\r\n     * @param {boolean} checked\r\n     */\r\n    Command.prototype.setChecked = function (checked) {\r\n        var changed = this._checked !== checked;\r\n        this._checked = checked;\r\n\r\n        if (changed) {\r\n            $(this).triggerHandler("checkedStateChange");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Is command checked?\r\n     * @return {boolean}\r\n     */\r\n    Command.prototype.getChecked = function () {\r\n        return this._checked;\r\n    };\r\n\r\n    /**\r\n     * Sets the name of the Command and dispatches "nameChange" so that\r\n     * UI that reflects the command name can update.\r\n     *\r\n     * Note, a Command name can appear in either HTML or native UI\r\n     * so HTML tags should not be used. To add a Unicode character,\r\n     * use \\uXXXX instead of an HTML entity.\r\n     *\r\n     * @param {string} name\r\n     */\r\n    Command.prototype.setName = function (name) {\r\n        var changed = this._name !== name;\r\n        this._name = name;\r\n\r\n        if (changed) {\r\n            $(this).triggerHandler("nameChange");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Get command name\r\n     * @return {string}\r\n     */\r\n    Command.prototype.getName = function () {\r\n        return this._name;\r\n    };\r\n\r\n\r\n\r\n    /**\r\n     * Registers a global command.\r\n     * @param {string} name - text that will be displayed in the UI to represent command\r\n     * @param {string} id - unique identifier for command.\r\n     *      Core commands in Brackets use a simple command title as an id, for example "open.file".\r\n     *      Extensions should use the following format: "author.myextension.mycommandname".\r\n     *      For example, "lschmitt.csswizard.format.css".\r\n     * @param {function(...)} commandFn - the function to call when the command is executed. Any arguments passed to\r\n     *     execute() (after the id) are passed as arguments to the function. If the function is asynchronous,\r\n     *     it must return a jQuery promise that is resolved when the command completes. Otherwise, the\r\n     *     CommandManager will assume it is synchronous, and return a promise that is already resolved.\r\n     * @return {?Command}\r\n     */\r\n    function register(name, id, commandFn) {\r\n        if (_commands[id]) {\r\n            console.log("Attempting to register an already-registered command: " + id);\r\n            return null;\r\n        }\r\n        if (!name || !id || !commandFn) {\r\n            console.error("Attempting to register a command with a missing name, id, or command function:" + name + " " + id);\r\n            return null;\r\n        }\r\n\r\n        var command = new Command(name, id, commandFn);\r\n        _commands[id] = command;\r\n        \r\n        $(exports).triggerHandler("commandRegistered", [command]);\r\n        \r\n        return command;\r\n    }\r\n\r\n    /**\r\n     * Registers a global internal only command.\r\n     * @param {string} id - unique identifier for command.\r\n     *      Core commands in Brackets use a simple command title as an id, for example "app.abort_quit".\r\n     *      Extensions should use the following format: "author.myextension.mycommandname".\r\n     *      For example, "lschmitt.csswizard.format.css".\r\n     * @param {function(...)} commandFn - the function to call when the command is executed. Any arguments passed to\r\n     *     execute() (after the id) are passed as arguments to the function. If the function is asynchronous,\r\n     *     it must return a jQuery promise that is resolved when the command completes. Otherwise, the\r\n     *     CommandManager will assume it is synchronous, and return a promise that is already resolved.\r\n     * @return {?Command}\r\n     */\r\n    function registerInternal(id, commandFn) {\r\n        if (_commands[id]) {\r\n            console.log("Attempting to register an already-registered command: " + id);\r\n            return null;\r\n        }\r\n        if (!id || !commandFn) {\r\n            console.error("Attempting to register an internal command with a missing id, or command function: " + id);\r\n            return null;\r\n        }\r\n\r\n        var command = new Command(null, id, commandFn);\r\n        _commands[id] = command;\r\n        \r\n        $(exports).triggerHandler("commandRegistered", [command]);\r\n        \r\n        return command;\r\n    }\r\n    \r\n    /**\r\n     * Clear all commands for unit testing, but first make copy of commands so that\r\n     * they can be restored afterward\r\n     */\r\n    function _testReset() {\r\n        _commandsOriginal = _commands;\r\n        _commands = {};\r\n    }\r\n\r\n    /**\r\n     * Restore original commands after test and release copy\r\n     */\r\n    function _testRestore() {\r\n        _commands = _commandsOriginal;\r\n        _commandsOriginal = {};\r\n    }\r\n    \r\n    /**\r\n     * Retrieves a Command object by id\r\n     * @param {string} id\r\n     * @return {Command}\r\n     */\r\n    function get(id) {\r\n        return _commands[id];\r\n    }\r\n    \r\n    /**\r\n     * Returns the ids of all registered commands\r\n     * @return {Array.<string>}\r\n     */\r\n    function getAll() {\r\n        return Object.keys(_commands);\r\n    }\r\n\r\n    /**\r\n     * Looks up and runs a global command. Additional arguments are passed to the command.\r\n     *\r\n     * @param {string} id The ID of the command to run.\r\n     * @return {$.Promise} a jQuery promise that will be resolved when the command completes.\r\n     */\r\n    function execute(id) {\r\n        var command = _commands[id];\r\n        \r\n        if (command) {\r\n            try {\r\n                $(exports).triggerHandler("beforeExecuteCommand", id);\r\n            } catch (err) {\r\n                console.error(err);\r\n            }\r\n            \r\n            return command.execute.apply(command, Array.prototype.slice.call(arguments, 1));\r\n        } else {\r\n            return (new $.Deferred()).reject().promise();\r\n        }\r\n    }\r\n\r\n    // Define public API\r\n    exports.register            = register;\r\n    exports.registerInternal    = registerInternal;\r\n    exports.execute             = execute;\r\n    exports.get                 = get;\r\n    exports.getAll              = getAll;\r\n    exports._testReset          = _testReset;\r\n    exports._testRestore        = _testRestore;\r\n});\r\n\n//# sourceURL=/command/CommandManager.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*global define, console, $ */\r\n\r\n/**\r\n *  Utilities functions to display deprecation warning in the console.\r\n *\r\n */\r\ndefine(\'utils/DeprecationWarning\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var displayedWarnings = {};\r\n\r\n    /**\r\n     * Trim the stack so that it does not have the call to this module,\r\n     * and all the calls to require.js to load the extension that shows \r\n     * this deprecation warning.\r\n     */\r\n    function _trimStack(stack) {\r\n        var indexOfFirstRequireJSline;\r\n        \r\n        // Remove everything in the stack up to the end of the line that shows this module file path\r\n        stack = stack.substr(stack.indexOf(")\\n") + 2);\r\n        \r\n        // Find the very first line of require.js in the stack if the call is from an extension.\r\n        // Remove all those lines from the call stack.\r\n        indexOfFirstRequireJSline = stack.indexOf("requirejs/require.js");\r\n        if (indexOfFirstRequireJSline !== -1) {\r\n            indexOfFirstRequireJSline = stack.lastIndexOf(")", indexOfFirstRequireJSline) + 1;\r\n            stack = stack.substr(0, indexOfFirstRequireJSline);\r\n        }\r\n        \r\n        return stack;\r\n    }\r\n    \r\n    /**\r\n     * Show deprecation warning with the call stack if it \r\n     * has never been displayed before.\r\n     * @param {!string} message The deprecation message to be displayed.\r\n     * @param {boolean=} oncePerCaller If true, displays the message once for each unique call location.\r\n     *     If false (the default), only displays the message once no matter where it\'s called from.\r\n     *     Note that setting this to true can cause a slight performance hit (because it has to generate\r\n     *     a stack trace), so don\'t set this for functions that you expect to be called from performance-\r\n     *     sensitive code (e.g. tight loops).\r\n     */\r\n    function deprecationWarning(message, oncePerCaller) {\r\n        // If oncePerCaller isn\'t set, then only show the message once no matter who calls it. \r\n        if (!message || (!oncePerCaller && displayedWarnings[message])) {\r\n            return;\r\n        }\r\n\r\n        // Don\'t show the warning again if we\'ve already gotten it from the current caller.\r\n        // The true caller location is the fourth line in the stack trace:\r\n        // * 0 is the word "Error"\r\n        // * 1 is this function\r\n        // * 2 is the caller of this function (the one throwing the deprecation warning)\r\n        // * 3 is the actual caller of the deprecated function.\r\n        var stack = new Error().stack,\r\n            callerLocation = stack.split("\\n")[3];\r\n        if (oncePerCaller && displayedWarnings[message] && displayedWarnings[message][callerLocation]) {\r\n            return;\r\n        }\r\n        \r\n        console.warn(message + "\\n" + _trimStack(stack));\r\n        if (!displayedWarnings[message]) {\r\n            displayedWarnings[message] = {};\r\n        }\r\n        displayedWarnings[message][callerLocation] = true;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Counts the number of event handlers listening for the specified event on the specified object\r\n     * @param {!Object} object - the object with the old event to dispatch\r\n     * @param {!string} name - the name of the  event\r\n     * @return {!number} count of event handlers\r\n     */\r\n    function getEventHandlerCount(object, name) {\r\n        var count = 0,\r\n            events = $._data(object, "events");\r\n        \r\n        // If there are there any listeners then display a deprecation warning\r\n        if (events && events.hasOwnProperty(name)) {\r\n            var listeners = events[name];\r\n            count = listeners.length;\r\n            \r\n            if (listeners.hasOwnProperty("delegateCount")) {\r\n                // we need to subtract 1 since delegateCount is counted \r\n                //  in the length computed above.\r\n                count += (listeners.delegateCount - 1);\r\n            }\r\n        }\r\n        \r\n        return count;\r\n    }\r\n    \r\n    /**\r\n     * Show a deprecation warning if there are listeners for the event\r\n     * \r\n     * ```\r\n     *    DeprecationWarning.deprecateEvent($(exports), \r\n     *                                      $(MainViewManager), \r\n     *                                      "workingSetAdd", \r\n     *                                      "workingSetAdd", \r\n     *                                      "DocumentManager.workingSetAdd", \r\n     *                                      "MainViewManager.workingSetAdd");\r\n     * ```\r\n     *\r\n     * @param {Object} outbound - the object with the old event to dispatch\r\n     * @param {Object} inbound - the object with the new event to map to the old event\r\n     * @param {string} oldEventName - the name of the old event\r\n     * @param {string} newEventName - the name of the new event\r\n     * @param {string=} canonicalOutboundName - the canonical name of the old event\r\n     * @param {string=} canonicalInboundName - the canonical name of the new event  \r\n     */\r\n    function deprecateEvent(outbound, inbound, oldEventName, newEventName, canonicalOutboundName, canonicalInboundName) {\r\n        // create an event handler for the new event to listen for \r\n        $(inbound).on(newEventName, function () {\r\n            // Get the jQuery event data from the outbound object -- usually the module\'s exports\r\n            var listenerCount = getEventHandlerCount(outbound, oldEventName);\r\n            if (listenerCount > 0) {\r\n                var message = "The Event " + (canonicalOutboundName || oldEventName) + " has been deprecated. Use " + (canonicalInboundName || newEventName) + " instead.";\r\n                // We only want to show the deprecation warning once\r\n                if (!displayedWarnings[message]) {\r\n                    displayedWarnings[message] = true;\r\n                    console.warn(message);\r\n                }\r\n            }\r\n\r\n            // dispatch the event even if there are no listeners just in case the jQuery data is wrong for some reason\r\n            $(outbound).trigger(oldEventName, Array.prototype.slice.call(arguments, 1));\r\n        });\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Create a deprecation warning and action for updated constants\r\n     * @param {!string} old Menu Id\r\n     * @param {!string} new Menu Id\r\n     */\r\n    function deprecateConstant(obj, oldId, newId) {\r\n        var warning     = "Use Menus." + newId + " instead of Menus." + oldId,\r\n            newValue    = obj[newId];\r\n        \r\n        Object.defineProperty(obj, oldId, {\r\n            get: function () {\r\n                deprecationWarning(warning, true);\r\n                return newValue;\r\n            }\r\n        });\r\n    }\r\n    \r\n    // Define public API\r\n    exports.deprecationWarning   = deprecationWarning;\r\n    exports.deprecateEvent       = deprecateEvent;\r\n    exports.getEventHandlerCount = getEventHandlerCount;\r\n    exports.deprecateConstant      = deprecateConstant;\r\n});\r\n\n//# sourceURL=/utils/DeprecationWarning.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\ndefine(\'command/Commands\',[\'require\',\'exports\',\'module\',\'utils/DeprecationWarning\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var DeprecationWarning = require("utils/DeprecationWarning");\r\n    \r\n    /**\r\n     * List of constants for global command IDs.\r\n     */\r\n    \r\n    // FILE\r\n    exports.FILE_NEW_UNTITLED           = "file.newDoc";                // DocumentCommandHandlers.js   handleFileNew()\r\n    exports.FILE_NEW                    = "file.newFile";               // DocumentCommandHandlers.js   handleFileNewInProject()\r\n    exports.FILE_NEW_FOLDER             = "file.newFolder";             // DocumentCommandHandlers.js   handleNewFolderInProject()\r\n    exports.FILE_OPEN                   = "file.open";                  // DocumentCommandHandlers.js   handleDocumentOpen()\r\n    exports.FILE_OPEN_FOLDER            = "file.openFolder";            // ProjectManager.js            openProject()\r\n    exports.FILE_SAVE                   = "file.save";                  // DocumentCommandHandlers.js   handleFileSave()\r\n    exports.FILE_SAVE_ALL               = "file.saveAll";               // DocumentCommandHandlers.js   handleFileSaveAll()\r\n    exports.FILE_SAVE_AS                = "file.saveAs";                // DocumentCommandHandlers.js   handleFileSaveAs()\r\n    exports.FILE_CLOSE                  = "file.close";                 // DocumentCommandHandlers.js   handleFileClose()\r\n    exports.FILE_CLOSE_ALL              = "file.close_all";             // DocumentCommandHandlers.js   handleFileCloseAll()\r\n    exports.FILE_CLOSE_LIST             = "file.close_list";            // DocumentCommandHandlers.js   handleFileCloseList()\r\n    exports.FILE_OPEN_DROPPED_FILES     = "file.openDroppedFiles";      // DragAndDrop.js               openDroppedFiles()\r\n    exports.FILE_LIVE_FILE_PREVIEW      = "file.liveFilePreview";       // LiveDevelopment/main.js      _handleGoLiveCommand()\r\n    exports.CMD_RELOAD_LIVE_PREVIEW     = "file.reloadLivePreview";     // LiveDevelopment/main.js      _handleReloadLivePreviewCommand()\r\n    exports.FILE_LIVE_HIGHLIGHT         = "file.previewHighlight";      // LiveDevelopment/main.js      _handlePreviewHighlightCommand()\r\n    exports.FILE_PROJECT_SETTINGS       = "file.projectSettings";       // ProjectManager.js            _projectSettings()\r\n    exports.FILE_RENAME                 = "file.rename";                // DocumentCommandHandlers.js   handleFileRename()\r\n    exports.FILE_DELETE                 = "file.delete";                // DocumentCommandHandlers.js   handleFileDelete()\r\n    exports.FILE_EXTENSION_MANAGER      = "file.extensionManager";      // ExtensionManagerDialog.js    _showDialog()\r\n    exports.FILE_REFRESH                = "file.refresh";               // ProjectManager.js            refreshFileTree()\r\n    exports.FILE_OPEN_PREFERENCES       = "file.openPreferences";       // PreferencesManager.js        _handleOpenPreferences()\r\n    \r\n    // File shell callbacks - string must MATCH string in native code (appshell/command_callbacks.h)\r\n    exports.FILE_CLOSE_WINDOW           = "file.close_window";          // DocumentCommandHandlers.js   handleFileCloseWindow()\r\n    exports.FILE_QUIT                   = "file.quit";                  // DocumentCommandHandlers.js   handleFileQuit()\r\n    \r\n    // EDIT\r\n    // File shell callbacks - string must MATCH string in native code (appshell/command_callbacks.h)\r\n    exports.EDIT_UNDO                   = "edit.undo";                  // EditorCommandHandlers.js     handleUndo()\r\n    exports.EDIT_REDO                   = "edit.redo";                  // EditorCommandHandlers.js     handleRedo()\r\n    exports.EDIT_CUT                    = "edit.cut";                   // EditorCommandHandlers.js     ignoreCommand()\r\n    exports.EDIT_COPY                   = "edit.copy";                  // EditorCommandHandlers.js     ignoreCommand()\r\n    exports.EDIT_PASTE                  = "edit.paste";                 // EditorCommandHandlers.js     ignoreCommand()\r\n    exports.EDIT_SELECT_ALL             = "edit.selectAll";             // EditorCommandHandlers.js     _handleSelectAll()\r\n    \r\n    exports.EDIT_SELECT_LINE            = "edit.selectLine";            // EditorCommandHandlers.js     selectLine()\r\n    exports.EDIT_SPLIT_SEL_INTO_LINES   = "edit.splitSelIntoLines";     // EditorCommandHandlers.js     splitSelIntoLines()\r\n    exports.EDIT_ADD_CUR_TO_NEXT_LINE   = "edit.addCursorToNextLine";   // EditorCommandHandlers.js     addCursorToNextLine()\r\n    exports.EDIT_ADD_CUR_TO_PREV_LINE   = "edit.addCursorToPrevLine";   // EditorCommandHandlers.js     addCursorToPrevLine()\r\n    exports.EDIT_INDENT                 = "edit.indent";                // EditorCommandHandlers.js     indentText()\r\n    exports.EDIT_UNINDENT               = "edit.unindent";              // EditorCommandHandlers.js     unindentText()\r\n    exports.EDIT_DUPLICATE              = "edit.duplicate";             // EditorCommandHandlers.js     duplicateText()\r\n    exports.EDIT_DELETE_LINES           = "edit.deletelines";           // EditorCommandHandlers.js     deleteCurrentLines()\r\n    exports.EDIT_LINE_COMMENT           = "edit.lineComment";           // EditorCommandHandlers.js     lineComment()\r\n    exports.EDIT_BLOCK_COMMENT          = "edit.blockComment";          // EditorCommandHandlers.js     blockComment()\r\n    exports.EDIT_LINE_UP                = "edit.lineUp";                // EditorCommandHandlers.js     moveLineUp()\r\n    exports.EDIT_LINE_DOWN              = "edit.lineDown";              // EditorCommandHandlers.js     moveLineDown()\r\n    exports.EDIT_OPEN_LINE_ABOVE        = "edit.openLineAbove";         // EditorCommandHandlers.js     openLineAbove()\r\n    exports.EDIT_OPEN_LINE_BELOW        = "edit.openLineBelow";         // EditorCommandHandlers.js     openLineBelow()\r\n    exports.TOGGLE_CLOSE_BRACKETS       = "edit.autoCloseBrackets";     // EditorOptionHandlers.js      _getToggler()\r\n    exports.SHOW_CODE_HINTS             = "edit.showCodeHints";         // CodeHintManager.js           _startNewSession()\r\n    \r\n    // FIND\r\n    exports.CMD_FIND                    = "cmd.find";                   // FindReplace.js               _launchFind()\r\n    exports.CMD_FIND_IN_FILES           = "cmd.findInFiles";            // FindInFilesUI.js             _showFindBar()\r\n    exports.CMD_FIND_IN_SELECTED        = "cmd.findInSelected";         // FindInFilesUI.js             _showFindBarForSubtree()\r\n    exports.CMD_FIND_IN_SUBTREE         = "cmd.findInSubtree";          // FindInFilesUI.js             _showFindBarForSubtree()\r\n    exports.CMD_FIND_NEXT               = "cmd.findNext";               // FindReplace.js               _findNext()\r\n    exports.CMD_FIND_PREVIOUS           = "cmd.findPrevious";           // FindReplace.js               _findPrevious()\r\n    exports.CMD_FIND_ALL_AND_SELECT     = "cmd.findAllAndSelect";       // FindReplace.js               _findAllAndSelect()\r\n    exports.CMD_ADD_NEXT_MATCH          = "cmd.addNextMatch";           // FindReplace.js               _expandAndAddNextToSelection()\r\n    exports.CMD_SKIP_CURRENT_MATCH      = "cmd.skipCurrentMatch";       // FindReplace.js               _skipCurrentMatch()\r\n    exports.CMD_REPLACE                 = "cmd.replace";                // FindReplace.js               _replace()\r\n    exports.CMD_REPLACE_IN_FILES        = "cmd.replaceInFiles";         // FindInFilesUI.js             _showReplaceBar()\r\n    exports.CMD_REPLACE_IN_SELECTED     = "cmd.replaceInSelected";      // FindInFilesUI.js             _showReplaceBarForSubtree()\r\n    exports.CMD_REPLACE_IN_SUBTREE      = "cmd.replaceInSubtree";       // FindInFilesUI.js             _showReplaceBarForSubtree()\r\n    \r\n    // VIEW\r\n    exports.CMD_THEMES_OPEN_SETTINGS    = "view.themesOpenSetting";     // MenuCommands.js              Settings.open()\r\n    exports.VIEW_HIDE_SIDEBAR           = "view.hideSidebar";           // SidebarView.js               toggle()\r\n    exports.VIEW_INCREASE_FONT_SIZE     = "view.increaseFontSize";      // ViewCommandHandlers.js       _handleIncreaseFontSize()\r\n    exports.VIEW_DECREASE_FONT_SIZE     = "view.decreaseFontSize";      // ViewCommandHandlers.js       _handleDecreaseFontSize()\r\n    exports.VIEW_RESTORE_FONT_SIZE      = "view.restoreFontSize";       // ViewCommandHandlers.js       _handleRestoreFontSize()\r\n    exports.VIEW_SCROLL_LINE_UP         = "view.scrollLineUp";          // ViewCommandHandlers.js       _handleScrollLineUp()\r\n    exports.VIEW_SCROLL_LINE_DOWN       = "view.scrollLineDown";        // ViewCommandHandlers.js       _handleScrollLineDown()\r\n    exports.VIEW_TOGGLE_INSPECTION      = "view.toggleCodeInspection";  // CodeInspection.js            toggleEnabled()\r\n    exports.TOGGLE_LINE_NUMBERS         = "view.toggleLineNumbers";     // EditorOptionHandlers.js      _getToggler()\r\n    exports.TOGGLE_ACTIVE_LINE          = "view.toggleActiveLine";      // EditorOptionHandlers.js      _getToggler()\r\n    exports.TOGGLE_WORD_WRAP            = "view.toggleWordWrap";        // EditorOptionHandlers.js      _getToggler()\r\n\r\n    exports.CMD_ADD_TO_WORKINGSET_AND_OPEN  = "cmd.addToWorkingSetAndOpen";          // DocumentCommandHandlers.js   handleOpenDocumentInNewPane()\r\n    exports.CMD_OPEN                        = "cmd.open";\r\n    \r\n    exports.CMD_ADD_TO_WORKINGSET_AND_OPEN  = "cmd.addToWorkingSetAndOpen";          // DocumentCommandHandlers.js   handleOpenDocumentInNewPane()\r\n    exports.CMD_WORKINGSET_SORT_BY_ADDED    = "cmd.sortWorkingSetByAdded";           // WorkingSetSort.js          _handleSort()\r\n    exports.CMD_WORKINGSET_SORT_BY_NAME     = "cmd.sortWorkingSetByName";            // WorkingSetSort.js          _handleSort()\r\n    exports.CMD_WORKINGSET_SORT_BY_TYPE     = "cmd.sortWorkingSetByType";            // WorkingSetSort.js          _handleSort()\r\n    exports.CMD_WORKING_SORT_TOGGLE_AUTO    = "cmd.sortWorkingSetToggleAuto";        // WorkingSetSort.js          _handleToggleAutoSort()\r\n    \r\n    // NAVIGATE\r\n    exports.NAVIGATE_NEXT_DOC           = "navigate.nextDoc";           // DocumentCommandHandlers.js   handleGoNextDoc()\r\n    exports.NAVIGATE_PREV_DOC           = "navigate.prevDoc";           // DocumentCommandHandlers.js   handleGoPrevDoc()\r\n    exports.NAVIGATE_SHOW_IN_FILE_TREE  = "navigate.showInFileTree";    // DocumentCommandHandlers.js   handleShowInTree()\r\n    exports.NAVIGATE_SHOW_IN_OS         = "navigate.showInOS";          // DocumentCommandHandlers.js   handleShowInOS()\r\n    exports.NAVIGATE_QUICK_OPEN         = "navigate.quickOpen";         // QuickOpen.js                 doFileSearch()\r\n    exports.NAVIGATE_JUMPTO_DEFINITION  = "navigate.jumptoDefinition";  // EditorManager.js             _doJumpToDef()\r\n    exports.NAVIGATE_GOTO_DEFINITION    = "navigate.gotoDefinition";    // QuickOpen.js                 doDefinitionSearch()\r\n    exports.NAVIGATE_GOTO_LINE          = "navigate.gotoLine";          // QuickOpen.js                 doGotoLine()\r\n    exports.NAVIGATE_GOTO_FIRST_PROBLEM = "navigate.gotoFirstProblem";  // CodeInspection.js            handleGotoFirstProblem()\r\n    exports.TOGGLE_QUICK_EDIT           = "navigate.toggleQuickEdit";   // EditorManager.js             _toggleInlineWidget()\r\n    exports.TOGGLE_QUICK_DOCS           = "navigate.toggleQuickDocs";   // EditorManager.js             _toggleInlineWidget()\r\n    exports.QUICK_EDIT_NEXT_MATCH       = "navigate.nextMatch";         // MultiRangeInlineEditor.js    _nextRange()\r\n    exports.QUICK_EDIT_PREV_MATCH       = "navigate.previousMatch";     // MultiRangeInlineEditor.js    _previousRange()\r\n    exports.CSS_QUICK_EDIT_NEW_RULE     = "navigate.newRule";           // CSSInlineEditor.js           _handleNewRule()\r\n    \r\n    // HELP\r\n    exports.HELP_CHECK_FOR_UPDATE       = "help.checkForUpdate";        // HelpCommandHandlers.js       _handleCheckForUpdates()\r\n    exports.HELP_HOW_TO_USE_BRACKETS    = "help.howToUseBrackets";      // HelpCommandHandlers.js       _handleLinkMenuItem()\r\n    exports.HELP_SUPPORT                = "help.support";               // HelpCommandHandlers.js       _handleLinkMenuItem()\r\n    exports.HELP_SUGGEST                = "help.suggest";               // HelpCommandHandlers.js       _handleLinkMenuItem()\r\n    exports.HELP_RELEASE_NOTES          = "help.releaseNotes";          // HelpCommandHandlers.js       _handleLinkMenuItem()\r\n    exports.HELP_GET_INVOLVED           = "help.getInvolved";           // HelpCommandHandlers.js       _handleLinkMenuItem()\r\n    exports.HELP_SHOW_EXT_FOLDER        = "help.showExtensionsFolder";  // HelpCommandHandlers.js       _handleShowExtensionsFolder()\r\n    exports.HELP_HOMEPAGE               = "help.homepage";              // HelpCommandHandlers.js       _handleLinkMenuItem()\r\n    exports.HELP_TWITTER                = "help.twitter";               // HelpCommandHandlers.js       _handleLinkMenuItem()\r\n    \r\n    // File shell callbacks - string must MATCH string in native code (appshell/command_callbacks.h)\r\n    exports.HELP_ABOUT                  = "help.about";                 // HelpCommandHandlers.js       _handleAboutDialog()\r\n    \r\n    // APP\r\n    exports.APP_RELOAD                  = "app.reload";                 // DocumentCommandHandlers.js   handleReload()\r\n    exports.APP_RELOAD_WITHOUT_EXTS     = "app.reload_without_exts";    // DocumentCommandHandlers.js   handleReloadWithoutExts()\r\n    \r\n    // File shell callbacks - string must MATCH string in native code (appshell/command_callbacks.h)\r\n    exports.APP_ABORT_QUIT              = "app.abort_quit";             // DocumentCommandHandlers.js   handleAbortQuit()\r\n    exports.APP_BEFORE_MENUPOPUP        = "app.before_menupopup";       // DocumentCommandHandlers.js   handleBeforeMenuPopup()\r\n    \r\n    // ADD_TO_WORKING_SET is deprectated but we need a handler for it because the new command doesn\'t return the same result as the legacy command\r\n    exports.FILE_ADD_TO_WORKING_SET     = "file.addToWorkingSet";       // Deprecated through DocumentCommandHandlers.js handleFileAddToWorkingSet\r\n    \r\n    // DEPRECATED: Working Set Commands\r\n    DeprecationWarning.deprecateConstant(exports, "SORT_WORKINGSET_BY_ADDED",   "CMD_WORKINGSET_SORT_BY_ADDED");\r\n    DeprecationWarning.deprecateConstant(exports, "SORT_WORKINGSET_BY_NAME",    "CMD_WORKINGSET_SORT_BY_NAME");\r\n    DeprecationWarning.deprecateConstant(exports, "SORT_WORKINGSET_BY_TYPE",    "CMD_WORKINGSET_SORT_BY_TYPE");\r\n    DeprecationWarning.deprecateConstant(exports, "SORT_WORKINGSET_AUTO",       "CMD_WORKING_SORT_TOGGLE_AUTO");\r\n              \r\n    // DEPRECATED: Edit commands that were moved from the Edit Menu to the Find Menu\r\n    DeprecationWarning.deprecateConstant(exports, "EDIT_FIND",                  "CMD_FIND");\r\n    DeprecationWarning.deprecateConstant(exports, "EDIT_FIND_IN_SELECTED",      "CMD_FIND_IN_SELECTED");\r\n    DeprecationWarning.deprecateConstant(exports, "EDIT_FIND_IN_SUBTREE",       "CMD_FIND_IN_SUBTREE");\r\n    DeprecationWarning.deprecateConstant(exports, "EDIT_FIND_NEXT",             "CMD_FIND_NEXT");\r\n    DeprecationWarning.deprecateConstant(exports, "EDIT_FIND_PREVIOUS",         "CMD_FIND_PREVIOUS");\r\n    DeprecationWarning.deprecateConstant(exports, "EDIT_FIND_ALL_AND_SELECT",   "CMD_FIND_ALL_AND_SELECT");\r\n    DeprecationWarning.deprecateConstant(exports, "EDIT_ADD_NEXT_MATCH",        "CMD_ADD_NEXT_MATCH");\r\n    DeprecationWarning.deprecateConstant(exports, "EDIT_SKIP_CURRENT_MATCH",    "CMD_SKIP_CURRENT_MATCH");\r\n    DeprecationWarning.deprecateConstant(exports, "EDIT_REPLACE",               "CMD_REPLACE");\r\n});\r\n\r\n\n//# sourceURL=/command/Commands.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\n /**\r\n  * This is JavaScript API exposed to the native shell when Brackets is run in a native shell rather than a browser.\r\n  */\r\ndefine(\'utils/ShellAPI\',[\'require\',\'exports\',\'module\',\'utils/AppInit\',\'command/CommandManager\',\'command/Commands\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    // Load dependent modules\r\n    var AppInit        = require("utils/AppInit"),\r\n        CommandManager = require("command/CommandManager"),\r\n        Commands       = require("command/Commands");\r\n\r\n    var appReady = false; // Set to true after app is fully initialized\r\n    \r\n    /**\r\n     * The native function BracketsShellAPI::DispatchBracketsJSCommand calls this function in order to enable\r\n     * calling Brackets commands from the native shell.\r\n     */\r\n    function executeCommand(eventName) {\r\n        // Temporary fix for #2616 - don\'t execute the command if a modal dialog is open.\r\n        // This should really be fixed with proper menu enabling.\r\n        if ($(".modal.instance").length || !appReady) {\r\n            // Another hack to fix issue #3219 so that all test windows are closed \r\n            // as before the fix for #3152 has been introduced. isBracketsTestWindow \r\n            // property is explicitly set in createTestWindowAndRun() in SpecRunnerUtils.js.\r\n            if (window.isBracketsTestWindow) {\r\n                return false;\r\n            }\r\n            // Return false for all commands except file.close_window command for \r\n            // which we have to return true (issue #3152).\r\n            return (eventName === Commands.FILE_CLOSE_WINDOW);\r\n        }\r\n\r\n        // Use E for Error so that uglify doesn\'t change this to simply Error()\r\n        var promise, E = Error, e = new E(), stackDepth = e.stack.split("\\n").length;\r\n        \r\n        // This function should *only* be called as a top-level function. If the current\r\n        // stack depth is > 2, it is most likely because we are at a breakpoint. \r\n        if (stackDepth < 3) {\r\n            promise = CommandManager.execute(eventName);\r\n        } else {\r\n            console.error("Skipping command " + eventName + " because it looks like you are " +\r\n                          "at a breakpoint. If you are NOT at a breakpoint, please " +\r\n                          "file a bug and mention this comment. Stack depth = " + stackDepth + ".");\r\n        }\r\n        return (promise && promise.state() === "rejected") ? false : true;\r\n    }\r\n\r\n    AppInit.appReady(function () {\r\n        appReady = true;\r\n    });\r\n    \r\n    exports.executeCommand = executeCommand;\r\n});\n//# sourceURL=/utils/ShellAPI.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\n/**\r\n * Initializes the global "brackets" variable and it\'s properties.\r\n * Modules should not access the global.brackets object until either\r\n * (a) the module requires this module, i.e. require("utils/Global") or\r\n * (b) the module receives a "appReady" callback from the utils/AppReady module.\r\n */\r\ndefine(\'utils/Global\',[\'require\',\'exports\',\'module\',\'text!config.json\',\'utils/UrlParams\',\'utils/ShellAPI\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var configJSON  = require("text!config.json"),\r\n        UrlParams   = require("utils/UrlParams").UrlParams;\r\n    \r\n    // Define core brackets namespace if it isn\'t already defined\r\n    //\r\n    // We can\'t simply do \'brackets = {}\' to define it in the global namespace because\r\n    // we\'re in "use strict" mode. Most likely, \'window\' will always point to the global\r\n    // object when this code is running. However, in case it isn\'t (e.g. if we\'re running \r\n    // inside Node for CI testing) we use this trick to get the global object.\r\n    var Fn = Function, global = (new Fn("return this"))();\r\n    if (!global.brackets) {\r\n        global.brackets = {};\r\n    }\r\n    \r\n    // Parse URL params\r\n    var params = new UrlParams();\r\n    params.parse();\r\n    \r\n    // Parse src/config.json\r\n    try {\r\n        global.brackets.metadata = JSON.parse(configJSON);\r\n        global.brackets.config = global.brackets.metadata.config;\r\n    } catch (err) {\r\n        console.log(err);\r\n    }\r\n        \r\n    // Uncomment the following line to force all low level file i/o routines to complete\r\n    // asynchronously. This should only be done for testing/debugging.\r\n    // NOTE: Make sure this line is commented out again before committing!\r\n    //brackets.forceAsyncCallbacks = true;\r\n\r\n    // Load native shell when brackets is run in a native shell rather than the browser\r\n    // TODO: (issue #266) load conditionally\r\n    global.brackets.shellAPI = require("utils/ShellAPI");\r\n    \r\n    // Determine OS/platform\r\n    if (global.navigator.platform === "MacIntel" || global.navigator.platform === "MacPPC") {\r\n        global.brackets.platform = "mac";\r\n    } else if (global.navigator.platform.indexOf("Linux") >= 0) {\r\n        global.brackets.platform = "linux";\r\n    } else {\r\n        global.brackets.platform = "win";\r\n    }\r\n    \r\n    global.brackets.inBrowser = !global.brackets.hasOwnProperty("fs");\r\n    \r\n    // Are we in a desktop shell with a native menu bar?\r\n    var hasNativeMenus = params.get("hasNativeMenus");\r\n    if (hasNativeMenus) {\r\n        global.brackets.nativeMenus = (hasNativeMenus === "true");\r\n    } else {\r\n        global.brackets.nativeMenus = (!global.brackets.inBrowser && (global.brackets.platform !== "linux"));\r\n    }\r\n    \r\n    // Locale-related APIs\r\n    global.brackets.isLocaleDefault = function () {\r\n        return !global.localStorage.getItem("locale");\r\n    };\r\n    \r\n    global.brackets.getLocale = function () {\r\n        // By default use the locale that was determined in brackets.js\r\n        return global.localStorage.getItem("locale") || global.require.s.contexts._.config.locale;\r\n    };\r\n\r\n    global.brackets.setLocale = function (locale) {\r\n        if (locale) {\r\n            global.localStorage.setItem("locale", locale);\r\n        } else {\r\n            global.localStorage.removeItem("locale");\r\n        }\r\n    };\r\n    \r\n    // Create empty app namespace if running in-browser\r\n    if (!global.brackets.app) {\r\n        global.brackets.app = {};\r\n    }\r\n    \r\n    // Loading extensions requires creating new require.js contexts, which\r\n    // requires access to the global \'require\' object that always gets hidden\r\n    // by the \'require\' in the AMD wrapper. We store this in the brackets\r\n    // object here so that the ExtensionLoader doesn\'t have to have access to\r\n    // the global object.\r\n    global.brackets.libRequire = global.require;\r\n\r\n    // Also store our current require.js context (the one that loads brackets\r\n    // core modules) so that extensions can use it.\r\n    // Note: we change the name to "getModule" because this won\'t do exactly\r\n    // the same thing as \'require\' in AMD-wrapped modules. The extension will\r\n    // only be able to load modules that have already been loaded once.\r\n    global.brackets.getModule = require;\r\n\r\n    exports.global = global;\r\n});\r\n\n//# sourceURL=/utils/Global.js'),eval("/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\n/**\r\n * Utilities for working with Deferred, Promise, and other asynchronous processes.\r\n */\r\ndefine('utils/Async',['require','exports','module'],function (require, exports, module) {\r\n    \"use strict\";\r\n    \r\n    // Further ideas for Async utilities...\r\n    //  - Utilities for blocking UI until a Promise completes?\r\n    //  - A \"SuperDeferred\" could feature some very useful enhancements:\r\n    //     - API for cancellation (non guaranteed, best attempt)\r\n    //     - Easier way to add a timeout clause (withTimeout() wrapper below is more verbose)\r\n    //     - Encapsulate the task kickoff code so you can start it later, e.g. superDeferred.start()\r\n    //  - Deferred/Promise are unable to do anything akin to a 'finally' block. It'd be nice if we\r\n    //    could harvest exceptions across all steps of an async process and pipe them to a handler,\r\n    //    so that we don't leave UI-blocking overlays up forever, etc. But this is hard: we'd have\r\n    //    wrap every async callback (including low-level native ones that don't use [Super]Deferred)\r\n    //    to catch exceptions, and then understand which Deferred(s) the code *would* have resolved/\r\n    //    rejected had it run to completion.\r\n    \r\n\r\n    /**\r\n     * Executes a series of tasks in parallel, returning a \"master\" Promise that is resolved once\r\n     * all the tasks have resolved. If one or more tasks fail, behavior depends on the failFast\r\n     * flag:\r\n     *   - If true, the master Promise is rejected as soon as the first task fails. The remaining\r\n     *     tasks continue to completion in the background.\r\n     *   - If false, the master Promise is rejected after all tasks have completed.\r\n     *\r\n     * If nothing fails:          (M = master promise; 1-4 = tasks; d = done; F = fail)\r\n     *  M  ------------d\r\n     *  1 >---d        .\r\n     *  2 >------d     .\r\n     *  3 >---------d  .\r\n     *  4 >------------d\r\n     *\r\n     * With failFast = false:\r\n     *  M  ------------F\r\n     *  1 >---d     .  .\r\n     *  2 >------d  .  .\r\n     *  3 >---------F  .\r\n     *  4 >------------d\r\n     *\r\n     * With failFast = true: -- equivalent to $.when()\r\n     *  M  ---------F\r\n     *  1 >---d     .\r\n     *  2 >------d  .\r\n     *  3 >---------F\r\n     *  4 >------------d   (#4 continues even though master Promise has failed)\r\n     * (Note: if tasks finish synchronously, the behavior is more like failFast=false because you\r\n     * won't get a chance to respond to the master Promise until after all items have been processed)\r\n     *\r\n     * To perform task-specific work after an individual task completes, attach handlers to each\r\n     * Promise before beginProcessItem() returns it.\r\n     *\r\n     * Note: don't use this if individual tasks (or their done/fail handlers) could ever show a user-\r\n     * visible dialog: because they run in parallel, you could show multiple dialogs atop each other.\r\n     *\r\n     * @param {!Array.<*>} items\r\n     * @param {!function(*, number):Promise} beginProcessItem\r\n     * @param {!boolean} failFast\r\n     * @return {$.Promise}\r\n     */\r\n    function doInParallel(items, beginProcessItem, failFast) {\r\n        var promises = [];\r\n        var masterDeferred = new $.Deferred();\r\n        \r\n        if (items.length === 0) {\r\n            masterDeferred.resolve();\r\n            \r\n        } else {\r\n            var numCompleted = 0;\r\n            var hasFailed = false;\r\n            \r\n            items.forEach(function (item, i) {\r\n                var itemPromise = beginProcessItem(item, i);\r\n                promises.push(itemPromise);\r\n                \r\n                itemPromise.fail(function () {\r\n                    if (failFast) {\r\n                        masterDeferred.reject();\r\n                    } else {\r\n                        hasFailed = true;\r\n                    }\r\n                });\r\n                itemPromise.always(function () {\r\n                    numCompleted++;\r\n                    if (numCompleted === items.length) {\r\n                        if (hasFailed) {\r\n                            masterDeferred.reject();\r\n                        } else {\r\n                            masterDeferred.resolve();\r\n                        }\r\n                    }\r\n                });\r\n            });\r\n            \r\n        }\r\n        \r\n        return masterDeferred.promise();\r\n    }\r\n    \r\n    /**\r\n     * Executes a series of tasks in serial (task N does not begin until task N-1 has completed).\r\n     * Returns a \"master\" Promise that is resolved once all the tasks have resolved. If one or more\r\n     * tasks fail, behavior depends on the failAndStopFast flag:\r\n     *   - If true, the master Promise is rejected as soon as the first task fails. The remaining\r\n     *     tasks are never started (the serial sequence is stopped).\r\n     *   - If false, the master Promise is rejected after all tasks have completed.\r\n     *\r\n     * If nothing fails:\r\n     *  M  ------------d\r\n     *  1 >---d        .\r\n     *  2     >--d     .\r\n     *  3        >--d  .\r\n     *  4           >--d\r\n     *\r\n     * With failAndStopFast = false:\r\n     *  M  ------------F\r\n     *  1 >---d     .  .\r\n     *  2     >--d  .  .\r\n     *  3        >--F  .\r\n     *  4           >--d\r\n     *\r\n     * With failAndStopFast = true:\r\n     *  M  ---------F\r\n     *  1 >---d     .\r\n     *  2     >--d  .\r\n     *  3        >--F\r\n     *  4          (#4 never runs)\r\n     *\r\n     * To perform task-specific work after an individual task completes, attach handlers to each\r\n     * Promise before beginProcessItem() returns it.\r\n     * \r\n     * @param {!Array.<*>} items\r\n     * @param {!function(*, number):Promise} beginProcessItem\r\n     * @param {!boolean} failAndStopFast\r\n     * @return {$.Promise}\r\n     */\r\n    function doSequentially(items, beginProcessItem, failAndStopFast) {\r\n\r\n        var masterDeferred = new $.Deferred(),\r\n            hasFailed = false;\r\n        \r\n        function doItem(i) {\r\n            if (i >= items.length) {\r\n                if (hasFailed) {\r\n                    masterDeferred.reject();\r\n                } else {\r\n                    masterDeferred.resolve();\r\n                }\r\n                return;\r\n            }\r\n            \r\n            var itemPromise = beginProcessItem(items[i], i);\r\n            \r\n            itemPromise.done(function () {\r\n                doItem(i + 1);\r\n            });\r\n            itemPromise.fail(function () {\r\n                if (failAndStopFast) {\r\n                    masterDeferred.reject();\r\n                    // note: we do NOT process any further items in this case\r\n                } else {\r\n                    hasFailed = true;\r\n                    doItem(i + 1);\r\n                }\r\n            });\r\n        }\r\n        \r\n        doItem(0);\r\n        \r\n        return masterDeferred.promise();\r\n    }\r\n    \r\n    /**\r\n     * Executes a series of synchronous tasks sequentially spread over time-slices less than maxBlockingTime.\r\n     * Processing yields by idleTime between time-slices.\r\n     * \r\n     * @param {!Array.<*>} items\r\n     * @param {!function(*, number)} fnProcessItem  Function that synchronously processes one item\r\n     * @param {number=} maxBlockingTime\r\n     * @param {number=} idleTime\r\n     * @return {$.Promise}\r\n     */\r\n    function doSequentiallyInBackground(items, fnProcessItem, maxBlockingTime, idleTime) {\r\n        \r\n        maxBlockingTime = maxBlockingTime || 15;\r\n        idleTime = idleTime || 30;\r\n        \r\n        var sliceStartTime = (new Date()).getTime();\r\n        \r\n        return doSequentially(items, function (item, i) {\r\n            var result = new $.Deferred();\r\n            \r\n            // process the next item\r\n            fnProcessItem(item, i);\r\n            \r\n            // if we've exhausted our maxBlockingTime\r\n            if ((new Date()).getTime() - sliceStartTime >= maxBlockingTime) {\r\n                //yield\r\n                window.setTimeout(function () {\r\n                    sliceStartTime = (new Date()).getTime();\r\n                    result.resolve();\r\n                }, idleTime);\r\n            } else {\r\n                //continue processing\r\n                result.resolve();\r\n            }\r\n\r\n            return result;\r\n        }, false);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Executes a series of tasks in parallel, saving up error info from any that fail along the way.\r\n     * Returns a Promise that is only resolved/rejected once all tasks are complete. This is\r\n     * essentially a wrapper around doInParallel(..., false).\r\n     *\r\n     * If one or more tasks failed, the entire \"master\" promise is rejected at the end - with one\r\n     * argument: an array objects, one per failed task. Each error object contains:\r\n     *  - item -- the entry in items whose task failed\r\n     *  - error -- the first argument passed to the fail() handler when the task failed\r\n     *\r\n     * @param {!Array.<*>} items\r\n     * @param {!function(*, number):Promise} beginProcessItem\r\n     * @return {$.Promise}\r\n     */\r\n    function doInParallel_aggregateErrors(items, beginProcessItem) {\r\n        var errors = [];\r\n        \r\n        var masterDeferred = new $.Deferred();\r\n        \r\n        var parallelResult = doInParallel(\r\n            items,\r\n            function (item, i) {\r\n                var itemResult = beginProcessItem(item, i);\r\n                itemResult.fail(function (error) {\r\n                    errors.push({ item: item, error: error });\r\n                });\r\n                return itemResult;\r\n            },\r\n            false\r\n        );\r\n        \r\n        parallelResult\r\n            .done(function () {\r\n                masterDeferred.resolve();\r\n            })\r\n            .fail(function () {\r\n                masterDeferred.reject(errors);\r\n            });\r\n        \r\n        return masterDeferred.promise();\r\n    }\r\n        \r\n    /** Value passed to fail() handlers that have been triggered due to withTimeout()'s timeout */\r\n    var ERROR_TIMEOUT = {};\r\n    \r\n    /**\r\n     * Adds timeout-driven termination to a Promise: returns a new Promise that is resolved/rejected when\r\n     * the given original Promise is resolved/rejected, OR is resolved/rejected after the given delay -\r\n     * whichever happens first.\r\n     * \r\n     * If the original Promise is resolved/rejected first, done()/fail() handlers receive arguments\r\n     * piped from the original Promise. If the timeout occurs first instead, then resolve() or\r\n     * fail() (with Async.ERROR_TIMEOUT) is called based on value of resolveTimeout.\r\n     * \r\n     * @param {$.Promise} promise\r\n     * @param {number} timeout\r\n     * @param {boolean=} resolveTimeout If true, then resolve deferred on timeout, otherwise reject. Default is false.\r\n     * @return {$.Promise}\r\n     */\r\n    function withTimeout(promise, timeout, resolveTimeout) {\r\n        var wrapper = new $.Deferred();\r\n        \r\n        var timer = window.setTimeout(function () {\r\n            if (resolveTimeout) {\r\n                wrapper.resolve();\r\n            } else {\r\n                wrapper.reject(ERROR_TIMEOUT);\r\n            }\r\n        }, timeout);\r\n        promise.always(function () {\r\n            window.clearTimeout(timer);\r\n        });\r\n        \r\n        // If the wrapper was already rejected due to timeout, the Promise's calls to resolve/reject\r\n        // won't do anything\r\n        promise.then(wrapper.resolve, wrapper.reject);\r\n        \r\n        return wrapper.promise();\r\n    }\r\n    \r\n    /**\r\n     * Allows waiting for all the promises to be either resolved or rejected.\r\n     * Unlike $.when(), it does not call .fail() or .always() handlers on first\r\n     * reject. The caller should take all the precaution to make sure all the\r\n     * promises passed to this function are completed to avoid blocking.\r\n     * \r\n     * If failOnReject is set to true, promise returned by the function will be\r\n     * rejected if at least one of the promises was rejected. The default value\r\n     * is false, which will cause the call to this function to be always\r\n     * successfully resolved.\r\n     * \r\n     * If timeout is specified, the promise will be rejected on timeout as per\r\n     * Async.withTimeout.\r\n     * \r\n     * @param {!Array.<$.Promise>} promises Array of promises to wait for\r\n     * @param {boolean=} failOnReject       Whether to reject or not if one of the promises has been rejected.\r\n     * @param {number=} timeout             Number of milliseconds to wait until rejecting the promise\r\n     * \r\n     * @return {$.Promise} A Promise which will be resolved once all dependent promises are resolved. \r\n     *                     It is resolved with an array of results from the successfully resolved dependent promises.\r\n     *                     The resulting array may not be in the same order or contain as many items as there were \r\n     *                     promises to wait on and it will contain 'undefined' entries for those promises that resolve\r\n     *                     without a result.\r\n     * \r\n     */\r\n    function waitForAll(promises, failOnReject, timeout) {\r\n        var masterDeferred = new $.Deferred(),\r\n            results = [],\r\n            count = 0,\r\n            sawRejects = false;\r\n        \r\n        if (!promises || promises.length === 0) {\r\n            masterDeferred.resolve();\r\n            return masterDeferred.promise();\r\n        }\r\n        \r\n        // set defaults if needed\r\n        failOnReject = (failOnReject === undefined) ? false : true;\r\n        \r\n        if (timeout !== undefined) {\r\n            withTimeout(masterDeferred, timeout);\r\n        }\r\n        \r\n        promises.forEach(function (promise) {\r\n            promise\r\n                .fail(function (err) {\r\n                    sawRejects = true;\r\n                })\r\n                .done(function (result) {\r\n                    results.push(result);\r\n                })\r\n                .always(function () {\r\n                    count++;\r\n                    if (count === promises.length) {\r\n                        if (failOnReject && sawRejects) {\r\n                            masterDeferred.reject();\r\n                        } else {\r\n                            masterDeferred.resolve(results);\r\n                        }\r\n                    }\r\n                });\r\n        });\r\n        \r\n        return masterDeferred.promise();\r\n    }\r\n    \r\n    /**\r\n     * Chains a series of synchronous and asynchronous (jQuery promise-returning) functions \r\n     * together, using the result of each successive function as the argument(s) to the next. \r\n     * A promise is returned that resolves with the result of the final call if all calls \r\n     * resolve or return normally. Otherwise, if any of the functions reject or throw, the \r\n     * computation is halted immediately and the promise is rejected with this halting error.\r\n     * \r\n     * @param {Array.<function(*)>} functions Functions to be chained\r\n     * @param {?Array} args Arguments to call the first function with\r\n     * @return {jQuery.Promise} A promise that resolves with the result of the final call, or\r\n     *      rejects with the first error.\r\n     */\r\n    function chain(functions, args) {\r\n        var deferred = $.Deferred();\r\n        \r\n        function chainHelper(index, args) {\r\n            if (functions.length === index) {\r\n                deferred.resolveWith(null, args);\r\n            } else {\r\n                var nextFunction = functions[index++];\r\n                try {\r\n                    var responseOrPromise = nextFunction.apply(null, args);\r\n                    if (responseOrPromise.hasOwnProperty(\"done\") &&\r\n                            responseOrPromise.hasOwnProperty(\"fail\")) {\r\n                        responseOrPromise.done(function () {\r\n                            chainHelper(index, arguments);\r\n                        });\r\n                        responseOrPromise.fail(function () {\r\n                            deferred.rejectWith(null, arguments);\r\n                        });\r\n                    } else {\r\n                        chainHelper(index, [responseOrPromise]);\r\n                    }\r\n                } catch (e) {\r\n                    deferred.reject(e);\r\n                }\r\n            }\r\n        }\r\n        \r\n        chainHelper(0, args || []);\r\n        \r\n        return deferred.promise();\r\n    }\r\n    \r\n    /**\r\n     * Utility for converting a method that takes (error, callback) to one that returns a promise;\r\n     * useful for using FileSystem methods (or other Node-style API methods) in a promise-oriented\r\n     * workflow. For example, instead of\r\n     *\r\n     *      var deferred = new $.Deferred();\r\n     *      file.read(function (err, contents) {\r\n     *          if (err) {\r\n     *              deferred.reject(err);\r\n     *          } else {\r\n     *              // ...process the contents...\r\n     *              deferred.resolve();\r\n     *          }\r\n     *      }\r\n     *      return deferred.promise();\r\n     *\r\n     * you can just do\r\n     *\r\n     *      return Async.promisify(file, \"read\").then(function (contents) {\r\n     *          // ...process the contents...\r\n     *      });\r\n     *\r\n     * The object/method are passed as an object/string pair so that we can\r\n     * properly call the method without the caller having to deal with \"bind\" all the time.\r\n     *\r\n     * @param {Object} obj The object to call the method on.\r\n     * @param {string} method The name of the method. The method should expect the errback\r\n     *      as its last parameter.\r\n     * @param {...Object} varargs The arguments you would have normally passed to the method\r\n     *      (excluding the errback itself).\r\n     * @return {$.Promise} A promise that is resolved with the arguments that were passed to the\r\n     *      errback (not including the err argument) if err is null, or rejected with the err if\r\n     *      non-null.\r\n     */\r\n    function promisify(obj, method) {\r\n        var result = new $.Deferred(),\r\n            args = Array.prototype.slice.call(arguments, 2);\r\n        args.push(function (err) {\r\n            if (err) {\r\n                result.reject(err);\r\n            } else {\r\n                result.resolve.apply(result, Array.prototype.slice.call(arguments, 1));\r\n            }\r\n        });\r\n        obj[method].apply(obj, args);\r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * Creates a queue of async operations that will be executed sequentially. Operations can be added to the\r\n     * queue at any time. If the queue is empty and nothing is currently executing when an operation is added, \r\n     * it will execute immediately. Otherwise, it will execute when the last operation currently in the queue \r\n     * has finished.\r\n     * @constructor\r\n     */\r\n    function PromiseQueue() {\r\n        this._queue = [];\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * @type {Array.<function(): $.Promise>}\r\n     * The queue of operations to execute sequentially. Note that even if this array is empty, there might\r\n     * still be an operation we need to wait on; that operation's promise is stored in _curPromise.\r\n     */\r\n    PromiseQueue.prototype._queue = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {$.Promise}\r\n     * The promise we're currently waiting on, or null if there's nothing currently executing.\r\n     */\r\n    PromiseQueue.prototype._curPromise = null;\r\n    \r\n    /**\r\n     * @type {number} The number of queued promises.\r\n     */\r\n    Object.defineProperties(PromiseQueue.prototype, {\r\n        \"length\": {\r\n            get: function () { return this._queue.length; },\r\n            set: function () { throw new Error(\"Cannot set length\"); }\r\n        }\r\n    });\r\n    \r\n    /**\r\n     * Adds an operation to the queue. If nothing is currently executing, it will execute immediately (and\r\n     * the next operation added to the queue will wait for it to complete). Otherwise, it will wait until\r\n     * the last operation in the queue (or the currently executing operation if nothing is in the queue) is\r\n     * finished. The operation must return a promise that will be resolved or rejected when it's finished;\r\n     * the queue will continue with the next operation regardless of whether the current operation's promise\r\n     * is resolved or rejected.\r\n     * @param {function(): $.Promise} op The operation to add to the queue.\r\n     */\r\n    PromiseQueue.prototype.add = function (op) {\r\n        this._queue.push(op);\r\n\r\n        // If something is currently executing, then _doNext() will get called when it's done. If nothing\r\n        // is executing (in which case the queue should have been empty), we need to call _doNext() to kickstart\r\n        // the queue.\r\n        if (!this._curPromise) {\r\n            this._doNext();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Removes all pending promises from the queue.\r\n     */\r\n    PromiseQueue.prototype.removeAll = function () {\r\n        this._queue = [];\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Pulls the next operation off the queue and executes it.\r\n     */\r\n    PromiseQueue.prototype._doNext = function () {\r\n        var self = this;\r\n        if (this._queue.length) {\r\n            var op = this._queue.shift();\r\n            this._curPromise = op();\r\n            this._curPromise.always(function () {\r\n                self._curPromise = null;\r\n                self._doNext();\r\n            });\r\n        }\r\n    };\r\n    \r\n    // Define public API\r\n    exports.doInParallel   = doInParallel;\r\n    exports.doSequentially = doSequentially;\r\n    exports.doSequentiallyInBackground   = doSequentiallyInBackground;\r\n    exports.doInParallel_aggregateErrors = doInParallel_aggregateErrors;\r\n    exports.withTimeout    = withTimeout;\r\n    exports.waitForAll     = waitForAll;\r\n    exports.ERROR_TIMEOUT  = ERROR_TIMEOUT;\r\n    exports.chain          = chain;\r\n    exports.promisify      = promisify;\r\n    exports.PromiseQueue   = PromiseQueue;\r\n});\r\n\n//# sourceURL=/utils/Async.js"),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\n/**\r\n * FileSystemError describes the errors that can occur when using the FileSystem, File,\r\n * and Directory modules.\r\n *\r\n * Error values are strings. Any "falsy" value: null, undefined or "" means "no error".\r\n */\r\ndefine(\'filesystem/FileSystemError\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    /**\r\n     * Enumerated File System Errors\r\n     * @enum {string}\r\n     */\r\n    module.exports = {\r\n        UNKNOWN                     : "Unknown",\r\n        INVALID_PARAMS              : "InvalidParams",\r\n        NOT_FOUND                   : "NotFound",\r\n        NOT_READABLE                : "NotReadable",\r\n        UNSUPPORTED_ENCODING        : "UnsupportedEncoding",\r\n        NOT_SUPPORTED               : "NotSupported",\r\n        NOT_WRITABLE                : "NotWritable",\r\n        OUT_OF_SPACE                : "OutOfSpace",\r\n        TOO_MANY_ENTRIES            : "TooManyEntries",\r\n        ALREADY_EXISTS              : "AlreadyExists",\r\n        CONTENTS_MODIFIED           : "ContentsModified",\r\n        ROOT_NOT_WATCHED            : "RootNotBeingWatched",\r\n        UNSUPPORTED_FILETYPE        : "UnsupportedFileType"\r\n        \r\n        // FUTURE: Add remote connection errors: timeout, not logged in, connection err, etc.\r\n    };\r\n});\r\n\n//# sourceURL=/filesystem/FileSystemError.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, brackets, $, window */\r\n\r\n/**\r\n * This is a collection of utility functions for gathering performance data.\r\n */\r\ndefine(\'utils/PerfUtils\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'utils/Global\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n    \r\n    var Global = require("utils/Global");\r\n\r\n    /**\r\n     * Flag to enable/disable performance data gathering. Default is true (enabled)\r\n     * @type {boolean} enabled\r\n     */\r\n    var enabled = brackets && !!brackets.app.getElapsedMilliseconds;\r\n    \r\n    /**\r\n     * Peformance data is stored in this hash object. The key is the name of the\r\n     * test (passed to markStart/addMeasurement), and the value is the time, in \r\n     * milliseconds, that it took to run the test. If multiple runs of the same test\r\n     * are made, the value is an Array with each run stored as an entry in the Array.\r\n     */\r\n    var perfData = {};\r\n    \r\n    /**\r\n     * Active tests. This is a hash of all tests that have had markStart() called,\r\n     * but have not yet had addMeasurement() called.\r\n     */\r\n    var activeTests = {};\r\n\r\n    /**\r\n     * Updatable tests. This is a hash of all tests that have had markStart() called,\r\n     * and have had updateMeasurement() called. Caller must explicitly remove tests\r\n     * from this list using finalizeMeasurement()\r\n     */\r\n    var updatableTests = {};\r\n    \r\n    /**\r\n     * Hash of measurement IDs\r\n     */\r\n    var perfMeasurementIds = {};\r\n    \r\n    /**\r\n     * @private\r\n     * A unique key to log performance data\r\n     *\r\n     * @param {!string} id Unique ID for this measurement name\r\n     * @param {!name} name A short name for this measurement\r\n     */\r\n    function PerfMeasurement(id, name) {\r\n        this.id = id;\r\n        this.name = name;\r\n    }\r\n    \r\n    /**\r\n     * Create a new PerfMeasurement key. Adds itself to the module export.\r\n     * Can be accessed on the module, e.g. PerfUtils.MY_PERF_KEY.\r\n     *\r\n     * @param {!string} id Unique ID for this measurement name\r\n     * @param {!name} name A short name for this measurement\r\n     */\r\n    function createPerfMeasurement(id, name) {\r\n        if (perfMeasurementIds[id]) {\r\n            console.error("Performance measurement " + id + " is already defined");\r\n        }\r\n        \r\n        var pm = new PerfMeasurement(id, name);\r\n        exports[id] = pm;\r\n        \r\n        return pm;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Convert a PerfMeasurement instance to it\'s id. Otherwise uses the string name for backwards compatibility.\r\n     */\r\n    function toMeasurementId(o) {\r\n        return (o instanceof PerfMeasurement) ? o.id : o;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Helper function for markStart()\r\n     *\r\n     * @param {string} name  Timer name.\r\n     * @param {number} time  Timer start time.\r\n     */\r\n    function _markStart(name, time) {\r\n        if (activeTests[name]) {\r\n            console.error("Recursive tests with the same name are not supported. Timer name: " + name);\r\n        }\r\n        \r\n        activeTests[name] = { startTime: time };\r\n    }\r\n    \r\n    /**\r\n     * Start a new named timer. The name should be as descriptive as possible, since\r\n     * this name will appear as an entry in the performance report. \r\n     * For example: "Open file: /Users/brackets/src/ProjectManager.js"\r\n     *\r\n     * Multiple timers can be opened simultaneously, but all open timers must have\r\n     * a unique name.\r\n     *\r\n     * @param {(string|Array.<string>)} name  Single name or an Array of names.\r\n     * @return {string} timer name. Returned for convenience to store and use\r\n     *      for calling addMeasure(). Since name is often creating via concatenating\r\n     *      strings this return value allows clients to construct the name once.\r\n     */\r\n    function markStart(name) {\r\n        if (!enabled) {\r\n            return;\r\n        }\r\n\r\n        var time = brackets.app.getElapsedMilliseconds();\r\n        name = toMeasurementId(name);\r\n\r\n        // Array of names can be passed in to have multiple timers with same start time\r\n        if (Array.isArray(name)) {\r\n            var i;\r\n            for (i = 0; i < name.length; i++) {\r\n                _markStart(name[i], time);\r\n            }\r\n        } else {\r\n            _markStart(name, time);\r\n        }\r\n\r\n        return name;\r\n    }\r\n    \r\n    /**\r\n     * Stop a timer and add its measurements to the performance data.\r\n     *\r\n     * Multiple measurements can be stored for any given name. If there are\r\n     * multiple values for a name, they are stored in an Array.\r\n     *\r\n     * If markStart() was not called for the specified timer, the\r\n     * measured time is relative to app startup.\r\n     *\r\n     * @param {string} name  Timer name.\r\n     */\r\n    function addMeasurement(name) {\r\n        if (!enabled) {\r\n            return;\r\n        }\r\n\r\n        var elapsedTime = brackets.app.getElapsedMilliseconds();\r\n        name = toMeasurementId(name);\r\n        \r\n        if (activeTests[name]) {\r\n            elapsedTime -= activeTests[name].startTime;\r\n            delete activeTests[name];\r\n        }\r\n        \r\n        if (perfData[name]) {\r\n            // We have existing data, add to it\r\n            if (Array.isArray(perfData[name])) {\r\n                perfData[name].push(elapsedTime);\r\n            } else {\r\n                // Current data is a number, convert to Array\r\n                perfData[name] = [perfData[name], elapsedTime];\r\n            }\r\n        } else {\r\n            perfData[name] = elapsedTime;\r\n        }\r\n\r\n        // Real time logging\r\n        //console.log(name + " " + elapsedTime);\r\n    }\r\n\r\n    /**\r\n     * This function is similar to addMeasurement(), but it allows timing the\r\n     * *last* event, when you don\'t know which event will be the last one.\r\n     *\r\n     * Tests that are in the activeTests list, have not yet been added, so add\r\n     * measurements to the performance data, and move test to updatableTests list.\r\n     * A test is moved to the updatable list so that it no longer passes isActive().\r\n     *\r\n     * Tests that are already in the updatableTests list are updated.\r\n     *\r\n     * Caller must explicitly remove test from the updatableTests list using\r\n     * finalizeMeasurement().\r\n     *\r\n     * If markStart() was not called for the specified timer, there is no way to\r\n     * determine if this is the first or subsequent call, so the measurement is\r\n     * not updatable, and it is handled in addMeasurement().\r\n     *\r\n     * @param {string} name  Timer name.\r\n     */\r\n    function updateMeasurement(name) {\r\n        var elapsedTime = brackets.app.getElapsedMilliseconds();\r\n\r\n        name = toMeasurementId(name);\r\n\r\n        if (updatableTests[name]) {\r\n            // update existing measurement\r\n            elapsedTime -= updatableTests[name].startTime;\r\n            \r\n            // update\r\n            if (perfData[name] && Array.isArray(perfData[name])) {\r\n                // We have existing data and it\'s an array, so update the last entry\r\n                perfData[name][perfData[name].length - 1] = elapsedTime;\r\n            } else {\r\n                // No current data or a single entry, so set/update it\r\n                perfData[name] = elapsedTime;\r\n            }\r\n            \r\n        } else {\r\n            // not yet in updatable list\r\n\r\n            if (activeTests[name]) {\r\n                // save startTime in updatable list before addMeasurement() deletes it\r\n                updatableTests[name] = { startTime: activeTests[name].startTime };\r\n            }\r\n            \r\n            // let addMeasurement() handle the initial case\r\n            addMeasurement(name);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Remove timer from lists so next action starts a new measurement\r\n     * \r\n     * updateMeasurement may not have been called, so timer may be\r\n     * in either or neither list, but should never be in both.\r\n     *\r\n     * @param {string} name  Timer name.\r\n     */\r\n    function finalizeMeasurement(name) {\r\n\r\n        name = toMeasurementId(name);\r\n\r\n        if (activeTests[name]) {\r\n            delete activeTests[name];\r\n        }\r\n\r\n        if (updatableTests[name]) {\r\n            delete updatableTests[name];\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Returns whether a timer is active or not, where "active" means that\r\n     * timer has been started with addMark(), but has not been added to perfdata\r\n     * with addMeasurement().\r\n     *\r\n     * @param {string} name  Timer name.\r\n     * @return {boolean} Whether a timer is active or not.\r\n     */\r\n    function isActive(name) {\r\n        return (activeTests[name]) ? true : false;\r\n    }\r\n\r\n    /**\r\n      * Returns the performance data as a tab deliminted string\r\n      * @return {string}\r\n      */\r\n    function getDelimitedPerfData() {\r\n        var getValue = function (entry) {\r\n            // return single value, or tab deliminted values for an array\r\n            if (Array.isArray(entry)) {\r\n                var i, values = "";\r\n                 \r\n                for (i = 0; i < entry.length; i++) {\r\n                    values += entry[i];\r\n                    if (i < entry.length - 1) {\r\n                        values += ", ";\r\n                    }\r\n                }\r\n                return values;\r\n            } else {\r\n                return entry;\r\n            }\r\n        };\r\n\r\n        var testName,\r\n            index,\r\n            result = "";\r\n        _.forEach(perfData, function (entry, testName) {\r\n            result += getValue(entry) + "\\t" + testName + "\\n";\r\n        });\r\n\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Returns the measured value for the given measurement name.\r\n     * @param {string|PerfMeasurement} name The measurement to retreive.\r\n     */\r\n    function getData(name) {\r\n        if (!name) {\r\n            return perfData;\r\n        }\r\n        \r\n        return perfData[toMeasurementId(name)];\r\n    }\r\n    \r\n    function searchData(regExp) {\r\n        var keys = Object.keys(perfData).filter(function (key) {\r\n            return regExp.test(key);\r\n        });\r\n        \r\n        var datas = [];\r\n        \r\n        keys.forEach(function (key) {\r\n            datas.push(perfData[key]);\r\n        });\r\n        \r\n        return datas;\r\n    }\r\n    \r\n    /**\r\n     * Clear all logs including metric data and active tests.\r\n     */\r\n    function clear() {\r\n        perfData = {};\r\n        activeTests = {};\r\n        updatableTests = {};\r\n    }\r\n    \r\n    // create performance measurement constants\r\n    createPerfMeasurement("INLINE_WIDGET_OPEN", "Open inline editor or docs");\r\n    createPerfMeasurement("INLINE_WIDGET_CLOSE", "Close inline editor or docs");\r\n    \r\n    // extensions may create additional measurement constants during their lifecycle\r\n\r\n    exports.addMeasurement          = addMeasurement;\r\n    exports.finalizeMeasurement     = finalizeMeasurement;\r\n    exports.isActive                = isActive;\r\n    exports.markStart               = markStart;\r\n    exports.getData                 = getData;\r\n    exports.searchData              = searchData;\r\n    exports.updateMeasurement       = updateMeasurement;\r\n    exports.getDelimitedPerfData    = getDelimitedPerfData;\r\n    exports.createPerfMeasurement   = createPerfMeasurement;\r\n    exports.clear                   = clear;\r\n});\r\n\n//# sourceURL=/utils/PerfUtils.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define  */\r\n\r\n/**\r\n * Utilities module to provide constants for keyCodes\r\n */\r\ndefine(\'utils/KeyEvent\',{\r\n    DOM_VK_CANCEL: 3,\r\n    DOM_VK_HELP: 6,\r\n    DOM_VK_BACK_SPACE: 8,\r\n    DOM_VK_TAB: 9,\r\n    DOM_VK_CLEAR: 12,\r\n    DOM_VK_RETURN: 13,\r\n    DOM_VK_ENTER: 14,\r\n    DOM_VK_SHIFT: 16,\r\n    DOM_VK_CONTROL: 17,\r\n    DOM_VK_ALT: 18,\r\n    DOM_VK_PAUSE: 19,\r\n    DOM_VK_CAPS_LOCK: 20,\r\n    DOM_VK_ESCAPE: 27,\r\n    DOM_VK_SPACE: 32,\r\n    DOM_VK_PAGE_UP: 33,\r\n    DOM_VK_PAGE_DOWN: 34,\r\n    DOM_VK_END: 35,\r\n    DOM_VK_HOME: 36,\r\n    DOM_VK_LEFT: 37,\r\n    DOM_VK_UP: 38,\r\n    DOM_VK_RIGHT: 39,\r\n    DOM_VK_DOWN: 40,\r\n    DOM_VK_PRINTSCREEN: 44,\r\n    DOM_VK_INSERT: 45,\r\n    DOM_VK_DELETE: 46,\r\n    DOM_VK_0: 48,\r\n    DOM_VK_1: 49,\r\n    DOM_VK_2: 50,\r\n    DOM_VK_3: 51,\r\n    DOM_VK_4: 52,\r\n    DOM_VK_5: 53,\r\n    DOM_VK_6: 54,\r\n    DOM_VK_7: 55,\r\n    DOM_VK_8: 56,\r\n    DOM_VK_9: 57,\r\n    DOM_VK_A: 65,\r\n    DOM_VK_B: 66,\r\n    DOM_VK_C: 67,\r\n    DOM_VK_D: 68,\r\n    DOM_VK_E: 69,\r\n    DOM_VK_F: 70,\r\n    DOM_VK_G: 71,\r\n    DOM_VK_H: 72,\r\n    DOM_VK_I: 73,\r\n    DOM_VK_J: 74,\r\n    DOM_VK_K: 75,\r\n    DOM_VK_L: 76,\r\n    DOM_VK_M: 77,\r\n    DOM_VK_N: 78,\r\n    DOM_VK_O: 79,\r\n    DOM_VK_P: 80,\r\n    DOM_VK_Q: 81,\r\n    DOM_VK_R: 82,\r\n    DOM_VK_S: 83,\r\n    DOM_VK_T: 84,\r\n    DOM_VK_U: 85,\r\n    DOM_VK_V: 86,\r\n    DOM_VK_W: 87,\r\n    DOM_VK_X: 88,\r\n    DOM_VK_Y: 89,\r\n    DOM_VK_Z: 90,\r\n    DOM_VK_CONTEXT_MENU: 93,\r\n    DOM_VK_NUMPAD0: 96,\r\n    DOM_VK_NUMPAD1: 97,\r\n    DOM_VK_NUMPAD2: 98,\r\n    DOM_VK_NUMPAD3: 99,\r\n    DOM_VK_NUMPAD4: 100,\r\n    DOM_VK_NUMPAD5: 101,\r\n    DOM_VK_NUMPAD6: 102,\r\n    DOM_VK_NUMPAD7: 103,\r\n    DOM_VK_NUMPAD8: 104,\r\n    DOM_VK_NUMPAD9: 105,\r\n    DOM_VK_MULTIPLY: 106,\r\n    DOM_VK_ADD: 107,\r\n    DOM_VK_SEPARATOR: 108,\r\n    DOM_VK_SUBTRACT: 109,\r\n    DOM_VK_DECIMAL: 110,\r\n    DOM_VK_DIVIDE: 111,\r\n    DOM_VK_F1: 112,\r\n    DOM_VK_F2: 113,\r\n    DOM_VK_F3: 114,\r\n    DOM_VK_F4: 115,\r\n    DOM_VK_F5: 116,\r\n    DOM_VK_F6: 117,\r\n    DOM_VK_F7: 118,\r\n    DOM_VK_F8: 119,\r\n    DOM_VK_F9: 120,\r\n    DOM_VK_F10: 121,\r\n    DOM_VK_F11: 122,\r\n    DOM_VK_F12: 123,\r\n    DOM_VK_F13: 124,\r\n    DOM_VK_F14: 125,\r\n    DOM_VK_F15: 126,\r\n    DOM_VK_F16: 127,\r\n    DOM_VK_F17: 128,\r\n    DOM_VK_F18: 129,\r\n    DOM_VK_F19: 130,\r\n    DOM_VK_F20: 131,\r\n    DOM_VK_F21: 132,\r\n    DOM_VK_F22: 133,\r\n    DOM_VK_F23: 134,\r\n    DOM_VK_F24: 135,\r\n    DOM_VK_NUM_LOCK: 144,\r\n    DOM_VK_SCROLL_LOCK: 145,\r\n    DOM_VK_SEMICOLON: 186,\r\n    DOM_VK_EQUALS: 187,\r\n    DOM_VK_COMMA: 188,\r\n    DOM_VK_DASH: 189,\r\n    DOM_VK_PERIOD: 190,\r\n    DOM_VK_SLASH: 191,\r\n    DOM_VK_BACK_QUOTE: 192,\r\n    DOM_VK_OPEN_BRACKET: 219,\r\n    DOM_VK_BACK_SLASH: 220,\r\n    DOM_VK_CLOSE_BRACKET: 221,\r\n    DOM_VK_QUOTE: 222,\r\n    DOM_VK_META: 224\r\n\r\n});\n//# sourceURL=/utils/KeyEvent.js'),eval('/**\r\n * @license RequireJS i18n 2.0.2 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\r\n * Available via the MIT or new BSD license.\r\n * see: http://github.com/requirejs/i18n for details\r\n */\r\n/*jslint regexp: true */\r\n/*global require: false, navigator: false, define: false */\r\n\r\n/**\r\n * This plugin handles i18n! prefixed modules. It does the following:\r\n *\r\n * 1) A regular module can have a dependency on an i18n bundle, but the regular\r\n * module does not want to specify what locale to load. So it just specifies\r\n * the top-level bundle, like "i18n!nls/colors".\r\n *\r\n * This plugin will load the i18n bundle at nls/colors, see that it is a root/master\r\n * bundle since it does not have a locale in its name. It will then try to find\r\n * the best match locale available in that master bundle, then request all the\r\n * locale pieces for that best match locale. For instance, if the locale is "en-us",\r\n * then the plugin will ask for the "en-us", "en" and "root" bundles to be loaded\r\n * (but only if they are specified on the master bundle).\r\n *\r\n * Once all the bundles for the locale pieces load, then it mixes in all those\r\n * locale pieces into each other, then finally sets the context.defined value\r\n * for the nls/colors bundle to be that mixed in locale.\r\n *\r\n * 2) A regular module specifies a specific locale to load. For instance,\r\n * i18n!nls/fr-fr/colors. In this case, the plugin needs to load the master bundle\r\n * first, at nls/colors, then figure out what the best match locale is for fr-fr,\r\n * since maybe only fr or just root is defined for that locale. Once that best\r\n * fit is found, all of its locale pieces need to have their bundles loaded.\r\n *\r\n * Once all the bundles for the locale pieces load, then it mixes in all those\r\n * locale pieces into each other, then finally sets the context.defined value\r\n * for the nls/fr-fr/colors bundle to be that mixed in locale.\r\n */\r\n(function () {\r\n    \'use strict\';\r\n\r\n    //regexp for reconstructing the master bundle name from parts of the regexp match\r\n    //nlsRegExp.exec("foo/bar/baz/nls/en-ca/foo") gives:\r\n    //["foo/bar/baz/nls/en-ca/foo", "foo/bar/baz/nls/", "/", "/", "en-ca", "foo"]\r\n    //nlsRegExp.exec("foo/bar/baz/nls/foo") gives:\r\n    //["foo/bar/baz/nls/foo", "foo/bar/baz/nls/", "/", "/", "foo", ""]\r\n    //so, if match[5] is blank, it means this is the top bundle definition.\r\n    var nlsRegExp = /(^.*(^|\\/)nls(\\/|$))([^\\/]*)\\/?([^\\/]*)/;\r\n\r\n    //Helper function to avoid repeating code. Lots of arguments in the\r\n    //desire to stay functional and support RequireJS contexts without having\r\n    //to know about the RequireJS contexts.\r\n    function addPart(locale, master, needed, toLoad, prefix, suffix) {\r\n        if (master[locale]) {\r\n            needed.push(locale);\r\n            if (master[locale] === true || master[locale] === 1) {\r\n                toLoad.push(prefix + locale + \'/\' + suffix);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addIfExists(req, locale, toLoad, prefix, suffix) {\r\n        var fullName = prefix + locale + \'/\' + suffix;\r\n        if (require._fileExists(req.toUrl(fullName + \'.js\'))) {\r\n            toLoad.push(fullName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simple function to mix in properties from source into target,\r\n     * but only if target does not already have a property of the same name.\r\n     * This is not robust in IE for transferring methods that match\r\n     * Object.prototype names, but the uses of mixin here seem unlikely to\r\n     * trigger a problem related to that.\r\n     */\r\n    function mixin(target, source, force) {\r\n        var prop;\r\n        for (prop in source) {\r\n            if (source.hasOwnProperty(prop) && (!target.hasOwnProperty(prop) || force)) {\r\n                target[prop] = source[prop];\r\n            } else if (typeof source[prop] === \'object\') {\r\n                mixin(target[prop], source[prop], force);\r\n            }\r\n        }\r\n    }\r\n\r\n    define(\'i18n\',[\'module\'], function (module) {\r\n        var masterConfig = module.config ? module.config() : {};\r\n\r\n        return {\r\n            version: \'2.0.1+\',\r\n            /**\r\n             * Called when a dependency needs to be loaded.\r\n             */\r\n            load: function (name, req, onLoad, config) {\r\n                config = config || {};\r\n\r\n                if (config.locale) {\r\n                    masterConfig.locale = config.locale;\r\n                }\r\n\r\n                var masterName,\r\n                    match = nlsRegExp.exec(name),\r\n                    prefix = match[1],\r\n                    locale = match[4],\r\n                    suffix = match[5],\r\n                    parts = locale.split("-"),\r\n                    toLoad = [],\r\n                    value = {},\r\n                    i, part, current = "";\r\n\r\n                //If match[5] is blank, it means this is the top bundle definition,\r\n                //so it does not have to be handled. Locale-specific requests\r\n                //will have a match[4] value but no match[5]\r\n                if (match[5]) {\r\n                    //locale-specific bundle\r\n                    prefix = match[1];\r\n                    masterName = prefix + suffix;\r\n                } else {\r\n                    //Top-level bundle.\r\n                    masterName = name;\r\n                    suffix = match[4];\r\n                    locale = masterConfig.locale;\r\n                    if (!locale) {\r\n                        locale = masterConfig.locale =\r\n                            typeof navigator === "undefined" ? "root" :\r\n                            (navigator.language ||\r\n                             navigator.userLanguage || "root").toLowerCase();\r\n                    }\r\n                    parts = locale.split("-");\r\n                }\r\n\r\n                if (config.isBuild) {\r\n                    //Check for existence of all locale possible files and\r\n                    //require them if exist.\r\n                    toLoad.push(masterName);\r\n                    addIfExists(req, "root", toLoad, prefix, suffix);\r\n                    for (i = 0; i < parts.length; i++) {\r\n                        part = parts[i];\r\n                        current += (current ? "-" : "") + part;\r\n                        addIfExists(req, current, toLoad, prefix, suffix);\r\n                    }\r\n\r\n                    req(toLoad, function () {\r\n                        onLoad();\r\n                    });\r\n                } else {\r\n                    //First, fetch the master bundle, it knows what locales are available.\r\n                    req([masterName], function (master) {\r\n                        //Figure out the best fit\r\n                        var needed = [],\r\n                            part;\r\n\r\n                        //Always allow for root, then do the rest of the locale parts.\r\n                        addPart("root", master, needed, toLoad, prefix, suffix);\r\n                        for (i = 0; i < parts.length; i++) {\r\n                            part = parts[i];\r\n                            current += (current ? "-" : "") + part;\r\n                            addPart(current, master, needed, toLoad, prefix, suffix);\r\n                        }\r\n\r\n                        //Load all the parts missing.\r\n                        req(toLoad, function () {\r\n                            var i, partBundle, part;\r\n                            for (i = needed.length - 1; i > -1 && needed[i]; i--) {\r\n                                part = needed[i];\r\n                                partBundle = master[part];\r\n                                if (partBundle === true || partBundle === 1) {\r\n                                    partBundle = req(prefix + part + \'/\' + suffix);\r\n                                }\r\n                                mixin(value, partBundle);\r\n                            }\r\n\r\n                            //All done, notify the loader.\r\n                            onLoad(value);\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    });\r\n}());\r\n\n//# sourceURL=/thirdparty/i18n/i18n.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\ndefine(\'nls/strings\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n\r\n    "use strict";\r\n\r\n    // Code that needs to display user strings should call require("strings") to load\r\n    // src/strings.js. This file will dynamically load strings.js for the specified brackets.locale.\r\n    //\r\n    // See the README.md file in this folder for information on how to add a new translation for\r\n    // another language or locale.\r\n    //\r\n    // TODO: dynamically populate the local prefix list below?\r\n    module.exports = {\r\n        root: true,\r\n        "cs": true,\r\n        "da": true,\r\n        "de": true,\r\n        "el": true,\r\n        "en-gb": true,\r\n        "es": true,\r\n        "fa-ir": true,\r\n        "fi": true,\r\n        "fr": true,\r\n        "gl": true,\r\n        "hr": true,\r\n        "hu": true,\r\n        "id": true,\r\n        "it": true,\r\n        "ja": true,\r\n        "ko": true,\r\n        "nb": true,\r\n        "nl": true,\r\n        "pl": true,\r\n        "pt-br": true,\r\n        "pt-pt": true,\r\n        "ro": true,\r\n        "ru": true,\r\n        "sk": true,\r\n        "sr": true,\r\n        "sv": true,\r\n        "tr": true,\r\n        "uk": true,\r\n        "zh-cn": true,\r\n        "zh-tw": true\r\n    };\r\n});\r\n\n//# sourceURL=/nls/strings.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\ndefine(\'nls/root/strings\',{\r\n    \r\n    /**\r\n     * Errors\r\n     */\r\n\r\n    // General file io error strings\r\n    "GENERIC_ERROR"                     : "(error {0})",\r\n    "NOT_FOUND_ERR"                     : "The file could not be found.",\r\n    "NOT_READABLE_ERR"                  : "The file could not be read.",\r\n    "NO_MODIFICATION_ALLOWED_ERR"       : "The target directory cannot be modified.",\r\n    "NO_MODIFICATION_ALLOWED_ERR_FILE"  : "The permissions do not allow you to make modifications.",\r\n    "CONTENTS_MODIFIED_ERR"             : "The file has been modified outside of {APP_NAME}.",\r\n    "UNSUPPORTED_ENCODING_ERR"          : "{APP_NAME} currently only supports UTF-8 encoded text files.",\r\n    "UNSUPPORTED_FILE_TYPE_ERR"         : "The file is not a supported file type.",\r\n    "FILE_EXISTS_ERR"                   : "The file or directory already exists.",\r\n    "FILE"                              : "file",\r\n    "FILE_TITLE"                        : "File",\r\n    "DIRECTORY"                         : "directory",\r\n    "DIRECTORY_TITLE"                   : "Directory",\r\n    "DIRECTORY_NAMES_LEDE"              : "Directory names",\r\n    "FILENAMES_LEDE"                    : "Filenames",\r\n    "FILENAME"                          : "Filename",\r\n    "DIRECTORY_NAME"                    : "Directory Name",\r\n    \r\n\r\n    // Project error strings\r\n    "ERROR_LOADING_PROJECT"             : "Error Loading Project",\r\n    "OPEN_DIALOG_ERROR"                 : "An error occurred when showing the open file dialog. (error {0})",\r\n    "REQUEST_NATIVE_FILE_SYSTEM_ERROR"  : "An error occurred when trying to load the directory <span class=\'dialog-filename\'>{0}</span>. (error {1})",\r\n    "READ_DIRECTORY_ENTRIES_ERROR"      : "An error occurred when reading the contents of the directory <span class=\'dialog-filename\'>{0}</span>. (error {1})",\r\n\r\n    // File open/save error string\r\n    "ERROR_OPENING_FILE_TITLE"          : "Error Opening File",\r\n    "ERROR_OPENING_FILE"                : "An error occurred when trying to open the file <span class=\'dialog-filename\'>{0}</span>. {1}",\r\n    "ERROR_OPENING_FILES"               : "An error occurred when trying to open the following files:",\r\n    "ERROR_RELOADING_FILE_TITLE"        : "Error Reloading Changes From Disk",\r\n    "ERROR_RELOADING_FILE"              : "An error occurred when trying to reload the file <span class=\'dialog-filename\'>{0}</span>. {1}",\r\n    "ERROR_SAVING_FILE_TITLE"           : "Error Saving File",\r\n    "ERROR_SAVING_FILE"                 : "An error occurred when trying to save the file <span class=\'dialog-filename\'>{0}</span>. {1}",\r\n    "ERROR_RENAMING_FILE_TITLE"         : "Error Renaming {0}",\r\n    "ERROR_RENAMING_FILE"               : "An error occurred when trying to rename the {2} <span class=\'dialog-filename\'>{0}</span>. {1}",\r\n    "ERROR_DELETING_FILE_TITLE"         : "Error Deleting {0}",\r\n    "ERROR_DELETING_FILE"               : "An error occurred when trying to delete the {2} <span class=\'dialog-filename\'>{0}</span>. {1}",\r\n    "INVALID_FILENAME_TITLE"            : "Invalid {0}",\r\n    "INVALID_FILENAME_MESSAGE"          : "{0} cannot use any system reserved words, end with dots (.) or use any of the following characters: <code class=\'emphasized\'>{1}</code>",\r\n    "ENTRY_WITH_SAME_NAME_EXISTS"       : "A file or directory with the name <span class=\'dialog-filename\'>{0}</span> already exists.",\r\n    "ERROR_CREATING_FILE_TITLE"         : "Error Creating {0}",\r\n    "ERROR_CREATING_FILE"               : "An error occurred when trying to create the {0} <span class=\'dialog-filename\'>{1}</span>. {2}",\r\n\r\n    // Application preferences corrupt error strings\r\n    "ERROR_PREFS_CORRUPT_TITLE"         : "Error Reading Preferences",\r\n    "ERROR_PREFS_CORRUPT"               : "Your preferences file is not valid JSON. The file will be opened so that you can correct the format. You will need to restart {APP_NAME} for the changes to take effect.",\r\n\r\n    // Application error strings\r\n    "ERROR_IN_BROWSER_TITLE"            : "Oops! {APP_NAME} Doesn\'t Run in Browsers Yet.",\r\n    "ERROR_IN_BROWSER"                  : "{APP_NAME} is built in HTML, but right now it runs as a desktop app so you can use it to edit local files. Please use the application shell in the <b>github.com/adobe/brackets-shell</b> repo to run {APP_NAME}.",\r\n    \r\n    // ProjectManager max files error string\r\n    "ERROR_MAX_FILES_TITLE"             : "Error Indexing Files",\r\n    "ERROR_MAX_FILES"                   : "This project contains more than 30,000 files. Features that operate across multiple files may be disabled or behave as if the project is empty. <a href=\'https://github.com/adobe/brackets/wiki/Large-Projects\'>Read more about working with large projects</a>.",\r\n\r\n    // Live Preview error strings\r\n    "ERROR_LAUNCHING_BROWSER_TITLE"     : "Error Launching Browser",\r\n    "ERROR_CANT_FIND_CHROME"            : "The Google Chrome browser could not be found. Please make sure it is installed.",\r\n    "ERROR_LAUNCHING_BROWSER"           : "An error occurred when launching the browser. (error {0})",\r\n    \r\n    "LIVE_DEVELOPMENT_ERROR_TITLE"      : "Live Preview Error",\r\n    "LIVE_DEVELOPMENT_RELAUNCH_TITLE"   : "Connecting to Browser",\r\n    "LIVE_DEVELOPMENT_ERROR_MESSAGE"    : "In order for Live Preview to connect, Chrome needs to be relaunched with remote debugging enabled.<br /><br />Would you like to relaunch Chrome and enable remote debugging?",\r\n    "LIVE_DEV_LOADING_ERROR_MESSAGE"    : "Unable to load Live Preview page",\r\n    "LIVE_DEV_NEED_HTML_MESSAGE"        : "Open an HTML file or make sure there is an index.html file in your project in order to launch live preview.",\r\n    "LIVE_DEV_NEED_BASEURL_MESSAGE"     : "To launch live preview with a server-side file, you need to specify a Base URL for this project.",\r\n    "LIVE_DEV_SERVER_NOT_READY_MESSAGE" : "Error starting up the HTTP server for live preview files. Please try again.",\r\n    "LIVE_DEVELOPMENT_INFO_TITLE"       : "Welcome to Live Preview!",\r\n    "LIVE_DEVELOPMENT_INFO_MESSAGE"     : "Live Preview connects {APP_NAME} to your browser. It launches a preview of your HTML file in the browser, then updates the preview instantly as you edit your code.<br /><br />In this early version of {APP_NAME}, Live Preview only works with <strong>Google Chrome</strong> and updates live as you edit <strong>CSS or HTML files</strong>. Changes to JavaScript files are automatically reloaded when you save.<br /><br />(You\'ll only see this message once.)",\r\n    "LIVE_DEVELOPMENT_TROUBLESHOOTING"  : "For more information, see <a href=\'{0}\' title=\'{0}\'>Troubleshooting Live Preview connection errors</a>.",\r\n    \r\n    "LIVE_DEV_STATUS_TIP_NOT_CONNECTED" : "Live Preview",\r\n    "LIVE_DEV_STATUS_TIP_PROGRESS1"     : "Live Preview: Connecting\\u2026",\r\n    "LIVE_DEV_STATUS_TIP_PROGRESS2"     : "Live Preview: Initializing\\u2026",\r\n    "LIVE_DEV_STATUS_TIP_CONNECTED"     : "Disconnect Live Preview",\r\n    "LIVE_DEV_STATUS_TIP_OUT_OF_SYNC"   : "Live Preview (save file to refresh)",\r\n    "LIVE_DEV_STATUS_TIP_SYNC_ERROR"    : "Live Preview (not updating due to syntax error)",\r\n\r\n    "LIVE_DEV_DETACHED_REPLACED_WITH_DEVTOOLS" : "Live Preview was cancelled because the browser\'s developer tools were opened",\r\n    "LIVE_DEV_DETACHED_TARGET_CLOSED"          : "Live Preview was cancelled because the page was closed in the browser",\r\n    "LIVE_DEV_NAVIGATED_AWAY"                  : "Live Preview was cancelled because the browser navigated to a page that is not part of the current project",\r\n    "LIVE_DEV_CLOSED_UNKNOWN_REASON"           : "Live Preview was cancelled for an unknown reason ({0})",\r\n    \r\n    "SAVE_CLOSE_TITLE"                  : "Save Changes",\r\n    "SAVE_CLOSE_MESSAGE"                : "Do you want to save the changes you made in the document <span class=\'dialog-filename\'>{0}</span>?",\r\n    "SAVE_CLOSE_MULTI_MESSAGE"          : "Do you want to save your changes to the following files?",\r\n    "EXT_MODIFIED_TITLE"                : "External Changes",\r\n    "CONFIRM_FOLDER_DELETE_TITLE"       : "Confirm Delete",\r\n    "CONFIRM_FOLDER_DELETE"             : "Are you sure you want to delete the folder <span class=\'dialog-filename\'>{0}</span>?",\r\n    "FILE_DELETED_TITLE"                : "File Deleted",\r\n    "EXT_MODIFIED_WARNING"              : "<span class=\'dialog-filename\'>{0}</span> has been modified on disk.<br /><br />Do you want to save the file and overwrite those changes?",\r\n    "EXT_MODIFIED_MESSAGE"              : "<span class=\'dialog-filename\'>{0}</span> has been modified on disk, but also has unsaved changes in {APP_NAME}.<br /><br />Which version do you want to keep?",\r\n    "EXT_DELETED_MESSAGE"               : "<span class=\'dialog-filename\'>{0}</span> has been deleted on disk, but has unsaved changes in {APP_NAME}.<br /><br />Do you want to keep your changes?",\r\n    \r\n    // Generic dialog/button labels\r\n    "DONE"                              : "Done",\r\n    "OK"                                : "OK",\r\n    "CANCEL"                            : "Cancel",\r\n    "DONT_SAVE"                         : "Don\'t Save",\r\n    "SAVE"                              : "Save",\r\n    "SAVE_AS"                           : "Save As\\u2026",\r\n    "SAVE_AND_OVERWRITE"                : "Overwrite",\r\n    "DELETE"                            : "Delete",\r\n    "BUTTON_YES"                        : "Yes",\r\n    "BUTTON_NO"                         : "No",\r\n    \r\n    // Find, Replace, Find in Files\r\n    "FIND_MATCH_INDEX"                  : "{0} of {1}",\r\n    "FIND_NO_RESULTS"                   : "No results",\r\n    "FIND_QUERY_PLACEHOLDER"            : "Find\\u2026",\r\n    "REPLACE_PLACEHOLDER"               : "Replace with\\u2026",\r\n    "BUTTON_REPLACE_ALL"                : "Batch\\u2026",\r\n    "BUTTON_REPLACE_ALL_IN_FILES"       : "Replace\\u2026",\r\n    "BUTTON_REPLACE"                    : "Replace",\r\n    "BUTTON_NEXT"                       : "\\u25B6",\r\n    "BUTTON_PREV"                       : "\\u25C0",\r\n    "BUTTON_NEXT_HINT"                  : "Next Match",\r\n    "BUTTON_PREV_HINT"                  : "Previous Match",\r\n    "BUTTON_CASESENSITIVE_HINT"         : "Match Case",\r\n    "BUTTON_REGEXP_HINT"                : "Regular Expression",\r\n    "REPLACE_WITHOUT_UNDO_WARNING_TITLE": "Replace Without Undo",\r\n    "REPLACE_WITHOUT_UNDO_WARNING"      : "Because more than {0} files need to be changed, {APP_NAME} will modify unopened files on disk.<br />You won\'t be able to undo replacements in those files.",\r\n    "BUTTON_REPLACE_WITHOUT_UNDO"       : "Replace Without Undo",\r\n\r\n    "OPEN_FILE"                         : "Open File",\r\n    "SAVE_FILE_AS"                      : "Save File",\r\n    "CHOOSE_FOLDER"                     : "Choose a folder",\r\n\r\n    "RELEASE_NOTES"                     : "Release Notes",\r\n    "NO_UPDATE_TITLE"                   : "You\'re Up to Date!",\r\n    "NO_UPDATE_MESSAGE"                 : "You are running the latest version of {APP_NAME}.",\r\n\r\n    // Find and Replace\r\n    "FIND_REPLACE_TITLE_LABEL"          : "Replace",\r\n    "FIND_REPLACE_TITLE_WITH"           : "with",\r\n    "FIND_TITLE_LABEL"                  : "Found",\r\n    "FIND_TITLE_SUMMARY"                : "&mdash; {0} {1} {2} in {3}",\r\n\r\n    // Find in Files\r\n    "FIND_NUM_FILES"                    : "{0} {1}",\r\n    "FIND_IN_FILES_SCOPED"              : "in <span class=\'dialog-filename\'>{0}</span>",\r\n    "FIND_IN_FILES_NO_SCOPE"            : "in project",\r\n    "FIND_IN_FILES_ZERO_FILES"          : "Filter excludes all files {0}",\r\n    "FIND_IN_FILES_FILE"                : "file",\r\n    "FIND_IN_FILES_FILES"               : "files",\r\n    "FIND_IN_FILES_MATCH"               : "match",\r\n    "FIND_IN_FILES_MATCHES"             : "matches",\r\n    "FIND_IN_FILES_MORE_THAN"           : "Over ",\r\n    "FIND_IN_FILES_PAGING"              : "{0}&mdash;{1}",\r\n    "FIND_IN_FILES_FILE_PATH"           : "<span class=\'dialog-filename\'>{0}</span> {2} <span class=\'dialog-path\'>{1}</span>", // We should use normal dashes on Windows instead of em dash eventually\r\n    "FIND_IN_FILES_EXPAND_COLLAPSE"     : "Ctrl/Cmd click to expand/collapse all",\r\n    "REPLACE_IN_FILES_ERRORS_TITLE"     : "Replace Errors",\r\n    "REPLACE_IN_FILES_ERRORS"           : "The following files weren\'t modified because they changed after the search or couldn\'t be written.",\r\n    \r\n    "ERROR_FETCHING_UPDATE_INFO_TITLE"  : "Error Getting Update Info",\r\n    "ERROR_FETCHING_UPDATE_INFO_MSG"    : "There was a problem getting the latest update information from the server. Please make sure you are connected to the internet and try again.",\r\n    \r\n    // File exclusion filters\r\n    "NEW_FILE_FILTER"                   : "New Exclusion Set\\u2026",\r\n    "CLEAR_FILE_FILTER"                 : "Don\'t Exclude Files",\r\n    "NO_FILE_FILTER"                    : "No Files Excluded",\r\n    "EXCLUDE_FILE_FILTER"               : "Exclude {0}",\r\n    "EDIT_FILE_FILTER"                  : "Edit\\u2026",\r\n    "FILE_FILTER_DIALOG"                : "Edit Exclusion Set",\r\n    "FILE_FILTER_INSTRUCTIONS"          : "Exclude files and folders matching any of the following strings / substrings or <a href=\'{0}\' title=\'{0}\'>wildcards</a>. Enter each string on a new line.",\r\n    "FILTER_NAME_PLACEHOLDER"           : "Name this exclusion set (optional)",\r\n    "FILE_FILTER_CLIPPED_SUFFIX"        : "and {0} more",\r\n    "FILTER_COUNTING_FILES"             : "Counting files\\u2026",\r\n    "FILTER_FILE_COUNT"                 : "Allows {0} of {1} files {2}",\r\n    "FILTER_FILE_COUNT_ALL"             : "Allows all {0} files {1}",\r\n\r\n    // Quick Edit\r\n    "ERROR_QUICK_EDIT_PROVIDER_NOT_FOUND"   : "No Quick Edit available for current cursor position",\r\n    "ERROR_CSSQUICKEDIT_BETWEENCLASSES"     : "CSS Quick Edit: place cursor on a single class name",\r\n    "ERROR_CSSQUICKEDIT_CLASSNOTFOUND"      : "CSS Quick Edit: incomplete class attribute",\r\n    "ERROR_CSSQUICKEDIT_IDNOTFOUND"         : "CSS Quick Edit: incomplete id attribute",\r\n    "ERROR_CSSQUICKEDIT_UNSUPPORTEDATTR"    : "CSS Quick Edit: place cursor in tag, class, or id",\r\n    "ERROR_TIMINGQUICKEDIT_INVALIDSYNTAX"   : "CSS Timing Function Quick Edit: invalid syntax",\r\n    "ERROR_JSQUICKEDIT_FUNCTIONNOTFOUND"    : "JS Quick Edit: place cursor in function name",\r\n\r\n    // Quick Docs\r\n    "ERROR_QUICK_DOCS_PROVIDER_NOT_FOUND"   : "No Quick Docs available for current cursor position",\r\n\r\n    /**\r\n     * ProjectManager\r\n     */\r\n    "PROJECT_LOADING"   : "Loading\\u2026",\r\n    "UNTITLED"          : "Untitled",\r\n    "WORKING_FILES"        : "Working Files",\r\n\r\n    /**\r\n     * MainViewManager\r\n     */\r\n    "TOP"               : "Top",\r\n    "BOTTOM"            : "Bottom",\r\n    "LEFT"              : "Left",\r\n    "RIGHT"             : "Right",\r\n\r\n    /**\r\n     * Keyboard modifier names\r\n     */\r\n    "KEYBOARD_CTRL"   : "Ctrl",\r\n    "KEYBOARD_SHIFT"  : "Shift",\r\n    "KEYBOARD_SPACE"  : "Space",\r\n    \r\n    /**\r\n     * StatusBar strings\r\n     */\r\n    "STATUSBAR_CURSOR_POSITION"             : "Line {0}, Column {1}",\r\n    "STATUSBAR_SELECTION_CH_SINGULAR"       : " \\u2014 Selected {0} column",\r\n    "STATUSBAR_SELECTION_CH_PLURAL"         : " \\u2014 Selected {0} columns",\r\n    "STATUSBAR_SELECTION_LINE_SINGULAR"     : " \\u2014 Selected {0} line",\r\n    "STATUSBAR_SELECTION_LINE_PLURAL"       : " \\u2014 Selected {0} lines",\r\n    "STATUSBAR_SELECTION_MULTIPLE"          : " \\u2014 {0} selections",\r\n    "STATUSBAR_INDENT_TOOLTIP_SPACES"       : "Click to switch indentation to spaces",\r\n    "STATUSBAR_INDENT_TOOLTIP_TABS"         : "Click to switch indentation to tabs",\r\n    "STATUSBAR_INDENT_SIZE_TOOLTIP_SPACES"  : "Click to change number of spaces used when indenting",\r\n    "STATUSBAR_INDENT_SIZE_TOOLTIP_TABS"    : "Click to change tab character width",\r\n    "STATUSBAR_SPACES"                      : "Spaces:",\r\n    "STATUSBAR_TAB_SIZE"                    : "Tab Size:",\r\n    "STATUSBAR_LINE_COUNT_SINGULAR"         : "\\u2014 {0} Line",\r\n    "STATUSBAR_LINE_COUNT_PLURAL"           : "\\u2014 {0} Lines",\r\n    "STATUSBAR_USER_EXTENSIONS_DISABLED"    : "Extensions Disabled",\r\n    "STATUSBAR_INSERT"                      : "INS",\r\n    "STATUSBAR_OVERWRITE"                   : "OVR",\r\n    "STATUSBAR_INSOVR_TOOLTIP"              : "Click to toggle cursor between Insert (INS) and Overwrite (OVR) modes",\r\n    "STATUSBAR_LANG_TOOLTIP"                : "Click to change file type",\r\n    "STATUSBAR_CODE_INSPECTION_TOOLTIP"     : "{0}. Click to toggle report panel.",\r\n    "STATUSBAR_DEFAULT_LANG"                : "(default)",\r\n    "STATUSBAR_SET_DEFAULT_LANG"            : "Set as Default for .{0} Files",\r\n\r\n    // CodeInspection: errors/warnings\r\n    "ERRORS_PANEL_TITLE_MULTIPLE"           : "{0} Problems",\r\n    "SINGLE_ERROR"                          : "1 {0} Problem",\r\n    "MULTIPLE_ERRORS"                       : "{1} {0} Problems",\r\n    "NO_ERRORS"                             : "No {0} problems found - good job!",\r\n    "NO_ERRORS_MULTIPLE_PROVIDER"           : "No problems found - good job!",\r\n    "LINT_DISABLED"                         : "Linting is disabled",\r\n    "NO_LINT_AVAILABLE"                     : "No linter available for {0}",\r\n    "NOTHING_TO_LINT"                       : "Nothing to lint",\r\n    "LINTER_TIMED_OUT"                      : "{0} has timed out after waiting for {1} ms",\r\n    "LINTER_FAILED"                         : "{0} terminated with error: {1}",\r\n    \r\n    \r\n    /**\r\n     * Command Name Constants\r\n     */\r\n\r\n    // File menu commands\r\n    "FILE_MENU"                           : "File",\r\n    "CMD_FILE_NEW_UNTITLED"               : "New",\r\n    "CMD_FILE_NEW"                        : "New File",\r\n    "CMD_FILE_NEW_FOLDER"                 : "New Folder",\r\n    "CMD_FILE_OPEN"                       : "Open\\u2026",\r\n    "CMD_ADD_TO_WORKINGSET_AND_OPEN"      : "Add To Working Set and Open",\r\n    "CMD_OPEN_DROPPED_FILES"              : "Open Dropped Files",\r\n    "CMD_OPEN_FOLDER"                     : "Open Folder\\u2026",\r\n    "CMD_FILE_CLOSE"                      : "Close",\r\n    "CMD_FILE_CLOSE_ALL"                  : "Close All",\r\n    "CMD_FILE_CLOSE_LIST"                 : "Close List",\r\n    "CMD_FILE_CLOSE_OTHERS"               : "Close Others",\r\n    "CMD_FILE_CLOSE_ABOVE"                : "Close Others Above",\r\n    "CMD_FILE_CLOSE_BELOW"                : "Close Others Below",\r\n    "CMD_FILE_SAVE"                       : "Save",\r\n    "CMD_FILE_SAVE_ALL"                   : "Save All",\r\n    "CMD_FILE_SAVE_AS"                    : "Save As\\u2026",\r\n    "CMD_LIVE_FILE_PREVIEW"               : "Live Preview",\r\n    "CMD_RELOAD_LIVE_PREVIEW"             : "Force Reload Live Preview",\r\n    "CMD_PROJECT_SETTINGS"                : "Project Settings\\u2026",\r\n    "CMD_FILE_RENAME"                     : "Rename",\r\n    "CMD_FILE_DELETE"                     : "Delete",\r\n    "CMD_INSTALL_EXTENSION"               : "Install Extension\\u2026",\r\n    "CMD_EXTENSION_MANAGER"               : "Extension Manager\\u2026",\r\n    "CMD_FILE_REFRESH"                    : "Refresh File Tree",\r\n    "CMD_QUIT"                            : "Quit",\r\n    // Used in native File menu on Windows\r\n    "CMD_EXIT"                            : "Exit",\r\n\r\n    // Edit menu commands\r\n    "EDIT_MENU"                           : "Edit",\r\n    "CMD_UNDO"                            : "Undo",\r\n    "CMD_REDO"                            : "Redo",\r\n    "CMD_CUT"                             : "Cut",\r\n    "CMD_COPY"                            : "Copy",\r\n    "CMD_PASTE"                           : "Paste",\r\n    "CMD_SELECT_ALL"                      : "Select All",\r\n    "CMD_SELECT_LINE"                     : "Select Line",\r\n    "CMD_SPLIT_SEL_INTO_LINES"            : "Split Selection into Lines",\r\n    "CMD_ADD_CUR_TO_NEXT_LINE"            : "Add Cursor to Next Line",\r\n    "CMD_ADD_CUR_TO_PREV_LINE"            : "Add Cursor to Previous Line",\r\n    "CMD_INDENT"                          : "Indent",\r\n    "CMD_UNINDENT"                        : "Unindent",\r\n    "CMD_DUPLICATE"                       : "Duplicate",\r\n    "CMD_DELETE_LINES"                    : "Delete Line",\r\n    "CMD_COMMENT"                         : "Toggle Line Comment",\r\n    "CMD_BLOCK_COMMENT"                   : "Toggle Block Comment",\r\n    "CMD_LINE_UP"                         : "Move Line Up",\r\n    "CMD_LINE_DOWN"                       : "Move Line Down",\r\n    "CMD_OPEN_LINE_ABOVE"                 : "Open Line Above",\r\n    "CMD_OPEN_LINE_BELOW"                 : "Open Line Below",\r\n    "CMD_TOGGLE_CLOSE_BRACKETS"           : "Auto Close Braces",\r\n    "CMD_SHOW_CODE_HINTS"                 : "Show Code Hints",\r\n    \r\n    // Search menu commands\r\n    "FIND_MENU"                           : "Find",\r\n    "CMD_FIND"                            : "Find",\r\n    "CMD_FIND_NEXT"                       : "Find Next",\r\n    "CMD_FIND_PREVIOUS"                   : "Find Previous",\r\n    "CMD_FIND_ALL_AND_SELECT"             : "Find All and Select",\r\n    "CMD_ADD_NEXT_MATCH"                  : "Add Next Match to Selection",\r\n    "CMD_SKIP_CURRENT_MATCH"              : "Skip and Add Next Match",\r\n    "CMD_FIND_IN_FILES"                   : "Find in Files",\r\n    "CMD_FIND_IN_SELECTED"                : "Find in Selected File/Folder",\r\n    "CMD_FIND_IN_SUBTREE"                 : "Find in\\u2026",\r\n    "CMD_REPLACE"                         : "Replace",\r\n    "CMD_REPLACE_IN_FILES"                : "Replace in Files",\r\n    "CMD_REPLACE_IN_SELECTED"             : "Replace in Selected File/Folder",\r\n    "CMD_REPLACE_IN_SUBTREE"              : "Replace in\\u2026",\r\n    \r\n    // View menu commands\r\n    "VIEW_MENU"                           : "View",\r\n    "CMD_HIDE_SIDEBAR"                    : "Hide Sidebar",\r\n    "CMD_SHOW_SIDEBAR"                    : "Show Sidebar",\r\n    "CMD_INCREASE_FONT_SIZE"              : "Increase Font Size",\r\n    "CMD_DECREASE_FONT_SIZE"              : "Decrease Font Size",\r\n    "CMD_RESTORE_FONT_SIZE"               : "Restore Font Size",\r\n    "CMD_SCROLL_LINE_UP"                  : "Scroll Line Up",\r\n    "CMD_SCROLL_LINE_DOWN"                : "Scroll Line Down",\r\n    "CMD_TOGGLE_LINE_NUMBERS"             : "Line Numbers",\r\n    "CMD_TOGGLE_ACTIVE_LINE"              : "Highlight Active Line",\r\n    "CMD_TOGGLE_WORD_WRAP"                : "Word Wrap",\r\n    "CMD_LIVE_HIGHLIGHT"                  : "Live Preview Highlight",\r\n    "CMD_VIEW_TOGGLE_INSPECTION"          : "Lint Files on Save",\r\n    "CMD_WORKINGSET_SORT_BY_ADDED"        : "Sort by Added",\r\n    "CMD_WORKINGSET_SORT_BY_NAME"         : "Sort by Name",\r\n    "CMD_WORKINGSET_SORT_BY_TYPE"         : "Sort by Type",\r\n    "CMD_WORKING_SORT_TOGGLE_AUTO"        : "Automatic Sort",\r\n    "CMD_THEMES"                          : "Themes\\u2026",\r\n\r\n    // Navigate menu Commands\r\n    "NAVIGATE_MENU"                       : "Navigate",\r\n    "CMD_QUICK_OPEN"                      : "Quick Open",\r\n    "CMD_GOTO_LINE"                       : "Go to Line",\r\n    "CMD_GOTO_DEFINITION"                 : "Quick Find Definition",\r\n    "CMD_GOTO_FIRST_PROBLEM"              : "Go to First Error/Warning",\r\n    "CMD_TOGGLE_QUICK_EDIT"               : "Quick Edit",\r\n    "CMD_TOGGLE_QUICK_DOCS"               : "Quick Docs",\r\n    "CMD_QUICK_EDIT_PREV_MATCH"           : "Previous Match",\r\n    "CMD_QUICK_EDIT_NEXT_MATCH"           : "Next Match",\r\n    "CMD_CSS_QUICK_EDIT_NEW_RULE"         : "New Rule",\r\n    "CMD_NEXT_DOC"                        : "Next Document",\r\n    "CMD_PREV_DOC"                        : "Previous Document",\r\n    "CMD_SHOW_IN_TREE"                    : "Show in File Tree",\r\n    "CMD_SHOW_IN_EXPLORER"                : "Show in Explorer",\r\n    "CMD_SHOW_IN_FINDER"                  : "Show in Finder",\r\n    "CMD_SHOW_IN_OS"                      : "Show in OS",\r\n    \r\n    // Help menu commands\r\n    "HELP_MENU"                           : "Help",\r\n    "CMD_CHECK_FOR_UPDATE"                : "Check for Updates",\r\n    "CMD_HOW_TO_USE_BRACKETS"             : "How to Use {APP_NAME}",\r\n    "CMD_SUPPORT"                         : "{APP_NAME} Support",\r\n    "CMD_SUGGEST"                         : "Suggest a Feature",\r\n    "CMD_RELEASE_NOTES"                   : "Release Notes",\r\n    "CMD_GET_INVOLVED"                    : "Get Involved",\r\n    "CMD_SHOW_EXTENSIONS_FOLDER"          : "Show Extensions Folder",\r\n    "CMD_HOMEPAGE"                        : "{APP_TITLE} Homepage",\r\n    "CMD_TWITTER"                         : "{TWITTER_NAME} on Twitter",\r\n    "CMD_ABOUT"                           : "About {APP_TITLE}",\r\n    "CMD_OPEN_PREFERENCES"                : "Open Preferences File",\r\n\r\n    // Strings for main-view.html\r\n    "EXPERIMENTAL_BUILD"                   : "experimental build",\r\n    "DEVELOPMENT_BUILD"                    : "development build",\r\n    "RELOAD_FROM_DISK"                     : "Reload from Disk",\r\n    "KEEP_CHANGES_IN_EDITOR"               : "Keep Changes in Editor",\r\n    "CLOSE_DONT_SAVE"                      : "Close (Don\'t Save)",\r\n    "RELAUNCH_CHROME"                      : "Relaunch Chrome",\r\n    "ABOUT"                                : "About",\r\n    "CLOSE"                                : "Close",\r\n    "ABOUT_TEXT_LINE1"                     : "Release {VERSION_MAJOR}.{VERSION_MINOR} {BUILD_TYPE} {VERSION}",\r\n    "ABOUT_TEXT_BUILD_TIMESTAMP"           : "build timestamp: ",\r\n    "ABOUT_TEXT_LINE3"                     : "Notices, terms and conditions pertaining to third party software are located at <a href=\'{ADOBE_THIRD_PARTY}\'>{ADOBE_THIRD_PARTY}</a> and incorporated by reference herein.",\r\n    "ABOUT_TEXT_LINE4"                     : "Documentation and source at <a href=\'https://github.com/adobe/brackets/\'>https://github.com/adobe/brackets/</a>",\r\n    "ABOUT_TEXT_LINE5"                     : "Made with \\u2764 and JavaScript by:",\r\n    "ABOUT_TEXT_LINE6"                     : "Lots of people (but we\'re having trouble loading that data right now).",\r\n    "ABOUT_TEXT_WEB_PLATFORM_DOCS"         : "Web Platform Docs and the Web Platform graphical logo are licensed under a Creative Commons Attribution license, <a href=\'{WEB_PLATFORM_DOCS_LICENSE}\'>CC-BY 3.0 Unported</a>.",\r\n    "UPDATE_NOTIFICATION_TOOLTIP"          : "There\'s a new build of {APP_NAME} available! Click here for details.",\r\n    "UPDATE_AVAILABLE_TITLE"               : "Update Available",\r\n    "UPDATE_MESSAGE"                       : "Hey, there\'s a new build of {APP_NAME} available. Here are some of the new features:",\r\n    "GET_IT_NOW"                           : "Get it now!",\r\n    "PROJECT_SETTINGS_TITLE"               : "Project Settings for: {0}",\r\n    "PROJECT_SETTING_BASE_URL"             : "Live Preview Base URL",\r\n    "PROJECT_SETTING_BASE_URL_HINT"        : "To use a local server, enter a url like http://localhost:8000/",\r\n    "BASEURL_ERROR_INVALID_PROTOCOL"       : "The {0} protocol isn\'t supported by Live Preview&mdash;please use http: or https: .",\r\n    "BASEURL_ERROR_SEARCH_DISALLOWED"      : "The base URL can\'t contain search parameters like \\"{0}\\".",\r\n    "BASEURL_ERROR_HASH_DISALLOWED"        : "The base URL can\'t contain hashes like \\"{0}\\".",\r\n    "BASEURL_ERROR_INVALID_CHAR"           : "Special characters like \'{0}\' must be %-encoded.",\r\n    "BASEURL_ERROR_UNKNOWN_ERROR"          : "Unknown error parsing Base URL",\r\n    "EMPTY_VIEW_HEADER"                    : "<em>Select a file while this view has focus</em>",\r\n    \r\n    // Strings for themes-settings.html and themes-general.html\r\n    "CURRENT_THEME"                        : "Current Theme",\r\n    "USE_THEME_SCROLLBARS"                 : "Use Theme Scrollbars",\r\n    "FONT_SIZE"                            : "Font Size",\r\n    "FONT_FAMILY"                          : "Font Family",\r\n    "THEMES_SETTINGS"                      : "Themes Settings",\r\n\r\n    // CSS Quick Edit\r\n    "BUTTON_NEW_RULE"                      : "New Rule",\r\n    \r\n    // Extension Management strings\r\n    "INSTALL"                              : "Install",\r\n    "UPDATE"                               : "Update",\r\n    "REMOVE"                               : "Remove",\r\n    "OVERWRITE"                            : "Overwrite",\r\n    "CANT_REMOVE_DEV"                      : "Extensions in the \\"dev\\" folder must be manually deleted.",\r\n    "CANT_UPDATE"                          : "The update isn\'t compatible with this version of {APP_NAME}.",\r\n    "CANT_UPDATE_DEV"                      : "Extensions in the \\"dev\\" folder can\'t be updated automatically.",\r\n    "INSTALL_EXTENSION_TITLE"              : "Install Extension",\r\n    "UPDATE_EXTENSION_TITLE"               : "Update Extension",\r\n    "INSTALL_EXTENSION_LABEL"              : "Extension URL",\r\n    "INSTALL_EXTENSION_HINT"               : "URL of the extension\'s zip file or GitHub repo",\r\n    "INSTALLING_FROM"                      : "Installing extension from {0}\\u2026",\r\n    "INSTALL_SUCCEEDED"                    : "Installation successful!",\r\n    "INSTALL_FAILED"                       : "Installation failed.",\r\n    "CANCELING_INSTALL"                    : "Canceling\\u2026",\r\n    "CANCELING_HUNG"                       : "Canceling the install is taking a long time. An internal error may have occurred.",\r\n    "INSTALL_CANCELED"                     : "Installation canceled.",\r\n    "VIEW_COMPLETE_DESCRIPTION"            : "View complete description",\r\n    "VIEW_TRUNCATED_DESCRIPTION"           : "View truncated description",\r\n    // These must match the error codes in ExtensionsDomain.Errors.* :\r\n    "INVALID_ZIP_FILE"                     : "The downloaded content is not a valid zip file.",\r\n    "INVALID_PACKAGE_JSON"                 : "The package.json file is not valid (error was: {0}).",\r\n    "MISSING_PACKAGE_NAME"                 : "The package.json file doesn\'t specify a package name.",\r\n    "BAD_PACKAGE_NAME"                     : "{0} is an invalid package name.",\r\n    "MISSING_PACKAGE_VERSION"              : "The package.json file doesn\'t specify a package version.",\r\n    "INVALID_VERSION_NUMBER"               : "The package version number ({0}) is invalid.",\r\n    "INVALID_BRACKETS_VERSION"             : "The {APP_NAME} compatibility string ({0}) is invalid.",\r\n    "DISALLOWED_WORDS"                     : "The words ({1}) are not allowed in the {0} field.",\r\n    "API_NOT_COMPATIBLE"                   : "The extension isn\'t compatible with this version of {APP_NAME}. It\'s installed in your disabled extensions folder.",\r\n    "MISSING_MAIN"                         : "The package has no main.js file.",\r\n    "EXTENSION_ALREADY_INSTALLED"          : "Installing this package will overwrite a previously installed extension. Overwrite the old extension?",\r\n    "EXTENSION_SAME_VERSION"               : "This package is the same version as the one that is currently installed. Overwrite the existing installation?",\r\n    "EXTENSION_OLDER_VERSION"              : "This package is version {0} which is older than the currently installed ({1}). Overwrite the existing installation?",\r\n    "DOWNLOAD_ID_IN_USE"                   : "Internal error: download ID already in use.",\r\n    "NO_SERVER_RESPONSE"                   : "Cannot connect to server.",\r\n    "BAD_HTTP_STATUS"                      : "File not found on server (HTTP {0}).",\r\n    "CANNOT_WRITE_TEMP"                    : "Unable to save download to temp file.",\r\n    "ERROR_LOADING"                        : "The extension encountered an error while starting up.",\r\n    "MALFORMED_URL"                        : "The URL is invalid. Please check that you entered it correctly.",\r\n    "UNSUPPORTED_PROTOCOL"                 : "The URL must be an http or https URL.",\r\n    "UNKNOWN_ERROR"                        : "Unknown internal error.",\r\n    // For NOT_FOUND_ERR, see generic strings above\r\n    "EXTENSION_MANAGER_TITLE"              : "Extension Manager",\r\n    "EXTENSION_MANAGER_ERROR_LOAD"         : "Unable to access the extension registry. Please try again later.",\r\n    "INSTALL_EXTENSION_DRAG"               : "Drag .zip here or",\r\n    "INSTALL_EXTENSION_DROP"               : "Drop .zip to install",\r\n    "INSTALL_EXTENSION_DROP_ERROR"         : "Install/Update aborted due to the following errors:",\r\n    "INSTALL_FROM_URL"                     : "Install from URL\\u2026",\r\n    "INSTALL_EXTENSION_VALIDATING"         : "Validating\\u2026",\r\n    "EXTENSION_AUTHOR"                     : "Author",\r\n    "EXTENSION_DATE"                       : "Date",\r\n    "EXTENSION_INCOMPATIBLE_NEWER"         : "This extension requires a newer version of {APP_NAME}.",\r\n    "EXTENSION_INCOMPATIBLE_OLDER"         : "This extension currently only works with older versions of {APP_NAME}.",\r\n    "EXTENSION_LATEST_INCOMPATIBLE_NEWER"  : "Version {0} of this extension requires a newer version of {APP_NAME}. But you can install the earlier version {1}.",\r\n    "EXTENSION_LATEST_INCOMPATIBLE_OLDER"  : "Version {0} of this extension only works with older versions of {APP_NAME}. But you can install the earlier version {1}.",\r\n    "EXTENSION_NO_DESCRIPTION"             : "No description",\r\n    "EXTENSION_MORE_INFO"                  : "More info...",\r\n    "EXTENSION_ERROR"                      : "Extension error",\r\n    "EXTENSION_KEYWORDS"                   : "Keywords",\r\n    "EXTENSION_TRANSLATED_USER_LANG"       : "Translated into {0} languages, including yours",\r\n    "EXTENSION_TRANSLATED_GENERAL"         : "Translated into {0} languages",\r\n    "EXTENSION_TRANSLATED_LANGS"           : "This extension has been translated into these languages: {0}",\r\n    "EXTENSION_INSTALLED"                  : "Installed",\r\n    "EXTENSION_UPDATE_INSTALLED"           : "This extension update has been downloaded and will be installed after {APP_NAME} reloads.",\r\n    "EXTENSION_SEARCH_PLACEHOLDER"         : "Search",\r\n    "EXTENSION_MORE_INFO_LINK"             : "More",\r\n    "BROWSE_EXTENSIONS"                    : "Browse Extensions",\r\n    "EXTENSION_MANAGER_REMOVE"             : "Remove Extension",\r\n    "EXTENSION_MANAGER_REMOVE_ERROR"       : "Unable to remove one or more extensions: {0}. {APP_NAME} will still reload.",\r\n    "EXTENSION_MANAGER_UPDATE"             : "Update Extension",\r\n    "EXTENSION_MANAGER_UPDATE_ERROR"       : "Unable to update one or more extensions: {0}. {APP_NAME} will still reload.",\r\n    "MARKED_FOR_REMOVAL"                   : "Marked for removal",\r\n    "UNDO_REMOVE"                          : "Undo",\r\n    "MARKED_FOR_UPDATE"                    : "Marked for update",\r\n    "UNDO_UPDATE"                          : "Undo",\r\n    "CHANGE_AND_RELOAD_TITLE"              : "Change Extensions",\r\n    "CHANGE_AND_RELOAD_MESSAGE"            : "To update or remove the marked extensions, {APP_NAME} will need to reload. You\'ll be prompted to save unsaved changes.",\r\n    "REMOVE_AND_RELOAD"                    : "Remove Extensions and Reload",\r\n    "CHANGE_AND_RELOAD"                    : "Change Extensions and Reload",\r\n    "UPDATE_AND_RELOAD"                    : "Update Extensions and Reload",\r\n    "PROCESSING_EXTENSIONS"                : "Processing extension changes\\u2026",\r\n    "EXTENSION_NOT_INSTALLED"              : "Couldn\'t remove extension {0} because it wasn\'t installed.",\r\n    "NO_EXTENSIONS"                        : "No extensions installed yet.<br>Click on the Available tab above to get started.",\r\n    "NO_EXTENSION_MATCHES"                 : "No extensions match your search.",\r\n    "REGISTRY_SANITY_CHECK_WARNING"        : "NOTE: These extensions may come from different authors than {APP_NAME} itself. Extensions are not reviewed and have full local privileges. Be cautious when installing extensions from an unknown source.",\r\n    "EXTENSIONS_INSTALLED_TITLE"           : "Installed",\r\n    "EXTENSIONS_AVAILABLE_TITLE"           : "Available",\r\n    "EXTENSIONS_THEMES_TITLE"              : "Themes",\r\n    "EXTENSIONS_UPDATES_TITLE"             : "Updates",\r\n    \r\n    "INLINE_EDITOR_NO_MATCHES"             : "No matches available.",\r\n    "CSS_QUICK_EDIT_NO_MATCHES"            : "There are no existing CSS rules that match your selection.<br> Click \\"New Rule\\" to create one.",\r\n    "CSS_QUICK_EDIT_NO_STYLESHEETS"        : "There are no stylesheets in your project.<br>Create one to add CSS rules.",\r\n\r\n    // Custom Viewers\r\n    "IMAGE_VIEWER_LARGEST_ICON"            : "largest",\r\n    \r\n    /**\r\n     * Unit names\r\n     */\r\n\r\n    "UNIT_PIXELS"                          : "pixels",\r\n\r\n    // extensions/default/DebugCommands\r\n    "DEBUG_MENU"                                : "Debug",\r\n    "ERRORS"                                    : "Errors",\r\n    "CMD_SHOW_DEV_TOOLS"                        : "Show Developer Tools",\r\n    "CMD_REFRESH_WINDOW"                        : "Reload With Extensions",\r\n    "CMD_RELOAD_WITHOUT_USER_EXTS"              : "Reload Without Extensions",\r\n    "CMD_NEW_BRACKETS_WINDOW"                   : "New {APP_NAME} Window",\r\n    "CMD_SWITCH_LANGUAGE"                       : "Switch Language",\r\n    "CMD_RUN_UNIT_TESTS"                        : "Run Tests",\r\n    "CMD_SHOW_PERF_DATA"                        : "Show Performance Data",\r\n    "CMD_ENABLE_NODE_DEBUGGER"                  : "Enable Node Debugger",\r\n    "CMD_LOG_NODE_STATE"                        : "Log Node State to Console",\r\n    "CMD_RESTART_NODE"                          : "Restart Node",\r\n    "CMD_SHOW_ERRORS_IN_STATUS_BAR"             : "Show Errors in Status Bar",\r\n    "CMD_OPEN_BRACKETS_SOURCE"                  : "Open Brackets Source",\r\n    \r\n    "LANGUAGE_TITLE"                            : "Switch Language",\r\n    "LANGUAGE_MESSAGE"                          : "Language:",\r\n    "LANGUAGE_SUBMIT"                           : "Reload {APP_NAME}",\r\n    "LANGUAGE_CANCEL"                           : "Cancel",\r\n    "LANGUAGE_SYSTEM_DEFAULT"                   : "System Default",\r\n    \r\n    // extensions/default/InlineTimingFunctionEditor\r\n    "INLINE_TIMING_EDITOR_TIME"                 : "Time",\r\n    "INLINE_TIMING_EDITOR_PROGRESSION"          : "Progression",\r\n    "BEZIER_EDITOR_INFO"                        : "<kbd>↑</kbd><kbd>↓</kbd><kbd>←</kbd><kbd>→</kbd> Move selected point<br><kbd class=\'text\'>Shift</kbd> Move by ten units<br><kbd class=\'text\'>Tab</kbd> Switch points",\r\n    "STEPS_EDITOR_INFO"                         : "<kbd>↑</kbd><kbd>↓</kbd> Increase or decrease steps<br><kbd>←</kbd><kbd>→</kbd> \'Start\' or \'End\'",\r\n    "INLINE_TIMING_EDITOR_INVALID"              : "The old value <code>{0}</code> is not valid, so the displayed function was changed to <code>{1}</code>. The document will be updated with the first edit.",\r\n    \r\n    // extensions/default/InlineColorEditor\r\n    "COLOR_EDITOR_CURRENT_COLOR_SWATCH_TIP"     : "Current Color",\r\n    "COLOR_EDITOR_ORIGINAL_COLOR_SWATCH_TIP"    : "Original Color",\r\n    "COLOR_EDITOR_RGBA_BUTTON_TIP"              : "RGBa Format",\r\n    "COLOR_EDITOR_HEX_BUTTON_TIP"               : "Hex Format",\r\n    "COLOR_EDITOR_HSLA_BUTTON_TIP"              : "HSLa Format",\r\n    "COLOR_EDITOR_USED_COLOR_TIP_SINGULAR"      : "{0} (Used {1} time)",\r\n    "COLOR_EDITOR_USED_COLOR_TIP_PLURAL"        : "{0} (Used {1} times)",\r\n    \r\n    // extensions/default/JavaScriptCodeHints\r\n    "CMD_JUMPTO_DEFINITION"                     : "Jump to Definition",\r\n    "CMD_SHOW_PARAMETER_HINT"                   : "Show Parameter Hint",\r\n    "NO_ARGUMENTS"                              : "<no parameters>",\r\n    "DETECTED_EXCLUSION_TITLE"                  : "JavaScript File Inference Problem",\r\n    "DETECTED_EXCLUSION_INFO"                   : "Brackets ran into trouble processing:<br><br>{0}<br><br>This file will no longer be processed for code hints and jump to definition. To turn this back on, open <code>.brackets.json</code> in your project and remove the file from jscodehints.detectedExclusions.",\r\n    \r\n    // extensions/default/JSLint\r\n    "JSLINT_NAME"                               : "JSLint",\r\n    \r\n    // extensions/default/QuickView\r\n    "CMD_ENABLE_QUICK_VIEW"                     : "Quick View on Hover",\r\n    \r\n    // extensions/default/RecentProjects\r\n    "CMD_TOGGLE_RECENT_PROJECTS"                : "Recent Projects",\r\n    \r\n    // extensions/default/WebPlatformDocs\r\n    "DOCS_MORE_LINK"                            : "Read more"\r\n});\r\n\n//# sourceURL=/nls/root/strings.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\ndefine(\'nls/urls\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    \r\n    "use strict";\r\n    \r\n    // Registry for languages that have specific per-language URLs or file paths that we use\r\n    // elsewhere in Brackets.\r\n    //\r\n    // TODO: dynamically populate the local prefix list below?\r\n    module.exports = {\r\n        root: true,\r\n        "cs": true,\r\n        "da": true,\r\n        "de": true,\r\n        "es": true,\r\n		"fa-ir": true,\r\n        "fi": true,\r\n        "fr": true,\r\n        "hr": true,\r\n        "id": true,\r\n        "it": true,\r\n        "ja": true,\r\n        "ko": true,\r\n        "nb": true,\r\n        "pl": true,\r\n        "pt-br": true,\r\n        "pt-pt": true,\r\n        "ru": true,\r\n        "sv": true,\r\n        "zh-cn": true,\r\n        "tr": true\r\n    };\r\n});\r\n\n//# sourceURL=/nls/urls.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\ndefine(\'nls/root/urls\',{\r\n    // Relative to the samples folder\r\n    "GETTING_STARTED"           : "root/Getting Started",\r\n    "ADOBE_THIRD_PARTY"         : "http://www.adobe.com/go/thirdparty/",\r\n    "WEB_PLATFORM_DOCS_LICENSE" : "http://creativecommons.org/licenses/by/3.0/"\r\n});\r\n\n//# sourceURL=/nls/root/urls.js'),eval("/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\ndefine('nls/strings-app',['require','exports','module'],function (require, exports, module) {\r\n    \r\n    \"use strict\";\r\n    \r\n    // Code that needs to display user strings should call require(\"strings\") to load\r\n    // src/strings.js. This file will dynamically load strings.js for the specified brackets.locale.\r\n    //\r\n    // See the README.md file in this folder for information on how to add a new translation for\r\n    // another language or locale.\r\n    //\r\n    // TODO: dynamically populate the local prefix list below?\r\n    module.exports = {\r\n        root: true\r\n    };\r\n});\r\n\n//# sourceURL=/nls/strings-app.js"),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\ndefine(\'nls/root/strings-app\',{\r\n    // product-specific strings\r\n    "APP_NAME"                             : "Brackets",\r\n\r\n    // Self locales (used by Debug > Switch Language)\r\n    "LOCALE_CS"                                 : "čeština",\r\n    "LOCALE_DA"                                 : "Dansk",\r\n    "LOCALE_DE"                                 : "Deutsch",\r\n    "LOCALE_EL"                                 : "Ελληνικά",\r\n    "LOCALE_EN"                                 : "English (US)",\r\n    "LOCALE_EN_GB"                              : "English (UK)",\r\n    "LOCALE_ES"                                 : "español",\r\n    "LOCALE_FA_IR"                              : "فارسی",\r\n    "LOCALE_FI"                                 : "suomi",\r\n    "LOCALE_FR"                                 : "français",\r\n    "LOCALE_GL"                                 : "galego",\r\n    "LOCALE_HR"                                 : "hrvatski",\r\n    "LOCALE_HU"                                 : "magyar",\r\n    "LOCALE_ID"                                 : "Bahasa Indonesia",\r\n    "LOCALE_IT"                                 : "italiano",\r\n    "LOCALE_JA"                                 : "日本語",\r\n    "LOCALE_KO"                                 : "한국어",\r\n    "LOCALE_NB"                                 : "norsk",\r\n    "LOCALE_NL"                                 : "Nederlands",\r\n    "LOCALE_PL"                                 : "polski",\r\n    "LOCALE_PT_BR"                              : "português (BR)",\r\n    "LOCALE_PT_PT"                              : "português (PT)",\r\n    "LOCALE_RO"                                 : "română",\r\n    "LOCALE_RU"                                 : "русский",\r\n    "LOCALE_SK"                                 : "slovenčina",\r\n    "LOCALE_SR"                                 : "Српски",\r\n    "LOCALE_SV"                                 : "svenska",\r\n    "LOCALE_TR"                                 : "Türkçe",\r\n    "LOCALE_UK"                                 : "Українська",\r\n    "LOCALE_ZH_CN"                              : "简体中文",\r\n    "LOCALE_ZH_TW"                              : "繁體中文"\r\n});\r\n\n//# sourceURL=/nls/root/strings-app.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets */\r\n\r\n/**\r\n *  Utilities functions related to string manipulation\r\n *\r\n */\r\ndefine(\'utils/StringUtils\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n\r\n    /**\r\n     * Format a string by replacing placeholder symbols with passed in arguments.\r\n     *\r\n     * Example: var formatted = StringUtils.format("Hello {0}", "World");\r\n     *\r\n     * @param {string} str The base string\r\n     * @param {...} Arguments to be substituted into the string\r\n     *\r\n     * @return {string} Formatted string\r\n     */\r\n    function format(str) {\r\n        // arguments[0] is the base string, so we need to adjust index values here\r\n        var args = [].slice.call(arguments, 1);\r\n        return str.replace(/\\{(\\d+)\\}/g, function (match, num) {\r\n            return typeof args[num] !== "undefined" ? args[num] : match;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @deprecated Use lodash `escape()` instead.\r\n     */\r\n    function htmlEscape(str) {\r\n        console.warn("StringUtils.htmlEscape is deprecated. Use _.escape instead.");\r\n        return _.escape(str);\r\n    }\r\n\r\n    function regexEscape(str) {\r\n        return str.replace(/([.?*+\\^$\\[\\]\\\\(){}|\\-])/g, "\\\\$1");\r\n    }\r\n\r\n    // Periods (aka "dots") are allowed in HTML identifiers, but jQuery interprets\r\n    // them as the start of a class selector, so they need to be escaped\r\n    function jQueryIdEscape(str) {\r\n        return str.replace(/\\./g, "\\\\.");\r\n    }\r\n\r\n    /**\r\n     * Splits the text by new line characters and returns an array of lines\r\n     * @param {string} text\r\n     * @return {Array.<string>} lines\r\n     */\r\n    function getLines(text) {\r\n        return text.split("\\n");\r\n    }\r\n\r\n    /**\r\n     * Returns a line number corresponding to an offset in some text. The text can\r\n     * be specified as a single string or as an array of strings that correspond to\r\n     * the lines of the string.\r\n     *\r\n     * Specify the text in lines when repeatedly calling the function on the same\r\n     * text in a loop. Use getLines() to divide the text into lines, then repeatedly call\r\n     * this function to compute a line number from the offset.\r\n     *\r\n     * @param {string | Array.<string>} textOrLines - string or array of lines from which\r\n     *      to compute the line number from the offset\r\n     * @param {number} offset\r\n     * @return {number} line number\r\n     */\r\n    function offsetToLineNum(textOrLines, offset) {\r\n        if (Array.isArray(textOrLines)) {\r\n            var lines = textOrLines,\r\n                total = 0,\r\n                line;\r\n            for (line = 0; line < lines.length; line++) {\r\n                if (total < offset) {\r\n                    // add 1 per line since /n were removed by splitting, but they needed to \r\n                    // contribute to the total offset count\r\n                    total += lines[line].length + 1;\r\n                } else if (total === offset) {\r\n                    return line;\r\n                } else {\r\n                    return line - 1;\r\n                }\r\n            }\r\n\r\n            // if offset is NOT over the total then offset is in the last line\r\n            if (offset <= total) {\r\n                return line - 1;\r\n            } else {\r\n                return undefined;\r\n            }\r\n        } else {\r\n            return textOrLines.substr(0, offset).split("\\n").length - 1;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Returns true if the given string ends with the given suffix.\r\n     *\r\n     * @param {string} str\r\n     * @param {string} suffix\r\n     */\r\n    function endsWith(str, suffix) {\r\n        return str.indexOf(suffix, str.length - suffix.length) !== -1;\r\n    }\r\n\r\n    function urlSort(a, b) {\r\n        var a2, b2;\r\n        function isFile(s) {\r\n            return ((s.lastIndexOf("/") + 1) < s.length);\r\n        }\r\n\r\n        if (brackets.platform === "win") {\r\n            // Windows: prepend folder names with a \'0\' and file names with a \'1\' so folders are listed first\r\n            a2 = ((isFile(a)) ? "1" : "0") + a.toLowerCase();\r\n            b2 = ((isFile(b)) ? "1" : "0") + b.toLowerCase();\r\n        } else {\r\n            a2 = a.toLowerCase();\r\n            b2 = b.toLowerCase();\r\n        }\r\n\r\n        if (a2 === b2) {\r\n            return 0;\r\n        } else {\r\n            return (a2 > b2) ? 1 : -1;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Return an escaped path or URL string that can be broken near path separators.\r\n     * @param {string} url the path or URL to format\r\n     * @return {string} the formatted path or URL\r\n     */\r\n    function breakableUrl(url) {\r\n        // This is for displaying in UI, so always want it escaped\r\n        var escUrl = _.escape(url);\r\n\r\n        // Inject zero-width space character (U+200B) near path separators (/) to allow line breaking there\r\n        return escUrl.replace(\r\n            new RegExp(regexEscape("/"), "g"),\r\n            "/" + "&#8203;"\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Converts number of bytes into human readable format.\r\n     * If param bytes is negative it returns the number without any changes.\r\n     *\r\n     * @param {number} bytes     Number of bytes to convert\r\n     * @param {number} precision Number of digits after the decimal separator\r\n     * @return {string}\r\n     */\r\n    function prettyPrintBytes(bytes, precision) {\r\n        var kilobyte = 1024,\r\n            megabyte = kilobyte * 1024,\r\n            gigabyte = megabyte * 1024,\r\n            terabyte = gigabyte * 1024,\r\n            returnVal = bytes;\r\n        \r\n        if ((bytes >= 0) && (bytes < kilobyte)) {\r\n            returnVal = bytes + " B";\r\n        } else if (bytes < megabyte) {\r\n            returnVal = (bytes / kilobyte).toFixed(precision) + " KB";\r\n        } else if (bytes < gigabyte) {\r\n            returnVal = (bytes / megabyte).toFixed(precision) + " MB";\r\n        } else if (bytes < terabyte) {\r\n            returnVal = (bytes / gigabyte).toFixed(precision) + " GB";\r\n        } else if (bytes >= terabyte) {\r\n            return (bytes / terabyte).toFixed(precision) + " TB";\r\n        }\r\n        \r\n        return returnVal;\r\n    }\r\n    \r\n    /**\r\n     * Truncate text to specified length.\r\n     * @param {string} str Text to be truncated.\r\n     * @param {number} len Length to which text should be truncated\r\n     * @return {?string} Returns truncated text only if it was changed\r\n     */\r\n    function truncate(str, len) {\r\n        // Truncate text to specified length\r\n        if (str.length > len) {\r\n            str = str.substr(0, len);\r\n\r\n            // To prevent awkwardly truncating in the middle of a word,\r\n            // attempt to truncate at the end of the last whole word\r\n            var lastSpaceChar = str.lastIndexOf(" ");\r\n            if (lastSpaceChar < len && lastSpaceChar > -1) {\r\n                str = str.substr(0, lastSpaceChar);\r\n            }\r\n            return str;\r\n        }\r\n    }\r\n\r\n    // Define public API\r\n    exports.format              = format;\r\n    exports.htmlEscape          = htmlEscape;\r\n    exports.regexEscape         = regexEscape;\r\n    exports.jQueryIdEscape      = jQueryIdEscape;\r\n    exports.getLines            = getLines;\r\n    exports.offsetToLineNum     = offsetToLineNum;\r\n    exports.urlSort             = urlSort;\r\n    exports.breakableUrl        = breakableUrl;\r\n    exports.endsWith            = endsWith;\r\n    exports.prettyPrintBytes    = prettyPrintBytes;\r\n    exports.truncate            = truncate;\r\n});\r\n\n//# sourceURL=/utils/StringUtils.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global $, define, brackets, window */\r\n\r\n/**\r\n * This file provides the interface to user visible strings in Brackets. Code that needs\r\n * to display strings should should load this module by calling `var Strings = require("strings")`.\r\n * The i18n plugin will dynamically load the strings for the right locale and populate\r\n * the exports variable. See src\\nls\\strings.js for the master file of English strings.\r\n */\r\ndefine(\'strings\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'i18n!nls/strings\',\'i18n!nls/urls\',\'i18n!nls/strings-app\',\'utils/Global\',\'utils/StringUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n    \r\n    var strings         = require("i18n!nls/strings"),\r\n        urls            = require("i18n!nls/urls"),\r\n        stringsApp      = require("i18n!nls/strings-app"),\r\n        Global          = require("utils/Global"),\r\n        StringUtils     = require("utils/StringUtils");\r\n\r\n    // Add URLs as additional globals\r\n    var additionalGlobals = $.extend({}, urls),\r\n        parsedVersion = /([0-9]+)\\.([0-9]+)\\.([0-9]+)/.exec(brackets.metadata.version);\r\n    \r\n    additionalGlobals.APP_NAME      = brackets.metadata.name || strings.APP_NAME;\r\n    additionalGlobals.APP_TITLE     = brackets.config.app_title || strings.APP_NAME;\r\n    additionalGlobals.TWITTER_NAME  = brackets.config.twitter_name;\r\n    additionalGlobals.VERSION       = brackets.metadata.version;\r\n    additionalGlobals.VERSION_MAJOR = parsedVersion[1];\r\n    additionalGlobals.VERSION_MINOR = parsedVersion[2];\r\n    additionalGlobals.VERSION_PATCH = parsedVersion[3];\r\n\r\n    var isDevBuild = !StringUtils.endsWith(decodeURI(window.location.pathname), "/www/index.html");\r\n    additionalGlobals.BUILD_TYPE    = (isDevBuild ? strings.DEVELOPMENT_BUILD : strings.EXPERIMENTAL_BUILD);\r\n    \r\n    // Insert application strings\r\n    _.forEach(strings, function (value, key) {\r\n        _.forEach(additionalGlobals, function (item, name) {\r\n            strings[key] = strings[key].replace(new RegExp("{" + name + "}", "g"), additionalGlobals[name]);\r\n        });\r\n    });\r\n    \r\n    // Append or overlay additional, product-specific strings\r\n    _.forEach(stringsApp, function (value, key) {\r\n        _.forEach(additionalGlobals, function (item, name) {\r\n            stringsApp[key] = stringsApp[key].replace(new RegExp("{" + name + "}", "g"), additionalGlobals[name]);\r\n        });\r\n        strings[key] = stringsApp[key];\r\n    });\r\n\r\n    module.exports = strings;\r\n\r\n});\n//# sourceURL=/strings.js'),eval('define(\'text!base-config/keyboard.json\',[],function () { return \'{\\r\\n    "file.newDoc":  [\\r\\n        "Ctrl-N"\\r\\n    ],\\r\\n    "file.open":  [\\r\\n        "Ctrl-O"\\r\\n    ],\\r\\n    "file.close":  [\\r\\n        "Ctrl-W"\\r\\n    ],\\r\\n    "file.openFolder": [\\r\\n        "Ctrl-Alt-O"\\r\\n    ],\\r\\n    "file.close_all":  [\\r\\n        "Ctrl-Shift-W"\\r\\n    ],\\r\\n    "file.save":  [\\r\\n        "Ctrl-S"\\r\\n    ],\\r\\n    "file.saveAll":  [\\r\\n        "Ctrl-Alt-S"\\r\\n    ],\\r\\n    "file.saveAs":  [\\r\\n        "Ctrl-Shift-S"\\r\\n    ],    \\r\\n    "file.liveFilePreview":  [\\r\\n        "Ctrl-Alt-P"\\r\\n    ],\\r\\n    "file.reloadLivePreview": [\\r\\n        {\\r\\n            "key": "Ctrl-Shift-R"\\r\\n        }\\r\\n    ],\\r\\n    "file.previewHighlight":  [\\r\\n        "Ctrl-Shift-C"\\r\\n    ],\\r\\n    "file.quit":  [\\r\\n        "Ctrl-Q"\\r\\n    ],\\r\\n    "edit.undo": [\\r\\n        "Ctrl-Z"\\r\\n    ],\\r\\n    "edit.redo": [\\r\\n        {\\r\\n            "key": "Ctrl-Y"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-Shift-Z",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "edit.cut": [\\r\\n        "Ctrl-X"\\r\\n    ],\\r\\n    "edit.copy": [\\r\\n        "Ctrl-C"\\r\\n    ],\\r\\n    "edit.paste": [\\r\\n        "Ctrl-V"\\r\\n    ],\\r\\n    "edit.selectAll":  [\\r\\n        "Ctrl-A"\\r\\n    ],\\r\\n    "edit.selectLine":  [\\r\\n        {\\r\\n            "key": "Ctrl-L"\\r\\n        },\\r\\n        {\\r\\n            "key": "Ctrl-L",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "edit.splitSelIntoLines": [\\r\\n        "Ctrl-Alt-L"\\r\\n    ],\\r\\n    "edit.addCursorToPrevLine": [\\r\\n        {\\r\\n            "key": "Shift-Alt-Up",\\r\\n            "displayKey": "Shift-Alt-↑"\\r\\n        }\\r\\n    ],\\r\\n    "edit.addCursorToNextLine": [\\r\\n        {\\r\\n            "key": "Shift-Alt-Down",\\r\\n            "displayKey": "Shift-Alt-↓"\\r\\n        }\\r\\n    ],\\r\\n    "edit.indent":  [\\r\\n        {\\r\\n            "key": "Ctrl-]"\\r\\n        }\\r\\n    ],\\r\\n    "edit.unindent":  [\\r\\n        {\\r\\n            "key": "Ctrl-["\\r\\n        }\\r\\n    ],\\r\\n    "edit.duplicate":  [\\r\\n        "Ctrl-D"\\r\\n    ],\\r\\n    "edit.deletelines":  [\\r\\n        "Ctrl-Shift-D"\\r\\n    ],\\r\\n    "edit.lineUp":  [\\r\\n        {\\r\\n            "key": "Ctrl-Shift-Up",\\r\\n            "displayKey": "Ctrl-Shift-↑"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-Ctrl-Up",\\r\\n            "displayKey": "Cmd-Ctrl-↑",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "edit.lineDown":  [\\r\\n        {\\r\\n            "key": "Ctrl-Shift-Down",\\r\\n            "displayKey": "Ctrl-Shift-↓"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-Ctrl-Down",\\r\\n            "displayKey": "Cmd-Ctrl-↓",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "edit.openLineAbove":  [\\r\\n        "Ctrl-Shift-Enter"\\r\\n    ],\\r\\n    "edit.openLineBelow":  [\\r\\n        "Ctrl-Enter"\\r\\n    ],\\r\\n    "edit.lineComment":  [\\r\\n        "Ctrl-/"\\r\\n    ],\\r\\n    "edit.blockComment":  [\\r\\n        {\\r\\n            "key": "Ctrl-Shift-/"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-Opt-/",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "edit.showCodeHints":  [\\r\\n        {\\r\\n            "key": "Ctrl-Space"\\r\\n        },\\r\\n        {\\r\\n            "key": "Ctrl-Space",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "cmd.find":  [\\r\\n        "Ctrl-F"\\r\\n    ],\\r\\n    "cmd.findInFiles":  [\\r\\n        "Ctrl-Shift-F"\\r\\n    ],\\r\\n    "cmd.replaceInFiles":  [\\r\\n        {\\r\\n            "key": "Ctrl-Shift-H"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-Alt-Shift-F",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "cmd.findNext":  [\\r\\n        {\\r\\n            "key": "F3"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-G",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "cmd.findPrevious":  [\\r\\n        {\\r\\n            "key": "Shift-F3"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-Shift-G",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "cmd.findAllAndSelect": [\\r\\n        {\\r\\n            "key": "Alt-F3"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-Ctrl-G",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "cmd.addNextMatch": [\\r\\n        {\\r\\n            "key": "Ctrl-B"\\r\\n        }\\r\\n    ],\\r\\n    "cmd.skipCurrentMatch": [\\r\\n        {\\r\\n            "key": "Ctrl-Shift-B"\\r\\n        }\\r\\n    ],\\r\\n    "cmd.replace":  [\\r\\n        {\\r\\n            "key": "Ctrl-H"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-Alt-F",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "view.hideSidebar":  [\\r\\n        {   \\r\\n            "key" : "Ctrl-Alt-H"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-Shift-H",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "view.increaseFontSize":  [\\r\\n        {\\r\\n            "key": "Ctrl-=",\\r\\n            "displayKey": "Cmd-+"\\r\\n        },\\r\\n        {\\r\\n            "key": "Ctrl-+",\\r\\n            "displayKey": "Cmd-+"\\r\\n        }\\r\\n    ],\\r\\n    "view.decreaseFontSize":  [\\r\\n        {\\r\\n            "key": "Ctrl--",\\r\\n            "displayKey": "Cmd-−"\\r\\n        }\\r\\n    ],\\r\\n    "view.restoreFontSize":  [\\r\\n        "Ctrl-0"\\r\\n    ],\\r\\n    "view.scrollLineUp":  [\\r\\n        {\\r\\n            "key": "Ctrl-Up",\\r\\n            "displayKey": "Ctrl-\\\\u2191"\\r\\n        },\\r\\n        {\\r\\n            "key": "Ctrl-Alt-Up",\\r\\n            "displayKey": "Ctrl-Alt-\\\\u2191",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "view.scrollLineDown":  [\\r\\n        {\\r\\n            "key": "Ctrl-Down",\\r\\n            "displayKey": "Ctrl-\\\\u2193"\\r\\n        },\\r\\n        {\\r\\n            "key": "Ctrl-Alt-Down",\\r\\n            "displayKey": "Ctrl-Alt-\\\\u2193",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "navigate.quickOpen":  [\\r\\n        "Ctrl-Shift-O"\\r\\n    ],\\r\\n    "navigate.gotoLine":  [\\r\\n        {\\r\\n            "key": "Ctrl-G"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-L",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "navigate.gotoDefinition":  [\\r\\n        "Ctrl-T"\\r\\n    ],\\r\\n    "navigate.jumptoDefinition":  [\\r\\n        "Ctrl-J"\\r\\n    ],\\r\\n    "navigate.gotoFirstProblem":  [\\r\\n        {\\r\\n            "key": "F8"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-\\\'",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "navigate.nextDoc":  [\\r\\n        {\\r\\n            "key": "Ctrl-Tab"\\r\\n        },\\r\\n        {\\r\\n            "key": "Ctrl-Tab",\\r\\n            "platform": "mac"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-Shift-]",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "navigate.prevDoc":  [\\r\\n        {\\r\\n            "key": "Ctrl-Shift-Tab"\\r\\n        },\\r\\n        {\\r\\n            "key": "Ctrl-Shift-Tab",\\r\\n            "platform": "mac"\\r\\n        },\\r\\n        {\\r\\n            "key": "Cmd-Shift-[",\\r\\n            "platform": "mac"\\r\\n        }\\r\\n    ],\\r\\n    "navigate.toggleQuickEdit":  [\\r\\n        "Ctrl-E"\\r\\n    ],\\r\\n    "navigate.toggleQuickDocs":  [\\r\\n        "Ctrl-K"\\r\\n    ],\\r\\n    "navigate.previousMatch":  [\\r\\n        {\\r\\n            "key": "Alt-Up",\\r\\n            "displayKey": "Alt-↑"\\r\\n        }\\r\\n    ],\\r\\n    "navigate.nextMatch":  [\\r\\n        {\\r\\n            "key": "Alt-Down",\\r\\n            "displayKey": "Alt-↓"\\r\\n        }\\r\\n    ],\\r\\n    "navigate.newRule":  [\\r\\n        "Cmd-Alt-N"\\r\\n    ],\\r\\n    "file.rename":  [\\r\\n        "F2"\\r\\n    ],\\r\\n    "help.support": [\\r\\n        "F1"\\r\\n    ]\\r\\n}\\r\\n\';});\n\n//# sourceURL=/text!base-config/keyboard.json'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, regexp: true */\r\n/*global define, $, brackets, window */\r\n/*unittests: KeyBindingManager */\r\n\r\n/**\r\n * Manages the mapping of keyboard inputs to commands.\r\n */\r\ndefine(\'command/KeyBindingManager\',[\'require\',\'exports\',\'module\',\'utils/Global\',\'utils/AppInit\',\'command/CommandManager\',\'utils/KeyEvent\',\'strings\',\'text!base-config/keyboard.json\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    require("utils/Global");\r\n\r\n    var AppInit        = require("utils/AppInit"),\r\n        CommandManager = require("command/CommandManager"),\r\n        KeyEvent       = require("utils/KeyEvent"),\r\n        Strings        = require("strings");\r\n\r\n    var KeyboardPrefs = JSON.parse(require("text!base-config/keyboard.json"));\r\n    \r\n    /**\r\n     * @private\r\n     * Maps normalized shortcut descriptor to key binding info.\r\n     * @type {!Object.<string, {commandID: string, key: string, displayKey: string}>}\r\n     */\r\n    var _keyMap = {};\r\n\r\n    /**\r\n     * @private\r\n     * Maps commandID to the list of shortcuts that are bound to it.\r\n     * @type {!Object.<string, Array.<{key: string, displayKey: string}>>}\r\n     */\r\n    var _commandMap = {};\r\n\r\n    /**\r\n     * @private\r\n     * Allow clients to toggle key binding\r\n     * @type {boolean}\r\n     */\r\n    var _enabled = true;\r\n    \r\n    /**\r\n     * @private\r\n     * Stack of registered global keydown hooks.\r\n     * @type {Array.<function(Event): boolean>}\r\n     */\r\n    var _globalKeydownHooks = [];\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    function _reset() {\r\n        _keyMap = {};\r\n        _commandMap = {};\r\n        _globalKeydownHooks = [];\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Initialize an empty keymap as the current keymap. It overwrites the current keymap if there is one.\r\n     * builds the keyDescriptor string from the given parts\r\n     * @param {boolean} hasCtrl Is Ctrl key enabled\r\n     * @param {boolean} hasAlt Is Alt key enabled\r\n     * @param {boolean} hasShift Is Shift key enabled\r\n     * @param {string} key The key that\'s pressed\r\n     * @return {string} The normalized key descriptor\r\n     */\r\n    function _buildKeyDescriptor(hasMacCtrl, hasCtrl, hasAlt, hasShift, key) {\r\n        if (!key) {\r\n            console.log("KeyBindingManager _buildKeyDescriptor() - No key provided!");\r\n            return "";\r\n        }\r\n        \r\n        var keyDescriptor = [];\r\n       \r\n        if (hasMacCtrl) {\r\n            keyDescriptor.push("Ctrl");\r\n        }\r\n        if (hasAlt) {\r\n            keyDescriptor.push("Alt");\r\n        }\r\n        if (hasShift) {\r\n            keyDescriptor.push("Shift");\r\n        }\r\n\r\n        if (hasCtrl) {\r\n            // Windows display Ctrl first, Mac displays Command symbol last\r\n            if (brackets.platform === "mac") {\r\n                keyDescriptor.push("Cmd");\r\n            } else {\r\n                keyDescriptor.unshift("Ctrl");\r\n            }\r\n        }\r\n\r\n        keyDescriptor.push(key);\r\n        \r\n        return keyDescriptor.join("-");\r\n    }\r\n    \r\n    \r\n    /**\r\n     * normalizes the incoming key descriptor so the modifier keys are always specified in the correct order\r\n     * @param {string} The string for a key descriptor, can be in any order, the result will be Ctrl-Alt-Shift-<Key>\r\n     * @return {string} The normalized key descriptor or null if the descriptor invalid\r\n     */\r\n    function normalizeKeyDescriptorString(origDescriptor) {\r\n        var hasMacCtrl = false,\r\n            hasCtrl = false,\r\n            hasAlt = false,\r\n            hasShift = false,\r\n            key = "",\r\n            error = false;\r\n\r\n        function _compareModifierString(left, right) {\r\n            if (!left || !right) {\r\n                return false;\r\n            }\r\n            left = left.trim().toLowerCase();\r\n            right = right.trim().toLowerCase();\r\n            \r\n            return (left.length > 0 && left === right);\r\n        }\r\n        \r\n        origDescriptor.split("-").forEach(function parseDescriptor(ele, i, arr) {\r\n            if (_compareModifierString("ctrl", ele)) {\r\n                if (brackets.platform === "mac") {\r\n                    hasMacCtrl = true;\r\n                } else {\r\n                    hasCtrl = true;\r\n                }\r\n            } else if (_compareModifierString("cmd", ele)) {\r\n                hasCtrl = true;\r\n            } else if (_compareModifierString("alt", ele)) {\r\n                hasAlt = true;\r\n            } else if (_compareModifierString("opt", ele)) {\r\n                hasAlt = true;\r\n            } else if (_compareModifierString("shift", ele)) {\r\n                hasShift = true;\r\n            } else if (key.length > 0) {\r\n                console.log("KeyBindingManager normalizeKeyDescriptorString() - Multiple keys defined. Using key: " + key + " from: " + origDescriptor);\r\n                error = true;\r\n            } else {\r\n                key = ele;\r\n            }\r\n        });\r\n        \r\n        if (error) {\r\n            return null;\r\n        }\r\n\r\n        // Check to see if the binding is for "-".\r\n        if (key === "" && origDescriptor.search(/^.+--$/) !== -1) {\r\n            key = "-";\r\n        }\r\n        \r\n        // \'+\' char is valid if it\'s the only key. Keyboard shortcut strings should use\r\n        // unicode characters (unescaped). Keyboard shortcut display strings may use\r\n        // unicode escape sequences (e.g. \\u20AC euro sign)\r\n        if ((key.indexOf("+")) >= 0 && (key.length > 1)) {\r\n            return null;\r\n        }\r\n        \r\n        return _buildKeyDescriptor(hasMacCtrl, hasCtrl, hasAlt, hasShift, key);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Looks for keycodes that have os-inconsistent keys and fixes them.\r\n     * @param {number} The keycode from the keyboard event.\r\n     * @param {string} The current best guess at what the key is.\r\n     * @return {string} If the key is OS-inconsistent, the correct key; otherwise, the original key.\r\n     **/\r\n    function _mapKeycodeToKey(keycode, key) {\r\n        // If keycode represents one of the digit keys (0-9), then return the corresponding digit\r\n        // by subtracting KeyEvent.DOM_VK_0 from keycode. ie. [48-57] --> [0-9]\r\n        if (keycode >= KeyEvent.DOM_VK_0 && keycode <= KeyEvent.DOM_VK_9) {\r\n            return String(keycode - KeyEvent.DOM_VK_0);\r\n        // Do the same with the numpad numbers\r\n        // by subtracting KeyEvent.DOM_VK_NUMPAD0 from keycode. ie. [96-105] --> [0-9]\r\n        } else if (keycode >= KeyEvent.DOM_VK_NUMPAD0 && keycode <= KeyEvent.DOM_VK_NUMPAD9) {\r\n            return String(keycode - KeyEvent.DOM_VK_NUMPAD0);\r\n        }\r\n        \r\n        \r\n        switch (keycode) {\r\n        case KeyEvent.DOM_VK_SEMICOLON:\r\n            return ";";\r\n        case KeyEvent.DOM_VK_EQUALS:\r\n            return "=";\r\n        case KeyEvent.DOM_VK_COMMA:\r\n            return ",";\r\n        case KeyEvent.DOM_VK_SUBTRACT:\r\n        case KeyEvent.DOM_VK_DASH:\r\n            return "-";\r\n        case KeyEvent.DOM_VK_ADD:\r\n            return "+";\r\n        case KeyEvent.DOM_VK_DECIMAL:\r\n        case KeyEvent.DOM_VK_PERIOD:\r\n            return ".";\r\n        case KeyEvent.DOM_VK_DIVIDE:\r\n        case KeyEvent.DOM_VK_SLASH:\r\n            return "/";\r\n        case KeyEvent.DOM_VK_BACK_QUOTE:\r\n            return "`";\r\n        case KeyEvent.DOM_VK_OPEN_BRACKET:\r\n            return "[";\r\n        case KeyEvent.DOM_VK_BACK_SLASH:\r\n            return "\\\\";\r\n        case KeyEvent.DOM_VK_CLOSE_BRACKET:\r\n            return "]";\r\n        case KeyEvent.DOM_VK_QUOTE:\r\n            return "\'";\r\n        default:\r\n            return key;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Takes a keyboard event and translates it into a key in a key map\r\n     */\r\n    function _translateKeyboardEvent(event) {\r\n        var hasMacCtrl = (brackets.platform === "mac") ? (event.ctrlKey) : false,\r\n            hasCtrl = (brackets.platform !== "mac") ? (event.ctrlKey) : (event.metaKey),\r\n            hasAlt = (event.altKey),\r\n            hasShift = (event.shiftKey),\r\n            key = String.fromCharCode(event.keyCode);\r\n        \r\n        //From the W3C, if we can get the KeyboardEvent.keyIdentifier then look here\r\n        //As that will let us use keys like then function keys "F5" for commands. The\r\n        //full set of values we can use is here\r\n        //http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set\r\n        var ident = event.keyIdentifier;\r\n        if (ident) {\r\n            if (ident.charAt(0) === "U" && ident.charAt(1) === "+") {\r\n                //This is a unicode code point like "U+002A", get the 002A and use that\r\n                key = String.fromCharCode(parseInt(ident.substring(2), 16));\r\n            } else {\r\n                //This is some non-character key, just use the raw identifier\r\n                key = ident;\r\n            }\r\n        }\r\n        \r\n        // Translate some keys to their common names\r\n        if (key === "\\t") {\r\n            key = "Tab";\r\n        } else if (key === " ") {\r\n            key = "Space";\r\n        } else {\r\n            key = _mapKeycodeToKey(event.keyCode, key);\r\n        }\r\n\r\n        return _buildKeyDescriptor(hasMacCtrl, hasCtrl, hasAlt, hasShift, key);\r\n    }\r\n    \r\n    /**\r\n     * Convert normalized key representation to display appropriate for platform.\r\n     * @param {!string} descriptor Normalized key descriptor.\r\n     * @return {!string} Display/Operating system appropriate string\r\n     */\r\n    function formatKeyDescriptor(descriptor) {\r\n        var displayStr;\r\n        \r\n        if (brackets.platform === "mac") {\r\n            displayStr = descriptor.replace(/-(?!$)/g, "");     // remove dashes\r\n            displayStr = displayStr.replace("Ctrl", "\\u2303");  // Ctrl > control symbol\r\n            displayStr = displayStr.replace("Cmd", "\\u2318");   // Cmd > command symbol\r\n            displayStr = displayStr.replace("Shift", "\\u21E7"); // Shift > shift symbol\r\n            displayStr = displayStr.replace("Alt", "\\u2325");   // Alt > option symbol\r\n        } else {\r\n            displayStr = descriptor.replace("Ctrl", Strings.KEYBOARD_CTRL);   // Ctrl\r\n            displayStr = displayStr.replace("Shift", Strings.KEYBOARD_SHIFT); // Shift > shift symbol\r\n            displayStr = displayStr.replace("Space", Strings.KEYBOARD_SPACE); // Alt > option symbol\r\n            displayStr = displayStr.replace(/-(?!$)/g, "+");\r\n        }\r\n\r\n        return displayStr;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * @param {string} A normalized key-description string.\r\n     * @return {boolean} true if the key is already assigned, false otherwise.\r\n     */\r\n    function _isKeyAssigned(key) {\r\n        return (_keyMap[key] !== undefined);\r\n    }\r\n\r\n    /**\r\n     * Remove a key binding from _keymap\r\n     *\r\n     * @param {!string} key - a key-description string that may or may not be normalized.\r\n     * @param {?string} platform - OS from which to remove the binding (all platforms if unspecified)\r\n     */\r\n    function removeBinding(key, platform) {\r\n        if (!key || ((platform !== null) && (platform !== undefined) && (platform !== brackets.platform))) {\r\n            return;\r\n        }\r\n\r\n        var normalizedKey = normalizeKeyDescriptorString(key);\r\n        \r\n        if (!normalizedKey) {\r\n            console.log("Fail to nomalize " + key);\r\n        } else if (_isKeyAssigned(normalizedKey)) {\r\n            var binding = _keyMap[normalizedKey],\r\n                command = CommandManager.get(binding.commandID),\r\n                bindings = _commandMap[binding.commandID];\r\n            \r\n            // delete key binding record\r\n            delete _keyMap[normalizedKey];\r\n            \r\n            if (bindings) {\r\n                // delete mapping from command to key binding\r\n                _commandMap[binding.commandID] = bindings.filter(function (b) {\r\n                    return (b.key !== normalizedKey);\r\n                });\r\n    \r\n                if (command) {\r\n                    $(command).triggerHandler("keyBindingRemoved", [{key: normalizedKey, displayKey: binding.displayKey}]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * @param {string} commandID\r\n     * @param {string|{{key: string, displayKey: string}}} keyBinding - a single shortcut.\r\n     * @param {?string} platform\r\n     *     - "all" indicates all platforms, not overridable\r\n     *     - undefined indicates all platforms, overridden by platform-specific binding\r\n     * @return {?{key: string, displayKey:String}} Returns a record for valid key bindings.\r\n     *     Returns null when key binding platform does not match, binding does not normalize,\r\n     *     or is already assigned.\r\n     */\r\n    function _addBinding(commandID, keyBinding, platform) {\r\n        var key,\r\n            result = null,\r\n            normalized,\r\n            normalizedDisplay,\r\n            explicitPlatform = keyBinding.platform || platform,\r\n            targetPlatform,\r\n            command,\r\n            bindingsToDelete = [],\r\n            existing;\r\n\r\n        // For platform: "all", use explicit current plaform\r\n        if (explicitPlatform && explicitPlatform !== "all") {\r\n            targetPlatform = explicitPlatform;\r\n        } else {\r\n            targetPlatform = brackets.platform;\r\n        }\r\n        \r\n        // if the request does not specify an explicit platform, and we\'re\r\n        // currently on a mac, then replace Ctrl with Cmd.\r\n        key = (keyBinding.key) || keyBinding;\r\n        if (brackets.platform === "mac" && (explicitPlatform === undefined || explicitPlatform === "all")) {\r\n            key = key.replace("Ctrl", "Cmd");\r\n            if (keyBinding.displayKey !== undefined) {\r\n                keyBinding.displayKey = keyBinding.displayKey.replace("Ctrl", "Cmd");\r\n            }\r\n        }\r\n        normalized = normalizeKeyDescriptorString(key);\r\n        \r\n        // skip if the key binding is invalid \r\n        if (!normalized) {\r\n            console.error("Unable to parse key binding " + key + ". Permitted modifiers: Ctrl, Cmd, Alt, Opt, Shift; separated by \'-\' (not \'+\').");\r\n            return null;\r\n        }\r\n        \r\n        // check for duplicate key bindings\r\n        existing = _keyMap[normalized];\r\n        \r\n        // for cross-platform compatibility\r\n        if (exports.useWindowsCompatibleBindings) {\r\n            // windows-only key bindings are used as the default binding\r\n            // only if a default binding wasn\'t already defined\r\n            if (explicitPlatform === "win") {\r\n                // search for a generic or platform-specific binding if it\r\n                // already exists\r\n                if (existing && (!existing.explicitPlatform ||\r\n                                 existing.explicitPlatform === brackets.platform ||\r\n                                 existing.explicitPlatform === "all")) {\r\n                    // do not clobber existing binding with windows-only binding\r\n                    return null;\r\n                }\r\n                \r\n                // target this windows binding for the current platform\r\n                targetPlatform = brackets.platform;\r\n            }\r\n        }\r\n        \r\n        // skip if this binding doesn\'t match the current platform\r\n        if (targetPlatform !== brackets.platform) {\r\n            return null;\r\n        }\r\n        \r\n        // skip if the key is already assigned\r\n        if (existing) {\r\n            if (!existing.explicitPlatform && explicitPlatform) {\r\n                // remove the the generic binding to replace with this new platform-specific binding\r\n                removeBinding(normalized);\r\n                existing = false;\r\n            }\r\n        }\r\n        \r\n        // delete existing bindings when\r\n        // (1) replacing a windows-compatible binding with a generic or\r\n        //     platform-specific binding\r\n        // (2) replacing a generic binding with a platform-specific binding\r\n        var existingBindings = _commandMap[commandID] || [],\r\n            isWindowsCompatible,\r\n            isReplaceGeneric,\r\n            ignoreGeneric;\r\n        \r\n        existingBindings.forEach(function (binding) {\r\n            // remove windows-only bindings in _commandMap\r\n            isWindowsCompatible = exports.useWindowsCompatibleBindings &&\r\n                binding.explicitPlatform === "win";\r\n            \r\n            // remove existing generic binding\r\n            isReplaceGeneric = !binding.explicitPlatform &&\r\n                explicitPlatform;\r\n            \r\n            if (isWindowsCompatible || isReplaceGeneric) {\r\n                bindingsToDelete.push(binding);\r\n            } else {\r\n                // existing binding is platform-specific and the requested binding is generic\r\n                ignoreGeneric = binding.explicitPlatform && !explicitPlatform;\r\n            }\r\n        });\r\n\r\n        if (ignoreGeneric) {\r\n            // explicit command binding overrides this one\r\n            return null;\r\n        }\r\n        \r\n        if (existing) {\r\n            // do not re-assign a key binding\r\n            console.error("Cannot assign " + normalized + " to " + commandID + ". It is already assigned to " + _keyMap[normalized].commandID);\r\n            return null;\r\n        }\r\n        \r\n        // remove generic or windows-compatible bindings\r\n        bindingsToDelete.forEach(function (binding) {\r\n            removeBinding(binding.key);\r\n        });\r\n        \r\n        // optional display-friendly string (e.g. CMD-+ instead of CMD-=)\r\n        normalizedDisplay = (keyBinding.displayKey) ? normalizeKeyDescriptorString(keyBinding.displayKey) : normalized;\r\n        \r\n        // 1-to-many commandID mapping to key binding\r\n        if (!_commandMap[commandID]) {\r\n            _commandMap[commandID] = [];\r\n        }\r\n        \r\n        result = {\r\n            key                 : normalized,\r\n            displayKey          : normalizedDisplay,\r\n            explicitPlatform    : explicitPlatform\r\n        };\r\n        \r\n        _commandMap[commandID].push(result);\r\n        \r\n        // 1-to-1 key binding to commandID\r\n        _keyMap[normalized] = {\r\n            commandID           : commandID,\r\n            key                 : normalized,\r\n            displayKey          : normalizedDisplay,\r\n            explicitPlatform    : explicitPlatform\r\n        };\r\n        \r\n        // notify listeners\r\n        command = CommandManager.get(commandID);\r\n        \r\n        if (command) {\r\n            $(command).triggerHandler("keyBindingAdded", [result]);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Returns a copy of the keymap\r\n     * @return {!Object.<string, {commandID: string, key: string, displayKey: string}>}\r\n     */\r\n    function getKeymap() {\r\n        return $.extend({}, _keyMap);\r\n    }\r\n\r\n    /**\r\n     * Process the keybinding for the current key.\r\n     *\r\n     * @param {string} A key-description string.\r\n     * @return {boolean} true if the key was processed, false otherwise\r\n     */\r\n    function _handleKey(key) {\r\n        if (_enabled && _keyMap[key]) {\r\n            // The execute() function returns a promise because some commands are async.\r\n            // Generally, commands decide whether they can run or not synchronously,\r\n            // and reject immediately, so we can test for that synchronously.\r\n            var promise = CommandManager.execute(_keyMap[key].commandID);\r\n            return (promise.state() !== "rejected");\r\n        }\r\n        return false;\r\n    }\r\n\r\n    // TODO (issue #414): Replace this temporary fix with a more robust solution to handle focus and modality\r\n    /**\r\n     * Enable or disable key bindings. Clients such as dialogs may wish to disable\r\n     * global key bindings temporarily.\r\n     *\r\n     * @param {string} A key-description string.\r\n     * @return {boolean} true if the key was processed, false otherwise\r\n     */\r\n    function setEnabled(value) {\r\n        _enabled = value;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     *\r\n     * Sort objects by platform property. Objects with a platform property come\r\n     * before objects without a platform property.\r\n     */\r\n    function _sortByPlatform(a, b) {\r\n        var a1 = (a.platform) ? 1 : 0,\r\n            b1 = (b.platform) ? 1 : 0;\r\n        return b1 - a1;\r\n    }\r\n\r\n    /**\r\n     * Add one or more key bindings to a particular Command.\r\n     *\r\n     * @param {!string | Command} command - A command ID or command object\r\n     * @param {?({key: string, displayKey: string}|Array.<{key: string, displayKey: string, platform: string}>)} keyBindings\r\n     *     A single key binding or an array of keybindings. Example:\r\n     *     "Shift-Cmd-F". Mac and Win key equivalents are automatically\r\n     *     mapped to each other. Use displayKey property to display a different\r\n     *     string (e.g. "CMD+" instead of "CMD=").\r\n     * @param {?string} platform The target OS of the keyBindings either\r\n     *     "mac", "win" or "linux". If undefined, all platforms not explicitly\r\n     *     defined will use the key binding.\r\n     * @return {{key: string, displayKey:String}|Array.<{key: string, displayKey:String}>}\r\n     *     Returns record(s) for valid key binding(s)\r\n     */\r\n    function addBinding(command, keyBindings, platform) {\r\n        var commandID           = "",\r\n            results;\r\n        \r\n        if (!command) {\r\n            console.error("addBinding(): missing required parameter: command");\r\n            return;\r\n        }\r\n        \r\n        if (!keyBindings) { return; }\r\n        \r\n        if (typeof (command) === "string") {\r\n            commandID = command;\r\n        } else {\r\n            commandID = command.getID();\r\n        }\r\n        \r\n        if (Array.isArray(keyBindings)) {\r\n            var keyBinding;\r\n            results = [];\r\n\r\n            // process platform-specific bindings first\r\n            keyBindings.sort(_sortByPlatform);\r\n            \r\n            keyBindings.forEach(function addSingleBinding(keyBindingRequest) {\r\n                // attempt to add keybinding\r\n                keyBinding = _addBinding(commandID, keyBindingRequest, keyBindingRequest.platform);\r\n                \r\n                if (keyBinding) {\r\n                    results.push(keyBinding);\r\n                }\r\n            });\r\n        } else {\r\n            results = _addBinding(commandID, keyBindings, platform);\r\n        }\r\n        \r\n        return results;\r\n    }\r\n\r\n    /**\r\n     * Retrieve key bindings currently associated with a command\r\n     *\r\n     * @param {!string | Command} command - A command ID or command object\r\n     * @return {!Array.<{{key: string, displayKey: string}}>} An array of associated key bindings.\r\n     */\r\n    function getKeyBindings(command) {\r\n        var bindings    = [],\r\n            commandID   = "";\r\n        \r\n        if (!command) {\r\n            console.error("getKeyBindings(): missing required parameter: command");\r\n            return [];\r\n        }\r\n        \r\n        if (typeof (command) === "string") {\r\n            commandID = command;\r\n        } else {\r\n            commandID = command.getID();\r\n        }\r\n        \r\n        bindings = _commandMap[commandID];\r\n        return bindings || [];\r\n    }\r\n    \r\n    /**\r\n     * Adds default key bindings when commands are registered to CommandManager\r\n     * @param {$.Event} event jQuery event\r\n     * @param {Command} command Newly registered command\r\n     */\r\n    function _handleCommandRegistered(event, command) {\r\n        var commandId   = command.getID(),\r\n            defaults    = KeyboardPrefs[commandId];\r\n        \r\n        if (defaults) {\r\n            addBinding(commandId, defaults);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Adds a global keydown hook that gets first crack at keydown events \r\n     * before standard keybindings do. This is intended for use by modal or \r\n     * semi-modal UI elements like dialogs or the code hint list that should \r\n     * execute before normal command bindings are run. \r\n     * \r\n     * The hook is passed one parameter, the original keyboard event. If the \r\n     * hook handles the event (or wants to block other global hooks from \r\n     * handling the event), it should return true. Note that this will *only*\r\n     * stop other global hooks and KeyBindingManager from handling the\r\n     * event; to prevent further event propagation, you will need to call\r\n     * stopPropagation(), stopImmediatePropagation(), and/or preventDefault()\r\n     * as usual.\r\n     *\r\n     * Multiple keydown hooks can be registered, and are executed in order, \r\n     * most-recently-added first.\r\n     * \r\n     * (We have to have a special API for this because (1) handlers are normally\r\n     * called in least-recently-added order, and we want most-recently-added; \r\n     * (2) native DOM events don\'t have a way for us to find out if \r\n     * stopImmediatePropagation()/stopPropagation() has been called on the\r\n     * event, so we have to have some other way for one of the hooks to \r\n     * indicate that it wants to block the other hooks from running.)\r\n     *\r\n     * @param {function(Event): boolean} hook The global hook to add.\r\n     */\r\n    function addGlobalKeydownHook(hook) {\r\n        _globalKeydownHooks.push(hook);\r\n    }\r\n    \r\n    /**\r\n     * Removes a global keydown hook added by `addGlobalKeydownHook`.\r\n     * Does not need to be the most recently added hook.\r\n     *\r\n     * @param {function(Event): boolean} hook The global hook to remove.\r\n     */\r\n    function removeGlobalKeydownHook(hook) {\r\n        var index = _globalKeydownHooks.indexOf(hook);\r\n        if (index !== -1) {\r\n            _globalKeydownHooks.splice(index, 1);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handles a given keydown event, checking global hooks first before\r\n     * deciding to handle it ourselves.\r\n     * @param {Event} The keydown event to handle.\r\n     */\r\n    function _handleKeyEvent(event) {\r\n        var i, handled = false;\r\n        for (i = _globalKeydownHooks.length - 1; i >= 0; i--) {\r\n            if (_globalKeydownHooks[i](event)) {\r\n                handled = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!handled && _handleKey(_translateKeyboardEvent(event))) {\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n    }\r\n\r\n    AppInit.htmlReady(function () {\r\n        // Install keydown event listener.\r\n        window.document.body.addEventListener(\r\n            "keydown",\r\n            _handleKeyEvent,\r\n            true\r\n        );\r\n        \r\n        exports.useWindowsCompatibleBindings = (brackets.platform !== "mac") &&\r\n            (brackets.platform !== "win");\r\n    });\r\n    \r\n    $(CommandManager).on("commandRegistered", _handleCommandRegistered);\r\n\r\n    // unit test only\r\n    exports._reset = _reset;\r\n\r\n    // Define public API\r\n    exports.getKeymap = getKeymap;\r\n    exports.setEnabled = setEnabled;\r\n    exports.addBinding = addBinding;\r\n    exports.removeBinding = removeBinding;\r\n    exports.formatKeyDescriptor = formatKeyDescriptor;\r\n    exports.getKeyBindings = getKeyBindings;\r\n    exports.addGlobalKeydownHook = addGlobalKeydownHook;\r\n    exports.removeGlobalKeydownHook = removeGlobalKeydownHook;\r\n    \r\n    /**\r\n     * Use windows-specific bindings if no other are found (e.g. Linux).\r\n     * Core Brackets modules that use key bindings should always define at\r\n     * least a generic keybinding that is applied for all platforms. This\r\n     * setting effectively creates a compatibility mode for third party\r\n     * extensions that define explicit key bindings for Windows and Mac, but\r\n     * not Linux.\r\n     */\r\n    exports.useWindowsCompatibleBindings = false;\r\n    \r\n    // For unit testing only\r\n    exports._handleKey = _handleKey;\r\n    exports._handleKeyEvent = _handleKeyEvent;\r\n});\n//# sourceURL=/command/KeyBindingManager.js'),eval("/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50*/\r\n/*global $, define, brackets, FileError */\r\n\r\ndefine('utils/NativeApp',['require','exports','module','utils/Async','filesystem/FileSystemError'],function (require, exports, module) {\r\n    \"use strict\";\r\n    \r\n    var Async           = require(\"utils/Async\"),\r\n        FileSystemError = require(\"filesystem/FileSystemError\");\r\n\r\n    /**\r\n     * @private\r\n     * Map an fs error code to a FileError.\r\n     */\r\n    function _browserErrToFileError(err) {\r\n        if (err === brackets.fs.ERR_NOT_FOUND) {\r\n            return FileSystemError.NOT_FOUND;\r\n        }\r\n        \r\n        // All other errors are mapped to the generic \"unknown\" error\r\n        return FileSystemError.UNKNOWN;\r\n    }\r\n    \r\n    var liveBrowserOpenedPIDs = [];\r\n\r\n    /** openLiveBrowser\r\n     * Open the given URL in the user's system browser, optionally enabling debugging.\r\n     * @param {string} url The URL to open.\r\n     * @param {boolean=} enableRemoteDebugging Whether to turn on remote debugging. Default false.\r\n     * @return {$.Promise} \r\n     */\r\n    function openLiveBrowser(url, enableRemoteDebugging) {\r\n        var result = new $.Deferred();\r\n        \r\n        brackets.app.openLiveBrowser(url, !!enableRemoteDebugging, function onRun(err, pid) {\r\n            if (!err) {\r\n                // Undefined ids never get removed from list, so don't push them on\r\n                if (pid !== undefined) {\r\n                    liveBrowserOpenedPIDs.push(pid);\r\n                }\r\n                result.resolve(pid);\r\n            } else {\r\n                result.reject(_browserErrToFileError(err));\r\n            }\r\n        });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /** closeLiveBrowser\r\n     *\r\n     * @return {$.Promise}\r\n     */\r\n    function closeLiveBrowser(pid) {\r\n        var result = new $.Deferred();\r\n        \r\n        if (isNaN(pid)) {\r\n            pid = 0;\r\n        }\r\n        brackets.app.closeLiveBrowser(function (err) {\r\n            if (!err) {\r\n                var i = liveBrowserOpenedPIDs.indexOf(pid);\r\n                if (i !== -1) {\r\n                    liveBrowserOpenedPIDs.splice(i, 1);\r\n                }\r\n                result.resolve();\r\n            } else {\r\n                result.reject(_browserErrToFileError(err));\r\n            }\r\n        }, pid);\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /** closeAllLiveBrowsers\r\n     * Closes all the browsers that were tracked on open\r\n     * TODO: does not seem to work on Windows\r\n     * @return {$.Promise}\r\n     */\r\n    function closeAllLiveBrowsers() {\r\n        //make a copy incase the array is edited as we iterate\r\n        var closeIDs = liveBrowserOpenedPIDs.concat();\r\n        return Async.doSequentially(closeIDs, closeLiveBrowser, false);\r\n    }\r\n    \r\n    /**\r\n     * Opens a URL in the system default browser\r\n     */\r\n    function openURLInDefaultBrowser(url) {\r\n        brackets.app.openURLInDefaultBrowser(url);\r\n    }\r\n    \r\n\r\n    // Define public API\r\n    exports.openLiveBrowser = openLiveBrowser;\r\n    exports.closeLiveBrowser = closeLiveBrowser;\r\n    exports.closeAllLiveBrowsers = closeAllLiveBrowsers;\r\n    exports.openURLInDefaultBrowser = openURLInDefaultBrowser;\r\n});\r\n\n//# sourceURL=/utils/NativeApp.js"),eval('define(\'text!htmlContent/dialog-template.html\',[],function () { return \'<div class="{{dlgClass}} template modal">\\r\\n    <div class="modal-header">\\r\\n        <h1 class="dialog-title">{{{title}}}</h1>\\r\\n    </div>\\r\\n    <div class="modal-body">\\r\\n        <div class="dialog-message">{{{message}}}</div>\\r\\n    </div>\\r\\n    <div class="modal-footer">\\r\\n        {{#buttons}}\\r\\n        <button class="dialog-button btn {{className}}" data-button-id="{{id}}">{{{text}}}</button>\\r\\n        {{/buttons}}\\r\\n    </div>\\r\\n</div>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/dialog-template.html'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets, window, Mustache */\r\n\r\n/**\r\n * Utilities for creating and managing standard modal dialogs.\r\n */\r\ndefine(\'widgets/Dialogs\',[\'require\',\'exports\',\'module\',\'utils/Global\',\'command/KeyBindingManager\',\'utils/KeyEvent\',\'utils/NativeApp\',\'strings\',\'text!htmlContent/dialog-template.html\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    require("utils/Global");\r\n\r\n    var KeyBindingManager = require("command/KeyBindingManager"),\r\n        KeyEvent          = require("utils/KeyEvent"),\r\n        NativeApp         = require("utils/NativeApp"),\r\n        Strings           = require("strings"),\r\n        DialogTemplate    = require("text!htmlContent/dialog-template.html");\r\n    \r\n    /**\r\n     * Dialog Buttons IDs\r\n     * @const {string}\r\n     */\r\n    var DIALOG_BTN_CANCEL           = "cancel",\r\n        DIALOG_BTN_OK               = "ok",\r\n        DIALOG_BTN_DONTSAVE         = "dontsave",\r\n        DIALOG_BTN_SAVE_AS          = "save_as",\r\n        DIALOG_CANCELED             = "_canceled",\r\n        DIALOG_BTN_DOWNLOAD         = "download";\r\n    \r\n    /**\r\n     * Dialog Buttons Class Names\r\n     * @const {string}\r\n     */\r\n    var DIALOG_BTN_CLASS_PRIMARY    = "primary",\r\n        DIALOG_BTN_CLASS_NORMAL     = "",\r\n        DIALOG_BTN_CLASS_LEFT       = "left";\r\n    \r\n    /**\r\n     * The z-index used for the dialogs. Each new dialog increase this number by 2\r\n     * @type {number}\r\n     */\r\n    var zIndex = 1050;\r\n\r\n    /**\r\n     * @private\r\n     * Dismises a modal dialog\r\n     * @param {$.Element} $dlg\r\n     * @param {string} buttonId\r\n     */\r\n    function _dismissDialog($dlg, buttonId) {\r\n        $dlg.data("buttonId", buttonId);\r\n        $dlg.modal("hide");\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * If autoDismiss is true, then dismisses the dialog. Otherwise just raises an event that the\r\n     * given button was clicked.\r\n     * @param {$.Element} $dlg The dialog element to be dismissed.\r\n     * @param {string} buttonId The ID of the button that was clicked.\r\n     * @param {boolean} autoDismiss Whether to autodismiss the dialog on a button click.\r\n     */\r\n    function _processButton($dlg, buttonId, autoDismiss) {\r\n        if (autoDismiss) {\r\n            _dismissDialog($dlg, buttonId);\r\n        } else {\r\n            $dlg.triggerHandler("buttonClick", buttonId);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Returns true if the modal dialog has a button with the given ID\r\n     * @param {$.Element} $dlg\r\n     * @param {string} buttonId\r\n     * @return {boolean}\r\n     */\r\n    function _hasButton($dlg, buttonId) {\r\n        return ($dlg.find("[data-button-id=\'" + buttonId + "\']").length > 0);\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Handles the use of Tab so that it stays inside the Dialog\r\n     * @param {$.Event} event\r\n     * @param {$.Element} $dlg\r\n     */\r\n    function _handleTab(event, $dlg) {\r\n        var $inputs = $(":input:enabled, a", $dlg).filter(":visible");\r\n\r\n        function stopEvent() {\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n\r\n        if ($(event.target).closest($dlg).length) {\r\n            // If it\'s the first or last tabbable element, focus the last/first element\r\n            if ((!event.shiftKey && event.target === $inputs[$inputs.length - 1]) ||\r\n                    (event.shiftKey && event.target === $inputs[0])) {\r\n                $inputs.filter(event.shiftKey ? ":last" : ":first").focus();\r\n                stopEvent();\r\n\r\n            // If there is no element to focus, don\'t let it focus outside of the dialog\r\n            } else if (!$inputs.length) {\r\n                stopEvent();\r\n            }\r\n\r\n        // If the focus left the dialog, focus the first element in the dialog\r\n        } else {\r\n            $inputs.first().focus();\r\n            stopEvent();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * Handles the keyDown event for the dialogs\r\n     * @param {$.Event} e\r\n     * @param {boolean} autoDismiss\r\n     * @return {boolean}\r\n     */\r\n    var _keydownHook = function (e, autoDismiss) {\r\n        var $primaryBtn     = this.find(".primary"),\r\n            buttonId        = null,\r\n            which           = String.fromCharCode(e.which),\r\n            $focusedElement = this.find(".dialog-button:focus, a:focus");\r\n        \r\n        function stopEvent() {\r\n            e.preventDefault();\r\n            e.stopPropagation();\r\n        }\r\n\r\n        // There might be a textfield in the dialog\'s UI; don\'t want to mistake normal typing for dialog dismissal\r\n        var inTextArea    = (e.target.tagName === "TEXTAREA"),\r\n            inTypingField = inTextArea || ($(e.target).filter(":text, :password").length > 0);\r\n        \r\n        if (e.which === KeyEvent.DOM_VK_TAB) {\r\n            // We don\'t want to stopEvent() in this case since we might want the default behavior.\r\n            // _handleTab takes care of stopping/preventing default as necessary.\r\n            _handleTab(e, this);\r\n        } else if (e.which === KeyEvent.DOM_VK_ESCAPE) {\r\n            buttonId = DIALOG_BTN_CANCEL;\r\n        } else if (e.which === KeyEvent.DOM_VK_RETURN && (!inTextArea || e.ctrlKey)) {\r\n            // Enter key in single-line text input always dismisses; in text area, only Ctrl+Enter dismisses\r\n            // Click primary\r\n            stopEvent();\r\n            if (e.target.tagName === "BUTTON") {\r\n                this.find(e.target).click();\r\n            } else {\r\n                $primaryBtn.click();\r\n            }\r\n        } else if (e.which === KeyEvent.DOM_VK_SPACE) {\r\n            if ($focusedElement.length) {\r\n                // Space bar on focused button or link\r\n                stopEvent();\r\n                $focusedElement.click();\r\n            }\r\n        } else if (brackets.platform === "mac") {\r\n            // CMD+D Don\'t Save\r\n            if (e.metaKey && (which === "D")) {\r\n                if (_hasButton(this, DIALOG_BTN_DONTSAVE)) {\r\n                    buttonId = DIALOG_BTN_DONTSAVE;\r\n                }\r\n            // FIXME (issue #418) CMD+. Cancel swallowed by native shell\r\n            } else if (e.metaKey && (e.which === KeyEvent.DOM_VK_PERIOD)) {\r\n                buttonId = DIALOG_BTN_CANCEL;\r\n            }\r\n        } else { // if (brackets.platform === "win") {\r\n            // \'N\' Don\'t Save\r\n            if (which === "N" && !inTypingField) {\r\n                if (_hasButton(this, DIALOG_BTN_DONTSAVE)) {\r\n                    buttonId = DIALOG_BTN_DONTSAVE;\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (buttonId) {\r\n            stopEvent();\r\n            _processButton(this, buttonId, autoDismiss);\r\n        }\r\n        \r\n        // Stop any other global hooks from processing the event (but\r\n        // allow it to continue bubbling if we haven\'t otherwise stopped it).\r\n        return true;\r\n    };\r\n    \r\n    \r\n    \r\n    /**\r\n     * @constructor\r\n     * @private\r\n     *\r\n     * @param {$.Element} $dlg The dialog jQuery element\r\n     * @param {$.Promise} promise A promise that will be resolved with the ID of the clicked button when the dialog\r\n     *     is dismissed. Never rejected.\r\n     */\r\n    function Dialog($dlg, promise) {\r\n        this._$dlg    = $dlg;\r\n        this._promise = promise;\r\n    }\r\n    \r\n    /**\r\n     * The dialog jQuery element\r\n     * @type {$.Element}\r\n     */\r\n    Dialog.prototype.getElement = function () {\r\n        return this._$dlg;\r\n    };\r\n    \r\n    /**\r\n     * The dialog promise\r\n     * @type {$.Promise}\r\n     */\r\n    Dialog.prototype.getPromise = function () {\r\n        return this._promise;\r\n    };\r\n    \r\n    /**\r\n     * Closes the dialog if is visible\r\n     */\r\n    Dialog.prototype.close = function () {\r\n        if (this._$dlg.is(":visible")) {   // Bootstrap breaks if try to hide dialog that\'s already hidden\r\n            _dismissDialog(this._$dlg, DIALOG_CANCELED);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Adds a done callback to the dialog promise\r\n     */\r\n    Dialog.prototype.done = function (callback) {\r\n        this._promise.done(callback);\r\n    };\r\n    \r\n\r\n    /**\r\n     * Don\'t allow dialog to exceed viewport size\r\n     */\r\n    function setDialogMaxSize() {\r\n        var maxWidth, maxHeight,\r\n            $dlgs = $(".modal-inner-wrapper > .instance");\r\n\r\n        // Verify 1 or more modal dialogs are showing\r\n        if ($dlgs.length > 0) {\r\n            maxWidth  = $("body").width();\r\n            maxHeight = $("body").height();\r\n\r\n            $dlgs.css({\r\n                "max-width":  maxWidth,\r\n                "max-height": maxHeight,\r\n                "overflow":   "auto"\r\n            });\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Creates a new modal dialog from a given template.\r\n     * The template can either be a string or a jQuery object representing a DOM node that is *not* in the current DOM.\r\n     *\r\n     * @param {string} template A string template or jQuery object to use as the dialog HTML.\r\n     * @param {boolean=} autoDismiss Whether to automatically dismiss the dialog when one of the buttons\r\n     *      is clicked. Default true. If false, you\'ll need to manually handle button clicks and the Esc\r\n     *      key, and dismiss the dialog yourself when ready by calling `close()` on the returned dialog.\r\n     * @return {Dialog}\r\n     */\r\n    function showModalDialogUsingTemplate(template, autoDismiss) {\r\n        if (autoDismiss === undefined) {\r\n            autoDismiss = true;\r\n        }\r\n        \r\n        $("body").append("<div class=\'modal-wrapper\'><div class=\'modal-inner-wrapper\'></div></div>");\r\n\r\n        var result  = new $.Deferred(),\r\n            promise = result.promise(),\r\n            $dlg    = $(template)\r\n                .addClass("instance")\r\n                .appendTo(".modal-inner-wrapper:last");\r\n\r\n        // Don\'t allow dialog to exceed viewport size\r\n        setDialogMaxSize();\r\n        \r\n        // Save the dialog promise for unit tests\r\n        $dlg.data("promise", promise);\r\n\r\n        var keydownHook = function (e) {\r\n            return _keydownHook.call($dlg, e, autoDismiss);\r\n        };\r\n\r\n        // Pipe dialog-closing notification back to client code\r\n        $dlg.one("hidden", function () {\r\n            var buttonId = $dlg.data("buttonId");\r\n            if (!buttonId) {    // buttonId will be undefined if closed via Bootstrap\'s "x" button\r\n                buttonId = DIALOG_BTN_CANCEL;\r\n            }\r\n            \r\n            // Let call stack return before notifying that dialog has closed; this avoids issue #191\r\n            // if the handler we\'re triggering might show another dialog (as long as there\'s no\r\n            // fade-out animation)\r\n            window.setTimeout(function () {\r\n                result.resolve(buttonId);\r\n            }, 0);\r\n            \r\n            // Remove the dialog instance from the DOM.\r\n            $dlg.remove();\r\n\r\n            // Remove our global keydown handler.\r\n            KeyBindingManager.removeGlobalKeydownHook(keydownHook);\r\n            \r\n            //Remove wrapper\r\n            $(".modal-wrapper:last").remove();\r\n        }).one("shown", function () {\r\n            var $primaryBtn = $dlg.find(".primary:enabled"),\r\n                $otherBtn   = $dlg.find(".modal-footer .dialog-button:enabled:eq(0)");\r\n            \r\n            // Set focus to the primary button, to any other button, or to the dialog depending\r\n            // if there are buttons\r\n            if ($primaryBtn.length) {\r\n                $primaryBtn.focus();\r\n            } else if ($otherBtn.length) {\r\n                $otherBtn.focus();\r\n            } else {\r\n                document.activeElement.blur();\r\n            }\r\n\r\n            // Push our global keydown handler onto the global stack of handlers.\r\n            KeyBindingManager.addGlobalKeydownHook(keydownHook);\r\n        });\r\n        \r\n        // Click handler for buttons\r\n        $dlg.one("click", ".dialog-button", function (e) {\r\n            _processButton($dlg, $(this).attr("data-button-id"), autoDismiss);\r\n        });\r\n                \r\n        // Run the dialog\r\n        $dlg\r\n            .modal({\r\n                backdrop: "static",\r\n                show:     true,\r\n                selector: ".modal-inner-wrapper:last",\r\n                keyboard: false // handle the ESC key ourselves so we can deal with nested dialogs\r\n            })\r\n            // Updates the z-index of the modal dialog and the backdrop\r\n            .css("z-index", zIndex + 1)\r\n            .next()\r\n            .css("z-index", zIndex);\r\n        \r\n        zIndex += 2;\r\n        \r\n        return (new Dialog($dlg, promise));\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Creates a new general purpose modal dialog using the default template and the template variables given\r\n     * as parameters as described.\r\n     *\r\n     * @param {string} dlgClass A class name identifier for the dialog. Typically one of DefaultDialogs.*\r\n     * @param {string=} title The title of the dialog. Can contain HTML markup. Defaults to "".\r\n     * @param {string=} message The message to display in the dialog. Can contain HTML markup. Defaults to "".\r\n     * @param {Array.<{className: string, id: string, text: string}>=} buttons An array of buttons where each button\r\n     *      has a class, id and text property. The id is used in "data-button-id". Defaults to a single Ok button.\r\n     *      Typically className is one of DIALOG_BTN_CLASS_*, id is one of DIALOG_BTN_*\r\n     * @param {boolean=} autoDismiss Whether to automatically dismiss the dialog when one of the buttons\r\n     *      is clicked. Default true. If false, you\'ll need to manually handle button clicks and the Esc\r\n     *      key, and dismiss the dialog yourself when ready by calling `close()` on the returned dialog.\r\n     * @return {Dialog}\r\n     */\r\n    function showModalDialog(dlgClass, title, message, buttons, autoDismiss) {\r\n        var templateVars = {\r\n            dlgClass: dlgClass,\r\n            title:    title   || "",\r\n            message:  message || "",\r\n            buttons:  buttons || [{ className: DIALOG_BTN_CLASS_PRIMARY, id: DIALOG_BTN_OK, text: Strings.OK }]\r\n        };\r\n        var template = Mustache.render(DialogTemplate, templateVars);\r\n        \r\n        return showModalDialogUsingTemplate(template, autoDismiss);\r\n    }\r\n    \r\n    /**\r\n     * Immediately closes any dialog instances with the given class. The dialog callback for each instance will\r\n     * be called with the special buttonId DIALOG_CANCELED (note: callback is run asynchronously).\r\n     * @param {string} dlgClass The class name identifier for the dialog.\r\n     * @param {string=} buttonId The button id to use when closing the dialog. Defaults to DIALOG_CANCELED\r\n     */\r\n    function cancelModalDialogIfOpen(dlgClass, buttonId) {\r\n        $("." + dlgClass + ".instance").each(function () {\r\n            if ($(this).is(":visible")) {   // Bootstrap breaks if try to hide dialog that\'s already hidden\r\n                _dismissDialog($(this), buttonId || DIALOG_CANCELED);\r\n            }\r\n        });\r\n    }\r\n    \r\n    window.addEventListener("resize", setDialogMaxSize);\r\n    \r\n    exports.DIALOG_BTN_CANCEL            = DIALOG_BTN_CANCEL;\r\n    exports.DIALOG_BTN_OK                = DIALOG_BTN_OK;\r\n    exports.DIALOG_BTN_DONTSAVE          = DIALOG_BTN_DONTSAVE;\r\n    exports.DIALOG_BTN_SAVE_AS           = DIALOG_BTN_SAVE_AS;\r\n    exports.DIALOG_CANCELED              = DIALOG_CANCELED;\r\n    exports.DIALOG_BTN_DOWNLOAD          = DIALOG_BTN_DOWNLOAD;\r\n    \r\n    exports.DIALOG_BTN_CLASS_PRIMARY     = DIALOG_BTN_CLASS_PRIMARY;\r\n    exports.DIALOG_BTN_CLASS_NORMAL      = DIALOG_BTN_CLASS_NORMAL;\r\n    exports.DIALOG_BTN_CLASS_LEFT        = DIALOG_BTN_CLASS_LEFT;\r\n    \r\n    exports.showModalDialog              = showModalDialog;\r\n    exports.showModalDialogUsingTemplate = showModalDialogUsingTemplate;\r\n    exports.cancelModalDialogIfOpen      = cancelModalDialogIfOpen;\r\n});\r\n\n//# sourceURL=/widgets/Dialogs.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\ndefine(\'widgets/DefaultDialogs\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    /**\r\n     * List of constants for the default dialogs IDs.\r\n     */\r\n    exports.DIALOG_ID_ERROR             = "error-dialog";\r\n    exports.DIALOG_ID_INFO              = "error-dialog"; // uses the same template for now--could be different in future\r\n    exports.DIALOG_ID_SAVE_CLOSE        = "save-close-dialog";\r\n    exports.DIALOG_ID_EXT_CHANGED       = "ext-changed-dialog";\r\n    exports.DIALOG_ID_EXT_DELETED       = "ext-deleted-dialog";\r\n    exports.DIALOG_ID_LIVE_DEVELOPMENT  = "live-development-error-dialog";\r\n    exports.DIALOG_ID_CHANGE_EXTENSIONS = "change-marked-extensions";\r\n});\r\n\n//# sourceURL=/widgets/DefaultDialogs.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $, FileError, brackets, unescape, window */\r\n\r\n/**\r\n * Set of utilites for working with files and text content.\r\n */\r\ndefine(\'file/FileUtils\',[\'require\',\'exports\',\'module\',\'utils/Global\',\'filesystem/FileSystemError\',\'language/LanguageManager\',\'utils/PerfUtils\',\'widgets/Dialogs\',\'widgets/DefaultDialogs\',\'strings\',\'utils/StringUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    require("utils/Global");\r\n    \r\n    var FileSystemError     = require("filesystem/FileSystemError"),\r\n        LanguageManager     = require("language/LanguageManager"),\r\n        PerfUtils           = require("utils/PerfUtils"),\r\n        Dialogs             = require("widgets/Dialogs"),\r\n        DefaultDialogs      = require("widgets/DefaultDialogs"),\r\n        Strings             = require("strings"),\r\n        StringUtils         = require("utils/StringUtils");\r\n\r\n    \r\n    /**\r\n     * Asynchronously reads a file as UTF-8 encoded text.\r\n     * @param {!File} file File to read\r\n     * @return {$.Promise} a jQuery promise that will be resolved with the \r\n     *  file\'s text content plus its timestamp, or rejected with a FileSystemError string\r\n     *  constant if the file can not be read.\r\n     */\r\n    function readAsText(file) {\r\n        var result = new $.Deferred();\r\n\r\n        // Measure performance\r\n        var perfTimerName = PerfUtils.markStart("readAsText:\\t" + file.fullPath);\r\n        result.always(function () {\r\n            PerfUtils.addMeasurement(perfTimerName);\r\n        });\r\n\r\n        // Read file\r\n        file.read(function (err, data, stat) {\r\n            if (!err) {\r\n                result.resolve(data, stat.mtime);\r\n            } else {\r\n                result.reject(err);\r\n            }\r\n        });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Asynchronously writes a file as UTF-8 encoded text.\r\n     * @param {!File} file File to write\r\n     * @param {!string} text\r\n     * @param {boolean=} allowBlindWrite Indicates whether or not CONTENTS_MODIFIED\r\n     *      errors---which can be triggered if the actual file contents differ from \r\n     *      the FileSystem\'s last-known contents---should be ignored.\r\n     * @return {$.Promise} a jQuery promise that will be resolved when\r\n     * file writing completes, or rejected with a FileSystemError string constant.\r\n     */\r\n    function writeText(file, text, allowBlindWrite) {\r\n        var result = new $.Deferred(),\r\n            options = {};\r\n        \r\n        if (allowBlindWrite) {\r\n            options.blind = true;\r\n        }\r\n        \r\n        file.write(text, options, function (err) {\r\n            if (!err) {\r\n                result.resolve();\r\n            } else {\r\n                result.reject(err);\r\n            }\r\n        });\r\n        \r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * Line endings\r\n     * @enum {string}\r\n     */\r\n    var LINE_ENDINGS_CRLF = "CRLF",\r\n        LINE_ENDINGS_LF   = "LF";\r\n    \r\n    /**\r\n     * Returns the standard line endings for the current platform\r\n     * @return {LINE_ENDINGS_CRLF|LINE_ENDINGS_LF}\r\n     */\r\n    function getPlatformLineEndings() {\r\n        return brackets.platform === "win" ? LINE_ENDINGS_CRLF : LINE_ENDINGS_LF;\r\n    }\r\n    \r\n    /**\r\n     * Scans the first 1000 chars of the text to determine how it encodes line endings. Returns\r\n     * null if usage is mixed or if no line endings found.\r\n     * @param {!string} text\r\n     * @return {null|LINE_ENDINGS_CRLF|LINE_ENDINGS_LF}\r\n     */\r\n    function sniffLineEndings(text) {\r\n        var subset = text.substr(0, 1000);  // (length is clipped to text.length)\r\n        var hasCRLF = /\\r\\n/.test(subset);\r\n        var hasLF = /[^\\r]\\n/.test(subset);\r\n        \r\n        if ((hasCRLF && hasLF) || (!hasCRLF && !hasLF)) {\r\n            return null;\r\n        } else {\r\n            return hasCRLF ? LINE_ENDINGS_CRLF : LINE_ENDINGS_LF;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Translates any line ending types in the given text to the be the single form specified\r\n     * @param {!string} text\r\n     * @param {null|LINE_ENDINGS_CRLF|LINE_ENDINGS_LF} lineEndings\r\n     * @return {string}\r\n     */\r\n    function translateLineEndings(text, lineEndings) {\r\n        if (lineEndings !== LINE_ENDINGS_CRLF && lineEndings !== LINE_ENDINGS_LF) {\r\n            lineEndings = getPlatformLineEndings();\r\n        }\r\n        \r\n        var eolStr = (lineEndings === LINE_ENDINGS_CRLF ? "\\r\\n" : "\\n");\r\n        var findAnyEol = /\\r\\n|\\r|\\n/g;\r\n        \r\n        return text.replace(findAnyEol, eolStr);\r\n    }\r\n\r\n    function getFileErrorString(name) {\r\n        // There are a few error codes that we have specific error messages for. The rest are\r\n        // displayed with a generic "(error N)" message.\r\n        var result;\r\n\r\n        if (name === FileSystemError.NOT_FOUND) {\r\n            result = Strings.NOT_FOUND_ERR;\r\n        } else if (name === FileSystemError.NOT_READABLE) {\r\n            result = Strings.NOT_READABLE_ERR;\r\n        } else if (name === FileSystemError.NOT_WRITABLE) {\r\n            result = Strings.NO_MODIFICATION_ALLOWED_ERR_FILE;\r\n        } else if (name === FileSystemError.CONTENTS_MODIFIED) {\r\n            result = Strings.CONTENTS_MODIFIED_ERR;\r\n        } else if (name === FileSystemError.UNSUPPORTED_ENCODING) {\r\n            result = Strings.UNSUPPORTED_ENCODING_ERR;\r\n        } else if (name === FileSystemError.UNSUPPORTED_FILETYPE) {\r\n            result = Strings.UNSUPPORTED_FILE_TYPE_ERR;\r\n        } else {\r\n            result = StringUtils.format(Strings.GENERIC_ERROR, name);\r\n        }\r\n\r\n        return result;\r\n    }\r\n    \r\n    function showFileOpenError(name, path) {\r\n        return Dialogs.showModalDialog(\r\n            DefaultDialogs.DIALOG_ID_ERROR,\r\n            Strings.ERROR_OPENING_FILE_TITLE,\r\n            StringUtils.format(\r\n                Strings.ERROR_OPENING_FILE,\r\n                StringUtils.breakableUrl(path),\r\n                getFileErrorString(name)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates an HTML string for a list of files to be reported on, suitable for use in a dialog.\r\n     * @param {Array.<string>} Array of filenames or paths to display.\r\n     */\r\n    function makeDialogFileList(paths) {\r\n        var result = "<ul class=\'dialog-list\'>";\r\n        paths.forEach(function (path) {\r\n            result += "<li><span class=\'dialog-filename\'>";\r\n            result += StringUtils.breakableUrl(path);\r\n            result += "</span></li>";\r\n        });\r\n        result += "</ul>";\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Convert a URI path to a native path.\r\n     * On both platforms, this unescapes the URI\r\n     * On windows, URI paths start with a "/", but have a drive letter ("C:"). In this\r\n     * case, remove the initial "/".\r\n     * @param {!string} path\r\n     * @return {string}\r\n     */\r\n    function convertToNativePath(path) {\r\n        path = unescape(path);\r\n        if (path.indexOf(":") !== -1 && path[0] === "/") {\r\n            return path.substr(1);\r\n        }\r\n        \r\n        return path;\r\n    }\r\n    \r\n    /**\r\n     * Convert a Windows-native path to use Unix style slashes.\r\n     * On Windows, this converts "C:\\foo\\bar\\baz.txt" to "C:/foo/bar/baz.txt".\r\n     * On Mac, this does nothing, since Mac paths are already in Unix syntax.\r\n     * (Note that this does not add an initial forward-slash. Internally, our\r\n     * APIs generally use the "C:/foo/bar/baz.txt" style for "native" paths.)\r\n     * @param {string} path A native-style path.\r\n     * @return {string} A Unix-style path.\r\n     */\r\n    function convertWindowsPathToUnixPath(path) {\r\n        if (brackets.platform === "win") {\r\n            path = path.replace(/\\\\/g, "/");\r\n        }\r\n        return path;\r\n    }\r\n    \r\n    /**\r\n     * Removes the trailing slash from a path, if it has one.\r\n     * Warning: this differs from the format of most paths used in Brackets! Use paths ending in "/"\r\n     * normally, as this is the format used by Directory.fullPath.\r\n     * \r\n     * @param {string} path\r\n     * @return {string}\r\n     */\r\n    function stripTrailingSlash(path) {\r\n        if (path && path[path.length - 1] === "/") {\r\n            return path.slice(0, -1);\r\n        } else {\r\n            return path;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Warning: Contrary to the name, this does NOT return a canonical path. The canonical format\r\n     * used by Directory.fullPath actually DOES include the trailing "/"\r\n     * @deprecated\r\n     * \r\n     * @param {string} path\r\n     * @return {string}\r\n     */\r\n    function canonicalizeFolderPath(path) {\r\n        console.error("Warning: FileUtils.canonicalizeFolderPath() is deprecated. Use paths ending in \'/\' if possible, like Directory.fullPath");\r\n        return stripTrailingSlash(path);\r\n    }\r\n    \r\n    /**\r\n     * Get the name of a file or a directory, removing any preceding path.\r\n     * @param {string} fullPath full path to a file or directory\r\n     * @return {string} Returns the base name of a file or the name of a\r\n     * directory\r\n     */\r\n    function getBaseName(fullPath) {\r\n        var lastSlash = fullPath.lastIndexOf("/");\r\n        if (lastSlash === fullPath.length - 1) {  // directory: exclude trailing "/" too\r\n            return fullPath.slice(fullPath.lastIndexOf("/", fullPath.length - 2) + 1, -1);\r\n        } else {\r\n            return fullPath.slice(lastSlash + 1);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Returns a native absolute path to the \'brackets\' source directory.\r\n     * Note that this only works when run in brackets/src/index.html, so it does\r\n     * not work for unit tests (which is run from brackets/test/SpecRunner.html)\r\n     * \r\n     * WARNING: unlike most paths in Brackets, this path EXCLUDES the trailing "/".\r\n     * @return {string}\r\n     */\r\n    function getNativeBracketsDirectoryPath() {\r\n        var pathname = decodeURI(window.location.pathname);\r\n        var directory = pathname.substr(0, pathname.lastIndexOf("/"));\r\n        return convertToNativePath(directory);\r\n    }\r\n    \r\n    /**\r\n     * Given the module object passed to JS module define function,\r\n     * convert the path to a native absolute path.\r\n     * Returns a native absolute path to the module folder.\r\n     * \r\n     * WARNING: unlike most paths in Brackets, this path EXCLUDES the trailing "/".\r\n     * @return {string}\r\n     */\r\n    function getNativeModuleDirectoryPath(module) {\r\n        var path;\r\n        \r\n        if (module && module.uri) {\r\n            path = decodeURI(module.uri);\r\n            \r\n            // Remove module name and trailing slash from path.\r\n            path = path.substr(0, path.lastIndexOf("/"));\r\n        }\r\n        return path;\r\n    }\r\n    \r\n    /**\r\n     * Get the file extension (excluding ".") given a path OR a bare filename.\r\n     * Returns "" for names with no extension. If the name starts with ".", the\r\n     * full remaining text is considered the extension.\r\n     *\r\n     * @param {string} fullPath full path to a file or directory\r\n     * @return {string} Returns the extension of a filename or empty string if\r\n     * the argument is a directory or a filename with no extension\r\n     */\r\n    function getFileExtension(fullPath) {\r\n        var baseName = getBaseName(fullPath),\r\n            idx      = baseName.lastIndexOf(".");\r\n\r\n        if (idx === -1) {\r\n            return "";\r\n        }\r\n\r\n        return baseName.substr(idx + 1);\r\n    }\r\n    \r\n    /**\r\n     * Get the file extension (excluding ".") given a path OR a bare filename.\r\n     * Returns "" for names with no extension.\r\n     * If the only `.` in the file is the first character,\r\n     * returns "" as this is not considered an extension.\r\n     * This method considers known extensions which include `.` in them.\r\n     *\r\n     * @param {string} fullPath full path to a file or directory\r\n     * @return {string} Returns the extension of a filename or empty string if\r\n     * the argument is a directory or a filename with no extension\r\n     */\r\n    function getSmartFileExtension(fullPath) {\r\n        var baseName = getBaseName(fullPath),\r\n            parts = baseName.split(".");\r\n\r\n        // get rid of file name\r\n        parts.shift();\r\n        if (baseName[0] === ".") {\r\n            // if starts with a `.`, then still consider it as file name\r\n            parts.shift();\r\n        }\r\n\r\n        var extension = [parts.pop()], // last part is always an extension\r\n            i = parts.length;\r\n        while (i--) {\r\n            if (LanguageManager.getLanguageForExtension(parts[i])) {\r\n                extension.unshift(parts[i]);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return extension.join(".");\r\n    }\r\n\r\n    /**\r\n     * Computes filename as relative to the basePath. For example:\r\n     * basePath: /foo/bar/, filename: /foo/bar/baz.txt\r\n     * returns: baz.txt\r\n     * \r\n     * The net effect is that the common prefix is stripped away. If basePath is not\r\n     * a prefix of filename, then undefined is returned.\r\n     * \r\n     * @param {string} basePath Path against which we\'re computing the relative path\r\n     * @param {string} filename Full path to the file for which we are computing a relative path\r\n     * @return {string} relative path\r\n     */\r\n    function getRelativeFilename(basePath, filename) {\r\n        if (!filename || filename.substr(0, basePath.length) !== basePath) {\r\n            return;\r\n        }\r\n        \r\n        return filename.substr(basePath.length);\r\n    }\r\n\r\n    /**\r\n     * File extensions - hard-coded for now, but may want to make these preferences\r\n     * @const {Array.<string>}\r\n     */\r\n    var _staticHtmlFileExts = ["htm", "html", "xhtml"],\r\n        _serverHtmlFileExts = ["php", "php3", "php4", "php5", "phtm", "phtml", "cfm", "cfml", "asp", "aspx", "jsp", "jspx", "shtm", "shtml"];\r\n\r\n    /**\r\n     * Determine if file extension is a static html file extension.\r\n     * @param {string} filePath could be a path, a file name or just a file extension\r\n     * @return {boolean} Returns true if fileExt is in the list\r\n     */\r\n    function isStaticHtmlFileExt(filePath) {\r\n        if (!filePath) {\r\n            return false;\r\n        }\r\n\r\n        return (_staticHtmlFileExts.indexOf(getFileExtension(filePath).toLowerCase()) !== -1);\r\n    }\r\n\r\n    /**\r\n     * Determine if file extension is a server html file extension.\r\n     * @param {string} filePath could be a path, a file name or just a file extension\r\n     * @return {boolean} Returns true if fileExt is in the list\r\n     */\r\n    function isServerHtmlFileExt(filePath) {\r\n        if (!filePath) {\r\n            return false;\r\n        }\r\n\r\n        return (_serverHtmlFileExts.indexOf(getFileExtension(filePath).toLowerCase()) !== -1);\r\n    }\r\n    \r\n    /**\r\n     * Determines if file extension is a CSS preprocessor file extension that Brackets supports.\r\n     * @param {string} filePath could be a path, a file name\r\n     * @return {boolean} true if LanguageManager identifies filePath as less or scss language.\r\n     */\r\n    function isCSSPreprocessorFile(filePath) {\r\n        var languageId = LanguageManager.getLanguageForPath(filePath).getId();\r\n        return (languageId === "less" || languageId === "scss");\r\n    }\r\n    \r\n    /**\r\n     * Get the parent directory of a file. If a directory is passed in the directory is returned.\r\n     * @param {string} fullPath full path to a file or directory\r\n     * @return {string} Returns the path to the parent directory of a file or the path of a directory,\r\n     *                  including trailing "/"\r\n     */\r\n    function getDirectoryPath(fullPath) {\r\n        return fullPath.substr(0, fullPath.lastIndexOf("/") + 1);\r\n    }\r\n\r\n    /**\r\n     * Get the file name without the extension.\r\n     * @param {string} filename File name of a file or directory\r\n     * @return {string} Returns the file name without the extension\r\n     */\r\n    function getFilenameWithoutExtension(filename) {\r\n        var index = filename.lastIndexOf(".");\r\n        return index === -1 ? filename : filename.slice(0, index);\r\n    }\r\n    \r\n    /**\r\n     * Compares 2 filenames in lowercases. In Windows it compares the names without the\r\n     * extension first and then the extensions to fix issue #4409\r\n     * @param {string} filename1\r\n     * @param {string} filename2\r\n     * @param {boolean} extFirst If true it compares the extensions first and then the file names.\r\n     * @return {number} The result of the local compare function\r\n     */\r\n    function compareFilenames(filename1, filename2, extFirst) {\r\n        var ext1   = getFileExtension(filename1),\r\n            ext2   = getFileExtension(filename2),\r\n            cmpExt = ext1.toLocaleLowerCase().localeCompare(ext2.toLocaleLowerCase(), undefined, {numeric: true}),\r\n            cmpNames;\r\n        \r\n        if (brackets.platform === "win") {\r\n            filename1 = getFilenameWithoutExtension(filename1);\r\n            filename2 = getFilenameWithoutExtension(filename2);\r\n        }\r\n        cmpNames = filename1.toLocaleLowerCase().localeCompare(filename2.toLocaleLowerCase(), undefined, {numeric: true});\r\n        \r\n        return extFirst ? (cmpExt || cmpNames) : (cmpNames || cmpExt);\r\n    }\r\n    \r\n    /**\r\n     * Compares two paths segment-by-segment, used for sorting. Sorts folders before files,\r\n     * and sorts files based on `compareFilenames()`.\r\n     * @param {string} path1\r\n     * @param {string} path2\r\n     * @return {number} -1, 0, or 1 depending on whether path1 is less than, equal to, or greater than\r\n     *     path2 according to this ordering.\r\n     */\r\n    function comparePaths(path1, path2) {\r\n        var entryName1, entryName2,\r\n            pathParts1 = path1.split("/"),\r\n            pathParts2 = path2.split("/"),\r\n            length     = Math.min(pathParts1.length, pathParts2.length),\r\n            folders1   = pathParts1.length - 1,\r\n            folders2   = pathParts2.length - 1,\r\n            index      = 0;\r\n\r\n        while (index < length) {\r\n            entryName1 = pathParts1[index];\r\n            entryName2 = pathParts2[index];\r\n\r\n            if (entryName1 !== entryName2) {\r\n                if (index < folders1 && index < folders2) {\r\n                    return entryName1.toLocaleLowerCase().localeCompare(entryName2.toLocaleLowerCase());\r\n                } else if (index >= folders1 && index >= folders2) {\r\n                    return compareFilenames(entryName1, entryName2);\r\n                }\r\n                return (index >= folders1 && index < folders2) ? 1 : -1;\r\n            }\r\n            index++;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    // Define public API\r\n    exports.LINE_ENDINGS_CRLF              = LINE_ENDINGS_CRLF;\r\n    exports.LINE_ENDINGS_LF                = LINE_ENDINGS_LF;\r\n    exports.getPlatformLineEndings         = getPlatformLineEndings;\r\n    exports.sniffLineEndings               = sniffLineEndings;\r\n    exports.translateLineEndings           = translateLineEndings;\r\n    exports.showFileOpenError              = showFileOpenError;\r\n    exports.getFileErrorString             = getFileErrorString;\r\n    exports.makeDialogFileList             = makeDialogFileList;\r\n    exports.readAsText                     = readAsText;\r\n    exports.writeText                      = writeText;\r\n    exports.convertToNativePath            = convertToNativePath;\r\n    exports.convertWindowsPathToUnixPath   = convertWindowsPathToUnixPath;\r\n    exports.getNativeBracketsDirectoryPath = getNativeBracketsDirectoryPath;\r\n    exports.getNativeModuleDirectoryPath   = getNativeModuleDirectoryPath;\r\n    exports.canonicalizeFolderPath         = canonicalizeFolderPath;\r\n    exports.stripTrailingSlash             = stripTrailingSlash;\r\n    exports.isCSSPreprocessorFile          = isCSSPreprocessorFile;\r\n    exports.isStaticHtmlFileExt            = isStaticHtmlFileExt;\r\n    exports.isServerHtmlFileExt            = isServerHtmlFileExt;\r\n    exports.getDirectoryPath               = getDirectoryPath;\r\n    exports.getBaseName                    = getBaseName;\r\n    exports.getRelativeFilename            = getRelativeFilename;\r\n    exports.getFilenameWithoutExtension    = getFilenameWithoutExtension;\r\n    exports.getFileExtension               = getFileExtension;\r\n    exports.getSmartFileExtension          = getSmartFileExtension;\r\n    exports.compareFilenames               = compareFilenames;\r\n    exports.comparePaths                   = comparePaths;\r\n});\r\n\n//# sourceURL=/file/FileUtils.js'),eval('define(\'text!language/languages.json\',[],function () { return \'{\\r\\n    "unknown": {\\r\\n        "name": "Text",\\r\\n        "mode": ["null", "text/plain"]\\r\\n    },\\r\\n    \\r\\n    "groovy": {\\r\\n        "name": "Groovy",\\r\\n        "mode": "groovy",\\r\\n        "fileExtensions": ["groovy"],\\r\\n        "blockComment": ["/*", "*/"],\\r\\n        "lineComment": ["//"]\\r\\n    },\\r\\n   \\r\\n    "properties": {\\r\\n        "name": "Properties",\\r\\n        "mode": ["properties", "text/x-properties"],\\r\\n        "fileExtensions": ["ini", "properties"]\\r\\n    },\\r\\n\\r\\n    "css": {\\r\\n        "name": "CSS",\\r\\n        "mode": "css",\\r\\n        "fileExtensions": ["css", "css.erb"],\\r\\n        "blockComment": ["/*", "*/"]\\r\\n    },\\r\\n\\r\\n    "scss": {\\r\\n        "name": "SCSS",\\r\\n        "mode": ["css", "text/x-scss"],\\r\\n        "fileExtensions": ["scss", "scss.erb"],\\r\\n        "blockComment": ["/*", "*/"],\\r\\n        "lineComment": ["//"]\\r\\n    },\\r\\n\\r\\n    "html": {\\r\\n        "name": "HTML",\\r\\n        "mode": ["htmlmixed", "text/x-brackets-html"],\\r\\n        "fileExtensions": ["html", "htm", "shtm", "shtml", "xhtml", "cfm", "cfml", "cfc", "dhtml", "xht", "tpl", "twig", "hbs", "handlebars", "kit", "jsp", "aspx", "ascx", "asp", "master", "cshtml", "vbhtml"],\\r\\n        "blockComment": ["<!--", "-->"]\\r\\n    },\\r\\n    \\r\\n    "ejs": {\\r\\n        "name": "EJS",\\r\\n        "mode": ["htmlembedded", "application/x-ejs"],\\r\\n        "fileExtensions": ["ejs", "dust"],\\r\\n        "blockComment": ["<!--", "-->"]\\r\\n    },\\r\\n    \\r\\n    "erb_html": {\\r\\n        "name": "Embedded Ruby",\\r\\n        "mode": ["htmlembedded", "application/x-erb"],\\r\\n        "fileExtensions": ["erb", "html.erb", "htm.erb"],\\r\\n        "blockComment": ["<!--", "-->"]\\r\\n    },\\r\\n\\r\\n    "javascript": {\\r\\n        "name": "JavaScript",\\r\\n        "mode": "javascript",\\r\\n        "fileExtensions": ["js", "jsx", "js.erb", "jsm", "_js"],\\r\\n        "blockComment": ["/*", "*/"],\\r\\n        "lineComment": ["//"]\\r\\n    },\\r\\n\\r\\n    "vbscript": {\\r\\n        "name": "VBScript",\\r\\n        "mode": "vbscript",\\r\\n        "fileExtensions": ["vbs"],\\r\\n        "lineComment": ["\\\'", "REM"]\\r\\n    },\\r\\n\\r\\n    "vb": {\\r\\n        "name": "VB",\\r\\n        "mode": ["vb", "text/x-vb"],\\r\\n        "fileExtensions": ["vb"],\\r\\n        "lineComment": ["\\\'"]\\r\\n    },\\r\\n\\r\\n    "json": {\\r\\n        "name": "JSON",\\r\\n        "mode": ["javascript", "application/json"],\\r\\n        "fileExtensions": ["json"],\\r\\n        "fileNames": [".jshintrc", ".bowerrc"]\\r\\n    },\\r\\n\\r\\n    "xml": {\\r\\n        "name": "XML",\\r\\n        "mode": "xml",\\r\\n        "fileExtensions": ["xml", "svg", "wxs", "wxl", "wsdl", "rss", "atom", "rdf", "xslt", "xsl", "xul", "xbl", "mathml", "config", "plist", "xaml"],\\r\\n        "blockComment": ["<!--", "-->"]\\r\\n    },\\r\\n\\r\\n    "php": {\\r\\n        "name": "PHP",\\r\\n        "mode": "php",\\r\\n        "fileExtensions": ["php", "php3", "php4", "php5", "phtm", "phtml", "ctp"],\\r\\n        "blockComment": ["/*", "*/"],\\r\\n        "lineComment": ["//", "#"]\\r\\n    },\\r\\n\\r\\n    "c": {\\r\\n        "name": "C",\\r\\n        "mode": ["clike", "text/x-csrc"],\\r\\n        "fileExtensions": ["c", "h", "i"],\\r\\n        "blockComment": ["/*", "*/"],\\r\\n        "lineComment": ["//"]\\r\\n    },\\r\\n\\r\\n    "cpp": {\\r\\n        "name": "C++",\\r\\n        "mode": ["clike", "text/x-c++src"],\\r\\n        "fileExtensions": ["cc", "cp", "cpp", "c++", "cxx", "hh", "hpp", "hxx", "h++", "ii", "ino"],\\r\\n        "blockComment": ["/*", "*/"],\\r\\n        "lineComment": ["//"]\\r\\n    },\\r\\n\\r\\n    "csharp": {\\r\\n        "name": "C#",\\r\\n        "mode": ["clike", "text/x-csharp"],\\r\\n        "fileExtensions": ["cs", "asax", "ashx"],\\r\\n        "blockComment": ["/*", "*/"],\\r\\n        "lineComment": ["//"]\\r\\n    },\\r\\n\\r\\n    "java": {\\r\\n        "name": "Java",\\r\\n        "mode": ["clike", "text/x-java"],\\r\\n        "fileExtensions": ["java"],\\r\\n        "blockComment": ["/*", "*/"],\\r\\n        "lineComment": ["//"]\\r\\n    },\\r\\n\\r\\n    "scala": {\\r\\n        "name": "Scala",\\r\\n        "mode": ["clike", "text/x-scala"],\\r\\n        "fileExtensions": ["scala", "sbt"],\\r\\n        "blockComment": ["/*", "*/"],\\r\\n        "lineComment": ["//"]\\r\\n    },\\r\\n\\r\\n    "coffeescript": {\\r\\n        "name": "CoffeeScript",\\r\\n        "mode": "coffeescript",\\r\\n        "fileExtensions": ["coffee", "cf", "cson", "_coffee"],\\r\\n        "fileNames": ["Cakefile"],\\r\\n        "blockComment": ["###", "###"],\\r\\n        "lineComment": ["#"]\\r\\n    },\\r\\n\\r\\n    "clojure": {\\r\\n        "name": "Clojure",\\r\\n        "mode": "clojure",\\r\\n        "fileExtensions": ["clj", "cljs", "cljx"],\\r\\n        "lineComment": [";", ";;"]\\r\\n    },\\r\\n\\r\\n    "perl": {\\r\\n        "name": "Perl",\\r\\n        "mode": "perl",\\r\\n        "fileExtensions": ["pl", "pm"],\\r\\n        "lineComment": ["#"]\\r\\n    },\\r\\n\\r\\n    "ruby": {\\r\\n        "name": "Ruby",\\r\\n        "mode": "ruby",\\r\\n        "fileExtensions": ["rb", "ru", "gemspec", "rake"],\\r\\n        "fileNames": ["Gemfile", "Rakefile", "Guardfile"],\\r\\n        "lineComment": ["#"]\\r\\n    },\\r\\n\\r\\n    "python": {\\r\\n        "name": "Python",\\r\\n        "mode": "python",\\r\\n        "fileExtensions": ["py", "pyw", "wsgi"],\\r\\n        "lineComment": ["#"]\\r\\n    },\\r\\n\\r\\n    "sass": {\\r\\n        "name": "SASS",\\r\\n        "mode": "sass",\\r\\n        "fileExtensions": ["sass"],\\r\\n        "blockComment": ["/*", "*/"],\\r\\n        "lineComment": ["//"]\\r\\n    },\\r\\n\\r\\n    "lua": {\\r\\n        "name": "Lua",\\r\\n        "mode": "lua",\\r\\n        "fileExtensions": ["lua"],\\r\\n        "blockComment": ["--[[", "]]"],\\r\\n        "lineComment": ["--"]\\r\\n    },\\r\\n\\r\\n    "sql": {\\r\\n        "name": "SQL",\\r\\n        "mode": ["sql", "text/x-mysql"],\\r\\n        "fileExtensions": ["sql"]\\r\\n    },\\r\\n\\r\\n    "diff": {\\r\\n        "name": "Diff",\\r\\n        "mode": "diff",\\r\\n        "fileExtensions": ["diff", "patch"]\\r\\n    },\\r\\n\\r\\n    "markdown": {\\r\\n        "name": "Markdown",\\r\\n        "mode": "markdown",\\r\\n        "fileExtensions": ["md", "markdown"],\\r\\n        "blockComment": ["<!--", "-->"]\\r\\n    },\\r\\n\\r\\n    "yaml": {\\r\\n        "name": "YAML",\\r\\n        "mode": "yaml",\\r\\n        "fileExtensions": ["yaml", "yml"],\\r\\n        "lineComment": ["#"]\\r\\n    },\\r\\n\\r\\n    "hx": {\\r\\n        "name": "Haxe",\\r\\n        "mode": "haxe",\\r\\n        "fileExtensions": ["hx"],\\r\\n        "blockComment": ["/*", "*/"],\\r\\n        "lineComment": ["//"]\\r\\n    },\\r\\n\\r\\n    "bash": {\\r\\n        "name": "Bash",\\r\\n        "mode": ["shell", "text/x-sh"],\\r\\n        "fileExtensions": ["sh", "command", "bash"],\\r\\n        "lineComment": ["#"]\\r\\n    },\\r\\n  \\r\\n    "image": {\\r\\n        "name": "Image",\\r\\n        "fileExtensions": ["gif", "png", "jpe", "jpeg", "jpg", "ico", "bmp"],\\r\\n        "isBinary": true\\r\\n    },\\r\\n    \\r\\n    "audio": {\\r\\n        "name": "Audio",\\r\\n        "fileExtensions": ["mp3", "wav", "aif", "aiff", "ogg"],\\r\\n        "isBinary": true\\r\\n    },\\r\\n    \\r\\n    "binary": {\\r\\n        "name": "Other Binary",\\r\\n        "fileExtensions": [\\r\\n            "a", "ai", "avi", "bin", "cab", "com", "db", "dll", "dmg",\\r\\n            "doc", "docx", "dot", "dotx", "dsym", "dylib", "egg", "epub", "eot",\\r\\n            "exe", "flv", "gz", "gzip", "htmz", "htmlz", "ipch", "iso", "jar",\\r\\n            "jsz", "lib", "mpeg", "mpg", "mp4", "msi", "node", "o", "obj", "odc",\\r\\n            "odb", "odf", "odg", "odp", "ods", "odt", "otf", "pak", "pdb", "pdf",\\r\\n            "pdi", "ppt", "pptx", "psd", "rar", "sdf", "so", "sqlite", "suo", "svgz",\\r\\n            "swf", "tar", "tif", "tiff", "ttf", "woff", "xls", "xlsx", "zip"\\r\\n        ],\\r\\n        "isBinary": true\\r\\n    }\\r\\n}\\r\\n\';});\n\n//# sourceURL=/text!language/languages.json'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n/*unittests: LanguageManager*/\r\n\r\n/**\r\n * LanguageManager provides access to the languages supported by Brackets\r\n *\r\n * To find out which languages we support by default, have a look at languages.json.\r\n *\r\n * To get access to an existing language, call getLanguage():\r\n *\r\n *     var language = LanguageManager.getLanguage("<id>");\r\n *\r\n * To define your own languages, call defineLanguage():\r\n *\r\n *     LanguageManager.defineLanguage("haskell", {\r\n *         name: "Haskell",\r\n *         mode: "haskell",\r\n *         fileExtensions: ["hs"],\r\n *         blockComment: ["{-", "-}"],\r\n *         lineComment: ["--"]\r\n *     });\r\n *\r\n * To use that language and its related mode, wait for the returned promise to be resolved:\r\n *\r\n *     LanguageManager.defineLanguage("haskell", definition).done(function (language) {\r\n *         console.log("Language " + language.getName() + " is now available!");\r\n *     });\r\n *\r\n * The extension can also contain dots:\r\n *\r\n *     LanguageManager.defineLanguage("literatecoffeescript", {\r\n *         name: "Literate CoffeeScript",\r\n *         mode: "coffeescript",\r\n *         fileExtensions: ["litcoffee", "coffee.md"]\r\n *     }); \r\n *\r\n * You can also specify file names:\r\n *\r\n *     LanguageManager.defineLanguage("makefile", {\r\n *         name: "Make",\r\n *         mode: ["null", "text/plain"],\r\n *         fileNames: ["Makefile"]\r\n *     });\r\n *\r\n * You can combine file names and extensions, or not define them at all.\r\n *\r\n * You can also refine an existing language:\r\n *\r\n *     var language = LanguageManager.getLanguage("haskell");\r\n *     language.setLineCommentSyntax(["--"]);\r\n *     language.setBlockCommentSyntax("{-", "-}");\r\n *     language.addFileExtension("lhs");\r\n *\r\n * Some CodeMirror modes define variations of themselves. They are called MIME modes.\r\n * To find existing MIME modes, search for "CodeMirror.defineMIME" in thirdparty/CodeMirror2/mode\r\n * For instance, C++, C# and Java all use the clike (C-like) mode with different settings and a different MIME name.\r\n * You can refine the mode definition by specifying the MIME mode as well:\r\n *\r\n *     LanguageManager.defineLanguage("csharp", {\r\n *         name: "C#",\r\n *         mode: ["clike", "text/x-csharp"],\r\n *         ...\r\n *     });\r\n *\r\n * Defining the base mode is still necessary to know which file to load.\r\n * However, language.getMode() will return just the MIME mode if one was\r\n * specified.\r\n *\r\n * If you need to configure a mode, you can just create a new MIME mode and use that:\r\n *\r\n *     CodeMirror.defineMIME("text/x-brackets-html", {\r\n *         "name": "htmlmixed",\r\n *         "scriptTypes": [{"matches": /\\/x-handlebars-template|\\/x-mustache/i,\r\n *                        "mode": null}]\r\n *     });\r\n *\r\n *     LanguageManager.defineLanguage("html", {\r\n *         name: "HTML",\r\n *         mode: ["htmlmixed", "text/x-brackets-html"],\r\n *         ...\r\n *     });\r\n *\r\n * If a mode is not shipped with our CodeMirror distribution, you need to first load it yourself.\r\n * If the mode is part of our CodeMirror distribution, it gets loaded automatically.\r\n *\r\n * You can also defines binary file types, i.e. Brackets supports image files by default, \r\n * such as *.jpg, *.png etc.\r\n * Binary files do not require mode because modes are specific to CodeMirror, which\r\n * only handles text based file types.\r\n * To register a binary language the isBinary flag must be set, i.e.\r\n *\r\n *     LanguageManager.defineLanguage("audio", {\r\n *         name: "Audio",\r\n *         fileExtensions: ["mp3", "wav", "aif", "aiff", "ogg"],\r\n *         isBinary: true    \r\n *     }); \r\n * \r\n * \r\n * LanguageManager dispatches two events:\r\n * \r\n *  - languageAdded -- When any new Language is added. 2nd arg is the new Language.\r\n *  - languageModified -- When the attributes of a Language change, or when the Language gains or loses\r\n *          file extension / filename mappings. 2nd arg is the modified Language.\r\n */\r\ndefine(\'language/LanguageManager\',[\'require\',\'exports\',\'module\',\'thirdparty/CodeMirror2/lib/codemirror\',\'utils/Async\',\'file/FileUtils\',\'text!language/languages.json\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    \r\n    // Dependencies\r\n    var CodeMirror            = require("thirdparty/CodeMirror2/lib/codemirror"),\r\n        Async                 = require("utils/Async"),\r\n        FileUtils             = require("file/FileUtils"),\r\n        _defaultLanguagesJSON = require("text!language/languages.json"),\r\n        _                     = require("thirdparty/lodash"),\r\n        \r\n        // PreferencesManager is loaded near the end of the file\r\n        PreferencesManager;\r\n    \r\n    // State\r\n    var _fallbackLanguage               = null,\r\n        _pendingLanguages               = {},\r\n        _languages                      = {},\r\n        _baseFileExtensionToLanguageMap = {},\r\n        _fileExtensionToLanguageMap     = Object.create(_baseFileExtensionToLanguageMap),\r\n        _fileNameToLanguageMap          = {},\r\n        _filePathToLanguageMap          = {},\r\n        _modeToLanguageMap              = {},\r\n        _ready;\r\n    \r\n    // Constants\r\n    \r\n    var _EXTENSION_MAP_PREF = "language.fileExtensions",\r\n        _NAME_MAP_PREF      = "language.fileNames";\r\n    \r\n    // Tracking for changes to mappings made by preferences\r\n    var _prefState = {};\r\n    \r\n    _prefState[_EXTENSION_MAP_PREF] = {\r\n        last: {},\r\n        overridden: {},\r\n        add: "addFileExtension",\r\n        remove: "removeFileExtension",\r\n        get: "getLanguageForExtension"\r\n    };\r\n    \r\n    _prefState[_NAME_MAP_PREF] = {\r\n        last: {},\r\n        overridden: {},\r\n        add: "addFileName",\r\n        remove: "removeFileName",\r\n        get: "getLanguageForPath"\r\n    };\r\n    \r\n    // Helper functions\r\n    \r\n    /**\r\n     * Checks whether value is a non-empty string. Reports an error otherwise.\r\n     * If no deferred is passed, console.error is called.\r\n     * Otherwise the deferred is rejected with the error message.\r\n     * @param {*}                value         The value to validate\r\n     * @param {!string}          description   A helpful identifier for value\r\n     * @param {?jQuery.Deferred} deferred      A deferred to reject with the error message in case of an error\r\n     * @return {boolean} True if the value is a non-empty string, false otherwise\r\n     */\r\n    function _validateNonEmptyString(value, description, deferred) {\r\n        var reportError = deferred ? deferred.reject : console.error;\r\n        \r\n        // http://stackoverflow.com/questions/1303646/check-whether-variable-is-number-or-string-in-javascript\r\n        if (Object.prototype.toString.call(value) !== "[object String]") {\r\n            reportError(description + " must be a string");\r\n            return false;\r\n        }\r\n        if (value === "") {\r\n            reportError(description + " must not be empty");\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Monkey-patch CodeMirror to prevent modes from being overwritten by extensions.\r\n     * We may rely on the tokens provided by some of these modes.\r\n     */\r\n    function _patchCodeMirror() {\r\n        var _original_CodeMirror_defineMode = CodeMirror.defineMode;\r\n        function _wrapped_CodeMirror_defineMode(name) {\r\n            if (CodeMirror.modes[name]) {\r\n                console.error("There already is a CodeMirror mode with the name \\"" + name + "\\"");\r\n                return;\r\n            }\r\n            _original_CodeMirror_defineMode.apply(CodeMirror, arguments);\r\n        }\r\n        CodeMirror.defineMode = _wrapped_CodeMirror_defineMode;\r\n    }\r\n    \r\n    /**\r\n     * Adds a global mode-to-language association.\r\n     * @param {!string} mode The mode to associate the language with\r\n     * @param {!Language} language The language to associate with the mode\r\n     */\r\n    function _setLanguageForMode(mode, language) {\r\n        if (_modeToLanguageMap[mode]) {\r\n            console.warn("CodeMirror mode \\"" + mode + "\\" is already used by language " + _modeToLanguageMap[mode]._name + " - cannot fully register language " + language._name +\r\n                         " using the same mode. Some features will treat all content with this mode as language " + _modeToLanguageMap[mode]._name);\r\n            return;\r\n        }\r\n\r\n        _modeToLanguageMap[mode] = language;\r\n    }\r\n    \r\n    /**\r\n     * Resolves a language ID to a Language object.\r\n     * File names have a higher priority than file extensions. \r\n     * @param {!string} id Identifier for this language: lowercase letters, digits, and _ separators (e.g. "cpp", "foo_bar", "c99")\r\n     * @return {Language} The language with the provided identifier or undefined\r\n     */\r\n    function getLanguage(id) {\r\n        return _languages[id];\r\n    }\r\n    \r\n    /**\r\n     * Resolves a file extension to a Language object.\r\n     * *Warning:* it is almost always better to use getLanguageForPath(), since Language can depend\r\n     * on file name and even full path. Use this API only if no relevant file/path exists.\r\n     * @param {!string} extension Extension that language should be resolved for\r\n     * @return {?Language} The language for the provided extension or null if none exists\r\n     */\r\n    function getLanguageForExtension(extension) {\r\n        return _fileExtensionToLanguageMap[extension.toLowerCase()];\r\n    }\r\n\r\n    /**\r\n     * Resolves a file path to a Language object.\r\n     * @param {!string} path Path to the file to find a language for\r\n     * @param {?boolean} ignoreOverride If set to true will cause the lookup to ignore any\r\n     *      overrides and return default binding. By default override is not ignored.\r\n     *\r\n     * @return {Language} The language for the provided file type or the fallback language\r\n     */\r\n    function getLanguageForPath(path, ignoreOverride) {\r\n        var fileName,\r\n            language = _filePathToLanguageMap[path],\r\n            extension,\r\n            parts;\r\n        \r\n        // if there\'s an override, return it\r\n        if (!ignoreOverride && language) {\r\n            return language;\r\n        }\r\n        \r\n        fileName = FileUtils.getBaseName(path).toLowerCase();\r\n        language = _fileNameToLanguageMap[fileName];\r\n        \r\n        // If no language was found for the file name, use the file extension instead\r\n        if (!language) {\r\n            // Split the file name into parts:\r\n            //   "foo.coffee.md"   => ["foo", "coffee", "md"]\r\n            //   ".profile.bak"    => ["", "profile", "bak"]\r\n            //   "1. Vacation.txt" => ["1", " Vacation", "txt"]\r\n            parts = fileName.split(".");\r\n            \r\n            // A leading dot does not indicate a file extension, but marks the file as hidden => remove it\r\n            if (parts[0] === "") {\r\n                // ["", "profile", "bak"] => ["profile", "bak"]\r\n                parts.shift();\r\n            }\r\n            \r\n            // The first part is assumed to be the title, not the extension => remove it\r\n            //   ["foo", "coffee", "md"]   => ["coffee", "md"]\r\n            //   ["profile", "bak"]        => ["bak"]\r\n            //   ["1", " Vacation", "txt"] => [" Vacation", "txt"]\r\n            parts.shift();\r\n            \r\n            // Join the remaining parts into a file extension until none are left or a language was found\r\n            while (!language && parts.length) {\r\n                // First iteration:\r\n                //   ["coffee", "md"]     => "coffee.md"\r\n                //   ["bak"]              => "bak"\r\n                //   [" Vacation", "txt"] => " Vacation.txt"\r\n                // Second iteration (assuming no language was found for "coffee.md"):\r\n                //   ["md"]  => "md"\r\n                //   ["txt"] => "txt"\r\n                extension = parts.join(".");\r\n                language  = _fileExtensionToLanguageMap[extension];\r\n                // Remove the first part\r\n                // First iteration:\r\n                //   ["coffee", "md"]     => ["md"]\r\n                //   ["bak"]              => []\r\n                //   [" Vacation", "txt"] => ["txt"]\r\n                // Second iteration:\r\n                //   ["md"]  => []\r\n                //   ["txt"] => []\r\n                parts.shift();\r\n            }\r\n        }\r\n        \r\n        return language || _fallbackLanguage;\r\n    }\r\n    \r\n    /**\r\n     * Returns a map of all the languages currently defined in the LanguageManager. The key to\r\n     * the map is the language id and the value is the language object.\r\n     *\r\n     * @return {Object.<string, Language>} A map containing all of the\r\n     *      languages currently defined.\r\n     */\r\n    function getLanguages() {\r\n        return $.extend({}, _languages); // copy to prevent modification\r\n    }\r\n    \r\n    /**\r\n     * Resolves a CodeMirror mode to a Language object.\r\n     * @param {!string} mode CodeMirror mode\r\n     * @return {Language} The language for the provided mode or the fallback language\r\n     */\r\n    function _getLanguageForMode(mode) {\r\n        var language = _modeToLanguageMap[mode];\r\n        if (language) {\r\n            return language;\r\n        }\r\n        \r\n        // In case of unsupported languages\r\n        console.log("Called LanguageManager._getLanguageForMode with a mode for which no language has been registered:", mode);\r\n        return _fallbackLanguage;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Notify listeners when a language is added\r\n     * @param {!Language} language The new language\r\n     */\r\n    function _triggerLanguageAdded(language) {\r\n        // finally, store language to _language map\r\n        _languages[language.getId()] = language;\r\n        $(exports).triggerHandler("languageAdded", [language]);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Notify listeners when a language is modified\r\n     * @param {!Language} language The modified language\r\n     */\r\n    function _triggerLanguageModified(language) {\r\n        $(exports).triggerHandler("languageModified", [language]);\r\n    }\r\n    \r\n    /**\r\n     * Adds a language mapping for the specified fullPath. If language is falsy (null or undefined), the mapping\r\n     * is removed. The override is NOT persisted across Brackets sessions.\r\n     *\r\n     * @param {!fullPath} fullPath absolute path of the file\r\n     * @param {?object} language language to associate the file with or falsy value to remove any existing override\r\n     */\r\n    function setLanguageOverrideForPath(fullPath, language) {\r\n        var oldLang = getLanguageForPath(fullPath);\r\n        if (!language) {\r\n            delete _filePathToLanguageMap[fullPath];\r\n        } else {\r\n            _filePathToLanguageMap[fullPath] = language;\r\n        }\r\n        var newLang = getLanguageForPath(fullPath);\r\n        \r\n        // Old language changed since this path is no longer mapped to it\r\n        _triggerLanguageModified(oldLang);\r\n        // New language changed since a path is now mapped to it that wasn\'t before\r\n        _triggerLanguageModified(newLang);\r\n    }\r\n    \r\n    /**\r\n     * Resets all the language overrides for file paths. Used by unit tests only.\r\n     */\r\n    function _resetPathLanguageOverrides() {\r\n        _filePathToLanguageMap = {};\r\n    }\r\n\r\n\r\n    \r\n\r\n    /**\r\n     * Model for a language.\r\n     * @constructor\r\n     */\r\n    function Language() {\r\n        this._fileExtensions    = [];\r\n        this._fileNames         = [];\r\n        this._modeToLanguageMap = {};\r\n        this._lineCommentSyntax = [];\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Identifier for this language\r\n     * @type {string}\r\n     */\r\n    Language.prototype._id = null;\r\n    \r\n    /**\r\n     * Human-readable name of this language\r\n     * @type {string}\r\n     */\r\n    Language.prototype._name = null;\r\n    \r\n    /**\r\n     * CodeMirror mode for this language\r\n     * @type {string}\r\n     */\r\n    Language.prototype._mode = null;\r\n    \r\n    /**\r\n     * File extensions that use this language\r\n     * @type {Array.<string>}\r\n     */\r\n    Language.prototype._fileExtensions = null;\r\n    \r\n    /**\r\n     * File names for extensionless files that use this language\r\n     * @type {Array.<string>}\r\n     */\r\n    Language.prototype._fileNames = null;\r\n    \r\n    /**\r\n     * Line comment syntax\r\n     * @type {Array.<string>}\r\n     */\r\n    Language.prototype._lineCommentSyntax = null;\r\n    \r\n    /**\r\n     * Which language to use for what CodeMirror mode\r\n     * @type {Object.<string,Language>}\r\n     */\r\n    Language.prototype._modeToLanguageMap = null;\r\n    \r\n    /**\r\n     * Block comment syntax\r\n     * @type {{ prefix: string, suffix: string }}\r\n     */\r\n    Language.prototype._blockCommentSyntax = null;\r\n    \r\n    /**\r\n     * Whether or not the language is binary\r\n     * @type {boolean}\r\n     */\r\n    Language.prototype._isBinary = false;\r\n    \r\n    /**\r\n     * Returns the identifier for this language.\r\n     * @return {string} The identifier\r\n     */\r\n    Language.prototype.getId = function () {\r\n        return this._id;\r\n    };\r\n    \r\n    /**\r\n     * Sets the identifier for this language or prints an error to the console.\r\n     * @param {!string} id Identifier for this language: lowercase letters, digits, and _ separators (e.g. "cpp", "foo_bar", "c99")\r\n     * @return {boolean} Whether the ID was valid and set or not\r\n     */\r\n    Language.prototype._setId = function (id) {\r\n        if (!_validateNonEmptyString(id, "Language ID")) {\r\n            return false;\r\n        }\r\n        // Make sure the ID is a string that can safely be used universally by the computer - as a file name, as an object key, as part of a URL, etc.\r\n        // Hence we use "_" instead of "." since the latter often has special meaning\r\n        if (!id.match(/^[a-z0-9]+(_[a-z0-9]+)*$/)) {\r\n            console.error("Invalid language ID \\"" + id + "\\": Only groups of lower case letters and numbers are allowed, separated by underscores.");\r\n            return false;\r\n        }\r\n        \r\n        this._id = id;\r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Returns the human-readable name of this language.\r\n     * @return {string} The name\r\n     */\r\n    Language.prototype.getName = function () {\r\n        return this._name;\r\n    };\r\n    \r\n    /**\r\n     * Sets the human-readable name of this language or prints an error to the console.\r\n     * @param {!string} name Human-readable name of the language, as it\'s commonly referred to (e.g. "C++")\r\n     * @return {boolean} Whether the name was valid and set or not\r\n     */\r\n    Language.prototype._setName = function (name) {\r\n        if (!_validateNonEmptyString(name, "name")) {\r\n            return false;\r\n        }\r\n        \r\n        this._name = name;\r\n        return true;\r\n    };\r\n    \r\n    /**\r\n     * Returns the CodeMirror mode for this language.\r\n     * @return {string} The mode\r\n     */\r\n    Language.prototype.getMode = function () {\r\n        return this._mode;\r\n    };\r\n    \r\n    /**\r\n     * Loads a mode and sets it for this language.\r\n     * \r\n     * @param {(string|Array.<string>)} mode  CodeMirror mode (e.g. "htmlmixed"), optionally paired with a MIME mode defined by\r\n     *      that mode (e.g. ["clike", "text/x-c++src"]). Unless the mode is located in thirdparty/CodeMirror2/mode/<name>/<name>.js,\r\n     *      you need to first load it yourself.\r\n     * @return {$.Promise} A promise object that will be resolved when the mode is loaded and set\r\n     */\r\n    Language.prototype._loadAndSetMode = function (mode) {\r\n        var result      = new $.Deferred(),\r\n            self        = this,\r\n            mimeMode; // Mode can be an array specifying a mode plus a MIME mode defined by that mode ["clike", "text/x-c++src"]\r\n        \r\n        if (Array.isArray(mode)) {\r\n            if (mode.length !== 2) {\r\n                result.reject("Mode must either be a string or an array containing two strings");\r\n                return result.promise();\r\n            }\r\n            mimeMode = mode[1];\r\n            mode = mode[0];\r\n        }\r\n        \r\n        // mode must not be empty. Use "null" (the string "null") mode for plain text\r\n        if (!_validateNonEmptyString(mode, "mode", result)) {\r\n            result.reject();\r\n            return result.promise();\r\n        }\r\n        \r\n        var finish = function () {\r\n            if (!CodeMirror.modes[mode]) {\r\n                result.reject("CodeMirror mode \\"" + mode + "\\" is not loaded");\r\n                return;\r\n            }\r\n            \r\n            if (mimeMode) {\r\n                var modeConfig = CodeMirror.mimeModes[mimeMode];\r\n                \r\n                if (!modeConfig) {\r\n                    result.reject("CodeMirror MIME mode \\"" + mimeMode + "\\" not found");\r\n                    return;\r\n                }\r\n            }\r\n            \r\n            // This mode is now only about what to tell CodeMirror\r\n            // The base mode was only necessary to load the proper mode file\r\n            self._mode = mimeMode || mode;\r\n            self._wasModified();\r\n            \r\n            result.resolve(self);\r\n        };\r\n        \r\n        if (CodeMirror.modes[mode]) {\r\n            finish();\r\n        } else {\r\n            require(["thirdparty/CodeMirror2/mode/" + mode + "/" + mode], finish);\r\n        }\r\n        \r\n        return result.promise();\r\n    };\r\n    \r\n    /**\r\n     * Returns an array of file extensions for this language.\r\n     * @return {Array.<string>} File extensions used by this language\r\n     */\r\n    Language.prototype.getFileExtensions = function () {\r\n        // Use concat to create a copy of this array, preventing external modification\r\n        return this._fileExtensions.concat();\r\n    };\r\n    \r\n    /**\r\n     * Returns an array of file names for extensionless files that use this language.\r\n     * @return {Array.<string>} Extensionless file names used by this language\r\n     */\r\n    Language.prototype.getFileNames = function () {\r\n        // Use concat to create a copy of this array, preventing external modification\r\n        return this._fileNames.concat();\r\n    };\r\n\r\n    /**\r\n     * Adds one or more file extensions to this language.\r\n     * @param {!string|Array.<string>} extension A file extension (or array thereof) used by this language\r\n     */\r\n    Language.prototype.addFileExtension = function (extension) {\r\n        if (Array.isArray(extension)) {\r\n            extension.forEach(this._addFileExtension.bind(this));\r\n        } else {\r\n            this._addFileExtension(extension);\r\n        }\r\n    };\r\n    Language.prototype._addFileExtension = function (extension) {\r\n        // Remove a leading dot if present\r\n        if (extension.charAt(0) === ".") {\r\n            extension = extension.substr(1);\r\n        }\r\n        \r\n        // Make checks below case-INsensitive\r\n        extension = extension.toLowerCase();\r\n        \r\n        if (this._fileExtensions.indexOf(extension) === -1) {\r\n            this._fileExtensions.push(extension);\r\n            \r\n            var language = _fileExtensionToLanguageMap[extension];\r\n            if (language) {\r\n                console.warn("Cannot register file extension \\"" + extension + "\\" for " + this._name + ", it already belongs to " + language._name);\r\n            } else {\r\n                _fileExtensionToLanguageMap[extension] = this;\r\n            }\r\n            \r\n            this._wasModified();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Unregisters one or more file extensions from this language.\r\n     * @param {!string|Array.<string>} extension File extension (or array thereof) to stop using for this language\r\n     */\r\n    Language.prototype.removeFileExtension = function (extension) {\r\n        if (Array.isArray(extension)) {\r\n            extension.forEach(this._removeFileExtension.bind(this));\r\n        } else {\r\n            this._removeFileExtension(extension);\r\n        }\r\n    };\r\n    Language.prototype._removeFileExtension = function (extension) {\r\n        // Remove a leading dot if present\r\n        if (extension.charAt(0) === ".") {\r\n            extension = extension.substr(1);\r\n        }\r\n        \r\n        // Make checks below case-INsensitive\r\n        extension = extension.toLowerCase();\r\n        \r\n        var index = this._fileExtensions.indexOf(extension);\r\n        if (index !== -1) {\r\n            this._fileExtensions.splice(index, 1);\r\n            \r\n            delete _fileExtensionToLanguageMap[extension];\r\n            \r\n            this._wasModified();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Adds one or more file names to the language which is used to match files that don\'t have extensions like "Makefile" for example.\r\n     * @param {!string|Array.<string>} extension An extensionless file name (or array thereof) used by this language\r\n     */\r\n    Language.prototype.addFileName = function (name) {\r\n        if (Array.isArray(name)) {\r\n            name.forEach(this._addFileName.bind(this));\r\n        } else {\r\n            this._addFileName(name);\r\n        }\r\n    };\r\n    Language.prototype._addFileName = function (name) {\r\n        // Make checks below case-INsensitive\r\n        name = name.toLowerCase();\r\n        \r\n        if (this._fileNames.indexOf(name) === -1) {\r\n            this._fileNames.push(name);\r\n            \r\n            var language = _fileNameToLanguageMap[name];\r\n            if (language) {\r\n                console.warn("Cannot register file name \\"" + name + "\\" for " + this._name + ", it already belongs to " + language._name);\r\n            } else {\r\n                _fileNameToLanguageMap[name] = this;\r\n            }\r\n            \r\n            this._wasModified();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Unregisters one or more file names from this language.\r\n     * @param {!string|Array.<string>} extension An extensionless file name (or array thereof) used by this language\r\n     */\r\n    Language.prototype.removeFileName = function (name) {\r\n        if (Array.isArray(name)) {\r\n            name.forEach(this._removeFileName.bind(this));\r\n        } else {\r\n            this._removeFileName(name);\r\n        }\r\n    };\r\n    Language.prototype._removeFileName = function (name) {\r\n        // Make checks below case-INsensitive\r\n        name = name.toLowerCase();\r\n        \r\n        var index = this._fileNames.indexOf(name);\r\n        if (index !== -1) {\r\n            this._fileNames.splice(index, 1);\r\n            \r\n            delete _fileNameToLanguageMap[name];\r\n            \r\n            this._wasModified();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns whether the line comment syntax is defined for this language.\r\n     * @return {boolean} Whether line comments are supported\r\n     */\r\n    Language.prototype.hasLineCommentSyntax = function () {\r\n        return this._lineCommentSyntax.length > 0;\r\n    };\r\n    \r\n    /**\r\n     * Returns an array of prefixes to use for line comments.\r\n     * @return {Array.<string>} The prefixes\r\n     */\r\n    Language.prototype.getLineCommentPrefixes = function () {\r\n        return this._lineCommentSyntax;\r\n    };\r\n\r\n    /**\r\n     * Sets the prefixes to use for line comments in this language or prints an error to the console.\r\n     * @param {!(string|Array.<string>)} prefix Prefix string or an array of prefix strings\r\n     *   to use for line comments (e.g. "//" or ["//", "#"])\r\n     * @return {boolean} Whether the syntax was valid and set or not\r\n     */\r\n    Language.prototype.setLineCommentSyntax = function (prefix) {\r\n        var prefixes = Array.isArray(prefix) ? prefix : [prefix];\r\n        var i;\r\n        \r\n        if (prefixes.length) {\r\n            this._lineCommentSyntax = [];\r\n            for (i = 0; i < prefixes.length; i++) {\r\n                _validateNonEmptyString(String(prefixes[i]), Array.isArray(prefix) ? "prefix[" + i + "]" : "prefix");\r\n                \r\n                this._lineCommentSyntax.push(prefixes[i]);\r\n            }\r\n            this._wasModified();\r\n        } else {\r\n            console.error("The prefix array should not be empty");\r\n        }\r\n        \r\n        return true;\r\n    };\r\n    \r\n    /**\r\n     * Returns whether the block comment syntax is defined for this language.\r\n     * @return {boolean} Whether block comments are supported\r\n     */\r\n    Language.prototype.hasBlockCommentSyntax = function () {\r\n        return Boolean(this._blockCommentSyntax);\r\n    };\r\n    \r\n    /**\r\n     * Returns the prefix to use for block comments.\r\n     * @return {string} The prefix\r\n     */\r\n    Language.prototype.getBlockCommentPrefix = function () {\r\n        return this._blockCommentSyntax && this._blockCommentSyntax.prefix;\r\n    };\r\n\r\n    /**\r\n     * Returns the suffix to use for block comments.\r\n     * @return {string} The suffix\r\n     */\r\n    Language.prototype.getBlockCommentSuffix = function () {\r\n        return this._blockCommentSyntax && this._blockCommentSyntax.suffix;\r\n    };\r\n    \r\n    /**\r\n     * Sets the prefix and suffix to use for blocks comments in this language or prints an error to the console.\r\n     * @param {!string} prefix Prefix string to use for block comments (e.g. "<!--")\r\n     * @param {!string} suffix Suffix string to use for block comments (e.g. "-->")\r\n     * @return {boolean} Whether the syntax was valid and set or not\r\n     */\r\n    Language.prototype.setBlockCommentSyntax = function (prefix, suffix) {\r\n        if (!_validateNonEmptyString(prefix, "prefix") || !_validateNonEmptyString(suffix, "suffix")) {\r\n            return false;\r\n        }\r\n        \r\n        this._blockCommentSyntax = { prefix: prefix, suffix: suffix };\r\n        this._wasModified();\r\n        \r\n        return true;\r\n    };\r\n    \r\n    /**\r\n     * Returns either a language associated with the mode or the fallback language.\r\n     * Used to disambiguate modes used by multiple languages.\r\n     * @param {!string} mode The mode to associate the language with\r\n     * @return {Language} This language if it uses the mode, or whatever {@link LanguageManager#_getLanguageForMode} returns\r\n     */\r\n    Language.prototype.getLanguageForMode = function (mode) {\r\n        if (mode === this._mode) {\r\n            return this;\r\n        }\r\n        return this._modeToLanguageMap[mode] || _getLanguageForMode(mode);\r\n    };\r\n\r\n    /**\r\n     * Overrides a mode-to-language association for this particular language only or prints an error to the console.\r\n     * Used to disambiguate modes used by multiple languages.\r\n     * @param {!string} mode The mode to associate the language with\r\n     * @param {!Language} language The language to associate with the mode\r\n     * @return {boolean} Whether the mode-to-language association was valid and set or not\r\n     * @private\r\n     */\r\n    Language.prototype._setLanguageForMode = function (mode, language) {\r\n        if (mode === this._mode && language !== this) {\r\n            console.error("A language must always map its mode to itself");\r\n            return false;\r\n        }\r\n        \r\n        this._modeToLanguageMap[mode] = language;\r\n        this._wasModified();\r\n        \r\n        return true;\r\n    };\r\n\r\n    /**\r\n     * Determines whether this is the fallback language or not\r\n     * @return {boolean} True if this is the fallback language, false otherwise\r\n     */\r\n    Language.prototype.isFallbackLanguage = function () {\r\n        return this === _fallbackLanguage;\r\n    };\r\n    \r\n    /**\r\n     * Trigger the "languageModified" event if this language is registered already\r\n     * @see _triggerLanguageModified\r\n     * @private\r\n     */\r\n    Language.prototype._wasModified = function () {\r\n        if (_languages[this._id]) {\r\n            _triggerLanguageModified(this);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Indicates whether or not the language is binary (e.g., image or audio).\r\n     * @return {boolean}\r\n     */\r\n    Language.prototype.isBinary = function () {\r\n        return this._isBinary;\r\n    };\r\n    \r\n    /**\r\n     * Sets whether or not the language is binary\r\n     * @param {!boolean} isBinary\r\n     */\r\n    Language.prototype._setBinary = function (isBinary) {\r\n        this._isBinary = isBinary;\r\n    };\r\n    \r\n    /**\r\n     * Defines a language.\r\n     *\r\n     * @param {!string}               id                        Unique identifier for this language: lowercase letters, digits, and _ separators (e.g. "cpp", "foo_bar", "c99")\r\n     * @param {!Object}               definition                An object describing the language\r\n     * @param {!string}               definition.name           Human-readable name of the language, as it\'s commonly referred to (e.g. "C++")\r\n     * @param {Array.<string>}        definition.fileExtensions List of file extensions used by this language (e.g. ["php", "php3"] or ["coffee.md"] - may contain dots)\r\n     * @param {Array.<string>}        definition.fileNames      List of exact file names (e.g. ["Makefile"] or ["package.json]). Higher precedence than file extension.\r\n     * @param {Array.<string>}        definition.blockComment   Array with two entries defining the block comment prefix and suffix (e.g. ["<!--", "-->"])\r\n     * @param {(string|Array.<string>)} definition.lineComment  Line comment prefixes (e.g. "//" or ["//", "#"])\r\n     * @param {(string|Array.<string>)} definition.mode         CodeMirror mode (e.g. "htmlmixed"), optionally with a MIME mode defined by that mode ["clike", "text/x-c++src"]\r\n     *                                                          Unless the mode is located in thirdparty/CodeMirror2/mode/<name>/<name>.js, you need to first load it yourself.\r\n     *\r\n     * @return {$.Promise} A promise object that will be resolved with a Language object\r\n     **/\r\n    function defineLanguage(id, definition) {\r\n        var result = new $.Deferred();\r\n        \r\n        if (_pendingLanguages[id]) {\r\n            result.reject("Language \\"" + id + "\\" is waiting to be resolved.");\r\n            return result.promise();\r\n        }\r\n        if (_languages[id]) {\r\n            result.reject("Language \\"" + id + "\\" is already defined");\r\n            return result.promise();\r\n        }\r\n\r\n        var language       = new Language(),\r\n            name           = definition.name,\r\n            fileExtensions = definition.fileExtensions,\r\n            fileNames      = definition.fileNames,\r\n            blockComment   = definition.blockComment,\r\n            lineComment    = definition.lineComment,\r\n            i,\r\n            l;\r\n        \r\n        function _finishRegisteringLanguage() {\r\n            if (fileExtensions) {\r\n                for (i = 0, l = fileExtensions.length; i < l; i++) {\r\n                    language.addFileExtension(fileExtensions[i]);\r\n                }\r\n            }\r\n            // register language file names after mode has loaded\r\n            if (fileNames) {\r\n                for (i = 0, l = fileNames.length; i < l; i++) {\r\n                    language.addFileName(fileNames[i]);\r\n                }\r\n            }\r\n            \r\n            language._setBinary(!!definition.isBinary);\r\n            \r\n            // store language to language map\r\n            _languages[language.getId()] = language;\r\n        }\r\n        \r\n        if (!language._setId(id) || !language._setName(name) ||\r\n                (blockComment && !language.setBlockCommentSyntax(blockComment[0], blockComment[1])) ||\r\n                (lineComment && !language.setLineCommentSyntax(lineComment))) {\r\n            result.reject();\r\n            return result.promise();\r\n        }\r\n\r\n        \r\n        if (definition.isBinary) {\r\n            // add file extensions and store language to language map\r\n            _finishRegisteringLanguage();\r\n            \r\n            result.resolve(language);\r\n            // Not notifying DocumentManager via event LanguageAdded, because DocumentManager\r\n            // does not care about binary files.\r\n        } else {\r\n            // track languages that are currently loading\r\n            _pendingLanguages[id] = language;\r\n            \r\n            language._loadAndSetMode(definition.mode).done(function () {\r\n  \r\n                // globally associate mode to language\r\n                _setLanguageForMode(language.getMode(), language);\r\n                \r\n                // add file extensions and store language to language map\r\n                _finishRegisteringLanguage();\r\n                \r\n                // fire an event to notify DocumentManager of the new language\r\n                _triggerLanguageAdded(language);\r\n                \r\n                result.resolve(language);\r\n            }).fail(function (error) {\r\n                console.error(error);\r\n                result.reject(error);\r\n            }).always(function () {\r\n                // delete from pending languages after success and failure\r\n                delete _pendingLanguages[id];\r\n            });\r\n        }\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * If a default file extension or name was overridden by a pref, restore it.\r\n     * \r\n     * @param {string} name Extension or filename that should be restored\r\n     * @param {{overridden: string, add: string}} prefState object for the pref that is currently being updated\r\n     */\r\n    function _restoreOverriddenDefault(name, state) {\r\n        if (state.overridden[name]) {\r\n            var language = getLanguage(state.overridden[name]);\r\n            language[state.add](name);\r\n            delete state.overridden[name];\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Updates extension and filename mappings from languages based on the current preferences values.\r\n     * \r\n     * The preferences look like this in a prefs file:\r\n     * \r\n     * Map *.foo to javascript, *.vm to html\r\n     * \r\n     *     "language.fileExtensions": {\r\n     *         "foo": "javascript",\r\n     *         "vm": "html"\r\n     *     }\r\n     * \r\n     * Map "Gemfile" to ruby:\r\n     * \r\n     *     "language.fileNames": {\r\n     *         "Gemfile": "ruby"\r\n     *     }\r\n     */\r\n    function _updateFromPrefs(pref) {\r\n        var newMapping = PreferencesManager.get(pref),\r\n            newNames = Object.keys(newMapping),\r\n            state = _prefState[pref],\r\n            last = state.last,\r\n            overridden = state.overridden;\r\n        \r\n        // Look for added and changed names (extensions or filenames)\r\n        newNames.forEach(function (name) {\r\n            var language;\r\n            if (newMapping[name] !== last[name]) {\r\n                if (last[name]) {\r\n                    language = getLanguage(last[name]);\r\n                    if (language) {\r\n                        language[state.remove](name);\r\n                        \r\n                        // If this name that was previously mapped was overriding a default\r\n                        // restore it now.\r\n                        _restoreOverriddenDefault(name, state);\r\n                    }\r\n                }\r\n                \r\n                language = exports[state.get](name);\r\n                if (language) {\r\n                    language[state.remove](name);\r\n                    \r\n                    // We\'re removing a name that was defined in Brackets or an extension,\r\n                    // so keep track of how it used to be mapped.\r\n                    if (!overridden[name]) {\r\n                        overridden[name] = language.getId();\r\n                    }\r\n                }\r\n                language = getLanguage(newMapping[name]);\r\n                if (language) {\r\n                    language[state.add](name);\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Look for removed names (extensions or filenames)\r\n        _.difference(Object.keys(last), newNames).forEach(function (name) {\r\n            var language = getLanguage(last[name]);\r\n            if (language) {\r\n                language[state.remove](name);\r\n                _restoreOverriddenDefault(name, state);\r\n            }\r\n        });\r\n        state.last = newMapping;\r\n    }\r\n    \r\n   \r\n    // Prevent modes from being overwritten by extensions\r\n    _patchCodeMirror();\r\n    \r\n    // Define a custom MIME mode here instead of putting it directly into languages.json\r\n    // because JSON files can\'t contain regular expressions. Also, all other modes so\r\n    // far were strings, so we spare us the trouble of allowing more complex mode values.\r\n    CodeMirror.defineMIME("text/x-brackets-html", {\r\n        "name": "htmlmixed",\r\n        "scriptTypes": [{"matches": /\\/x-handlebars|\\/x-mustache|^text\\/html$/i,\r\n                       "mode": null}]\r\n    });\r\n \r\n    // Load the default languages\r\n    _defaultLanguagesJSON = JSON.parse(_defaultLanguagesJSON);\r\n    _ready = Async.doInParallel(Object.keys(_defaultLanguagesJSON), function (key) {\r\n        return defineLanguage(key, _defaultLanguagesJSON[key]);\r\n    }, false);\r\n    \r\n    // Get the object for HTML\r\n    _ready.always(function () {\r\n        var html = getLanguage("html");\r\n        \r\n        // The htmlmixed mode uses the xml mode internally for the HTML parts, so we map it to HTML\r\n        html._setLanguageForMode("xml", html);\r\n        \r\n        // Currently we override the above mentioned "xml" in TokenUtils.getModeAt, instead returning "html".\r\n        // When the CSSInlineEditor and the hint providers are no longer based on modes, this can be changed.\r\n        // But for now, we need to associate this madeup "html" mode with our HTML language object.\r\n        _setLanguageForMode("html", html);\r\n        \r\n        // Similarly, the php mode uses clike internally for the PHP parts\r\n        var php = getLanguage("php");\r\n        php._setLanguageForMode("clike", php);\r\n\r\n        // Similar hack to the above for dealing with SCSS/CSS.\r\n        var scss = getLanguage("scss");\r\n        scss._setLanguageForMode("css", scss);\r\n        \r\n        // The fallback language for unknown modes and file extensions\r\n        _fallbackLanguage = getLanguage("unknown");\r\n        \r\n        // There is a circular dependency between FileUtils and LanguageManager which\r\n        // was introduced in 254b01e2f2eebea4416026d0f40d017b8ca6dbc9\r\n        // and may be preventing us from importing PreferencesManager (which also\r\n        // depends on FileUtils) here. Using the async form of require fixes this.\r\n        require(["preferences/PreferencesManager"], function (pm) {\r\n            PreferencesManager = pm;\r\n            pm.definePreference(_EXTENSION_MAP_PREF, "object", {}).on("change", function () {\r\n                _updateFromPrefs(_EXTENSION_MAP_PREF);\r\n            });\r\n            pm.definePreference(_NAME_MAP_PREF, "object", {}).on("change", function () {\r\n                _updateFromPrefs(_NAME_MAP_PREF);\r\n            });\r\n            _updateFromPrefs(_EXTENSION_MAP_PREF);\r\n            _updateFromPrefs(_NAME_MAP_PREF);\r\n        });\r\n    });\r\n    \r\n    // Private for unit tests\r\n    exports._EXTENSION_MAP_PREF         = _EXTENSION_MAP_PREF;\r\n    exports._NAME_MAP_PREF              = _NAME_MAP_PREF;\r\n    exports._resetPathLanguageOverrides = _resetPathLanguageOverrides;\r\n    \r\n    // Public methods\r\n    exports.ready                       = _ready;\r\n    exports.defineLanguage              = defineLanguage;\r\n    exports.getLanguage                 = getLanguage;\r\n    exports.getLanguageForExtension     = getLanguageForExtension;\r\n    exports.getLanguageForPath          = getLanguageForPath;\r\n    exports.getLanguages                = getLanguages;\r\n    exports.setLanguageOverrideForPath  = setLanguageOverrideForPath;\r\n});\r\n\n//# sourceURL=/language/LanguageManager.js'),eval('/*\r\n * jsTree 1.0-rc3\r\n * http://jstree.com/\r\n *\r\n * Copyright (c) 2010 Ivan Bozhanov (vakata.com)\r\n *\r\n * Licensed same as jquery - under the terms of either the MIT License or the GPL Version 2 License\r\n *   http://www.opensource.org/licenses/mit-license.php\r\n *   http://www.gnu.org/licenses/gpl.html\r\n *\r\n * $Date: 2011-02-09 01:17:14 +0200 (ср, 09 февр 2011) $\r\n * $Revision: 236 $\r\n */\r\n\r\n/*jslint browser: true, onevar: true, undef: true, bitwise: true, strict: true */\r\n/*global window : false, clearInterval: false, clearTimeout: false, document: false, setInterval: false, setTimeout: false, jQuery: false, navigator: false, XSLTProcessor: false, DOMParser: false, XMLSerializer: false*/\r\n\r\n"use strict";\r\n\r\n// top wrapper to prevent multiple inclusion (is this OK?)\r\n(function () { if(jQuery && jQuery.jstree) { return; }\r\n	var is_ie6 = false, is_ie7 = false, is_ff2 = false;\r\n\r\n/* \r\n * jsTree core\r\n */\r\n(function ($) {\r\n	// Common functions not related to jsTree \r\n	// decided to move them to a `vakata` "namespace"\r\n	$.vakata = {};\r\n	// CSS related functions\r\n	$.vakata.css = {\r\n		get_css : function(rule_name, delete_flag, sheet) {\r\n			rule_name = rule_name.toLowerCase();\r\n			var css_rules = sheet.cssRules || sheet.rules,\r\n				j = 0;\r\n			do {\r\n				if(css_rules.length && j > css_rules.length + 5) { return false; }\r\n				if(css_rules[j].selectorText && css_rules[j].selectorText.toLowerCase() == rule_name) {\r\n					if(delete_flag === true) {\r\n						if(sheet.removeRule) { sheet.removeRule(j); }\r\n						if(sheet.deleteRule) { sheet.deleteRule(j); }\r\n						return true;\r\n					}\r\n					else { return css_rules[j]; }\r\n				}\r\n			}\r\n			while (css_rules[++j]);\r\n			return false;\r\n		},\r\n		add_css : function(rule_name, sheet) {\r\n			if($.jstree.css.get_css(rule_name, false, sheet)) { return false; }\r\n			if(sheet.insertRule) { sheet.insertRule(rule_name + \' { }\', 0); } else { sheet.addRule(rule_name, null, 0); }\r\n			return $.vakata.css.get_css(rule_name);\r\n		},\r\n		remove_css : function(rule_name, sheet) { \r\n			return $.vakata.css.get_css(rule_name, true, sheet); \r\n		},\r\n		add_sheet : function(opts) {\r\n			var tmp = false, is_new = true;\r\n			if(opts.str) {\r\n				if(opts.title) { tmp = $("style[id=\'" + opts.title + "-stylesheet\']")[0]; }\r\n				if(tmp) { is_new = false; }\r\n				else {\r\n					tmp = document.createElement("style");\r\n					tmp.setAttribute(\'type\',"text/css");\r\n					if(opts.title) { tmp.setAttribute("id", opts.title + "-stylesheet"); }\r\n				}\r\n				if(tmp.styleSheet) {\r\n					if(is_new) { \r\n						document.getElementsByTagName("head")[0].appendChild(tmp); \r\n						tmp.styleSheet.cssText = opts.str; \r\n					}\r\n					else {\r\n						tmp.styleSheet.cssText = tmp.styleSheet.cssText + " " + opts.str; \r\n					}\r\n				}\r\n				else {\r\n					tmp.appendChild(document.createTextNode(opts.str));\r\n					document.getElementsByTagName("head")[0].appendChild(tmp);\r\n				}\r\n				return tmp.sheet || tmp.styleSheet;\r\n			}\r\n			if(opts.url) {\r\n				if(document.createStyleSheet) {\r\n					try { tmp = document.createStyleSheet(opts.url); } catch (e) { }\r\n				}\r\n				else {\r\n					tmp			= document.createElement(\'link\');\r\n					tmp.rel		= \'stylesheet\';\r\n					tmp.type	= \'text/css\';\r\n					tmp.media	= "all";\r\n					tmp.href	= opts.url;\r\n					document.getElementsByTagName("head")[0].appendChild(tmp);\r\n					return tmp.styleSheet;\r\n				}\r\n			}\r\n		}\r\n	};\r\n\r\n	// private variables \r\n	var instances = [],			// instance array (used by $.jstree.reference/create/focused)\r\n		focused_instance = -1,	// the index in the instance array of the currently focused instance\r\n		plugins = {},			// list of included plugins\r\n		prepared_move = {};		// for the move_node function\r\n\r\n	// jQuery plugin wrapper (thanks to jquery UI widget function)\r\n	$.fn.jstree = function (settings) {\r\n		var isMethodCall = (typeof settings == \'string\'), // is this a method call like $().jstree("open_node")\r\n			args = Array.prototype.slice.call(arguments, 1), \r\n			returnValue = this;\r\n\r\n		// if a method call execute the method on all selected instances\r\n		if(isMethodCall) {\r\n			if(settings.substring(0, 1) == \'_\') { return returnValue; }\r\n			this.each(function() {\r\n				var instance = instances[$.data(this, "jstree_instance_id")],\r\n					methodValue = (instance && $.isFunction(instance[settings])) ? instance[settings].apply(instance, args) : instance;\r\n					if(typeof methodValue !== "undefined" && (settings.indexOf("is_") === 0 || (methodValue !== true && methodValue !== false))) { returnValue = methodValue; return false; }\r\n			});\r\n		}\r\n		else {\r\n			this.each(function() {\r\n				// extend settings and allow for multiple hashes and $.data\r\n				var instance_id = $.data(this, "jstree_instance_id"),\r\n					a = [],\r\n					b = settings ? $.extend({}, true, settings) : {},\r\n					c = $(this), \r\n					s = false, \r\n					t = [];\r\n				a = a.concat(args);\r\n				if(c.data("jstree")) { a.push(c.data("jstree")); }\r\n				b = a.length ? $.extend.apply(null, [true, b].concat(a)) : b;\r\n\r\n				// if an instance already exists, destroy it first\r\n				if(typeof instance_id !== "undefined" && instances[instance_id]) { instances[instance_id].destroy(); }\r\n				// push a new empty object to the instances array\r\n				instance_id = parseInt(instances.push({}),10) - 1;\r\n				// store the jstree instance id to the container element\r\n				$.data(this, "jstree_instance_id", instance_id);\r\n				// clean up all plugins\r\n				b.plugins = $.isArray(b.plugins) ? b.plugins : $.jstree.defaults.plugins.slice();\r\n				b.plugins.unshift("core");\r\n				// only unique plugins\r\n				b.plugins = b.plugins.sort().join(",,").replace(/(,|^)([^,]+)(,,\\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");\r\n\r\n				// extend defaults with passed data\r\n				s = $.extend(true, {}, $.jstree.defaults, b);\r\n				s.plugins = b.plugins;\r\n				$.each(plugins, function (i, val) { \r\n					if($.inArray(i, s.plugins) === -1) { s[i] = null; delete s[i]; } \r\n					else { t.push(i); }\r\n				});\r\n				s.plugins = t;\r\n\r\n				// push the new object to the instances array (at the same time set the default classes to the container) and init\r\n				instances[instance_id] = new $.jstree._instance(instance_id, $(this).addClass("jstree jstree-" + instance_id), s); \r\n				// init all activated plugins for this instance\r\n				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { instances[instance_id].data[val] = {}; });\r\n				$.each(instances[instance_id]._get_settings().plugins, function (i, val) { if(plugins[val]) { plugins[val].__init.apply(instances[instance_id]); } });\r\n				// initialize the instance\r\n				setTimeout(function() { if(instances[instance_id]) { instances[instance_id].init(); } }, 0);\r\n			});\r\n		}\r\n		// return the jquery selection (or if it was a method call that returned a value - the returned value)\r\n		return returnValue;\r\n	};\r\n	// object to store exposed functions and objects\r\n	$.jstree = {\r\n		defaults : {\r\n			plugins : []\r\n		},\r\n		_focused : function () { return instances[focused_instance] || null; },\r\n		_reference : function (needle) { \r\n			// get by instance id\r\n			if(instances[needle]) { return instances[needle]; }\r\n			// get by DOM (if still no luck - return null\r\n			var o = $(needle); \r\n			if(!o.length && typeof needle === "string") { o = $("#" + needle); }\r\n			if(!o.length) { return null; }\r\n			return instances[o.closest(".jstree").data("jstree_instance_id")] || null; \r\n		},\r\n		_instance : function (index, container, settings) { \r\n			// for plugins to store data in\r\n			this.data = { core : {} };\r\n			this.get_settings	= function () { return $.extend(true, {}, settings); };\r\n			this._get_settings	= function () { return settings; };\r\n			this.get_index		= function () { return index; };\r\n			this.get_container	= function () { return container; };\r\n			this.get_container_ul = function () { return container.children("ul:eq(0)"); };\r\n			this._set_settings	= function (s) { \r\n				settings = $.extend(true, {}, settings, s);\r\n			};\r\n		},\r\n		_fn : { },\r\n		plugin : function (pname, pdata) {\r\n			pdata = $.extend({}, {\r\n				__init		: $.noop, \r\n				__destroy	: $.noop,\r\n				_fn			: {},\r\n				defaults	: false\r\n			}, pdata);\r\n			plugins[pname] = pdata;\r\n\r\n			$.jstree.defaults[pname] = pdata.defaults;\r\n			$.each(pdata._fn, function (i, val) {\r\n				val.plugin		= pname;\r\n				val.old			= $.jstree._fn[i];\r\n				$.jstree._fn[i] = function () {\r\n					var rslt,\r\n						func = val,\r\n						args = Array.prototype.slice.call(arguments),\r\n						evnt = new $.Event("before.jstree"),\r\n						rlbk = false;\r\n\r\n					if(this.data.core.locked === true && i !== "unlock" && i !== "is_locked") { return; }\r\n\r\n					// Check if function belongs to the included plugins of this instance\r\n					do {\r\n						if(func && func.plugin && $.inArray(func.plugin, this._get_settings().plugins) !== -1) { break; }\r\n						func = func.old;\r\n					} while(func);\r\n					if(!func) { return; }\r\n\r\n					// context and function to trigger events, then finally call the function\r\n					if(i.indexOf("_") === 0) {\r\n						rslt = func.apply(this, args);\r\n					}\r\n					else {\r\n						rslt = this.get_container().triggerHandler(evnt, { "func" : i, "inst" : this, "args" : args, "plugin" : func.plugin });\r\n						if(rslt === false) { return; }\r\n						if(typeof rslt !== "undefined") { args = rslt; }\r\n\r\n						rslt = func.apply(\r\n							$.extend({}, this, { \r\n								__callback : function (data) { \r\n									this.get_container().triggerHandler( i + \'.jstree\', { "inst" : this, "args" : args, "rslt" : data, "rlbk" : rlbk });\r\n								},\r\n								__rollback : function () { \r\n									rlbk = this.get_rollback();\r\n									return rlbk;\r\n								},\r\n								__call_old : function (replace_arguments) {\r\n									return func.old.apply(this, (replace_arguments ? Array.prototype.slice.call(arguments, 1) : args ) );\r\n								}\r\n							}), args);\r\n					}\r\n\r\n					// return the result\r\n					return rslt;\r\n				};\r\n				$.jstree._fn[i].old = val.old;\r\n				$.jstree._fn[i].plugin = pname;\r\n			});\r\n		},\r\n		rollback : function (rb) {\r\n			if(rb) {\r\n				if(!$.isArray(rb)) { rb = [ rb ]; }\r\n				$.each(rb, function (i, val) {\r\n					instances[val.i].set_rollback(val.h, val.d);\r\n				});\r\n			}\r\n		}\r\n	};\r\n	// set the prototype for all instances\r\n	$.jstree._fn = $.jstree._instance.prototype = {};\r\n\r\n	// load the css when DOM is ready\r\n	$(function() {\r\n		// code is copied from jQuery ($.browser is deprecated + there is a bug in IE)\r\n		var u = navigator.userAgent.toLowerCase(),\r\n			v = (u.match( /.+?(?:rv|it|ra|ie)[\\/: ]([\\d.]+)/ ) || [0,\'0\'])[1],\r\n			css_string = \'\' + \r\n				\'.jstree ul, .jstree li { display:block; margin:0 0 0 0; padding:0 0 0 0; list-style-type:none; } \' + \r\n				\'.jstree li { display:block; min-height:18px; line-height:18px; white-space:nowrap; margin-left:18px; min-width:18px; } \' + \r\n				\'.jstree-rtl li { margin-left:0; margin-right:18px; } \' + \r\n				\'.jstree > ul > li { margin-left:0px; } \' + \r\n				\'.jstree-rtl > ul > li { margin-right:0px; } \' + \r\n				\'.jstree ins { display:inline-block; text-decoration:none; width:18px; height:18px; margin:0 0 0 0; padding:0; } \' + \r\n				\'.jstree a { display:inline-block; line-height:16px; height:16px; color:black; white-space:nowrap; text-decoration:none; padding:1px 2px; margin:0; } \' + \r\n				\'.jstree a:focus { outline: none; } \' + \r\n				\'.jstree a > ins { height:16px; width:16px; } \' + \r\n				\'.jstree a > .jstree-icon { margin-right:3px; } \' + \r\n				\'.jstree-rtl a > .jstree-icon { margin-left:3px; margin-right:0; } \' + \r\n				\'li.jstree-open > ul { display:block; } \' + \r\n				\'li.jstree-closed > ul { display:none; } \';\r\n		// Correct IE 6 (does not support the > CSS selector)\r\n		if(/msie/.test(u) && parseInt(v, 10) == 6) { \r\n			is_ie6 = true;\r\n\r\n			// fix image flicker and lack of caching\r\n			try {\r\n				document.execCommand("BackgroundImageCache", false, true);\r\n			} catch (err) { }\r\n\r\n			css_string += \'\' + \r\n				\'.jstree li { height:18px; margin-left:0; margin-right:0; } \' + \r\n				\'.jstree li li { margin-left:18px; } \' + \r\n				\'.jstree-rtl li li { margin-left:0px; margin-right:18px; } \' + \r\n				\'li.jstree-open ul { display:block; } \' + \r\n				\'li.jstree-closed ul { display:none !important; } \' + \r\n				\'.jstree li a { display:inline; border-width:0 !important; padding:0px 2px !important; } \' + \r\n				\'.jstree li a ins { height:16px; width:16px; margin-right:3px; } \' + \r\n				\'.jstree-rtl li a ins { margin-right:0px; margin-left:3px; } \';\r\n		}\r\n		// Correct IE 7 (shifts anchor nodes onhover)\r\n		if(/msie/.test(u) && parseInt(v, 10) == 7) { \r\n			is_ie7 = true;\r\n			css_string += \'.jstree li a { border-width:0 !important; padding:0px 2px !important; } \';\r\n		}\r\n		// correct ff2 lack of display:inline-block\r\n		if(!/compatible/.test(u) && /mozilla/.test(u) && parseFloat(v, 10) < 1.9) {\r\n			is_ff2 = true;\r\n			css_string += \'\' + \r\n				\'.jstree ins { display:-moz-inline-box; } \' + \r\n				\'.jstree li { line-height:12px; } \' + // WHY??\r\n				\'.jstree a { display:-moz-inline-box; } \' + \r\n				\'.jstree .jstree-no-icons .jstree-checkbox { display:-moz-inline-stack !important; } \';\r\n				/* this shouldn\'t be here as it is theme specific */\r\n		}\r\n		// the default stylesheet\r\n		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });\r\n	});\r\n\r\n	// core functions (open, close, create, update, delete)\r\n	$.jstree.plugin("core", {\r\n		__init : function () {\r\n			this.data.core.locked = false;\r\n			this.data.core.to_open = this.get_settings().core.initially_open;\r\n			this.data.core.to_load = this.get_settings().core.initially_load;\r\n		},\r\n		defaults : { \r\n			html_titles	: false,\r\n			animation	: 500,\r\n			initially_open : [],\r\n			initially_load : [],\r\n			open_parents : true,\r\n			notify_plugins : true,\r\n			rtl			: false,\r\n			load_open	: false,\r\n			strings		: {\r\n				loading		: "Loading ...",\r\n				new_node	: "New node",\r\n				multiple_selection : "Multiple selection"\r\n			}\r\n		},\r\n		_fn : { \r\n			init	: function () { \r\n				this.set_focus(); \r\n				if(this._get_settings().core.rtl) {\r\n					this.get_container().addClass("jstree-rtl").css("direction", "rtl");\r\n				}\r\n				this.get_container().html("<ul><li class=\'jstree-last jstree-leaf\'><ins>&#160;</ins><a class=\'jstree-loading\' href=\'#\'><ins class=\'jstree-icon\'>&#160;</ins>" + this._get_string("loading") + "</a></li></ul>");\r\n				this.data.core.li_height = this.get_container_ul().find("li.jstree-closed, li.jstree-leaf").eq(0).height() || 18;\r\n\r\n				this.get_container()\r\n					.delegate("li > ins", "click.jstree", $.proxy(function (event) {\r\n							var trgt = $(event.target);\r\n							// if(trgt.is("ins") && event.pageY - trgt.offset().top < this.data.core.li_height) { this.toggle_node(trgt); }\r\n							this.toggle_node(trgt);\r\n						}, this))\r\n					.bind("mousedown.jstree", $.proxy(function () { \r\n							this.set_focus(); // This used to be setTimeout(set_focus,0) - why?\r\n						}, this))\r\n					.bind("dblclick.jstree", function (event) { \r\n						var sel;\r\n						if(document.selection && document.selection.empty) { document.selection.empty(); }\r\n						else {\r\n							if(window.getSelection) {\r\n								sel = window.getSelection();\r\n								try { \r\n									sel.removeAllRanges();\r\n									sel.collapse();\r\n								} catch (err) { }\r\n							}\r\n						}\r\n					});\r\n				if(this._get_settings().core.notify_plugins) {\r\n					this.get_container()\r\n						.bind("load_node.jstree", $.proxy(function (e, data) { \r\n								var o = this._get_node(data.rslt.obj),\r\n									t = this;\r\n								if(o === -1) { o = this.get_container_ul(); }\r\n								if(!o.length) { return; }\r\n								o.find("li").each(function () {\r\n									var th = $(this);\r\n									if(th.data("jstree")) {\r\n										$.each(th.data("jstree"), function (plugin, values) {\r\n											if(t.data[plugin] && $.isFunction(t["_" + plugin + "_notify"])) {\r\n												t["_" + plugin + "_notify"].call(t, th, values);\r\n											}\r\n										});\r\n									}\r\n								});\r\n							}, this));\r\n				}\r\n				if(this._get_settings().core.load_open) {\r\n					this.get_container()\r\n						.bind("load_node.jstree", $.proxy(function (e, data) { \r\n								var o = this._get_node(data.rslt.obj),\r\n									t = this;\r\n								if(o === -1) { o = this.get_container_ul(); }\r\n								if(!o.length) { return; }\r\n								o.find("li.jstree-open:not(:has(ul))").each(function () {\r\n									t.load_node(this, $.noop, $.noop);\r\n								});\r\n							}, this));\r\n				}\r\n				this.__callback();\r\n				this.load_node(-1, function () { this.loaded(); this.reload_nodes(); });\r\n			},\r\n			destroy	: function () { \r\n				var i,\r\n					n = this.get_index(),\r\n					s = this._get_settings(),\r\n					_this = this;\r\n\r\n				$.each(s.plugins, function (i, val) {\r\n					try { plugins[val].__destroy.apply(_this); } catch(err) { }\r\n				});\r\n				this.__callback();\r\n				// set focus to another instance if this one is focused\r\n				if(this.is_focused()) { \r\n					for(i in instances) { \r\n						if(instances.hasOwnProperty(i) && i != n) { \r\n							instances[i].set_focus(); \r\n							break; \r\n						} \r\n					}\r\n				}\r\n				// if no other instance found\r\n				if(n === focused_instance) { focused_instance = -1; }\r\n				// remove all traces of jstree in the DOM (only the ones set using jstree*) and cleans all events\r\n				this.get_container()\r\n					.unbind(".jstree")\r\n					.undelegate(".jstree")\r\n					.removeData("jstree_instance_id")\r\n					.find("[class^=\'jstree\']")\r\n						.addBack()\r\n						.attr("class", function () { return this.className.replace(/jstree[^ ]*|$/ig,\'\'); });\r\n				$(document)\r\n					.unbind(".jstree-" + n)\r\n					.undelegate(".jstree-" + n);\r\n				// remove the actual data\r\n				instances[n] = null;\r\n				delete instances[n];\r\n			},\r\n\r\n			_core_notify : function (n, data) {\r\n				if(data.opened) {\r\n					this.open_node(n, false, true);\r\n				}\r\n			},\r\n\r\n			lock : function () {\r\n				this.data.core.locked = true;\r\n				this.get_container().children("ul").addClass("jstree-locked").css("opacity","0.7");\r\n				this.__callback({});\r\n			},\r\n			unlock : function () {\r\n				this.data.core.locked = false;\r\n				this.get_container().children("ul").removeClass("jstree-locked").css("opacity","1");\r\n				this.__callback({});\r\n			},\r\n			is_locked : function () { return this.data.core.locked; },\r\n			save_opened : function () {\r\n				var _this = this;\r\n				this.data.core.to_open = [];\r\n				this.get_container_ul().find("li.jstree-open").each(function () { \r\n					if(this.id) { _this.data.core.to_open.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\\\\//g,"/").replace(/\\//g,"\\\\\\/").replace(/\\\\\\./g,".").replace(/\\./g,"\\\\.").replace(/\\:/g,"\\\\:")); }\r\n				});\r\n				this.__callback(_this.data.core.to_open);\r\n			},\r\n			save_loaded : function () { },\r\n			reload_nodes : function (is_callback) {\r\n				var _this = this,\r\n					done = true,\r\n					current = [],\r\n					remaining = [];\r\n				if(!is_callback) { \r\n					this.data.core.reopen = false; \r\n					this.data.core.refreshing = true; \r\n					this.data.core.to_open = $.map($.makeArray(this.data.core.to_open), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\\\\//g,"/").replace(/\\//g,"\\\\\\/").replace(/\\\\\\./g,".").replace(/\\./g,"\\\\.").replace(/\\:/g,"\\\\:"); });\r\n					this.data.core.to_load = $.map($.makeArray(this.data.core.to_load), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\\\\//g,"/").replace(/\\//g,"\\\\\\/").replace(/\\\\\\./g,".").replace(/\\./g,"\\\\.").replace(/\\:/g,"\\\\:"); });\r\n					if(this.data.core.to_open.length) {\r\n						this.data.core.to_load = this.data.core.to_load.concat(this.data.core.to_open);\r\n					}\r\n				}\r\n				if(this.data.core.to_load.length) {\r\n					$.each(this.data.core.to_load, function (i, val) {\r\n						if(val == "#") { return true; }\r\n						if($(val).length) { current.push(val); }\r\n						else { remaining.push(val); }\r\n					});\r\n					if(current.length) {\r\n						this.data.core.to_load = remaining;\r\n						$.each(current, function (i, val) { \r\n							if(!_this._is_loaded(val)) {\r\n								_this.load_node(val, function () { _this.reload_nodes(true); }, function () { _this.reload_nodes(true); });\r\n								done = false;\r\n							}\r\n						});\r\n					}\r\n				}\r\n				if(this.data.core.to_open.length) {\r\n					$.each(this.data.core.to_open, function (i, val) {\r\n						_this.open_node(val, false, true); \r\n					});\r\n				}\r\n				if(done) { \r\n					// TODO: find a more elegant approach to syncronizing returning requests\r\n					if(this.data.core.reopen) { clearTimeout(this.data.core.reopen); }\r\n					this.data.core.reopen = setTimeout(function () { _this.__callback({}, _this); }, 50);\r\n					this.data.core.refreshing = false;\r\n					this.reopen();\r\n				}\r\n			},\r\n			reopen : function () {\r\n				var _this = this;\r\n				if(this.data.core.to_open.length) {\r\n					$.each(this.data.core.to_open, function (i, val) {\r\n						_this.open_node(val, false, true); \r\n					});\r\n				}\r\n				this.__callback({});\r\n			},\r\n			refresh : function (obj) {\r\n				var _this = this;\r\n				this.save_opened();\r\n				if(!obj) { obj = -1; }\r\n				obj = this._get_node(obj);\r\n				if(!obj) { obj = -1; }\r\n				if(obj !== -1) { obj.children("UL").remove(); }\r\n				else { this.get_container_ul().empty(); }\r\n				this.load_node(obj, function () { _this.__callback({ "obj" : obj}); _this.reload_nodes(); });\r\n			},\r\n			// Dummy function to fire after the first load (so that there is a jstree.loaded event)\r\n			loaded	: function () { \r\n				this.__callback(); \r\n			},\r\n			// deal with focus\r\n			set_focus	: function () { \r\n				if(this.is_focused()) { return; }\r\n				var f = $.jstree._focused();\r\n				if(f) { f.unset_focus(); }\r\n\r\n				this.get_container().addClass("jstree-focused"); \r\n				focused_instance = this.get_index(); \r\n				this.__callback();\r\n			},\r\n			is_focused	: function () { \r\n				return focused_instance == this.get_index(); \r\n			},\r\n			unset_focus	: function () {\r\n				if(this.is_focused()) {\r\n					this.get_container().removeClass("jstree-focused"); \r\n					focused_instance = -1; \r\n				}\r\n				this.__callback();\r\n			},\r\n\r\n			// traverse\r\n			_get_node		: function (obj) { \r\n				var $obj = $(obj, this.get_container()); \r\n				if($obj.is(".jstree") || obj == -1) { return -1; } \r\n				$obj = $obj.closest("li", this.get_container()); \r\n				return $obj.length ? $obj : false; \r\n			},\r\n			_get_next		: function (obj, strict) {\r\n				obj = this._get_node(obj);\r\n				if(obj === -1) { return this.get_container().find("> ul > li:first-child"); }\r\n				if(!obj.length) { return false; }\r\n				if(strict) { return (obj.nextAll("li").length > 0) ? obj.nextAll("li:eq(0)") : false; }\r\n\r\n				if(obj.hasClass("jstree-open")) { return obj.find("li:eq(0)"); }\r\n				else if(obj.nextAll("li").length > 0) { return obj.nextAll("li:eq(0)"); }\r\n				else { return obj.parentsUntil(".jstree","li").next("li").eq(0); }\r\n			},\r\n			_get_prev		: function (obj, strict) {\r\n				obj = this._get_node(obj);\r\n				if(obj === -1) { return this.get_container().find("> ul > li:last-child"); }\r\n				if(!obj.length) { return false; }\r\n				if(strict) { return (obj.prevAll("li").length > 0) ? obj.prevAll("li:eq(0)") : false; }\r\n\r\n				if(obj.prev("li").length) {\r\n					obj = obj.prev("li").eq(0);\r\n					while(obj.hasClass("jstree-open")) { obj = obj.children("ul:eq(0)").children("li:last"); }\r\n					return obj;\r\n				}\r\n				else { var o = obj.parentsUntil(".jstree","li:eq(0)"); return o.length ? o : false; }\r\n			},\r\n			_get_parent		: function (obj) {\r\n				obj = this._get_node(obj);\r\n				if(obj == -1 || !obj.length) { return false; }\r\n				var o = obj.parentsUntil(".jstree", "li:eq(0)");\r\n				return o.length ? o : -1;\r\n			},\r\n			_get_children	: function (obj) {\r\n				obj = this._get_node(obj);\r\n				if(obj === -1) { return this.get_container().children("ul:eq(0)").children("li"); }\r\n				if(!obj.length) { return false; }\r\n				return obj.children("ul:eq(0)").children("li");\r\n			},\r\n			get_path		: function (obj, id_mode) {\r\n				var p = [],\r\n					_this = this;\r\n				obj = this._get_node(obj);\r\n				if(obj === -1 || !obj || !obj.length) { return false; }\r\n				obj.parentsUntil(".jstree", "li").each(function () {\r\n					p.push( id_mode ? this.id : _this.get_text(this) );\r\n				});\r\n				p.reverse();\r\n				p.push( id_mode ? obj.attr("id") : this.get_text(obj) );\r\n				return p;\r\n			},\r\n\r\n			// string functions\r\n			_get_string : function (key) {\r\n				return this._get_settings().core.strings[key] || key;\r\n			},\r\n\r\n			is_open		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-open"); },\r\n			is_closed	: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-closed"); },\r\n			is_leaf		: function (obj) { obj = this._get_node(obj); return obj && obj !== -1 && obj.hasClass("jstree-leaf"); },\r\n			correct_state	: function (obj) {\r\n				obj = this._get_node(obj);\r\n				if(!obj || obj === -1) { return false; }\r\n				obj.removeClass("jstree-closed jstree-open").addClass("jstree-leaf").children("ul").remove();\r\n				this.__callback({ "obj" : obj });\r\n			},\r\n			// open/close\r\n			open_node	: function (obj, callback, skip_animation) {\r\n				obj = this._get_node(obj);\r\n				if(!obj.length) { return false; }\r\n				if(!obj.hasClass("jstree-closed")) { if(callback) { callback.call(); } return false; }\r\n				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,\r\n					t = this;\r\n				if(!this._is_loaded(obj)) {\r\n					obj.children("a").addClass("jstree-loading");\r\n					this.load_node(obj, function () { t.open_node(obj, callback, skip_animation); }, callback);\r\n				}\r\n				else {\r\n					if(this._get_settings().core.open_parents) {\r\n						obj.parentsUntil(".jstree",".jstree-closed").each(function () {\r\n							t.open_node(this, false, true);\r\n						});\r\n					}\r\n					if(s) { obj.children("ul").css("display","none"); }\r\n					obj.removeClass("jstree-closed").addClass("jstree-open").children("a").removeClass("jstree-loading");\r\n					if(s) { obj.children("ul").stop(true, true).slideDown(s, function () { this.style.display = ""; t.after_open(obj); }); }\r\n					else { t.after_open(obj); }\r\n					this.__callback({ "obj" : obj });\r\n					if(callback) { callback.call(); }\r\n				}\r\n			},\r\n			after_open	: function (obj) { this.__callback({ "obj" : obj }); },\r\n			close_node	: function (obj, skip_animation) {\r\n				obj = this._get_node(obj);\r\n				var s = skip_animation || is_ie6 ? 0 : this._get_settings().core.animation,\r\n					t = this;\r\n				if(!obj.length || !obj.hasClass("jstree-open")) { return false; }\r\n				if(s) { obj.children("ul").attr("style","display:block !important"); }\r\n				obj.removeClass("jstree-open").addClass("jstree-closed");\r\n				if(s) { obj.children("ul").stop(true, true).slideUp(s, function () { this.style.display = ""; t.after_close(obj); }); }\r\n				else { t.after_close(obj); }\r\n				this.__callback({ "obj" : obj });\r\n			},\r\n			after_close	: function (obj) { this.__callback({ "obj" : obj }); },\r\n			toggle_node	: function (obj) {\r\n				obj = this._get_node(obj);\r\n				if(obj.hasClass("jstree-closed")) { return this.open_node(obj); }\r\n				if(obj.hasClass("jstree-open")) { return this.close_node(obj); }\r\n			},\r\n			open_all	: function (obj, do_animation, original_obj) {\r\n				obj = obj ? this._get_node(obj) : -1;\r\n				if(!obj || obj === -1) { obj = this.get_container_ul(); }\r\n				if(original_obj) { \r\n					obj = obj.find("li.jstree-closed");\r\n				}\r\n				else {\r\n					original_obj = obj;\r\n					if(obj.is(".jstree-closed")) { obj = obj.find("li.jstree-closed").addBack(); }\r\n					else { obj = obj.find("li.jstree-closed"); }\r\n				}\r\n				var _this = this;\r\n				obj.each(function () { \r\n					var __this = this; \r\n					if(!_this._is_loaded(this)) { _this.open_node(this, function() { _this.open_all(__this, do_animation, original_obj); }, !do_animation); }\r\n					else { _this.open_node(this, false, !do_animation); }\r\n				});\r\n				// so that callback is fired AFTER all nodes are open\r\n				if(original_obj.find(\'li.jstree-closed\').length === 0) { this.__callback({ "obj" : original_obj }); }\r\n			},\r\n			close_all	: function (obj, do_animation) {\r\n				var _this = this;\r\n				obj = obj ? this._get_node(obj) : this.get_container();\r\n				if(!obj || obj === -1) { obj = this.get_container_ul(); }\r\n				obj.find("li.jstree-open").addBack().each(function () { _this.close_node(this, !do_animation); });\r\n				this.__callback({ "obj" : obj });\r\n			},\r\n			clean_node	: function (obj) {\r\n				obj = obj && obj != -1 ? $(obj) : this.get_container_ul();\r\n				obj = obj.is("li") ? obj.find("li").addBack() : obj.find("li");\r\n				obj.removeClass("jstree-last")\r\n					.filter("li:last-child").addClass("jstree-last").end()\r\n					.filter(":has(li)")\r\n						.not(".jstree-open").removeClass("jstree-leaf").addClass("jstree-closed");\r\n				obj.not(".jstree-open, .jstree-closed").addClass("jstree-leaf").children("ul").remove();\r\n				this.__callback({ "obj" : obj });\r\n			},\r\n			// rollback\r\n			get_rollback : function () { \r\n				this.__callback();\r\n				return { i : this.get_index(), h : this.get_container().children("ul").clone(true), d : this.data }; \r\n			},\r\n			set_rollback : function (html, data) {\r\n				this.get_container().empty().append(html);\r\n				this.data = data;\r\n				this.__callback();\r\n			},\r\n			// Dummy functions to be overwritten by any datastore plugin included\r\n			load_node	: function (obj, s_call, e_call) { this.__callback({ "obj" : obj }); },\r\n			_is_loaded	: function (obj) { return true; },\r\n\r\n			// Basic operations: create\r\n			create_node	: function (obj, position, js, callback, is_loaded) {\r\n				obj = this._get_node(obj);\r\n				position = typeof position === "undefined" ? "last" : position;\r\n				var d = $("<li />"),\r\n					s = this._get_settings().core,\r\n					tmp;\r\n\r\n				if(obj !== -1 && !obj.length) { return false; }\r\n				if(!is_loaded && !this._is_loaded(obj)) { this.load_node(obj, function () { this.create_node(obj, position, js, callback, true); }); return false; }\r\n\r\n				this.__rollback();\r\n\r\n				if(typeof js === "string") { js = { "data" : js }; }\r\n				if(!js) { js = {}; }\r\n				if(js.attr) { d.attr(js.attr); }\r\n				if(js.metadata) { d.data(js.metadata); }\r\n				if(js.state) { d.addClass("jstree-" + js.state); }\r\n				if(!js.data) { js.data = this._get_string("new_node"); }\r\n				if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }\r\n				$.each(js.data, function (i, m) {\r\n					tmp = $("<a />");\r\n					if($.isFunction(m)) { m = m.call(this, js); }\r\n					if(typeof m == "string") { tmp.attr(\'href\',\'#\')[ s.html_titles ? "html" : "text" ](m); }\r\n					else {\r\n						if(!m.attr) { m.attr = {}; }\r\n						if(!m.attr.href) { m.attr.href = \'#\'; }\r\n						tmp.attr(m.attr)[ s.html_titles ? "html" : "text" ](m.title);\r\n						if(m.language) { tmp.addClass(m.language); }\r\n					}\r\n					tmp.prepend("<ins class=\'jstree-icon\'>&#160;</ins>");\r\n					if(!m.icon && js.icon) { m.icon = js.icon; }\r\n					if(m.icon) { \r\n						if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }\r\n						else { tmp.children("ins").css("background","url(\'" + m.icon + "\') center center no-repeat"); }\r\n					}\r\n					d.append(tmp);\r\n				});\r\n				d.prepend("<ins class=\'jstree-icon\'>&#160;</ins>");\r\n				if(obj === -1) {\r\n					obj = this.get_container();\r\n					if(position === "before") { position = "first"; }\r\n					if(position === "after") { position = "last"; }\r\n				}\r\n				switch(position) {\r\n					case "before": obj.before(d); tmp = this._get_parent(obj); break;\r\n					case "after" : obj.after(d);  tmp = this._get_parent(obj); break;\r\n					case "inside":\r\n					case "first" :\r\n						if(!obj.children("ul").length) { obj.append("<ul />"); }\r\n						obj.children("ul").prepend(d);\r\n						tmp = obj;\r\n						break;\r\n					case "last":\r\n						if(!obj.children("ul").length) { obj.append("<ul />"); }\r\n						obj.children("ul").append(d);\r\n						tmp = obj;\r\n						break;\r\n					default:\r\n						if(!obj.children("ul").length) { obj.append("<ul />"); }\r\n						if(!position) { position = 0; }\r\n						tmp = obj.children("ul").children("li").eq(position);\r\n						if(tmp.length) { tmp.before(d); }\r\n						else { obj.children("ul").append(d); }\r\n						tmp = obj;\r\n						break;\r\n				}\r\n				if(tmp === -1 || tmp.get(0) === this.get_container().get(0)) { tmp = -1; }\r\n				this.clean_node(tmp);\r\n				this.__callback({ "obj" : d, "parent" : tmp });\r\n				if(callback) { callback.call(this, d); }\r\n				return d;\r\n			},\r\n			// Basic operations: rename (deal with text)\r\n			get_text	: function (obj) {\r\n				obj = this._get_node(obj);\r\n				if(!obj.length) { return false; }\r\n				var s = this._get_settings().core.html_titles;\r\n				obj = obj.children("a:eq(0)");\r\n				if(s) {\r\n					obj = obj.clone();\r\n					obj.children("INS").remove();\r\n					return obj.html();\r\n				}\r\n				else {\r\n					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];\r\n					return obj.nodeValue;\r\n				}\r\n			},\r\n			set_text	: function (obj, val) {\r\n				obj = this._get_node(obj);\r\n				if(!obj.length) { return false; }\r\n				obj = obj.children("a:eq(0)");\r\n				if(this._get_settings().core.html_titles) {\r\n					var tmp = obj.children("INS").clone();\r\n					obj.html(val).prepend(tmp);\r\n					this.__callback({ "obj" : obj, "name" : val });\r\n					return true;\r\n				}\r\n				else {\r\n					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];\r\n					this.__callback({ "obj" : obj, "name" : val });\r\n					return (obj.nodeValue = val);\r\n				}\r\n			},\r\n			rename_node : function (obj, val) {\r\n				obj = this._get_node(obj);\r\n				this.__rollback();\r\n				if(obj && obj.length && this.set_text.apply(this, Array.prototype.slice.call(arguments))) { this.__callback({ "obj" : obj, "name" : val }); }\r\n			},\r\n			// Basic operations: deleting nodes\r\n			delete_node : function (obj) {\r\n				obj = this._get_node(obj);\r\n				if(!obj.length) { return false; }\r\n				this.__rollback();\r\n				var p = this._get_parent(obj), prev = $([]), t = this;\r\n				obj.each(function () {\r\n					prev = prev.add(t._get_prev(this));\r\n				});\r\n				obj = obj.detach();\r\n				if(p !== -1 && p.find("> ul > li").length === 0) {\r\n					p.removeClass("jstree-open jstree-closed").addClass("jstree-leaf");\r\n				}\r\n				this.clean_node(p);\r\n				this.__callback({ "obj" : obj, "prev" : prev, "parent" : p });\r\n				return obj;\r\n			},\r\n			prepare_move : function (o, r, pos, cb, is_cb) {\r\n				var p = {};\r\n\r\n				p.ot = $.jstree._reference(o) || this;\r\n				p.o = p.ot._get_node(o);\r\n				p.r = r === - 1 ? -1 : this._get_node(r);\r\n				p.p = (typeof pos === "undefined" || pos === false) ? "last" : pos; // TODO: move to a setting\r\n				if(!is_cb && prepared_move.o && prepared_move.o[0] === p.o[0] && prepared_move.r[0] === p.r[0] && prepared_move.p === p.p) {\r\n					this.__callback(prepared_move);\r\n					if(cb) { cb.call(this, prepared_move); }\r\n					return;\r\n				}\r\n				p.ot = $.jstree._reference(p.o) || this;\r\n				p.rt = $.jstree._reference(p.r) || this; // r === -1 ? p.ot : $.jstree._reference(p.r) || this\r\n				if(p.r === -1 || !p.r) {\r\n					p.cr = -1;\r\n					switch(p.p) {\r\n						case "first":\r\n						case "before":\r\n						case "inside":\r\n							p.cp = 0; \r\n							break;\r\n						case "after":\r\n						case "last":\r\n							p.cp = p.rt.get_container().find(" > ul > li").length; \r\n							break;\r\n						default:\r\n							p.cp = p.p;\r\n							break;\r\n					}\r\n				}\r\n				else {\r\n					if(!/^(before|after)$/.test(p.p) && !this._is_loaded(p.r)) {\r\n						return this.load_node(p.r, function () { this.prepare_move(o, r, pos, cb, true); });\r\n					}\r\n					switch(p.p) {\r\n						case "before":\r\n							p.cp = p.r.index();\r\n							p.cr = p.rt._get_parent(p.r);\r\n							break;\r\n						case "after":\r\n							p.cp = p.r.index() + 1;\r\n							p.cr = p.rt._get_parent(p.r);\r\n							break;\r\n						case "inside":\r\n						case "first":\r\n							p.cp = 0;\r\n							p.cr = p.r;\r\n							break;\r\n						case "last":\r\n							p.cp = p.r.find(" > ul > li").length; \r\n							p.cr = p.r;\r\n							break;\r\n						default: \r\n							p.cp = p.p;\r\n							p.cr = p.r;\r\n							break;\r\n					}\r\n				}\r\n				p.np = p.cr == -1 ? p.rt.get_container() : p.cr;\r\n				p.op = p.ot._get_parent(p.o);\r\n				p.cop = p.o.index();\r\n				if(p.op === -1) { p.op = p.ot ? p.ot.get_container() : this.get_container(); }\r\n				if(!/^(before|after)$/.test(p.p) && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp++; }\r\n				//if(p.p === "before" && p.op && p.np && p.op[0] === p.np[0] && p.o.index() < p.cp) { p.cp--; }\r\n				p.or = p.np.find(" > ul > li:nth-child(" + (p.cp + 1) + ")");\r\n				prepared_move = p;\r\n				this.__callback(prepared_move);\r\n				if(cb) { cb.call(this, prepared_move); }\r\n			},\r\n			check_move : function () {\r\n				var obj = prepared_move, ret = true, r = obj.r === -1 ? this.get_container() : obj.r;\r\n				if(!obj || !obj.o || obj.or[0] === obj.o[0]) { return false; }\r\n				if(obj.op && obj.np && obj.op[0] === obj.np[0] && obj.cp - 1 === obj.o.index()) { return false; }\r\n				obj.o.each(function () { \r\n					if(r.parentsUntil(".jstree", "li").addBack().index(this) !== -1) { ret = false; return false; }\r\n				});\r\n				return ret;\r\n			},\r\n			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {\r\n				if(!is_prepared) { \r\n					return this.prepare_move(obj, ref, position, function (p) {\r\n						this.move_node(p, false, false, is_copy, true, skip_check);\r\n					});\r\n				}\r\n				if(is_copy) { \r\n					prepared_move.cy = true;\r\n				}\r\n				if(!skip_check && !this.check_move()) { return false; }\r\n\r\n				this.__rollback();\r\n				var o = false;\r\n				if(is_copy) {\r\n					o = obj.o.clone(true);\r\n					o.find("*[id]").addBack().each(function () {\r\n						if(this.id) { this.id = "copy_" + this.id; }\r\n					});\r\n				}\r\n				else { o = obj.o; }\r\n\r\n				if(obj.or.length) { obj.or.before(o); }\r\n				else { \r\n					if(!obj.np.children("ul").length) { $("<ul />").appendTo(obj.np); }\r\n					obj.np.children("ul:eq(0)").append(o); \r\n				}\r\n\r\n				try { \r\n					obj.ot.clean_node(obj.op);\r\n					obj.rt.clean_node(obj.np);\r\n					if(!obj.op.find("> ul > li").length) {\r\n						obj.op.removeClass("jstree-open jstree-closed").addClass("jstree-leaf").children("ul").remove();\r\n					}\r\n				} catch (e) { }\r\n\r\n				if(is_copy) { \r\n					prepared_move.cy = true;\r\n					prepared_move.oc = o; \r\n				}\r\n				this.__callback(prepared_move);\r\n				return prepared_move;\r\n			},\r\n			_get_move : function () { return prepared_move; }\r\n		}\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/* \r\n * jsTree ui plugin\r\n * This plugins handles selecting/deselecting/hovering/dehovering nodes\r\n */\r\n(function ($) {\r\n	var scrollbar_width, e1, e2;\r\n	$(function() {\r\n		if (/msie/.test(navigator.userAgent.toLowerCase())) {\r\n			e1 = $(\'<textarea cols="10" rows="2"></textarea>\').css({ position: \'absolute\', top: -1000, left: 0 }).appendTo(\'body\');\r\n			e2 = $(\'<textarea cols="10" rows="2" style="overflow: hidden;"></textarea>\').css({ position: \'absolute\', top: -1000, left: 0 }).appendTo(\'body\');\r\n			scrollbar_width = e1.width() - e2.width();\r\n			e1.add(e2).remove();\r\n		} \r\n		else {\r\n			e1 = $(\'<div />\').css({ width: 100, height: 100, overflow: \'auto\', position: \'absolute\', top: -1000, left: 0 })\r\n					.prependTo(\'body\').append(\'<div />\').find(\'div\').css({ width: \'100%\', height: 200 });\r\n			scrollbar_width = 100 - e1.width();\r\n			e1.parent().remove();\r\n		}\r\n	});\r\n	$.jstree.plugin("ui", {\r\n		__init : function () { \r\n			this.data.ui.selected = $(); \r\n			this.data.ui.last_selected = false; \r\n			this.data.ui.hovered = null;\r\n			this.data.ui.to_select = this.get_settings().ui.initially_select;\r\n\r\n			this.get_container()\r\n				.delegate("a", "click.jstree", $.proxy(function (event) {\r\n						event.preventDefault();\r\n						event.currentTarget.blur();\r\n						if(!$(event.currentTarget).hasClass("jstree-loading")) {\r\n							this.select_node(event.currentTarget, true, event);\r\n						}\r\n					}, this))\r\n				.delegate("a", "mouseenter.jstree", $.proxy(function (event) {\r\n						if(!$(event.currentTarget).hasClass("jstree-loading")) {\r\n							this.hover_node(event.target);\r\n						}\r\n					}, this))\r\n				.delegate("a", "mouseleave.jstree", $.proxy(function (event) {\r\n						if(!$(event.currentTarget).hasClass("jstree-loading")) {\r\n							this.dehover_node(event.target);\r\n						}\r\n					}, this))\r\n				.bind("reopen.jstree", $.proxy(function () { \r\n						this.reselect();\r\n					}, this))\r\n				.bind("get_rollback.jstree", $.proxy(function () { \r\n						this.dehover_node();\r\n						this.save_selected();\r\n					}, this))\r\n				.bind("set_rollback.jstree", $.proxy(function () { \r\n						this.reselect();\r\n					}, this))\r\n				.bind("close_node.jstree", $.proxy(function (event, data) { \r\n						var s = this._get_settings().ui,\r\n							obj = this._get_node(data.rslt.obj),\r\n							clk = (obj && obj.length) ? obj.children("ul").find("a.jstree-clicked") : $(),\r\n							_this = this;\r\n						if(s.selected_parent_close === false || !clk.length) { return; }\r\n						clk.each(function () { \r\n							_this.deselect_node(this);\r\n							if(s.selected_parent_close === "select_parent") { _this.select_node(obj); }\r\n						});\r\n					}, this))\r\n				.bind("delete_node.jstree", $.proxy(function (event, data) { \r\n						var s = this._get_settings().ui.select_prev_on_delete,\r\n							obj = this._get_node(data.rslt.obj),\r\n							clk = (obj && obj.length) ? obj.find("a.jstree-clicked") : [],\r\n							_this = this;\r\n						clk.each(function () { _this.deselect_node(this); });\r\n						if(s && clk.length) { \r\n							data.rslt.prev.each(function () { \r\n								if(this.parentNode) { _this.select_node(this); return false; /* if return false is removed all prev nodes will be selected */}\r\n							});\r\n						}\r\n					}, this))\r\n				.bind("move_node.jstree", $.proxy(function (event, data) { \r\n						if(data.rslt.cy) { \r\n							data.rslt.oc.find("a.jstree-clicked").removeClass("jstree-clicked");\r\n						}\r\n					}, this));\r\n		},\r\n		defaults : {\r\n			select_limit : -1, // 0, 1, 2 ... or -1 for unlimited\r\n			select_multiple_modifier : "ctrl", // on, or ctrl, shift, alt\r\n			select_range_modifier : "shift",\r\n			selected_parent_close : "select_parent", // false, "deselect", "select_parent"\r\n			selected_parent_open : true,\r\n			select_prev_on_delete : true,\r\n			disable_selecting_children : false,\r\n			initially_select : []\r\n		},\r\n		_fn : { \r\n			_get_node : function (obj, allow_multiple) {\r\n				if(typeof obj === "undefined" || obj === null) { return allow_multiple ? this.data.ui.selected : this.data.ui.last_selected; }\r\n				var $obj = $(obj, this.get_container()); \r\n				if($obj.is(".jstree") || obj == -1) { return -1; } \r\n				$obj = $obj.closest("li", this.get_container()); \r\n				return $obj.length ? $obj : false; \r\n			},\r\n			_ui_notify : function (n, data) {\r\n				if(data.selected) {\r\n					this.select_node(n, false);\r\n				}\r\n			},\r\n			save_selected : function () {\r\n				var _this = this;\r\n				this.data.ui.to_select = [];\r\n				this.data.ui.selected.each(function () { if(this.id) { _this.data.ui.to_select.push("#" + this.id.toString().replace(/^#/,"").replace(/\\\\\\//g,"/").replace(/\\//g,"\\\\\\/").replace(/\\\\\\./g,".").replace(/\\./g,"\\\\.").replace(/\\:/g,"\\\\:")); } });\r\n				this.__callback(this.data.ui.to_select);\r\n			},\r\n			reselect : function () {\r\n				var _this = this,\r\n					s = this.data.ui.to_select;\r\n				s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\\\\//g,"/").replace(/\\//g,"\\\\\\/").replace(/\\\\\\./g,".").replace(/\\./g,"\\\\.").replace(/\\:/g,"\\\\:"); });\r\n				// this.deselect_all(); WHY deselect, breaks plugin state notifier?\r\n				$.each(s, function (i, val) { if(val && val !== "#") { _this.select_node(val); } });\r\n				this.data.ui.selected = this.data.ui.selected.filter(function () { return this.parentNode; });\r\n				this.__callback();\r\n			},\r\n			refresh : function (obj) {\r\n				this.save_selected();\r\n				return this.__call_old();\r\n			},\r\n			hover_node : function (obj) {\r\n				obj = this._get_node(obj);\r\n				if(!obj.length) { return false; }\r\n				//if(this.data.ui.hovered && obj.get(0) === this.data.ui.hovered.get(0)) { return; }\r\n				if(!obj.hasClass("jstree-hovered")) { this.dehover_node(); }\r\n				this.data.ui.hovered = obj.children("a").addClass("jstree-hovered").parent();\r\n				// brackets: jstree uses default scroll bar widths, and there\'s no clean way to override the code from brackets, which causes continuous scrolling, so just disable for now\r\n				//this._fix_scroll(obj);\r\n				this.__callback({ "obj" : obj });\r\n			},\r\n			dehover_node : function () {\r\n				var obj = this.data.ui.hovered, p;\r\n				if(!obj || !obj.length) { return false; }\r\n				p = obj.children("a").removeClass("jstree-hovered").parent();\r\n				if(this.data.ui.hovered[0] === p[0]) { this.data.ui.hovered = null; }\r\n				this.__callback({ "obj" : obj });\r\n			},\r\n			select_node : function (obj, check, e) {\r\n				obj = this._get_node(obj);\r\n				if(obj == -1 || !obj || !obj.length) { return false; }\r\n				var s = this._get_settings().ui,\r\n					is_multiple = (s.select_multiple_modifier == "on" || (s.select_multiple_modifier !== false && e && e[s.select_multiple_modifier + "Key"])),\r\n					is_range = (s.select_range_modifier !== false && e && e[s.select_range_modifier + "Key"] && this.data.ui.last_selected && this.data.ui.last_selected[0] !== obj[0] && this.data.ui.last_selected.parent()[0] === obj.parent()[0]),\r\n					is_selected = this.is_selected(obj),\r\n					proceed = true,\r\n					t = this;\r\n				if(check) {\r\n					if(s.disable_selecting_children && is_multiple && \r\n						(\r\n							(obj.parentsUntil(".jstree","li").children("a.jstree-clicked").length) ||\r\n							(obj.children("ul").find("a.jstree-clicked:eq(0)").length)\r\n						)\r\n					) {\r\n						return false;\r\n					}\r\n					proceed = false;\r\n					switch(!0) {\r\n						case (is_range):\r\n							this.data.ui.last_selected.addClass("jstree-last-selected");\r\n							obj = obj[ obj.index() < this.data.ui.last_selected.index() ? "nextUntil" : "prevUntil" ](".jstree-last-selected").addBack();\r\n							if(s.select_limit == -1 || obj.length < s.select_limit) {\r\n								this.data.ui.last_selected.removeClass("jstree-last-selected");\r\n								this.data.ui.selected.each(function () {\r\n									if(this !== t.data.ui.last_selected[0]) { t.deselect_node(this); }\r\n								});\r\n								is_selected = false;\r\n								proceed = true;\r\n							}\r\n							else {\r\n								proceed = false;\r\n							}\r\n							break;\r\n						case (is_selected && !is_multiple): \r\n							this.deselect_all();\r\n							is_selected = false;\r\n							proceed = true;\r\n							break;\r\n						case (!is_selected && !is_multiple): \r\n							if(s.select_limit == -1 || s.select_limit > 0) {\r\n								this.deselect_all();\r\n								proceed = true;\r\n							}\r\n							break;\r\n						case (is_selected && is_multiple): \r\n							this.deselect_node(obj);\r\n							break;\r\n						case (!is_selected && is_multiple): \r\n							if(s.select_limit == -1 || this.data.ui.selected.length + 1 <= s.select_limit) { \r\n								proceed = true;\r\n							}\r\n							break;\r\n					}\r\n				}\r\n				if(proceed && !is_selected) {\r\n					if(!is_range) { this.data.ui.last_selected = obj; }\r\n					obj.children("a").addClass("jstree-clicked");\r\n					if(s.selected_parent_open) {\r\n						obj.parents(".jstree-closed").each(function () { t.open_node(this, false, true); });\r\n					}\r\n					this.data.ui.selected = this.data.ui.selected.add(obj);\r\n					this._fix_scroll(obj.eq(0));\r\n					this.__callback({ "obj" : obj, "e" : e });\r\n				}\r\n			},\r\n			_fix_scroll : function (obj) {\r\n				var c = this.get_container()[0], t;\r\n				if(c.scrollHeight > c.offsetHeight) {\r\n					obj = this._get_node(obj);\r\n					if(!obj || obj === -1 || !obj.length || !obj.is(":visible")) { return; }\r\n					t = obj.offset().top - this.get_container().offset().top;\r\n					if(t < 0) { \r\n						c.scrollTop = c.scrollTop + t - 1; \r\n					}\r\n					if(t + this.data.core.li_height + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0) > c.offsetHeight) { \r\n						c.scrollTop = c.scrollTop + (t - c.offsetHeight + this.data.core.li_height + 1 + (c.scrollWidth > c.offsetWidth ? scrollbar_width : 0)); \r\n					}\r\n				}\r\n			},\r\n			deselect_node : function (obj) {\r\n				obj = this._get_node(obj);\r\n				if(!obj.length) { return false; }\r\n				if(this.is_selected(obj)) {\r\n					obj.children("a").removeClass("jstree-clicked");\r\n					this.data.ui.selected = this.data.ui.selected.not(obj);\r\n					if(this.data.ui.last_selected.get(0) === obj.get(0)) { this.data.ui.last_selected = this.data.ui.selected.eq(0); }\r\n					this.__callback({ "obj" : obj });\r\n				}\r\n			},\r\n			toggle_select : function (obj) {\r\n				obj = this._get_node(obj);\r\n				if(!obj.length) { return false; }\r\n				if(this.is_selected(obj)) { this.deselect_node(obj); }\r\n				else { this.select_node(obj); }\r\n			},\r\n			is_selected : function (obj) { return this.data.ui.selected.index(this._get_node(obj)) >= 0; },\r\n			get_selected : function (context) { \r\n				return context ? $(context).find("a.jstree-clicked").parent() : this.data.ui.selected; \r\n			},\r\n			deselect_all : function (context) {\r\n				var ret = context ? $(context).find("a.jstree-clicked").parent() : this.get_container().find("a.jstree-clicked").parent();\r\n				ret.children("a.jstree-clicked").removeClass("jstree-clicked");\r\n				this.data.ui.selected = $([]);\r\n				this.data.ui.last_selected = false;\r\n				this.__callback({ "obj" : ret });\r\n			}\r\n		}\r\n	});\r\n	// include the selection plugin by default\r\n	$.jstree.defaults.plugins.push("ui");\r\n})(jQuery);\r\n//*/\r\n\r\n/* \r\n * jsTree CRRM plugin\r\n * Handles creating/renaming/removing/moving nodes by user interaction.\r\n */\r\n(function ($) {\r\n	$.jstree.plugin("crrm", { \r\n		__init : function () {\r\n			this.get_container()\r\n				.bind("move_node.jstree", $.proxy(function (e, data) {\r\n					if(this._get_settings().crrm.move.open_onmove) {\r\n						var t = this;\r\n						data.rslt.np.parentsUntil(".jstree").addBack().filter(".jstree-closed").each(function () {\r\n							t.open_node(this, false, true);\r\n						});\r\n					}\r\n				}, this));\r\n		},\r\n		defaults : {\r\n			input_width_limit : 200,\r\n			move : {\r\n				always_copy			: false, // false, true or "multitree"\r\n				open_onmove			: true,\r\n				default_position	: "last",\r\n				check_move			: function (m) { return true; }\r\n			}\r\n		},\r\n		_fn : {\r\n			_show_input : function (obj, callback) {\r\n				obj = this._get_node(obj);\r\n				var rtl = this._get_settings().core.rtl,\r\n					w = this._get_settings().crrm.input_width_limit,\r\n					w1 = obj.children("ins").width(),\r\n					w2 = obj.find("> a:visible > ins").width() * obj.find("> a:visible > ins").length,\r\n					t = this.get_text(obj),\r\n					h1 = $("<div />", { css : { "position" : "absolute", "top" : "-200px", "left" : (rtl ? "0px" : "-1000px"), "visibility" : "hidden" } }).appendTo("body"),\r\n					h2 = obj.css("position","relative").append(\r\n					$("<input />", { \r\n						"value" : t,\r\n						"class" : "jstree-rename-input",\r\n						// "size" : t.length,\r\n						"css" : {\r\n							"right" : (rtl ? (w1 + w2 + 4) + "px" : "auto"),\r\n							"height" : (this.data.core.li_height - 2) + "px",\r\n							"lineHeight" : (this.data.core.li_height - 2) + "px",\r\n						},\r\n						"blur" : $.proxy(function () {\r\n							var i = obj.children(".jstree-rename-input"),\r\n								v = i.val();\r\n							if(v === "") { v = t; }\r\n							h1.remove();\r\n							i.remove(); // rollback purposes\r\n							this.set_text(obj,t); // rollback purposes\r\n							this.rename_node(obj, v);\r\n							callback.call(this, obj, v, t);\r\n							obj.css("position","");\r\n						}, this),\r\n						"keyup" : function (event) {\r\n							var key = event.keyCode || event.which;\r\n							if(key == 27) { this.value = t; this.blur(); return; }\r\n							else if(key == 13) { this.blur(); return; }\r\n							else {\r\n								h2.width(Math.min(h1.text("pW" + this.value).width(),w));\r\n							}\r\n						},\r\n						"keypress" : function(event) {\r\n							var key = event.keyCode || event.which;\r\n							if(key == 13) { return false; }\r\n						}\r\n					})\r\n				).children(".jstree-rename-input"); \r\n				this.set_text(obj, "");\r\n				h1.css({\r\n						fontFamily		: h2.css(\'fontFamily\')		|| \'\',\r\n						fontSize		: h2.css(\'fontSize\')		|| \'\',\r\n						fontWeight		: h2.css(\'fontWeight\')		|| \'\',\r\n						fontStyle		: h2.css(\'fontStyle\')		|| \'\',\r\n						fontStretch		: h2.css(\'fontStretch\')		|| \'\',\r\n						fontVariant		: h2.css(\'fontVariant\')		|| \'\',\r\n						letterSpacing	: h2.css(\'letterSpacing\')	|| \'\',\r\n						wordSpacing		: h2.css(\'wordSpacing\')		|| \'\'\r\n				});\r\n				h2.width(Math.min(h1.text("pW" + h2[0].value).width(),w))[0].select();\r\n			},\r\n			rename : function (obj) {\r\n				obj = this._get_node(obj);\r\n				this.__rollback();\r\n				var f = this.__callback;\r\n				this._show_input(obj, function (obj, new_name, old_name) { \r\n					f.call(this, { "obj" : obj, "new_name" : new_name, "old_name" : old_name });\r\n				});\r\n			},\r\n			create : function (obj, position, js, callback, skip_rename) {\r\n				var t, _this = this;\r\n				obj = this._get_node(obj);\r\n				if(!obj) { obj = -1; }\r\n				this.__rollback();\r\n				t = this.create_node(obj, position, js, function (t) {\r\n					var p = this._get_parent(t),\r\n						pos = $(t).index();\r\n					if(callback) { callback.call(this, t); }\r\n					if(p.length && p.hasClass("jstree-closed")) { this.open_node(p, false, true); }\r\n					if(!skip_rename) { \r\n						this._show_input(t, function (obj, new_name, old_name) { \r\n							_this.__callback({ "obj" : obj, "name" : new_name, "parent" : p, "position" : pos });\r\n						});\r\n					}\r\n					else { _this.__callback({ "obj" : t, "name" : this.get_text(t), "parent" : p, "position" : pos }); }\r\n				});\r\n				return t;\r\n			},\r\n			remove : function (obj) {\r\n				obj = this._get_node(obj, true);\r\n				var p = this._get_parent(obj), prev = this._get_prev(obj);\r\n				this.__rollback();\r\n				obj = this.delete_node(obj);\r\n				if(obj !== false) { this.__callback({ "obj" : obj, "prev" : prev, "parent" : p }); }\r\n			},\r\n			check_move : function () {\r\n				if(!this.__call_old()) { return false; }\r\n				var s = this._get_settings().crrm.move;\r\n				if(!s.check_move.call(this, this._get_move())) { return false; }\r\n				return true;\r\n			},\r\n			move_node : function (obj, ref, position, is_copy, is_prepared, skip_check) {\r\n				var s = this._get_settings().crrm.move;\r\n				if(!is_prepared) { \r\n					if(typeof position === "undefined") { position = s.default_position; }\r\n					if(position === "inside" && !s.default_position.match(/^(before|after)$/)) { position = s.default_position; }\r\n					return this.__call_old(true, obj, ref, position, is_copy, false, skip_check);\r\n				}\r\n				// if the move is already prepared\r\n				if(s.always_copy === true || (s.always_copy === "multitree" && obj.rt.get_index() !== obj.ot.get_index() )) {\r\n					is_copy = true;\r\n				}\r\n				this.__call_old(true, obj, ref, position, is_copy, true, skip_check);\r\n			},\r\n\r\n			cut : function (obj) {\r\n				obj = this._get_node(obj, true);\r\n				if(!obj || !obj.length) { return false; }\r\n				this.data.crrm.cp_nodes = false;\r\n				this.data.crrm.ct_nodes = obj;\r\n				this.__callback({ "obj" : obj });\r\n			},\r\n			copy : function (obj) {\r\n				obj = this._get_node(obj, true);\r\n				if(!obj || !obj.length) { return false; }\r\n				this.data.crrm.ct_nodes = false;\r\n				this.data.crrm.cp_nodes = obj;\r\n				this.__callback({ "obj" : obj });\r\n			},\r\n			paste : function (obj) { \r\n				obj = this._get_node(obj);\r\n				if(!obj || !obj.length) { return false; }\r\n				var nodes = this.data.crrm.ct_nodes ? this.data.crrm.ct_nodes : this.data.crrm.cp_nodes;\r\n				if(!this.data.crrm.ct_nodes && !this.data.crrm.cp_nodes) { return false; }\r\n				if(this.data.crrm.ct_nodes) { this.move_node(this.data.crrm.ct_nodes, obj); this.data.crrm.ct_nodes = false; }\r\n				if(this.data.crrm.cp_nodes) { this.move_node(this.data.crrm.cp_nodes, obj, false, true); }\r\n				this.__callback({ "obj" : obj, "nodes" : nodes });\r\n			}\r\n		}\r\n	});\r\n	// include the crr plugin by default\r\n	// $.jstree.defaults.plugins.push("crrm");\r\n})(jQuery);\r\n//*/\r\n\r\n/* \r\n * jsTree themes plugin\r\n * Handles loading and setting themes, as well as detecting path to themes, etc.\r\n */\r\n(function ($) {\r\n	var themes_loaded = [];\r\n	// this variable stores the path to the themes folder - if left as false - it will be autodetected\r\n	$.jstree._themes = false;\r\n	$.jstree.plugin("themes", {\r\n		__init : function () { \r\n			this.get_container()\r\n				.bind("init.jstree", $.proxy(function () {\r\n						var s = this._get_settings().themes;\r\n						this.data.themes.dots = s.dots; \r\n						this.data.themes.icons = s.icons; \r\n						this.set_theme(s.theme, s.url);\r\n					}, this))\r\n				.bind("loaded.jstree", $.proxy(function () {\r\n						// bound here too, as simple HTML tree\'s won\'t honor dots & icons otherwise\r\n						if(!this.data.themes.dots) { this.hide_dots(); }\r\n						else { this.show_dots(); }\r\n						if(!this.data.themes.icons) { this.hide_icons(); }\r\n						else { this.show_icons(); }\r\n					}, this));\r\n		},\r\n		defaults : { \r\n			theme : "default", \r\n			url : false,\r\n			dots : true,\r\n			icons : true\r\n		},\r\n		_fn : {\r\n			set_theme : function (theme_name, theme_url) {\r\n				if(!theme_name) { return false; }\r\n				if(!theme_url) { theme_url = $.jstree._themes + theme_name + \'/style.css\'; }\r\n				if($.inArray(theme_url, themes_loaded) == -1) {\r\n					$.vakata.css.add_sheet({ "url" : theme_url });\r\n					themes_loaded.push(theme_url);\r\n				}\r\n				if(this.data.themes.theme != theme_name) {\r\n					this.get_container().removeClass(\'jstree-\' + this.data.themes.theme);\r\n					this.data.themes.theme = theme_name;\r\n				}\r\n				this.get_container().addClass(\'jstree-\' + theme_name);\r\n				if(!this.data.themes.dots) { this.hide_dots(); }\r\n				else { this.show_dots(); }\r\n				if(!this.data.themes.icons) { this.hide_icons(); }\r\n				else { this.show_icons(); }\r\n				this.__callback();\r\n			},\r\n			get_theme	: function () { return this.data.themes.theme; },\r\n\r\n			show_dots	: function () { this.data.themes.dots = true; this.get_container().children("ul").removeClass("jstree-no-dots"); },\r\n			hide_dots	: function () { this.data.themes.dots = false; this.get_container().children("ul").addClass("jstree-no-dots"); },\r\n			toggle_dots	: function () { if(this.data.themes.dots) { this.hide_dots(); } else { this.show_dots(); } },\r\n\r\n			show_icons	: function () { this.data.themes.icons = true; this.get_container().children("ul").removeClass("jstree-no-icons"); },\r\n			hide_icons	: function () { this.data.themes.icons = false; this.get_container().children("ul").addClass("jstree-no-icons"); },\r\n			toggle_icons: function () { if(this.data.themes.icons) { this.hide_icons(); } else { this.show_icons(); } }\r\n		}\r\n	});\r\n	// autodetect themes path\r\n	$(function () {\r\n		if($.jstree._themes === false) {\r\n			$("script").each(function () { \r\n				if(this.src.toString().match(/jquery\\.jstree[^\\/]*?\\.js(\\?.*)?$/)) { \r\n					$.jstree._themes = this.src.toString().replace(/jquery\\.jstree[^\\/]*?\\.js(\\?.*)?$/, "") + \'themes/\'; \r\n					return false; \r\n				}\r\n			});\r\n		}\r\n		if($.jstree._themes === false) { $.jstree._themes = "themes/"; }\r\n	});\r\n	// include the themes plugin by default\r\n	$.jstree.defaults.plugins.push("themes");\r\n})(jQuery);\r\n//*/\r\n\r\n/*\r\n * jsTree hotkeys plugin\r\n * Enables keyboard navigation for all tree instances\r\n * Depends on the jstree ui & jquery hotkeys plugins\r\n */\r\n(function ($) {\r\n	var bound = [];\r\n	function exec(i, event) {\r\n		var f = $.jstree._focused(), tmp;\r\n		if(f && f.data && f.data.hotkeys && f.data.hotkeys.enabled) { \r\n			tmp = f._get_settings().hotkeys[i];\r\n			if(tmp) { return tmp.call(f, event); }\r\n		}\r\n	}\r\n	$.jstree.plugin("hotkeys", {\r\n		__init : function () {\r\n			if(typeof $.hotkeys === "undefined") { throw "jsTree hotkeys: jQuery hotkeys plugin not included."; }\r\n			if(!this.data.ui) { throw "jsTree hotkeys: jsTree UI plugin not included."; }\r\n			$.each(this._get_settings().hotkeys, function (i, v) {\r\n				if(v !== false && $.inArray(i, bound) == -1) {\r\n					$(document).bind("keydown", i, function (event) { return exec(i, event); });\r\n					bound.push(i);\r\n				}\r\n			});\r\n			this.get_container()\r\n				.bind("lock.jstree", $.proxy(function () {\r\n						if(this.data.hotkeys.enabled) { this.data.hotkeys.enabled = false; this.data.hotkeys.revert = true; }\r\n					}, this))\r\n				.bind("unlock.jstree", $.proxy(function () {\r\n						if(this.data.hotkeys.revert) { this.data.hotkeys.enabled = true; }\r\n					}, this));\r\n			this.enable_hotkeys();\r\n		},\r\n		defaults : {\r\n			"up" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;\r\n				this.hover_node(this._get_prev(o));\r\n				return false; \r\n			},\r\n			"ctrl+up" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;\r\n				this.hover_node(this._get_prev(o));\r\n				return false; \r\n			},\r\n			"shift+up" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;\r\n				this.hover_node(this._get_prev(o));\r\n				return false; \r\n			},\r\n			"down" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;\r\n				this.hover_node(this._get_next(o));\r\n				return false;\r\n			},\r\n			"ctrl+down" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;\r\n				this.hover_node(this._get_next(o));\r\n				return false;\r\n			},\r\n			"shift+down" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected || -1;\r\n				this.hover_node(this._get_next(o));\r\n				return false;\r\n			},\r\n			"left" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected;\r\n				if(o) {\r\n					if(o.hasClass("jstree-open")) { this.close_node(o); }\r\n					else { this.hover_node(this._get_prev(o)); }\r\n				}\r\n				return false;\r\n			},\r\n			"ctrl+left" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected;\r\n				if(o) {\r\n					if(o.hasClass("jstree-open")) { this.close_node(o); }\r\n					else { this.hover_node(this._get_prev(o)); }\r\n				}\r\n				return false;\r\n			},\r\n			"shift+left" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected;\r\n				if(o) {\r\n					if(o.hasClass("jstree-open")) { this.close_node(o); }\r\n					else { this.hover_node(this._get_prev(o)); }\r\n				}\r\n				return false;\r\n			},\r\n			"right" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected;\r\n				if(o && o.length) {\r\n					if(o.hasClass("jstree-closed")) { this.open_node(o); }\r\n					else { this.hover_node(this._get_next(o)); }\r\n				}\r\n				return false;\r\n			},\r\n			"ctrl+right" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected;\r\n				if(o && o.length) {\r\n					if(o.hasClass("jstree-closed")) { this.open_node(o); }\r\n					else { this.hover_node(this._get_next(o)); }\r\n				}\r\n				return false;\r\n			},\r\n			"shift+right" : function () { \r\n				var o = this.data.ui.hovered || this.data.ui.last_selected;\r\n				if(o && o.length) {\r\n					if(o.hasClass("jstree-closed")) { this.open_node(o); }\r\n					else { this.hover_node(this._get_next(o)); }\r\n				}\r\n				return false;\r\n			},\r\n			"space" : function () { \r\n				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").click(); } \r\n				return false; \r\n			},\r\n			"ctrl+space" : function (event) { \r\n				event.type = "click";\r\n				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } \r\n				return false; \r\n			},\r\n			"shift+space" : function (event) { \r\n				event.type = "click";\r\n				if(this.data.ui.hovered) { this.data.ui.hovered.children("a:eq(0)").trigger(event); } \r\n				return false; \r\n			},\r\n			"f2" : function () { this.rename(this.data.ui.hovered || this.data.ui.last_selected); },\r\n			"del" : function () { this.remove(this.data.ui.hovered || this._get_node(null)); }\r\n		},\r\n		_fn : {\r\n			enable_hotkeys : function () {\r\n				this.data.hotkeys.enabled = true;\r\n			},\r\n			disable_hotkeys : function () {\r\n				this.data.hotkeys.enabled = false;\r\n			}\r\n		}\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/* \r\n * jsTree JSON plugin\r\n * The JSON data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.\r\n */\r\n(function ($) {\r\n	$.jstree.plugin("json_data", {\r\n		__init : function() {\r\n			var s = this._get_settings().json_data;\r\n			if(s.progressive_unload) {\r\n				this.get_container().bind("after_close.jstree", function (e, data) {\r\n					data.rslt.obj.children("ul").remove();\r\n				});\r\n			}\r\n		},\r\n		defaults : { \r\n			// `data` can be a function:\r\n			//  * accepts two arguments - node being loaded and a callback to pass the result to\r\n			//  * will be executed in the current tree\'s scope & ajax won\'t be supported\r\n			data : false, \r\n			ajax : false,\r\n			correct_state : true,\r\n			progressive_render : false,\r\n			progressive_unload : false\r\n		},\r\n		_fn : {\r\n			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_json(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },\r\n			_is_loaded : function (obj) { \r\n				var s = this._get_settings().json_data;\r\n				obj = this._get_node(obj); \r\n				return obj == -1 || !obj || (!s.ajax && !s.progressive_render && !$.isFunction(s.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").length > 0;\r\n			},\r\n			refresh : function (obj) {\r\n				obj = this._get_node(obj);\r\n				var s = this._get_settings().json_data;\r\n				if(obj && obj !== -1 && s.progressive_unload && ($.isFunction(s.data) || !!s.ajax)) {\r\n					obj.removeData("jstree_children");\r\n				}\r\n				return this.__call_old();\r\n			},\r\n			load_node_json : function (obj, s_call, e_call) {\r\n				var s = this.get_settings().json_data, d,\r\n					error_func = function () {},\r\n					success_func = function () {};\r\n				obj = this._get_node(obj);\r\n\r\n				if(obj && obj !== -1 && (s.progressive_render || s.progressive_unload) && !obj.is(".jstree-open, .jstree-leaf") && obj.children("ul").children("li").length === 0 && obj.data("jstree_children")) {\r\n					d = this._parse_json(obj.data("jstree_children"), obj);\r\n					if(d) {\r\n						obj.append(d);\r\n						if(!s.progressive_unload) { obj.removeData("jstree_children"); }\r\n					}\r\n					this.clean_node(obj);\r\n					if(s_call) { s_call.call(this); }\r\n					return;\r\n				}\r\n\r\n				if(obj && obj !== -1) {\r\n					if(obj.data("jstree_is_loading")) { return; }\r\n					else { obj.data("jstree_is_loading",true); }\r\n				}\r\n				switch(!0) {\r\n					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";\r\n					// function option added here for easier model integration (also supporting async - see callback)\r\n					case ($.isFunction(s.data)):\r\n						s.data.call(this, obj, $.proxy(function (d) {\r\n							d = this._parse_json(d, obj);\r\n							if(!d) { \r\n								if(obj === -1 || !obj) {\r\n									if(s.correct_state) { this.get_container().children("ul").empty(); }\r\n								}\r\n								else {\r\n									obj.children("a.jstree-loading").removeClass("jstree-loading");\r\n									obj.removeData("jstree_is_loading");\r\n									if(s.correct_state) { this.correct_state(obj); }\r\n								}\r\n								if(e_call) { e_call.call(this); }\r\n							}\r\n							else {\r\n								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }\r\n								else { obj.append(d).children("a.jstree-loading").removeClass("jstree-loading"); obj.removeData("jstree_is_loading"); }\r\n								this.clean_node(obj);\r\n								if(s_call) { s_call.call(this); }\r\n							}\r\n						}, this));\r\n						break;\r\n					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):\r\n						if(!obj || obj == -1) {\r\n							d = this._parse_json(s.data, obj);\r\n							if(d) {\r\n								this.get_container().children("ul").empty().append(d.children());\r\n								this.clean_node();\r\n							}\r\n							else { \r\n								if(s.correct_state) { this.get_container().children("ul").empty(); }\r\n							}\r\n						}\r\n						if(s_call) { s_call.call(this); }\r\n						break;\r\n					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):\r\n						error_func = function (x, t, e) {\r\n							var ef = this.get_settings().json_data.ajax.error; \r\n							if(ef) { ef.call(this, x, t, e); }\r\n							if(obj != -1 && obj.length) {\r\n								obj.children("a.jstree-loading").removeClass("jstree-loading");\r\n								obj.removeData("jstree_is_loading");\r\n								if(t === "success" && s.correct_state) { this.correct_state(obj); }\r\n							}\r\n							else {\r\n								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }\r\n							}\r\n							if(e_call) { e_call.call(this); }\r\n						};\r\n						success_func = function (d, t, x) {\r\n							var sf = this.get_settings().json_data.ajax.success; \r\n							if(sf) { d = sf.call(this,d,t,x) || d; }\r\n							if(d === "" || (d && d.toString && d.toString().replace(/^[\\s\\n]+$/,"") === "") || (!$.isArray(d) && !$.isPlainObject(d))) {\r\n								return error_func.call(this, x, t, "");\r\n							}\r\n							d = this._parse_json(d, obj);\r\n							if(d) {\r\n								if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }\r\n								else { obj.append(d).children("a.jstree-loading").removeClass("jstree-loading"); obj.removeData("jstree_is_loading"); }\r\n								this.clean_node(obj);\r\n								if(s_call) { s_call.call(this); }\r\n							}\r\n							else {\r\n								if(obj === -1 || !obj) {\r\n									if(s.correct_state) { \r\n										this.get_container().children("ul").empty(); \r\n										if(s_call) { s_call.call(this); }\r\n									}\r\n								}\r\n								else {\r\n									obj.children("a.jstree-loading").removeClass("jstree-loading");\r\n									obj.removeData("jstree_is_loading");\r\n									if(s.correct_state) { \r\n										this.correct_state(obj);\r\n										if(s_call) { s_call.call(this); } \r\n									}\r\n								}\r\n							}\r\n						};\r\n						s.ajax.context = this;\r\n						s.ajax.error = error_func;\r\n						s.ajax.success = success_func;\r\n						if(!s.ajax.dataType) { s.ajax.dataType = "json"; }\r\n						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }\r\n						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }\r\n						$.ajax(s.ajax);\r\n						break;\r\n				}\r\n			},\r\n			_parse_json : function (js, obj, is_callback) {\r\n				var d = false, \r\n					p = this._get_settings(),\r\n					s = p.json_data,\r\n					t = p.core.html_titles,\r\n					tmp, i, j, ul1, ul2;\r\n\r\n				if(!js) { return d; }\r\n				if(s.progressive_unload && obj && obj !== -1) { \r\n					obj.data("jstree_children", d);\r\n				}\r\n				if($.isArray(js)) {\r\n					d = $();\r\n					if(!js.length) { return false; }\r\n					for(i = 0, j = js.length; i < j; i++) {\r\n						tmp = this._parse_json(js[i], obj, true);\r\n						if(tmp.length) { d = d.add(tmp); }\r\n					}\r\n				}\r\n				else {\r\n					if(typeof js == "string") { js = { data : js }; }\r\n					if(!js.data && js.data !== "") { return d; }\r\n					d = $("<li />");\r\n					if(js.attr) { d.attr(js.attr); }\r\n					if(js.metadata) { d.data(js.metadata); }\r\n					if(js.state) { d.addClass("jstree-" + js.state); }\r\n					if(!$.isArray(js.data)) { tmp = js.data; js.data = []; js.data.push(tmp); }\r\n					$.each(js.data, function (i, m) {\r\n						tmp = $("<a />");\r\n						if($.isFunction(m)) { m = m.call(this, js); }\r\n						if(typeof m == "string") { tmp.attr(\'href\',\'#\')[ t ? "html" : "text" ](m); }\r\n						else {\r\n							if(!m.attr) { m.attr = {}; }\r\n							if(!m.attr.href) { m.attr.href = \'#\'; }\r\n							tmp.attr(m.attr)[ t ? "html" : "text" ](m.title);\r\n							if(m.language) { tmp.addClass(m.language); }\r\n						}\r\n						tmp.prepend("<ins class=\'jstree-icon\'>&#160;</ins>");\r\n						if(!m.icon && js.icon) { m.icon = js.icon; }\r\n						if(m.icon) { \r\n							if(m.icon.indexOf("/") === -1) { tmp.children("ins").addClass(m.icon); }\r\n							else { tmp.children("ins").css("background","url(\'" + m.icon + "\') center center no-repeat"); }\r\n						}\r\n						d.append(tmp);\r\n					});\r\n					d.prepend("<ins class=\'jstree-icon\'>&#160;</ins>");\r\n					if(js.children) { \r\n						if(s.progressive_render && js.state !== "open") {\r\n							d.addClass("jstree-closed").data("jstree_children", js.children);\r\n						}\r\n						else {\r\n							if(s.progressive_unload) { d.data("jstree_children", js.children); }\r\n							if($.isArray(js.children) && js.children.length) {\r\n								tmp = this._parse_json(js.children, obj, true);\r\n								if(tmp.length) {\r\n									ul2 = $("<ul />");\r\n									ul2.append(tmp);\r\n									d.append(ul2);\r\n								}\r\n							}\r\n						}\r\n					}\r\n				}\r\n				if(!is_callback) {\r\n					ul1 = $("<ul />");\r\n					ul1.append(d);\r\n					d = ul1;\r\n				}\r\n				return d;\r\n			},\r\n			get_json : function (obj, li_attr, a_attr, is_callback) {\r\n				var result = [], \r\n					s = this._get_settings(), \r\n					_this = this,\r\n					tmp1, tmp2, li, a, t, lang;\r\n				obj = this._get_node(obj);\r\n				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }\r\n				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];\r\n				if(!is_callback && this.data.types) { li_attr.push(s.types.type_attr); }\r\n				a_attr = $.isArray(a_attr) ? a_attr : [ ];\r\n\r\n				obj.each(function () {\r\n					li = $(this);\r\n					tmp1 = { data : [] };\r\n					if(li_attr.length) { tmp1.attr = { }; }\r\n					$.each(li_attr, function (i, v) { \r\n						tmp2 = li.attr(v); \r\n						if(tmp2 && tmp2.length && tmp2.replace(/jstree[^ ]*/ig,\'\').length) {\r\n							tmp1.attr[v] = (" " + tmp2).replace(/ jstree[^ ]*/ig,\'\').replace(/\\s+$/ig," ").replace(/^ /,"").replace(/ $/,""); \r\n						}\r\n					});\r\n					if(li.hasClass("jstree-open")) { tmp1.state = "open"; }\r\n					if(li.hasClass("jstree-closed")) { tmp1.state = "closed"; }\r\n					if(li.data()) { tmp1.metadata = li.data(); }\r\n					a = li.children("a");\r\n					a.each(function () {\r\n						t = $(this);\r\n						if(\r\n							a_attr.length || \r\n							$.inArray("languages", s.plugins) !== -1 || \r\n							t.children("ins").get(0).style.backgroundImage.length || \r\n							(t.children("ins").get(0).className && t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,\'\').length)\r\n						) { \r\n							lang = false;\r\n							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {\r\n								$.each(s.languages, function (l, lv) {\r\n									if(t.hasClass(lv)) {\r\n										lang = lv;\r\n										return false;\r\n									}\r\n								});\r\n							}\r\n							tmp2 = { attr : { }, title : _this.get_text(t, lang) }; \r\n							$.each(a_attr, function (k, z) {\r\n								tmp2.attr[z] = (" " + (t.attr(z) || "")).replace(/ jstree[^ ]*/ig,\'\').replace(/\\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");\r\n							});\r\n							if($.inArray("languages", s.plugins) !== -1 && $.isArray(s.languages) && s.languages.length) {\r\n								$.each(s.languages, function (k, z) {\r\n									if(t.hasClass(z)) { tmp2.language = z; return true; }\r\n								});\r\n							}\r\n							if(t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,\'\').replace(/^\\s+$/ig,"").length) {\r\n								tmp2.icon = t.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,\'\').replace(/\\s+$/ig," ").replace(/^ /,"").replace(/ $/,"");\r\n							}\r\n							if(t.children("ins").get(0).style.backgroundImage.length) {\r\n								tmp2.icon = t.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","");\r\n							}\r\n						}\r\n						else {\r\n							tmp2 = _this.get_text(t);\r\n						}\r\n						if(a.length > 1) { tmp1.data.push(tmp2); }\r\n						else { tmp1.data = tmp2; }\r\n					});\r\n					li = li.find("> ul > li");\r\n					if(li.length) { tmp1.children = _this.get_json(li, li_attr, a_attr, true); }\r\n					result.push(tmp1);\r\n				});\r\n				return result;\r\n			}\r\n		}\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/* \r\n * jsTree languages plugin\r\n * Adds support for multiple language versions in one tree\r\n * This basically allows for many titles coexisting in one node, but only one of them being visible at any given time\r\n * This is useful for maintaining the same structure in many languages (hence the name of the plugin)\r\n */\r\n(function ($) {\r\n	$.jstree.plugin("languages", {\r\n		__init : function () { this._load_css();  },\r\n		defaults : [],\r\n		_fn : {\r\n			set_lang : function (i) { \r\n				var langs = this._get_settings().languages,\r\n					st = false,\r\n					selector = ".jstree-" + this.get_index() + \' a\';\r\n				if(!$.isArray(langs) || langs.length === 0) { return false; }\r\n				if($.inArray(i,langs) == -1) {\r\n					if(!!langs[i]) { i = langs[i]; }\r\n					else { return false; }\r\n				}\r\n				if(i == this.data.languages.current_language) { return true; }\r\n				st = $.vakata.css.get_css(selector + "." + this.data.languages.current_language, false, this.data.languages.language_css);\r\n				if(st !== false) { st.style.display = "none"; }\r\n				st = $.vakata.css.get_css(selector + "." + i, false, this.data.languages.language_css);\r\n				if(st !== false) { st.style.display = ""; }\r\n				this.data.languages.current_language = i;\r\n				this.__callback(i);\r\n				return true;\r\n			},\r\n			get_lang : function () {\r\n				return this.data.languages.current_language;\r\n			},\r\n			_get_string : function (key, lang) {\r\n				var langs = this._get_settings().languages,\r\n					s = this._get_settings().core.strings;\r\n				if($.isArray(langs) && langs.length) {\r\n					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;\r\n				}\r\n				if(s[lang] && s[lang][key]) { return s[lang][key]; }\r\n				if(s[key]) { return s[key]; }\r\n				return key;\r\n			},\r\n			get_text : function (obj, lang) {\r\n				obj = this._get_node(obj) || this.data.ui.last_selected;\r\n				if(!obj.length) { return false; }\r\n				var langs = this._get_settings().languages,\r\n					s = this._get_settings().core.html_titles;\r\n				if($.isArray(langs) && langs.length) {\r\n					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;\r\n					obj = obj.children("a." + lang);\r\n				}\r\n				else { obj = obj.children("a:eq(0)"); }\r\n				if(s) {\r\n					obj = obj.clone();\r\n					obj.children("INS").remove();\r\n					return obj.html();\r\n				}\r\n				else {\r\n					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];\r\n					return obj.nodeValue;\r\n				}\r\n			},\r\n			set_text : function (obj, val, lang) {\r\n				obj = this._get_node(obj) || this.data.ui.last_selected;\r\n				if(!obj.length) { return false; }\r\n				var langs = this._get_settings().languages,\r\n					s = this._get_settings().core.html_titles,\r\n					tmp;\r\n				if($.isArray(langs) && langs.length) {\r\n					lang = (lang && $.inArray(lang,langs) != -1) ? lang : this.data.languages.current_language;\r\n					obj = obj.children("a." + lang);\r\n				}\r\n				else { obj = obj.children("a:eq(0)"); }\r\n				if(s) {\r\n					tmp = obj.children("INS").clone();\r\n					obj.html(val).prepend(tmp);\r\n					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });\r\n					return true;\r\n				}\r\n				else {\r\n					obj = obj.contents().filter(function() { return this.nodeType == 3; })[0];\r\n					this.__callback({ "obj" : obj, "name" : val, "lang" : lang });\r\n					return (obj.nodeValue = val);\r\n				}\r\n			},\r\n			_load_css : function () {\r\n				var langs = this._get_settings().languages,\r\n					str = "/* languages css */",\r\n					selector = ".jstree-" + this.get_index() + \' a\',\r\n					ln;\r\n				if($.isArray(langs) && langs.length) {\r\n					this.data.languages.current_language = langs[0];\r\n					for(ln = 0; ln < langs.length; ln++) {\r\n						str += selector + "." + langs[ln] + " {";\r\n						if(langs[ln] != this.data.languages.current_language) { str += " display:none; "; }\r\n						str += " } ";\r\n					}\r\n					this.data.languages.language_css = $.vakata.css.add_sheet({ \'str\' : str, \'title\' : "jstree-languages" });\r\n				}\r\n			},\r\n			create_node : function (obj, position, js, callback) {\r\n				var t = this.__call_old(true, obj, position, js, function (t) {\r\n					var langs = this._get_settings().languages,\r\n						a = t.children("a"),\r\n						ln;\r\n					if($.isArray(langs) && langs.length) {\r\n						for(ln = 0; ln < langs.length; ln++) {\r\n							if(!a.is("." + langs[ln])) {\r\n								t.append(a.eq(0).clone().removeClass(langs.join(" ")).addClass(langs[ln]));\r\n							}\r\n						}\r\n						a.not("." + langs.join(", .")).remove();\r\n					}\r\n					if(callback) { callback.call(this, t); }\r\n				});\r\n				return t;\r\n			}\r\n		}\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/*\r\n * jsTree cookies plugin\r\n * Stores the currently opened/selected nodes in a cookie and then restores them\r\n * Depends on the jquery.cookie plugin\r\n */\r\n(function ($) {\r\n	$.jstree.plugin("cookies", {\r\n		__init : function () {\r\n			if(typeof $.cookie === "undefined") { throw "jsTree cookie: jQuery cookie plugin not included."; }\r\n\r\n			var s = this._get_settings().cookies,\r\n				tmp;\r\n			if(!!s.save_loaded) {\r\n				tmp = $.cookie(s.save_loaded);\r\n				if(tmp && tmp.length) { this.data.core.to_load = tmp.split(","); }\r\n			}\r\n			if(!!s.save_opened) {\r\n				tmp = $.cookie(s.save_opened);\r\n				if(tmp && tmp.length) { this.data.core.to_open = tmp.split(","); }\r\n			}\r\n			if(!!s.save_selected) {\r\n				tmp = $.cookie(s.save_selected);\r\n				if(tmp && tmp.length && this.data.ui) { this.data.ui.to_select = tmp.split(","); }\r\n			}\r\n			this.get_container()\r\n				.one( ( this.data.ui ? "reselect" : "reopen" ) + ".jstree", $.proxy(function () {\r\n					this.get_container()\r\n						.bind("open_node.jstree close_node.jstree select_node.jstree deselect_node.jstree", $.proxy(function (e) { \r\n								if(this._get_settings().cookies.auto_save) { this.save_cookie((e.handleObj.namespace + e.handleObj.type).replace("jstree","")); }\r\n							}, this));\r\n				}, this));\r\n		},\r\n		defaults : {\r\n			save_loaded		: "jstree_load",\r\n			save_opened		: "jstree_open",\r\n			save_selected	: "jstree_select",\r\n			auto_save		: true,\r\n			cookie_options	: {}\r\n		},\r\n		_fn : {\r\n			save_cookie : function (c) {\r\n				if(this.data.core.refreshing) { return; }\r\n				var s = this._get_settings().cookies;\r\n				if(!c) { // if called manually and not by event\r\n					if(s.save_loaded) {\r\n						this.save_loaded();\r\n						$.cookie(s.save_loaded, this.data.core.to_load.join(","), s.cookie_options);\r\n					}\r\n					if(s.save_opened) {\r\n						this.save_opened();\r\n						$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options);\r\n					}\r\n					if(s.save_selected && this.data.ui) {\r\n						this.save_selected();\r\n						$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options);\r\n					}\r\n					return;\r\n				}\r\n				switch(c) {\r\n					case "open_node":\r\n					case "close_node":\r\n						if(!!s.save_opened) { \r\n							this.save_opened(); \r\n							$.cookie(s.save_opened, this.data.core.to_open.join(","), s.cookie_options); \r\n						}\r\n						if(!!s.save_loaded) { \r\n							this.save_loaded(); \r\n							$.cookie(s.save_loaded, this.data.core.to_load.join(","), s.cookie_options); \r\n						}\r\n						break;\r\n					case "select_node":\r\n					case "deselect_node":\r\n						if(!!s.save_selected && this.data.ui) { \r\n							this.save_selected(); \r\n							$.cookie(s.save_selected, this.data.ui.to_select.join(","), s.cookie_options); \r\n						}\r\n						break;\r\n				}\r\n			}\r\n		}\r\n	});\r\n	// include cookies by default\r\n	// $.jstree.defaults.plugins.push("cookies");\r\n})(jQuery);\r\n//*/\r\n\r\n/*\r\n * jsTree sort plugin\r\n * Sorts items alphabetically (or using any other function)\r\n */\r\n(function ($) {\r\n	$.jstree.plugin("sort", {\r\n		__init : function () {\r\n			this.get_container()\r\n				.bind("load_node.jstree", $.proxy(function (e, data) {\r\n						var obj = this._get_node(data.rslt.obj);\r\n						obj = obj === -1 ? this.get_container().children("ul") : obj.children("ul");\r\n						this.sort(obj);\r\n					}, this))\r\n				.bind("rename_node.jstree create_node.jstree create.jstree", $.proxy(function (e, data) {\r\n						this.sort(data.rslt.obj.parent());\r\n					}, this))\r\n				.bind("move_node.jstree", $.proxy(function (e, data) {\r\n						var m = data.rslt.np == -1 ? this.get_container() : data.rslt.np;\r\n						this.sort(m.children("ul"));\r\n					}, this));\r\n		},\r\n		defaults : function (a, b) { return this.get_text(a) > this.get_text(b) ? 1 : -1; },\r\n		_fn : {\r\n			sort : function (obj) {\r\n				var s = this._get_settings().sort,\r\n					t = this;\r\n				obj.append($.makeArray(obj.children("li")).sort($.proxy(s, t)));\r\n				obj.find("> li > ul").each(function() { t.sort($(this)); });\r\n				this.clean_node(obj);\r\n			}\r\n		}\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/*\r\n * jsTree DND plugin\r\n * Drag and drop plugin for moving/copying nodes\r\n */\r\n(function ($) {\r\n	var o = false,\r\n		r = false,\r\n		m = false,\r\n		ml = false,\r\n		sli = false,\r\n		sti = false,\r\n		dir1 = false,\r\n		dir2 = false,\r\n		last_pos = false;\r\n	$.vakata.dnd = {\r\n		is_down : false,\r\n		is_drag : false,\r\n		helper : false,\r\n		scroll_spd : 10,\r\n		init_x : 0,\r\n		init_y : 0,\r\n		threshold : 5,\r\n		helper_left : 5,\r\n		helper_top : 10,\r\n		user_data : {},\r\n\r\n		drag_start : function (e, data, html) { \r\n			if($.vakata.dnd.is_drag) { $.vakata.drag_stop({}); }\r\n			try {\r\n				e.currentTarget.unselectable = "on";\r\n				e.currentTarget.onselectstart = function() { return false; };\r\n				if(e.currentTarget.style) { e.currentTarget.style.MozUserSelect = "none"; }\r\n			} catch(err) { }\r\n			$.vakata.dnd.init_x = e.pageX;\r\n			$.vakata.dnd.init_y = e.pageY;\r\n			$.vakata.dnd.user_data = data;\r\n			$.vakata.dnd.is_down = true;\r\n			$.vakata.dnd.helper = $("<div id=\'vakata-dragged\' />").html(html); //.fadeTo(10,0.25);\r\n			$(document).bind("mousemove", $.vakata.dnd.drag);\r\n			$(document).bind("mouseup", $.vakata.dnd.drag_stop);\r\n			return false;\r\n		},\r\n		drag : function (e) { \r\n			if(!$.vakata.dnd.is_down) { return; }\r\n			if(!$.vakata.dnd.is_drag) {\r\n				if(Math.abs(e.pageX - $.vakata.dnd.init_x) > 5 || Math.abs(e.pageY - $.vakata.dnd.init_y) > 5) { \r\n					$.vakata.dnd.helper.appendTo("body");\r\n					$.vakata.dnd.is_drag = true;\r\n					$(document).triggerHandler("drag_start.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });\r\n				}\r\n				else { return; }\r\n			}\r\n\r\n			// maybe use a scrolling parent element instead of document?\r\n			if(e.type === "mousemove") { // thought of adding scroll in order to move the helper, but mouse poisition is n/a\r\n				var d = $(document), t = d.scrollTop(), l = d.scrollLeft();\r\n				if(e.pageY - t < 20) { \r\n					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }\r\n					if(!sti) { dir1 = "up"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() - $.vakata.dnd.scroll_spd); }, 150); }\r\n				}\r\n				else { \r\n					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }\r\n				}\r\n				if($(window).height() - (e.pageY - t) < 20) {\r\n					if(sti && dir1 === "up") { clearInterval(sti); sti = false; }\r\n					if(!sti) { dir1 = "down"; sti = setInterval(function () { $(document).scrollTop($(document).scrollTop() + $.vakata.dnd.scroll_spd); }, 150); }\r\n				}\r\n				else { \r\n					if(sti && dir1 === "down") { clearInterval(sti); sti = false; }\r\n				}\r\n\r\n				if(e.pageX - l < 20) {\r\n					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }\r\n					if(!sli) { dir2 = "left"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() - $.vakata.dnd.scroll_spd); }, 150); }\r\n				}\r\n				else { \r\n					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }\r\n				}\r\n				if($(window).width() - (e.pageX - l) < 20) {\r\n					if(sli && dir2 === "left") { clearInterval(sli); sli = false; }\r\n					if(!sli) { dir2 = "right"; sli = setInterval(function () { $(document).scrollLeft($(document).scrollLeft() + $.vakata.dnd.scroll_spd); }, 150); }\r\n				}\r\n				else { \r\n					if(sli && dir2 === "right") { clearInterval(sli); sli = false; }\r\n				}\r\n			}\r\n\r\n			$.vakata.dnd.helper.css({ left : (e.pageX + $.vakata.dnd.helper_left) + "px", top : (e.pageY + $.vakata.dnd.helper_top) + "px" });\r\n			$(document).triggerHandler("drag.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });\r\n		},\r\n		drag_stop : function (e) {\r\n			if(sli) { clearInterval(sli); }\r\n			if(sti) { clearInterval(sti); }\r\n			$(document).unbind("mousemove", $.vakata.dnd.drag);\r\n			$(document).unbind("mouseup", $.vakata.dnd.drag_stop);\r\n			$(document).triggerHandler("drag_stop.vakata", { "event" : e, "data" : $.vakata.dnd.user_data });\r\n			$.vakata.dnd.helper.remove();\r\n			$.vakata.dnd.init_x = 0;\r\n			$.vakata.dnd.init_y = 0;\r\n			$.vakata.dnd.user_data = {};\r\n			$.vakata.dnd.is_down = false;\r\n			$.vakata.dnd.is_drag = false;\r\n		}\r\n	};\r\n	$(function() {\r\n		var css_string = \'#vakata-dragged { display:block; margin:0 0 0 0; padding:4px 4px 4px 24px; position:absolute; top:-2000px; line-height:16px; z-index:10000; } \';\r\n		$.vakata.css.add_sheet({ str : css_string, title : "vakata" });\r\n	});\r\n\r\n	$.jstree.plugin("dnd", {\r\n		__init : function () {\r\n			this.data.dnd = {\r\n				active : false,\r\n				after : false,\r\n				inside : false,\r\n				before : false,\r\n				off : false,\r\n				prepared : false,\r\n				w : 0,\r\n				to1 : false,\r\n				to2 : false,\r\n				cof : false,\r\n				cw : false,\r\n				ch : false,\r\n				i1 : false,\r\n				i2 : false,\r\n				mto : false\r\n			};\r\n			this.get_container()\r\n				.bind("mouseenter.jstree", $.proxy(function (e) {\r\n						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {\r\n							if(this.data.themes) {\r\n								m.attr("class", "jstree-" + this.data.themes.theme); \r\n								if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }\r\n								$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme);\r\n							}\r\n							//if($(e.currentTarget).find("> ul > li").length === 0) {\r\n							if(e.currentTarget === e.target && $.vakata.dnd.user_data.obj && $($.vakata.dnd.user_data.obj).length && $($.vakata.dnd.user_data.obj).parents(".jstree:eq(0)")[0] !== e.target) { // node should not be from the same tree\r\n								var tr = $.jstree._reference(e.target), dc;\r\n								if(tr.data.dnd.foreign) {\r\n									dc = tr._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });\r\n									if(dc === true || dc.inside === true || dc.before === true || dc.after === true) {\r\n										$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");\r\n									}\r\n								}\r\n								else {\r\n									tr.prepare_move(o, tr.get_container(), "last");\r\n									if(tr.check_move()) {\r\n										$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");\r\n									}\r\n								}\r\n							}\r\n						}\r\n					}, this))\r\n				.bind("mouseup.jstree", $.proxy(function (e) {\r\n						//if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && $(e.currentTarget).find("> ul > li").length === 0) {\r\n						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && e.currentTarget === e.target && $.vakata.dnd.user_data.obj && $($.vakata.dnd.user_data.obj).length && $($.vakata.dnd.user_data.obj).parents(".jstree:eq(0)")[0] !== e.target) { // node should not be from the same tree\r\n							var tr = $.jstree._reference(e.currentTarget), dc;\r\n							if(tr.data.dnd.foreign) {\r\n								dc = tr._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });\r\n								if(dc === true || dc.inside === true || dc.before === true || dc.after === true) {\r\n									tr._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : tr.get_container(), is_root : true });\r\n								}\r\n							}\r\n							else {\r\n								tr.move_node(o, tr.get_container(), "last", e[tr._get_settings().dnd.copy_modifier + "Key"]);\r\n							}\r\n						}\r\n					}, this))\r\n				.bind("mouseleave.jstree", $.proxy(function (e) {\r\n						if(e.relatedTarget && e.relatedTarget.id && e.relatedTarget.id === "jstree-marker-line") {\r\n							return false; \r\n						}\r\n						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {\r\n							if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }\r\n							if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }\r\n							if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }\r\n							if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }\r\n							if($.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {\r\n								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");\r\n							}\r\n						}\r\n					}, this))\r\n				.bind("mousemove.jstree", $.proxy(function (e) {\r\n						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {\r\n							var cnt = this.get_container()[0];\r\n\r\n							// Horizontal scroll\r\n							if(e.pageX + 24 > this.data.dnd.cof.left + this.data.dnd.cw) {\r\n								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }\r\n								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft += $.vakata.dnd.scroll_spd; }, cnt), 100);\r\n							}\r\n							else if(e.pageX - 24 < this.data.dnd.cof.left) {\r\n								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }\r\n								this.data.dnd.i1 = setInterval($.proxy(function () { this.scrollLeft -= $.vakata.dnd.scroll_spd; }, cnt), 100);\r\n							}\r\n							else {\r\n								if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }\r\n							}\r\n\r\n							// Vertical scroll\r\n							if(e.pageY + 24 > this.data.dnd.cof.top + this.data.dnd.ch) {\r\n								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }\r\n								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop += $.vakata.dnd.scroll_spd; }, cnt), 100);\r\n							}\r\n							else if(e.pageY - 24 < this.data.dnd.cof.top) {\r\n								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }\r\n								this.data.dnd.i2 = setInterval($.proxy(function () { this.scrollTop -= $.vakata.dnd.scroll_spd; }, cnt), 100);\r\n							}\r\n							else {\r\n								if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }\r\n							}\r\n\r\n						}\r\n					}, this))\r\n				.bind("scroll.jstree", $.proxy(function (e) { \r\n						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && m && ml) {\r\n							m.hide();\r\n							ml.hide();\r\n						}\r\n					}, this))\r\n				.delegate("a", "mousedown.jstree", $.proxy(function (e) { \r\n						if(e.which === 1) {\r\n							this.start_drag(e.currentTarget, e);\r\n							return false;\r\n						}\r\n					}, this))\r\n				.delegate("a", "mouseenter.jstree", $.proxy(function (e) { \r\n						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {\r\n							this.dnd_enter(e.currentTarget);\r\n						}\r\n					}, this))\r\n				.delegate("a", "mousemove.jstree", $.proxy(function (e) { \r\n						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {\r\n							if(!r || !r.length || r.children("a")[0] !== e.currentTarget) {\r\n								this.dnd_enter(e.currentTarget);\r\n							}\r\n							if(typeof this.data.dnd.off.top === "undefined") { this.data.dnd.off = $(e.target).offset(); }\r\n							this.data.dnd.w = (e.pageY - (this.data.dnd.off.top || 0)) % this.data.core.li_height;\r\n							if(this.data.dnd.w < 0) { this.data.dnd.w += this.data.core.li_height; }\r\n							this.dnd_show();\r\n						}\r\n					}, this))\r\n				.delegate("a", "mouseleave.jstree", $.proxy(function (e) { \r\n						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {\r\n							if(e.relatedTarget && e.relatedTarget.id && e.relatedTarget.id === "jstree-marker-line") {\r\n								return false; \r\n							}\r\n								if(m) { m.hide(); }\r\n								if(ml) { ml.hide(); }\r\n							/*\r\n							var ec = $(e.currentTarget).closest("li"), \r\n								er = $(e.relatedTarget).closest("li");\r\n							if(er[0] !== ec.prev()[0] && er[0] !== ec.next()[0]) {\r\n								if(m) { m.hide(); }\r\n								if(ml) { ml.hide(); }\r\n							}\r\n							*/\r\n							this.data.dnd.mto = setTimeout( \r\n								(function (t) { return function () { t.dnd_leave(e); }; })(this),\r\n							0);\r\n						}\r\n					}, this))\r\n				.delegate("a", "mouseup.jstree", $.proxy(function (e) { \r\n						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree) {\r\n							this.dnd_finish(e);\r\n						}\r\n					}, this));\r\n\r\n			$(document)\r\n				.bind("drag_stop.vakata", $.proxy(function () {\r\n						if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }\r\n						if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }\r\n						if(this.data.dnd.i1) { clearInterval(this.data.dnd.i1); }\r\n						if(this.data.dnd.i2) { clearInterval(this.data.dnd.i2); }\r\n						this.data.dnd.after		= false;\r\n						this.data.dnd.before	= false;\r\n						this.data.dnd.inside	= false;\r\n						this.data.dnd.off		= false;\r\n						this.data.dnd.prepared	= false;\r\n						this.data.dnd.w			= false;\r\n						this.data.dnd.to1		= false;\r\n						this.data.dnd.to2		= false;\r\n						this.data.dnd.i1		= false;\r\n						this.data.dnd.i2		= false;\r\n						this.data.dnd.active	= false;\r\n						this.data.dnd.foreign	= false;\r\n						if(m) { m.css({ "top" : "-2000px" }); }\r\n						if(ml) { ml.css({ "top" : "-2000px" }); }\r\n					}, this))\r\n				.bind("drag_start.vakata", $.proxy(function (e, data) {\r\n						if(data.data.jstree) { \r\n							var et = $(data.event.target);\r\n							if(et.closest(".jstree").hasClass("jstree-" + this.get_index())) {\r\n								this.dnd_enter(et);\r\n							}\r\n						}\r\n					}, this));\r\n				/*\r\n				.bind("keydown.jstree-" + this.get_index() + " keyup.jstree-" + this.get_index(), $.proxy(function(e) {\r\n						if($.vakata.dnd.is_drag && $.vakata.dnd.user_data.jstree && !this.data.dnd.foreign) {\r\n							var h = $.vakata.dnd.helper.children("ins");\r\n							if(e[this._get_settings().dnd.copy_modifier + "Key"] && h.hasClass("jstree-ok")) {\r\n								h.parent().html(h.parent().html().replace(/ \\(Copy\\)$/, "") + " (Copy)");\r\n							} \r\n							else {\r\n								h.parent().html(h.parent().html().replace(/ \\(Copy\\)$/, ""));\r\n							}\r\n						}\r\n					}, this)); */\r\n\r\n\r\n\r\n			var s = this._get_settings().dnd;\r\n			if(s.drag_target) {\r\n				$(document)\r\n					.delegate(s.drag_target, "mousedown.jstree-" + this.get_index(), $.proxy(function (e) {\r\n						o = e.target;\r\n						$.vakata.dnd.drag_start(e, { jstree : true, obj : e.target }, "<ins class=\'jstree-icon\'></ins>" + $(e.target).text() );\r\n						if(this.data.themes) { \r\n							if(m) { m.attr("class", "jstree-" + this.data.themes.theme); }\r\n							if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }\r\n							$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); \r\n						}\r\n						$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");\r\n						var cnt = this.get_container();\r\n						this.data.dnd.cof = cnt.offset();\r\n						this.data.dnd.cw = parseInt(cnt.width(),10);\r\n						this.data.dnd.ch = parseInt(cnt.height(),10);\r\n						this.data.dnd.foreign = true;\r\n						e.preventDefault();\r\n					}, this));\r\n			}\r\n			if(s.drop_target) {\r\n				$(document)\r\n					.delegate(s.drop_target, "mouseenter.jstree-" + this.get_index(), $.proxy(function (e) {\r\n							if(this.data.dnd.active && this._get_settings().dnd.drop_check.call(this, { "o" : o, "r" : $(e.target), "e" : e })) {\r\n								$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");\r\n							}\r\n						}, this))\r\n					.delegate(s.drop_target, "mouseleave.jstree-" + this.get_index(), $.proxy(function (e) {\r\n							if(this.data.dnd.active) {\r\n								$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");\r\n							}\r\n						}, this))\r\n					.delegate(s.drop_target, "mouseup.jstree-" + this.get_index(), $.proxy(function (e) {\r\n							if(this.data.dnd.active && $.vakata.dnd.helper.children("ins").hasClass("jstree-ok")) {\r\n								this._get_settings().dnd.drop_finish.call(this, { "o" : o, "r" : $(e.target), "e" : e });\r\n							}\r\n						}, this));\r\n			}\r\n		},\r\n		defaults : {\r\n			copy_modifier	: "ctrl",\r\n			check_timeout	: 100,\r\n			open_timeout	: 500,\r\n			drop_target		: ".jstree-drop",\r\n			drop_check		: function (data) { return true; },\r\n			drop_finish		: $.noop,\r\n			drag_target		: ".jstree-draggable",\r\n			drag_finish		: $.noop,\r\n			drag_check		: function (data) { return { after : false, before : false, inside : true }; }\r\n		},\r\n		_fn : {\r\n			dnd_prepare : function () {\r\n				if(!r || !r.length) { return; }\r\n				this.data.dnd.off = r.offset();\r\n				if(this._get_settings().core.rtl) {\r\n					this.data.dnd.off.right = this.data.dnd.off.left + r.width();\r\n				}\r\n				if(this.data.dnd.foreign) {\r\n					var a = this._get_settings().dnd.drag_check.call(this, { "o" : o, "r" : r });\r\n					this.data.dnd.after = a.after;\r\n					this.data.dnd.before = a.before;\r\n					this.data.dnd.inside = a.inside;\r\n					this.data.dnd.prepared = true;\r\n					return this.dnd_show();\r\n				}\r\n				this.prepare_move(o, r, "before");\r\n				this.data.dnd.before = this.check_move();\r\n				this.prepare_move(o, r, "after");\r\n				this.data.dnd.after = this.check_move();\r\n				if(this._is_loaded(r)) {\r\n					this.prepare_move(o, r, "inside");\r\n					this.data.dnd.inside = this.check_move();\r\n				}\r\n				else {\r\n					this.data.dnd.inside = false;\r\n				}\r\n				this.data.dnd.prepared = true;\r\n				return this.dnd_show();\r\n			},\r\n			dnd_show : function () {\r\n				if(!this.data.dnd.prepared) { return; }\r\n				var o = ["before","inside","after"],\r\n					r = false,\r\n					rtl = this._get_settings().core.rtl,\r\n					pos;\r\n				if(this.data.dnd.w < this.data.core.li_height/3) { o = ["before","inside","after"]; }\r\n				else if(this.data.dnd.w <= this.data.core.li_height*2/3) {\r\n					o = this.data.dnd.w < this.data.core.li_height/2 ? ["inside","before","after"] : ["inside","after","before"];\r\n				}\r\n				else { o = ["after","inside","before"]; }\r\n				$.each(o, $.proxy(function (i, val) { \r\n					if(this.data.dnd[val]) {\r\n						$.vakata.dnd.helper.children("ins").attr("class","jstree-ok");\r\n						r = val;\r\n						return false;\r\n					}\r\n				}, this));\r\n				if(r === false) { $.vakata.dnd.helper.children("ins").attr("class","jstree-invalid"); }\r\n				\r\n				pos = rtl ? (this.data.dnd.off.right - 18) : (this.data.dnd.off.left + 10);\r\n				switch(r) {\r\n					case "before":\r\n						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top - 6) + "px" }).show();\r\n						if(ml) { ml.css({ "left" : (pos + 8) + "px", "top" : (this.data.dnd.off.top - 1) + "px" }).show(); }\r\n						break;\r\n					case "after":\r\n						m.css({ "left" : pos + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 6) + "px" }).show();\r\n						if(ml) { ml.css({ "left" : (pos + 8) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height - 1) + "px" }).show(); }\r\n						break;\r\n					case "inside":\r\n						m.css({ "left" : pos + ( rtl ? -4 : 4) + "px", "top" : (this.data.dnd.off.top + this.data.core.li_height/2 - 5) + "px" }).show();\r\n						if(ml) { ml.hide(); }\r\n						break;\r\n					default:\r\n						m.hide();\r\n						if(ml) { ml.hide(); }\r\n						break;\r\n				}\r\n				last_pos = r;\r\n				return r;\r\n			},\r\n			dnd_open : function () {\r\n				this.data.dnd.to2 = false;\r\n				this.open_node(r, $.proxy(this.dnd_prepare,this), true);\r\n			},\r\n			dnd_finish : function (e) {\r\n				if(this.data.dnd.foreign) {\r\n					if(this.data.dnd.after || this.data.dnd.before || this.data.dnd.inside) {\r\n						this._get_settings().dnd.drag_finish.call(this, { "o" : o, "r" : r, "p" : last_pos });\r\n					}\r\n				}\r\n				else {\r\n					this.dnd_prepare();\r\n					this.move_node(o, r, last_pos, e[this._get_settings().dnd.copy_modifier + "Key"]);\r\n				}\r\n				o = false;\r\n				r = false;\r\n				m.hide();\r\n				if(ml) { ml.hide(); }\r\n			},\r\n			dnd_enter : function (obj) {\r\n				if(this.data.dnd.mto) { \r\n					clearTimeout(this.data.dnd.mto);\r\n					this.data.dnd.mto = false;\r\n				}\r\n				var s = this._get_settings().dnd;\r\n				this.data.dnd.prepared = false;\r\n				r = this._get_node(obj);\r\n				if(s.check_timeout) { \r\n					// do the calculations after a minimal timeout (users tend to drag quickly to the desired location)\r\n					if(this.data.dnd.to1) { clearTimeout(this.data.dnd.to1); }\r\n					this.data.dnd.to1 = setTimeout($.proxy(this.dnd_prepare, this), s.check_timeout); \r\n				}\r\n				else { \r\n					this.dnd_prepare(); \r\n				}\r\n				if(s.open_timeout) { \r\n					if(this.data.dnd.to2) { clearTimeout(this.data.dnd.to2); }\r\n					if(r && r.length && r.hasClass("jstree-closed")) { \r\n						// if the node is closed - open it, then recalculate\r\n						this.data.dnd.to2 = setTimeout($.proxy(this.dnd_open, this), s.open_timeout);\r\n					}\r\n				}\r\n				else {\r\n					if(r && r.length && r.hasClass("jstree-closed")) { \r\n						this.dnd_open();\r\n					}\r\n				}\r\n			},\r\n			dnd_leave : function (e) {\r\n				this.data.dnd.after		= false;\r\n				this.data.dnd.before	= false;\r\n				this.data.dnd.inside	= false;\r\n				$.vakata.dnd.helper.children("ins").attr("class","jstree-invalid");\r\n				m.hide();\r\n				if(ml) { ml.hide(); }\r\n				if(r && r[0] === e.target.parentNode) {\r\n					if(this.data.dnd.to1) {\r\n						clearTimeout(this.data.dnd.to1);\r\n						this.data.dnd.to1 = false;\r\n					}\r\n					if(this.data.dnd.to2) {\r\n						clearTimeout(this.data.dnd.to2);\r\n						this.data.dnd.to2 = false;\r\n					}\r\n				}\r\n			},\r\n			start_drag : function (obj, e) {\r\n				o = this._get_node(obj);\r\n				if(this.data.ui && this.is_selected(o)) { o = this._get_node(null, true); }\r\n				var dt = o.length > 1 ? this._get_string("multiple_selection") : this.get_text(o),\r\n					cnt = this.get_container();\r\n				if(!this._get_settings().core.html_titles) { dt = dt.replace(/</ig,"&lt;").replace(/>/ig,"&gt;"); }\r\n				$.vakata.dnd.drag_start(e, { jstree : true, obj : o }, "<ins class=\'jstree-icon\'></ins>" + dt );\r\n				if(this.data.themes) { \r\n					if(m) { m.attr("class", "jstree-" + this.data.themes.theme); }\r\n					if(ml) { ml.attr("class", "jstree-" + this.data.themes.theme); }\r\n					$.vakata.dnd.helper.attr("class", "jstree-dnd-helper jstree-" + this.data.themes.theme); \r\n				}\r\n				this.data.dnd.cof = cnt.offset();\r\n				this.data.dnd.cw = parseInt(cnt.width(),10);\r\n				this.data.dnd.ch = parseInt(cnt.height(),10);\r\n				this.data.dnd.active = true;\r\n			}\r\n		}\r\n	});\r\n	$(function() {\r\n		var css_string = \'\' + \r\n			\'#vakata-dragged ins { display:block; text-decoration:none; width:16px; height:16px; margin:0 0 0 0; padding:0; position:absolute; top:4px; left:4px; \' + \r\n			\' -moz-border-radius:4px; border-radius:4px; -webkit-border-radius:4px; \' +\r\n			\'} \' + \r\n			\'#vakata-dragged .jstree-ok { background:green; } \' + \r\n			\'#vakata-dragged .jstree-invalid { background:red; } \' + \r\n			\'#jstree-marker { padding:0; margin:0; font-size:12px; overflow:hidden; height:12px; width:8px; position:absolute; top:-30px; z-index:10001; background-repeat:no-repeat; display:none; background-color:transparent; text-shadow:1px 1px 1px white; color:black; line-height:10px; } \' + \r\n			\'#jstree-marker-line { padding:0; margin:0; line-height:0%; font-size:1px; overflow:hidden; height:1px; width:100px; position:absolute; top:-30px; z-index:10000; background-repeat:no-repeat; display:none; background-color:#456c43; \' + \r\n			\' cursor:pointer; border:1px solid #eeeeee; border-left:0; -moz-box-shadow: 0px 0px 2px #666; -webkit-box-shadow: 0px 0px 2px #666; box-shadow: 0px 0px 2px #666; \' + \r\n			\' -moz-border-radius:1px; border-radius:1px; -webkit-border-radius:1px; \' +\r\n			\'}\' + \r\n			\'\';\r\n		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });\r\n		m = $("<div />").attr({ id : "jstree-marker" }).hide().html("&raquo;")\r\n			.bind("mouseleave mouseenter", function (e) { \r\n				m.hide();\r\n				ml.hide();\r\n				e.preventDefault(); \r\n				e.stopImmediatePropagation(); \r\n				return false; \r\n			})\r\n			.appendTo("body");\r\n		ml = $("<div />").attr({ id : "jstree-marker-line" }).hide()\r\n			.bind("mouseup", function (e) { \r\n				if(r && r.length) { \r\n					r.children("a").trigger(e); \r\n					e.preventDefault(); \r\n					e.stopImmediatePropagation(); \r\n					return false; \r\n				} \r\n			})\r\n			.bind("mouseleave", function (e) { \r\n				var rt = $(e.relatedTarget);\r\n				if(rt.is(".jstree") || rt.closest(".jstree").length === 0) {\r\n					if(r && r.length) { \r\n						r.children("a").trigger(e); \r\n						m.hide();\r\n						ml.hide();\r\n						e.preventDefault(); \r\n						e.stopImmediatePropagation(); \r\n						return false; \r\n					}\r\n				}\r\n			})\r\n			.appendTo("body");\r\n		$(document).bind("drag_start.vakata", function (e, data) {\r\n			if(data.data.jstree) { m.show(); if(ml) { ml.show(); } }\r\n		});\r\n		$(document).bind("drag_stop.vakata", function (e, data) {\r\n			if(data.data.jstree) { m.hide(); if(ml) { ml.hide(); } }\r\n		});\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/*\r\n * jsTree checkbox plugin\r\n * Inserts checkboxes in front of every node\r\n * Depends on the ui plugin\r\n * DOES NOT WORK NICELY WITH MULTITREE DRAG\'N\'DROP\r\n */\r\n(function ($) {\r\n	$.jstree.plugin("checkbox", {\r\n		__init : function () {\r\n			this.data.checkbox.noui = this._get_settings().checkbox.override_ui;\r\n			if(this.data.ui && this.data.checkbox.noui) {\r\n				this.select_node = this.deselect_node = this.deselect_all = $.noop;\r\n				this.get_selected = this.get_checked;\r\n			}\r\n\r\n			this.get_container()\r\n				.bind("open_node.jstree create_node.jstree clean_node.jstree refresh.jstree", $.proxy(function (e, data) { \r\n						this._prepare_checkboxes(data.rslt.obj);\r\n					}, this))\r\n				.bind("loaded.jstree", $.proxy(function (e) {\r\n						this._prepare_checkboxes();\r\n					}, this))\r\n				.delegate( (this.data.ui && this.data.checkbox.noui ? "a" : "ins.jstree-checkbox") , "click.jstree", $.proxy(function (e) {\r\n						e.preventDefault();\r\n						if(this._get_node(e.target).hasClass("jstree-checked")) { this.uncheck_node(e.target); }\r\n						else { this.check_node(e.target); }\r\n						if(this.data.ui && this.data.checkbox.noui) {\r\n							this.save_selected();\r\n							if(this.data.cookies) { this.save_cookie("select_node"); }\r\n						}\r\n						else {\r\n							e.stopImmediatePropagation();\r\n							return false;\r\n						}\r\n					}, this));\r\n		},\r\n		defaults : {\r\n			override_ui : false,\r\n			two_state : false,\r\n			real_checkboxes : false,\r\n			checked_parent_open : true,\r\n			real_checkboxes_names : function (n) { return [ ("check_" + (n[0].id || Math.ceil(Math.random() * 10000))) , 1]; }\r\n		},\r\n		__destroy : function () {\r\n			this.get_container()\r\n				.find("input.jstree-real-checkbox").removeClass("jstree-real-checkbox").end()\r\n				.find("ins.jstree-checkbox").remove();\r\n		},\r\n		_fn : {\r\n			_checkbox_notify : function (n, data) {\r\n				if(data.checked) {\r\n					this.check_node(n, false);\r\n				}\r\n			},\r\n			_prepare_checkboxes : function (obj) {\r\n				obj = !obj || obj == -1 ? this.get_container().find("> ul > li") : this._get_node(obj);\r\n				if(obj === false) { return; } // added for removing root nodes\r\n				var c, _this = this, t, ts = this._get_settings().checkbox.two_state, rc = this._get_settings().checkbox.real_checkboxes, rcn = this._get_settings().checkbox.real_checkboxes_names;\r\n				obj.each(function () {\r\n					t = $(this);\r\n					c = t.is("li") && (t.hasClass("jstree-checked") || (rc && t.children(":checked").length)) ? "jstree-checked" : "jstree-unchecked";\r\n					t.find("li").addBack().each(function () {\r\n						var $t = $(this), nm;\r\n						$t.children("a" + (_this.data.languages ? "" : ":eq(0)") ).not(":has(.jstree-checkbox)").prepend("<ins class=\'jstree-checkbox\'>&#160;</ins>").parent().not(".jstree-checked, .jstree-unchecked").addClass( ts ? "jstree-unchecked" : c );\r\n						if(rc) {\r\n							if(!$t.children("[type=checkbox]").length) {\r\n								nm = rcn.call(_this, $t);\r\n								$t.prepend("<input type=\'checkbox\' class=\'jstree-real-checkbox\' id=\'" + nm[0] + "\' name=\'" + nm[0] + "\' value=\'" + nm[1] + "\' />");\r\n							}\r\n							else {\r\n								$t.children("[type=checkbox]").addClass("jstree-real-checkbox");\r\n							}\r\n						}\r\n						if(!ts) {\r\n							if(c === "jstree-checked" || $t.hasClass("jstree-checked") || $t.children(\':checked\').length) {\r\n								$t.find("li").addBack().addClass("jstree-checked").children("[type=checkbox]").prop("checked", true);\r\n							}\r\n						}\r\n						else {\r\n							if($t.hasClass("jstree-checked") || $t.children(\':checked\').length) {\r\n								$t.addClass("jstree-checked").children("[type=checkbox]").prop("checked", true);\r\n							}\r\n						}\r\n					});\r\n				});\r\n				if(!ts) {\r\n					obj.find(".jstree-checked").parent().parent().each(function () { _this._repair_state(this); }); \r\n				}\r\n			},\r\n			change_state : function (obj, state) {\r\n				obj = this._get_node(obj);\r\n				var coll = false, rc = this._get_settings().checkbox.real_checkboxes;\r\n				if(!obj || obj === -1) { return false; }\r\n				state = (state === false || state === true) ? state : obj.hasClass("jstree-checked");\r\n				if(this._get_settings().checkbox.two_state) {\r\n					if(state) { \r\n						obj.removeClass("jstree-checked").addClass("jstree-unchecked"); \r\n						if(rc) { obj.children("[type=checkbox]").prop("checked", false); }\r\n					}\r\n					else { \r\n						obj.removeClass("jstree-unchecked").addClass("jstree-checked"); \r\n						if(rc) { obj.children("[type=checkbox]").prop("checked", true); }\r\n					}\r\n				}\r\n				else {\r\n					if(state) { \r\n						coll = obj.find("li").addBack();\r\n						if(!coll.filter(".jstree-checked, .jstree-undetermined").length) { return false; }\r\n						coll.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked"); \r\n						if(rc) { coll.children("[type=checkbox]").prop("checked", false); }\r\n					}\r\n					else { \r\n						coll = obj.find("li").addBack();\r\n						if(!coll.filter(".jstree-unchecked, .jstree-undetermined").length) { return false; }\r\n						coll.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked"); \r\n						if(rc) { coll.children("[type=checkbox]").prop("checked", true); }\r\n						if(this.data.ui) { this.data.ui.last_selected = obj; }\r\n						this.data.checkbox.last_selected = obj;\r\n					}\r\n					obj.parentsUntil(".jstree", "li").each(function () {\r\n						var $this = $(this);\r\n						if(state) {\r\n							if($this.children("ul").children("li.jstree-checked, li.jstree-undetermined").length) {\r\n								$this.parentsUntil(".jstree", "li").addBack().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");\r\n								if(rc) { $this.parentsUntil(".jstree", "li").addBack().children("[type=checkbox]").prop("checked", false); }\r\n								return false;\r\n							}\r\n							else {\r\n								$this.removeClass("jstree-checked jstree-undetermined").addClass("jstree-unchecked");\r\n								if(rc) { $this.children("[type=checkbox]").prop("checked", false); }\r\n							}\r\n						}\r\n						else {\r\n							if($this.children("ul").children("li.jstree-unchecked, li.jstree-undetermined").length) {\r\n								$this.parentsUntil(".jstree", "li").addBack().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");\r\n								if(rc) { $this.parentsUntil(".jstree", "li").addBack().children("[type=checkbox]").prop("checked", false); }\r\n								return false;\r\n							}\r\n							else {\r\n								$this.removeClass("jstree-unchecked jstree-undetermined").addClass("jstree-checked");\r\n								if(rc) { $this.children("[type=checkbox]").prop("checked", true); }\r\n							}\r\n						}\r\n					});\r\n				}\r\n				if(this.data.ui && this.data.checkbox.noui) { this.data.ui.selected = this.get_checked(); }\r\n				this.__callback(obj);\r\n				return true;\r\n			},\r\n			check_node : function (obj) {\r\n				if(this.change_state(obj, false)) { \r\n					obj = this._get_node(obj);\r\n					if(this._get_settings().checkbox.checked_parent_open) {\r\n						var t = this;\r\n						obj.parents(".jstree-closed").each(function () { t.open_node(this, false, true); });\r\n					}\r\n					this.__callback({ "obj" : obj }); \r\n				}\r\n			},\r\n			uncheck_node : function (obj) {\r\n				if(this.change_state(obj, true)) { this.__callback({ "obj" : this._get_node(obj) }); }\r\n			},\r\n			check_all : function () {\r\n				var _this = this, \r\n					coll = this._get_settings().checkbox.two_state ? this.get_container_ul().find("li") : this.get_container_ul().children("li");\r\n				coll.each(function () {\r\n					_this.change_state(this, false);\r\n				});\r\n				this.__callback();\r\n			},\r\n			uncheck_all : function () {\r\n				var _this = this,\r\n					coll = this._get_settings().checkbox.two_state ? this.get_container_ul().find("li") : this.get_container_ul().children("li");\r\n				coll.each(function () {\r\n					_this.change_state(this, true);\r\n				});\r\n				this.__callback();\r\n			},\r\n\r\n			is_checked : function(obj) {\r\n				obj = this._get_node(obj);\r\n				return obj.length ? obj.is(".jstree-checked") : false;\r\n			},\r\n			get_checked : function (obj, get_all) {\r\n				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);\r\n				return get_all || this._get_settings().checkbox.two_state ? obj.find(".jstree-checked") : obj.find("> ul > .jstree-checked, .jstree-undetermined > ul > .jstree-checked");\r\n			},\r\n			get_unchecked : function (obj, get_all) { \r\n				obj = !obj || obj === -1 ? this.get_container() : this._get_node(obj);\r\n				return get_all || this._get_settings().checkbox.two_state ? obj.find(".jstree-unchecked") : obj.find("> ul > .jstree-unchecked, .jstree-undetermined > ul > .jstree-unchecked");\r\n			},\r\n\r\n			show_checkboxes : function () { this.get_container().children("ul").removeClass("jstree-no-checkboxes"); },\r\n			hide_checkboxes : function () { this.get_container().children("ul").addClass("jstree-no-checkboxes"); },\r\n\r\n			_repair_state : function (obj) {\r\n				obj = this._get_node(obj);\r\n				if(!obj.length) { return; }\r\n				if(this._get_settings().checkbox.two_state) {\r\n					obj.find(\'li\').addBack().not(\'.jstree-checked\').removeClass(\'jstree-undetermined\').addClass(\'jstree-unchecked\').children("[type=checkbox]").prop(\'checked\', true);\r\n					return;\r\n				}\r\n				var rc = this._get_settings().checkbox.real_checkboxes,\r\n					a = obj.find("> ul > .jstree-checked").length,\r\n					b = obj.find("> ul > .jstree-undetermined").length,\r\n					c = obj.find("> ul > li").length;\r\n				if(c === 0) { if(obj.hasClass("jstree-undetermined")) { this.change_state(obj, false); } }\r\n				else if(a === 0 && b === 0) { this.change_state(obj, true); }\r\n				else if(a === c) { this.change_state(obj, false); }\r\n				else { \r\n					obj.parentsUntil(".jstree","li").addBack().removeClass("jstree-checked jstree-unchecked").addClass("jstree-undetermined");\r\n					if(rc) { obj.parentsUntil(".jstree", "li").addBack().children("[type=checkbox]").prop("checked", false); }\r\n				}\r\n			},\r\n			reselect : function () {\r\n				if(this.data.ui && this.data.checkbox.noui) { \r\n					var _this = this,\r\n						s = this.data.ui.to_select;\r\n					s = $.map($.makeArray(s), function (n) { return "#" + n.toString().replace(/^#/,"").replace(/\\\\\\//g,"/").replace(/\\//g,"\\\\\\/").replace(/\\\\\\./g,".").replace(/\\./g,"\\\\.").replace(/\\:/g,"\\\\:"); });\r\n					this.deselect_all();\r\n					$.each(s, function (i, val) { _this.check_node(val); });\r\n					this.__callback();\r\n				}\r\n				else { \r\n					this.__call_old(); \r\n				}\r\n			},\r\n			save_loaded : function () {\r\n				var _this = this;\r\n				this.data.core.to_load = [];\r\n				this.get_container_ul().find("li.jstree-closed.jstree-undetermined").each(function () {\r\n					if(this.id) { _this.data.core.to_load.push("#" + this.id); }\r\n				});\r\n			}\r\n		}\r\n	});\r\n	$(function() {\r\n		var css_string = \'.jstree .jstree-real-checkbox { display:none; } \';\r\n		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/* \r\n * jsTree XML plugin\r\n * The XML data store. Datastores are build by overriding the `load_node` and `_is_loaded` functions.\r\n */\r\n(function ($) {\r\n	$.vakata.xslt = function (xml, xsl, callback) {\r\n		var rs = "", xm, xs, processor, support;\r\n		// TODO: IE9 no XSLTProcessor, no document.recalc\r\n		if(document.recalc) {\r\n			xm = document.createElement(\'xml\');\r\n			xs = document.createElement(\'xml\');\r\n			xm.innerHTML = xml;\r\n			xs.innerHTML = xsl;\r\n			$("body").append(xm).append(xs);\r\n			setTimeout( (function (xm, xs, callback) {\r\n				return function () {\r\n					callback.call(null, xm.transformNode(xs.XMLDocument));\r\n					setTimeout( (function (xm, xs) { return function () { $(xm).remove(); $(xs).remove(); }; })(xm, xs), 200);\r\n				};\r\n			})(xm, xs, callback), 100);\r\n			return true;\r\n		}\r\n		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor === "undefined") {\r\n			xml = new DOMParser().parseFromString(xml, "text/xml");\r\n			xsl = new DOMParser().parseFromString(xsl, "text/xml");\r\n			// alert(xml.transformNode());\r\n			// callback.call(null, new XMLSerializer().serializeToString(rs));\r\n			\r\n		}\r\n		if(typeof window.DOMParser !== "undefined" && typeof window.XMLHttpRequest !== "undefined" && typeof window.XSLTProcessor !== "undefined") {\r\n			processor = new XSLTProcessor();\r\n			support = $.isFunction(processor.transformDocument) ? (typeof window.XMLSerializer !== "undefined") : true;\r\n			if(!support) { return false; }\r\n			xml = new DOMParser().parseFromString(xml, "text/xml");\r\n			xsl = new DOMParser().parseFromString(xsl, "text/xml");\r\n			if($.isFunction(processor.transformDocument)) {\r\n				rs = document.implementation.createDocument("", "", null);\r\n				processor.transformDocument(xml, xsl, rs, null);\r\n				callback.call(null, new XMLSerializer().serializeToString(rs));\r\n				return true;\r\n			}\r\n			else {\r\n				processor.importStylesheet(xsl);\r\n				rs = processor.transformToFragment(xml, document);\r\n				callback.call(null, $("<div />").append(rs).html());\r\n				return true;\r\n			}\r\n		}\r\n		return false;\r\n	};\r\n	var xsl = {\r\n		\'nest\' : \'<\' + \'?xml version="1.0" encoding="utf-8" ?>\' + \r\n			\'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >\' + \r\n			\'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/html" />\' + \r\n			\'<xsl:template match="/">\' + \r\n			\'	<xsl:call-template name="nodes">\' + \r\n			\'		<xsl:with-param name="node" select="/root" />\' + \r\n			\'	</xsl:call-template>\' + \r\n			\'</xsl:template>\' + \r\n			\'<xsl:template name="nodes">\' + \r\n			\'	<xsl:param name="node" />\' + \r\n			\'	<ul>\' + \r\n			\'	<xsl:for-each select="$node/item">\' + \r\n			\'		<xsl:variable name="children" select="count(./item) &gt; 0" />\' + \r\n			\'		<li>\' + \r\n			\'			<xsl:attribute name="class">\' + \r\n			\'				<xsl:if test="position() = last()">jstree-last </xsl:if>\' + \r\n			\'				<xsl:choose>\' + \r\n			\'					<xsl:when test="@state = \\\'open\\\'">jstree-open </xsl:when>\' + \r\n			\'					<xsl:when test="$children or @hasChildren or @state = \\\'closed\\\'">jstree-closed </xsl:when>\' + \r\n			\'					<xsl:otherwise>jstree-leaf </xsl:otherwise>\' + \r\n			\'				</xsl:choose>\' + \r\n			\'				<xsl:value-of select="@class" />\' + \r\n			\'			</xsl:attribute>\' + \r\n			\'			<xsl:for-each select="@*">\' + \r\n			\'				<xsl:if test="name() != \\\'class\\\' and name() != \\\'state\\\' and name() != \\\'hasChildren\\\'">\' + \r\n			\'					<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>\' + \r\n			\'				</xsl:if>\' + \r\n			\'			</xsl:for-each>\' + \r\n			\'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>\' + \r\n			\'			<xsl:for-each select="content/name">\' + \r\n			\'				<a>\' + \r\n			\'				<xsl:attribute name="href">\' + \r\n			\'					<xsl:choose>\' + \r\n			\'					<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>\' + \r\n			\'					<xsl:otherwise>#</xsl:otherwise>\' + \r\n			\'					</xsl:choose>\' + \r\n			\'				</xsl:attribute>\' + \r\n			\'				<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>\' + \r\n			\'				<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>\' + \r\n			\'				<xsl:for-each select="@*">\' + \r\n			\'					<xsl:if test="name() != \\\'style\\\' and name() != \\\'class\\\' and name() != \\\'href\\\'">\' + \r\n			\'						<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>\' + \r\n			\'					</xsl:if>\' + \r\n			\'				</xsl:for-each>\' + \r\n			\'					<ins>\' + \r\n			\'						<xsl:attribute name="class">jstree-icon \' + \r\n			\'							<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\\\'/\\\'))"><xsl:value-of select="@icon" /></xsl:if>\' + \r\n			\'						</xsl:attribute>\' + \r\n			\'						<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\\\'/\\\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>\' + \r\n			\'						<xsl:text>&#xa0;</xsl:text>\' + \r\n			\'					</ins>\' + \r\n			\'					<xsl:copy-of select="./child::node()" />\' + \r\n			\'				</a>\' + \r\n			\'			</xsl:for-each>\' + \r\n			\'			<xsl:if test="$children or @hasChildren"><xsl:call-template name="nodes"><xsl:with-param name="node" select="current()" /></xsl:call-template></xsl:if>\' + \r\n			\'		</li>\' + \r\n			\'	</xsl:for-each>\' + \r\n			\'	</ul>\' + \r\n			\'</xsl:template>\' + \r\n			\'</xsl:stylesheet>\',\r\n\r\n		\'flat\' : \'<\' + \'?xml version="1.0" encoding="utf-8" ?>\' + \r\n			\'<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" >\' + \r\n			\'<xsl:output method="html" encoding="utf-8" omit-xml-declaration="yes" standalone="no" indent="no" media-type="text/xml" />\' + \r\n			\'<xsl:template match="/">\' + \r\n			\'	<ul>\' + \r\n			\'	<xsl:for-each select="//item[not(@parent_id) or @parent_id=0 or not(@parent_id = //item/@id)]">\' + /* the last `or` may be removed */\r\n			\'		<xsl:call-template name="nodes">\' + \r\n			\'			<xsl:with-param name="node" select="." />\' + \r\n			\'			<xsl:with-param name="is_last" select="number(position() = last())" />\' + \r\n			\'		</xsl:call-template>\' + \r\n			\'	</xsl:for-each>\' + \r\n			\'	</ul>\' + \r\n			\'</xsl:template>\' + \r\n			\'<xsl:template name="nodes">\' + \r\n			\'	<xsl:param name="node" />\' + \r\n			\'	<xsl:param name="is_last" />\' + \r\n			\'	<xsl:variable name="children" select="count(//item[@parent_id=$node/attribute::id]) &gt; 0" />\' + \r\n			\'	<li>\' + \r\n			\'	<xsl:attribute name="class">\' + \r\n			\'		<xsl:if test="$is_last = true()">jstree-last </xsl:if>\' + \r\n			\'		<xsl:choose>\' + \r\n			\'			<xsl:when test="@state = \\\'open\\\'">jstree-open </xsl:when>\' + \r\n			\'			<xsl:when test="$children or @hasChildren or @state = \\\'closed\\\'">jstree-closed </xsl:when>\' + \r\n			\'			<xsl:otherwise>jstree-leaf </xsl:otherwise>\' + \r\n			\'		</xsl:choose>\' + \r\n			\'		<xsl:value-of select="@class" />\' + \r\n			\'	</xsl:attribute>\' + \r\n			\'	<xsl:for-each select="@*">\' + \r\n			\'		<xsl:if test="name() != \\\'parent_id\\\' and name() != \\\'hasChildren\\\' and name() != \\\'class\\\' and name() != \\\'state\\\'">\' + \r\n			\'		<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>\' + \r\n			\'		</xsl:if>\' + \r\n			\'	</xsl:for-each>\' + \r\n			\'	<ins class="jstree-icon"><xsl:text>&#xa0;</xsl:text></ins>\' + \r\n			\'	<xsl:for-each select="content/name">\' + \r\n			\'		<a>\' + \r\n			\'		<xsl:attribute name="href">\' + \r\n			\'			<xsl:choose>\' + \r\n			\'			<xsl:when test="@href"><xsl:value-of select="@href" /></xsl:when>\' + \r\n			\'			<xsl:otherwise>#</xsl:otherwise>\' + \r\n			\'			</xsl:choose>\' + \r\n			\'		</xsl:attribute>\' + \r\n			\'		<xsl:attribute name="class"><xsl:value-of select="@lang" /> <xsl:value-of select="@class" /></xsl:attribute>\' + \r\n			\'		<xsl:attribute name="style"><xsl:value-of select="@style" /></xsl:attribute>\' + \r\n			\'		<xsl:for-each select="@*">\' + \r\n			\'			<xsl:if test="name() != \\\'style\\\' and name() != \\\'class\\\' and name() != \\\'href\\\'">\' + \r\n			\'				<xsl:attribute name="{name()}"><xsl:value-of select="." /></xsl:attribute>\' + \r\n			\'			</xsl:if>\' + \r\n			\'		</xsl:for-each>\' + \r\n			\'			<ins>\' + \r\n			\'				<xsl:attribute name="class">jstree-icon \' + \r\n			\'					<xsl:if test="string-length(attribute::icon) > 0 and not(contains(@icon,\\\'/\\\'))"><xsl:value-of select="@icon" /></xsl:if>\' + \r\n			\'				</xsl:attribute>\' + \r\n			\'				<xsl:if test="string-length(attribute::icon) > 0 and contains(@icon,\\\'/\\\')"><xsl:attribute name="style">background:url(<xsl:value-of select="@icon" />) center center no-repeat;</xsl:attribute></xsl:if>\' + \r\n			\'				<xsl:text>&#xa0;</xsl:text>\' + \r\n			\'			</ins>\' + \r\n			\'			<xsl:copy-of select="./child::node()" />\' + \r\n			\'		</a>\' + \r\n			\'	</xsl:for-each>\' + \r\n			\'	<xsl:if test="$children">\' + \r\n			\'		<ul>\' + \r\n			\'		<xsl:for-each select="//item[@parent_id=$node/attribute::id]">\' + \r\n			\'			<xsl:call-template name="nodes">\' + \r\n			\'				<xsl:with-param name="node" select="." />\' + \r\n			\'				<xsl:with-param name="is_last" select="number(position() = last())" />\' + \r\n			\'			</xsl:call-template>\' + \r\n			\'		</xsl:for-each>\' + \r\n			\'		</ul>\' + \r\n			\'	</xsl:if>\' + \r\n			\'	</li>\' + \r\n			\'</xsl:template>\' + \r\n			\'</xsl:stylesheet>\'\r\n	},\r\n	escape_xml = function(string) {\r\n		return string\r\n			.toString()\r\n			.replace(/&/g, \'&amp;\')\r\n			.replace(/</g, \'&lt;\')\r\n			.replace(/>/g, \'&gt;\')\r\n			.replace(/"/g, \'&quot;\')\r\n			.replace(/\'/g, \'&apos;\');\r\n	};\r\n	$.jstree.plugin("xml_data", {\r\n		defaults : { \r\n			data : false,\r\n			ajax : false,\r\n			xsl : "flat",\r\n			clean_node : false,\r\n			correct_state : true,\r\n			get_skip_empty : false,\r\n			get_include_preamble : true\r\n		},\r\n		_fn : {\r\n			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_xml(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },\r\n			_is_loaded : function (obj) { \r\n				var s = this._get_settings().xml_data;\r\n				obj = this._get_node(obj);\r\n				return obj == -1 || !obj || (!s.ajax && !$.isFunction(s.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").length > 0;\r\n			},\r\n			load_node_xml : function (obj, s_call, e_call) {\r\n				var s = this.get_settings().xml_data,\r\n					error_func = function () {},\r\n					success_func = function () {};\r\n\r\n				obj = this._get_node(obj);\r\n				if(obj && obj !== -1) {\r\n					if(obj.data("jstree_is_loading")) { return; }\r\n					else { obj.data("jstree_is_loading",true); }\r\n				}\r\n				switch(!0) {\r\n					case (!s.data && !s.ajax): throw "Neither data nor ajax settings supplied.";\r\n					case ($.isFunction(s.data)):\r\n						s.data.call(this, obj, $.proxy(function (d) {\r\n							this.parse_xml(d, $.proxy(function (d) {\r\n								if(d) {\r\n									d = d.replace(/ ?xmlns="[^"]*"/ig, "");\r\n									if(d.length > 10) {\r\n										d = $(d);\r\n										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }\r\n										else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.removeData("jstree_is_loading"); }\r\n										if(s.clean_node) { this.clean_node(obj); }\r\n										if(s_call) { s_call.call(this); }\r\n									}\r\n									else {\r\n										if(obj && obj !== -1) { \r\n											obj.children("a.jstree-loading").removeClass("jstree-loading");\r\n											obj.removeData("jstree_is_loading");\r\n											if(s.correct_state) { \r\n												this.correct_state(obj);\r\n												if(s_call) { s_call.call(this); } \r\n											}\r\n										}\r\n										else {\r\n											if(s.correct_state) { \r\n												this.get_container().children("ul").empty();\r\n												if(s_call) { s_call.call(this); } \r\n											}\r\n										}\r\n									}\r\n								}\r\n							}, this));\r\n						}, this));\r\n						break;\r\n					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):\r\n						if(!obj || obj == -1) {\r\n							this.parse_xml(s.data, $.proxy(function (d) {\r\n								if(d) {\r\n									d = d.replace(/ ?xmlns="[^"]*"/ig, "");\r\n									if(d.length > 10) {\r\n										d = $(d);\r\n										this.get_container().children("ul").empty().append(d.children());\r\n										if(s.clean_node) { this.clean_node(obj); }\r\n										if(s_call) { s_call.call(this); }\r\n									}\r\n								}\r\n								else { \r\n									if(s.correct_state) { \r\n										this.get_container().children("ul").empty(); \r\n										if(s_call) { s_call.call(this); }\r\n									}\r\n								}\r\n							}, this));\r\n						}\r\n						break;\r\n					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):\r\n						error_func = function (x, t, e) {\r\n							var ef = this.get_settings().xml_data.ajax.error; \r\n							if(ef) { ef.call(this, x, t, e); }\r\n							if(obj !== -1 && obj.length) {\r\n								obj.children("a.jstree-loading").removeClass("jstree-loading");\r\n								obj.removeData("jstree_is_loading");\r\n								if(t === "success" && s.correct_state) { this.correct_state(obj); }\r\n							}\r\n							else {\r\n								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }\r\n							}\r\n							if(e_call) { e_call.call(this); }\r\n						};\r\n						success_func = function (d, t, x) {\r\n							d = x.responseText;\r\n							var sf = this.get_settings().xml_data.ajax.success; \r\n							if(sf) { d = sf.call(this,d,t,x) || d; }\r\n							if(d === "" || (d && d.toString && d.toString().replace(/^[\\s\\n]+$/,"") === "")) {\r\n								return error_func.call(this, x, t, "");\r\n							}\r\n							this.parse_xml(d, $.proxy(function (d) {\r\n								if(d) {\r\n									d = d.replace(/ ?xmlns="[^"]*"/ig, "");\r\n									if(d.length > 10) {\r\n										d = $(d);\r\n										if(obj === -1 || !obj) { this.get_container().children("ul").empty().append(d.children()); }\r\n										else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d); obj.removeData("jstree_is_loading"); }\r\n										if(s.clean_node) { this.clean_node(obj); }\r\n										if(s_call) { s_call.call(this); }\r\n									}\r\n									else {\r\n										if(obj && obj !== -1) { \r\n											obj.children("a.jstree-loading").removeClass("jstree-loading");\r\n											obj.removeData("jstree_is_loading");\r\n											if(s.correct_state) { \r\n												this.correct_state(obj);\r\n												if(s_call) { s_call.call(this); } \r\n											}\r\n										}\r\n										else {\r\n											if(s.correct_state) { \r\n												this.get_container().children("ul").empty();\r\n												if(s_call) { s_call.call(this); } \r\n											}\r\n										}\r\n									}\r\n								}\r\n							}, this));\r\n						};\r\n						s.ajax.context = this;\r\n						s.ajax.error = error_func;\r\n						s.ajax.success = success_func;\r\n						if(!s.ajax.dataType) { s.ajax.dataType = "xml"; }\r\n						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }\r\n						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }\r\n						$.ajax(s.ajax);\r\n						break;\r\n				}\r\n			},\r\n			parse_xml : function (xml, callback) {\r\n				var s = this._get_settings().xml_data;\r\n				$.vakata.xslt(xml, xsl[s.xsl], callback);\r\n			},\r\n			get_xml : function (tp, obj, li_attr, a_attr, is_callback) {\r\n				var result = "", \r\n					s = this._get_settings(), \r\n					_this = this,\r\n					tmp1, tmp2, li, a, lang;\r\n				if(!tp) { tp = "flat"; }\r\n				if(!is_callback) { is_callback = 0; }\r\n				obj = this._get_node(obj);\r\n				if(!obj || obj === -1) { obj = this.get_container().find("> ul > li"); }\r\n				li_attr = $.isArray(li_attr) ? li_attr : [ "id", "class" ];\r\n				if(!is_callback && this.data.types && $.inArray(s.types.type_attr, li_attr) === -1) { li_attr.push(s.types.type_attr); }\r\n\r\n				a_attr = $.isArray(a_attr) ? a_attr : [ ];\r\n\r\n				if(!is_callback) { \r\n					if(s.xml_data.get_include_preamble) { \r\n						result += \'<\' + \'?xml version="1.0" encoding="UTF-8"?\' + \'>\'; \r\n					}\r\n					result += "<root>"; \r\n				}\r\n				obj.each(function () {\r\n					result += "<item";\r\n					li = $(this);\r\n					$.each(li_attr, function (i, v) { \r\n						var t = li.attr(v);\r\n						if(!s.xml_data.get_skip_empty || typeof t !== "undefined") {\r\n							result += " " + v + "=\\"" + escape_xml((" " + (t || "")).replace(/ jstree[^ ]*/ig,\'\').replace(/\\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + "\\""; \r\n						}\r\n					});\r\n					if(li.hasClass("jstree-open")) { result += " state=\\"open\\""; }\r\n					if(li.hasClass("jstree-closed")) { result += " state=\\"closed\\""; }\r\n					if(tp === "flat") { result += " parent_id=\\"" + escape_xml(is_callback) + "\\""; }\r\n					result += ">";\r\n					result += "<content>";\r\n					a = li.children("a");\r\n					a.each(function () {\r\n						tmp1 = $(this);\r\n						lang = false;\r\n						result += "<name";\r\n						if($.inArray("languages", s.plugins) !== -1) {\r\n							$.each(s.languages, function (k, z) {\r\n								if(tmp1.hasClass(z)) { result += " lang=\\"" + escape_xml(z) + "\\""; lang = z; return false; }\r\n							});\r\n						}\r\n						if(a_attr.length) { \r\n							$.each(a_attr, function (k, z) {\r\n								var t = tmp1.attr(z);\r\n								if(!s.xml_data.get_skip_empty || typeof t !== "undefined") {\r\n									result += " " + z + "=\\"" + escape_xml((" " + t || "").replace(/ jstree[^ ]*/ig,\'\').replace(/\\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + "\\"";\r\n								}\r\n							});\r\n						}\r\n						if(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,\'\').replace(/^\\s+$/ig,"").length) {\r\n							result += \' icon="\' + escape_xml(tmp1.children("ins").get(0).className.replace(/jstree[^ ]*|$/ig,\'\').replace(/\\s+$/ig," ").replace(/^ /,"").replace(/ $/,"")) + \'"\';\r\n						}\r\n						if(tmp1.children("ins").get(0).style.backgroundImage.length) {\r\n							result += \' icon="\' + escape_xml(tmp1.children("ins").get(0).style.backgroundImage.replace("url(","").replace(")","").replace(/\'/ig,"").replace(/"/ig,"")) + \'"\';\r\n						}\r\n						result += ">";\r\n						result += "<![CDATA[" + _this.get_text(tmp1, lang) + "]]>";\r\n						result += "</name>";\r\n					});\r\n					result += "</content>";\r\n					tmp2 = li[0].id || true;\r\n					li = li.find("> ul > li");\r\n					if(li.length) { tmp2 = _this.get_xml(tp, li, li_attr, a_attr, tmp2); }\r\n					else { tmp2 = ""; }\r\n					if(tp == "nest") { result += tmp2; }\r\n					result += "</item>";\r\n					if(tp == "flat") { result += tmp2; }\r\n				});\r\n				if(!is_callback) { result += "</root>"; }\r\n				return result;\r\n			}\r\n		}\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/*\r\n * jsTree search plugin\r\n * Enables both sync and async search on the tree\r\n * DOES NOT WORK WITH JSON PROGRESSIVE RENDER\r\n */\r\n(function ($) {\r\n	$.expr[\':\'].jstree_contains = function(a,i,m){\r\n		return (a.textContent || a.innerText || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;\r\n	};\r\n	$.expr[\':\'].jstree_title_contains = function(a,i,m) {\r\n		return (a.getAttribute("title") || "").toLowerCase().indexOf(m[3].toLowerCase())>=0;\r\n	};\r\n	$.jstree.plugin("search", {\r\n		__init : function () {\r\n			this.data.search.str = "";\r\n			this.data.search.result = $();\r\n			if(this._get_settings().search.show_only_matches) {\r\n				this.get_container()\r\n					.bind("search.jstree", function (e, data) {\r\n						$(this).children("ul").find("li").hide().removeClass("jstree-last");\r\n						data.rslt.nodes.parentsUntil(".jstree").addBack().show()\r\n							.filter("ul").each(function () { $(this).children("li:visible").eq(-1).addClass("jstree-last"); });\r\n					})\r\n					.bind("clear_search.jstree", function () {\r\n						$(this).children("ul").find("li").css("display","").end().end().jstree("clean_node", -1);\r\n					});\r\n			}\r\n		},\r\n		defaults : {\r\n			ajax : false,\r\n			search_method : "jstree_contains", // for case insensitive - jstree_contains\r\n			show_only_matches : false\r\n		},\r\n		_fn : {\r\n			search : function (str, skip_async) {\r\n				if($.trim(str) === "") { this.clear_search(); return; }\r\n				var s = this.get_settings().search, \r\n					t = this,\r\n					error_func = function () { },\r\n					success_func = function () { };\r\n				this.data.search.str = str;\r\n\r\n				if(!skip_async && s.ajax !== false && this.get_container_ul().find("li.jstree-closed:not(:has(ul)):eq(0)").length > 0) {\r\n					this.search.supress_callback = true;\r\n					error_func = function () { };\r\n					success_func = function (d, t, x) {\r\n						var sf = this.get_settings().search.ajax.success; \r\n						if(sf) { d = sf.call(this,d,t,x) || d; }\r\n						this.data.search.to_open = d;\r\n						this._search_open();\r\n					};\r\n					s.ajax.context = this;\r\n					s.ajax.error = error_func;\r\n					s.ajax.success = success_func;\r\n					if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, str); }\r\n					if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, str); }\r\n					if(!s.ajax.data) { s.ajax.data = { "search_string" : str }; }\r\n					if(!s.ajax.dataType || /^json/.exec(s.ajax.dataType)) { s.ajax.dataType = "json"; }\r\n					$.ajax(s.ajax);\r\n					return;\r\n				}\r\n				if(this.data.search.result.length) { this.clear_search(); }\r\n				this.data.search.result = this.get_container().find("a" + (this.data.languages ? "." + this.get_lang() : "" ) + ":" + (s.search_method) + "(" + this.data.search.str + ")");\r\n				this.data.search.result.addClass("jstree-search").parent().parents(".jstree-closed").each(function () {\r\n					t.open_node(this, false, true);\r\n				});\r\n				this.__callback({ nodes : this.data.search.result, str : str });\r\n			},\r\n			clear_search : function (str) {\r\n				this.data.search.result.removeClass("jstree-search");\r\n				this.__callback(this.data.search.result);\r\n				this.data.search.result = $();\r\n			},\r\n			_search_open : function (is_callback) {\r\n				var _this = this,\r\n					done = true,\r\n					current = [],\r\n					remaining = [];\r\n				if(this.data.search.to_open.length) {\r\n					$.each(this.data.search.to_open, function (i, val) {\r\n						if(val == "#") { return true; }\r\n						if($(val).length && $(val).is(".jstree-closed")) { current.push(val); }\r\n						else { remaining.push(val); }\r\n					});\r\n					if(current.length) {\r\n						this.data.search.to_open = remaining;\r\n						$.each(current, function (i, val) { \r\n							_this.open_node(val, function () { _this._search_open(true); }); \r\n						});\r\n						done = false;\r\n					}\r\n				}\r\n				if(done) { this.search(this.data.search.str, true); }\r\n			}\r\n		}\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/* \r\n * jsTree contextmenu plugin\r\n */\r\n(function ($) {\r\n	$.vakata.context = {\r\n		hide_on_mouseleave : false,\r\n\r\n		cnt		: $("<div id=\'vakata-contextmenu\' />"),\r\n		vis		: false,\r\n		tgt		: false,\r\n		par		: false,\r\n		func	: false,\r\n		data	: false,\r\n		rtl		: false,\r\n		show	: function (s, t, x, y, d, p, rtl) {\r\n			$.vakata.context.rtl = !!rtl;\r\n			var html = $.vakata.context.parse(s), h, w;\r\n			if(!html) { return; }\r\n			$.vakata.context.vis = true;\r\n			$.vakata.context.tgt = t;\r\n			$.vakata.context.par = p || t || null;\r\n			$.vakata.context.data = d || null;\r\n			$.vakata.context.cnt\r\n				.html(html)\r\n				.css({ "visibility" : "hidden", "display" : "block", "left" : 0, "top" : 0 });\r\n\r\n			if($.vakata.context.hide_on_mouseleave) {\r\n				$.vakata.context.cnt\r\n					.one("mouseleave", function(e) { $.vakata.context.hide(); });\r\n			}\r\n\r\n			h = $.vakata.context.cnt.height();\r\n			w = $.vakata.context.cnt.width();\r\n			if(x + w > $(document).width()) { \r\n				x = $(document).width() - (w + 5); \r\n				$.vakata.context.cnt.find("li > ul").addClass("right"); \r\n			}\r\n			if(y + h > $(document).height()) { \r\n				y = y - (h + t[0].offsetHeight); \r\n				$.vakata.context.cnt.find("li > ul").addClass("bottom"); \r\n			}\r\n\r\n			$.vakata.context.cnt\r\n				.css({ "left" : x, "top" : y })\r\n				.find("li:has(ul)")\r\n					.bind("mouseenter", function (e) { \r\n						var w = $(document).width(),\r\n							h = $(document).height(),\r\n							ul = $(this).children("ul").show(); \r\n						if(w !== $(document).width()) { ul.toggleClass("right"); }\r\n						if(h !== $(document).height()) { ul.toggleClass("bottom"); }\r\n					})\r\n					.bind("mouseleave", function (e) { \r\n						$(this).children("ul").hide(); \r\n					})\r\n					.end()\r\n				.css({ "visibility" : "visible" })\r\n				.show();\r\n			$(document).triggerHandler("context_show.vakata");\r\n		},\r\n		hide	: function () {\r\n			$.vakata.context.vis = false;\r\n			$.vakata.context.cnt.attr("class","").css({ "visibility" : "hidden" });\r\n			$(document).triggerHandler("context_hide.vakata");\r\n		},\r\n		parse	: function (s, is_callback) {\r\n			if(!s) { return false; }\r\n			var str = "",\r\n				tmp = false,\r\n				was_sep = true;\r\n			if(!is_callback) { $.vakata.context.func = {}; }\r\n			str += "<ul>";\r\n			$.each(s, function (i, val) {\r\n				if(!val) { return true; }\r\n				$.vakata.context.func[i] = val.action;\r\n				if(!was_sep && val.separator_before) {\r\n					str += "<li class=\'vakata-separator vakata-separator-before\'></li>";\r\n				}\r\n				was_sep = false;\r\n				str += "<li class=\'" + (val._class || "") + (val._disabled ? " jstree-contextmenu-disabled " : "") + "\'><ins ";\r\n				if(val.icon && val.icon.indexOf("/") === -1) { str += " class=\'" + val.icon + "\' "; }\r\n				if(val.icon && val.icon.indexOf("/") !== -1) { str += " style=\'background:url(" + val.icon + ") center center no-repeat;\' "; }\r\n				str += ">&#160;</ins><a href=\'#\' rel=\'" + i + "\'>";\r\n				if(val.submenu) {\r\n					str += "<span style=\'float:" + ($.vakata.context.rtl ? "left" : "right") + ";\'>&raquo;</span>";\r\n				}\r\n				str += val.label + "</a>";\r\n				if(val.submenu) {\r\n					tmp = $.vakata.context.parse(val.submenu, true);\r\n					if(tmp) { str += tmp; }\r\n				}\r\n				str += "</li>";\r\n				if(val.separator_after) {\r\n					str += "<li class=\'vakata-separator vakata-separator-after\'></li>";\r\n					was_sep = true;\r\n				}\r\n			});\r\n			str = str.replace(/<li class\\=\'vakata-separator vakata-separator-after\'\\><\\/li\\>$/,"");\r\n			str += "</ul>";\r\n			$(document).triggerHandler("context_parse.vakata");\r\n			return str.length > 10 ? str : false;\r\n		},\r\n		exec	: function (i) {\r\n			if($.isFunction($.vakata.context.func[i])) {\r\n				// if is string - eval and call it!\r\n				$.vakata.context.func[i].call($.vakata.context.data, $.vakata.context.par);\r\n				return true;\r\n			}\r\n			else { return false; }\r\n		}\r\n	};\r\n	$(function () {\r\n		var css_string = \'\' + \r\n			\'#vakata-contextmenu { display:block; visibility:hidden; left:0; top:-200px; position:absolute; margin:0; padding:0; min-width:180px; background:#ebebeb; border:1px solid silver; z-index:10000; *width:180px; } \' + \r\n			\'#vakata-contextmenu ul { min-width:180px; *width:180px; } \' + \r\n			\'#vakata-contextmenu ul, #vakata-contextmenu li { margin:0; padding:0; list-style-type:none; display:block; } \' + \r\n			\'#vakata-contextmenu li { line-height:20px; min-height:20px; position:relative; padding:0px; } \' + \r\n			\'#vakata-contextmenu li a { padding:1px 6px; line-height:17px; display:block; text-decoration:none; margin:1px 1px 0 1px; } \' + \r\n			\'#vakata-contextmenu li ins { float:left; width:16px; height:16px; text-decoration:none; margin-right:2px; } \' + \r\n			\'#vakata-contextmenu li a:hover, #vakata-contextmenu li.vakata-hover > a { background:gray; color:white; } \' + \r\n			\'#vakata-contextmenu li ul { display:none; position:absolute; top:-2px; left:100%; background:#ebebeb; border:1px solid gray; } \' + \r\n			\'#vakata-contextmenu .right { right:100%; left:auto; } \' + \r\n			\'#vakata-contextmenu .bottom { bottom:-1px; top:auto; } \' + \r\n			\'#vakata-contextmenu li.vakata-separator { min-height:0; height:1px; line-height:1px; font-size:1px; overflow:hidden; margin:0 2px; background:silver; /* border-top:1px solid #fefefe; */ padding:0; } \';\r\n		$.vakata.css.add_sheet({ str : css_string, title : "vakata" });\r\n		$.vakata.context.cnt\r\n			.delegate("a","click", function (e) { e.preventDefault(); })\r\n			.delegate("a","mouseup", function (e) {\r\n				if(!$(this).parent().hasClass("jstree-contextmenu-disabled") && $.vakata.context.exec($(this).attr("rel"))) {\r\n					$.vakata.context.hide();\r\n				}\r\n				else { $(this).blur(); }\r\n			})\r\n			.delegate("a","mouseover", function () {\r\n				$.vakata.context.cnt.find(".vakata-hover").removeClass("vakata-hover");\r\n			})\r\n			.appendTo("body");\r\n		$(document).bind("mousedown", function (e) { if($.vakata.context.vis && !$.contains($.vakata.context.cnt[0], e.target)) { $.vakata.context.hide(); } });\r\n		if(typeof $.hotkeys !== "undefined") {\r\n			$(document)\r\n				.bind("keydown", "up", function (e) { \r\n					if($.vakata.context.vis) { \r\n						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").prevAll("li:not(.vakata-separator)").first();\r\n						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").last(); }\r\n						o.addClass("vakata-hover");\r\n						e.stopImmediatePropagation(); \r\n						e.preventDefault();\r\n					} \r\n				})\r\n				.bind("keydown", "down", function (e) { \r\n					if($.vakata.context.vis) { \r\n						var o = $.vakata.context.cnt.find("ul:visible").last().children(".vakata-hover").removeClass("vakata-hover").nextAll("li:not(.vakata-separator)").first();\r\n						if(!o.length) { o = $.vakata.context.cnt.find("ul:visible").last().children("li:not(.vakata-separator)").first(); }\r\n						o.addClass("vakata-hover");\r\n						e.stopImmediatePropagation(); \r\n						e.preventDefault();\r\n					} \r\n				})\r\n				.bind("keydown", "right", function (e) { \r\n					if($.vakata.context.vis) { \r\n						$.vakata.context.cnt.find(".vakata-hover").children("ul").show().children("li:not(.vakata-separator)").removeClass("vakata-hover").first().addClass("vakata-hover");\r\n						e.stopImmediatePropagation(); \r\n						e.preventDefault();\r\n					} \r\n				})\r\n				.bind("keydown", "left", function (e) { \r\n					if($.vakata.context.vis) { \r\n						$.vakata.context.cnt.find(".vakata-hover").children("ul").hide().children(".vakata-separator").removeClass("vakata-hover");\r\n						e.stopImmediatePropagation(); \r\n						e.preventDefault();\r\n					} \r\n				})\r\n				.bind("keydown", "esc", function (e) { \r\n					$.vakata.context.hide(); \r\n					e.preventDefault();\r\n				})\r\n				.bind("keydown", "space", function (e) { \r\n					$.vakata.context.cnt.find(".vakata-hover").last().children("a").click();\r\n					e.preventDefault();\r\n				});\r\n		}\r\n	});\r\n\r\n	$.jstree.plugin("contextmenu", {\r\n		__init : function () {\r\n			this.get_container()\r\n				.delegate("a", "contextmenu.jstree", $.proxy(function (e) {\r\n						e.preventDefault();\r\n						if(!$(e.currentTarget).hasClass("jstree-loading")) {\r\n							this.show_contextmenu(e.currentTarget, e.pageX, e.pageY);\r\n						}\r\n					}, this))\r\n				.delegate("a", "click.jstree", $.proxy(function (e) {\r\n						if(this.data.contextmenu) {\r\n							$.vakata.context.hide();\r\n						}\r\n					}, this))\r\n				.bind("destroy.jstree", $.proxy(function () {\r\n						// TODO: move this to descruct method\r\n						if(this.data.contextmenu) {\r\n							$.vakata.context.hide();\r\n						}\r\n					}, this));\r\n			$(document).bind("context_hide.vakata", $.proxy(function () { this.data.contextmenu = false; }, this));\r\n		},\r\n		defaults : { \r\n			select_node : false, // requires UI plugin\r\n			show_at_node : true,\r\n			items : { // Could be a function that should return an object like this one\r\n				"create" : {\r\n					"separator_before"	: false,\r\n					"separator_after"	: true,\r\n					"label"				: "Create",\r\n					"action"			: function (obj) { this.create(obj); }\r\n				},\r\n				"rename" : {\r\n					"separator_before"	: false,\r\n					"separator_after"	: false,\r\n					"label"				: "Rename",\r\n					"action"			: function (obj) { this.rename(obj); }\r\n				},\r\n				"remove" : {\r\n					"separator_before"	: false,\r\n					"icon"				: false,\r\n					"separator_after"	: false,\r\n					"label"				: "Delete",\r\n					"action"			: function (obj) { if(this.is_selected(obj)) { this.remove(); } else { this.remove(obj); } }\r\n				},\r\n				"ccp" : {\r\n					"separator_before"	: true,\r\n					"icon"				: false,\r\n					"separator_after"	: false,\r\n					"label"				: "Edit",\r\n					"action"			: false,\r\n					"submenu" : { \r\n						"cut" : {\r\n							"separator_before"	: false,\r\n							"separator_after"	: false,\r\n							"label"				: "Cut",\r\n							"action"			: function (obj) { this.cut(obj); }\r\n						},\r\n						"copy" : {\r\n							"separator_before"	: false,\r\n							"icon"				: false,\r\n							"separator_after"	: false,\r\n							"label"				: "Copy",\r\n							"action"			: function (obj) { this.copy(obj); }\r\n						},\r\n						"paste" : {\r\n							"separator_before"	: false,\r\n							"icon"				: false,\r\n							"separator_after"	: false,\r\n							"label"				: "Paste",\r\n							"action"			: function (obj) { this.paste(obj); }\r\n						}\r\n					}\r\n				}\r\n			}\r\n		},\r\n		_fn : {\r\n			show_contextmenu : function (obj, x, y) {\r\n				obj = this._get_node(obj);\r\n				var s = this.get_settings().contextmenu,\r\n					a = obj.children("a:visible:eq(0)"),\r\n					o = false,\r\n					i = false;\r\n				if(s.select_node && this.data.ui && !this.is_selected(obj)) {\r\n					this.deselect_all();\r\n					this.select_node(obj, true);\r\n				}\r\n				if(s.show_at_node || typeof x === "undefined" || typeof y === "undefined") {\r\n					o = a.offset();\r\n					x = o.left;\r\n					y = o.top + this.data.core.li_height;\r\n				}\r\n				i = obj.data("jstree") && obj.data("jstree").contextmenu ? obj.data("jstree").contextmenu : s.items;\r\n				if($.isFunction(i)) { i = i.call(this, obj); }\r\n				this.data.contextmenu = true;\r\n				$.vakata.context.show(i, a, x, y, this, obj, this._get_settings().core.rtl);\r\n				if(this.data.themes) { $.vakata.context.cnt.attr("class", "jstree-" + this.data.themes.theme + "-context"); }\r\n			}\r\n		}\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/* \r\n * jsTree types plugin\r\n * Adds support types of nodes\r\n * You can set an attribute on each li node, that represents its type.\r\n * According to the type setting the node may get custom icon/validation rules\r\n */\r\n(function ($) {\r\n	$.jstree.plugin("types", {\r\n		__init : function () {\r\n			var s = this._get_settings().types;\r\n			this.data.types.attach_to = [];\r\n			this.get_container()\r\n				.bind("init.jstree", $.proxy(function () { \r\n						var types = s.types, \r\n							attr  = s.type_attr, \r\n							icons_css = "", \r\n							_this = this;\r\n\r\n						$.each(types, function (i, tp) {\r\n							$.each(tp, function (k, v) { \r\n								if(!/^(max_depth|max_children|icon|valid_children)$/.test(k)) { _this.data.types.attach_to.push(k); }\r\n							});\r\n							if(!tp.icon) { return true; }\r\n							if( tp.icon.image || tp.icon.position) {\r\n								if(i == "default")	{ icons_css += \'.jstree-\' + _this.get_index() + \' a > .jstree-icon { \'; }\r\n								else				{ icons_css += \'.jstree-\' + _this.get_index() + \' li[\' + attr + \'="\' + i + \'"] > a > .jstree-icon { \'; }\r\n								if(tp.icon.image)	{ icons_css += \' background-image:url(\' + tp.icon.image + \'); \'; }\r\n								if(tp.icon.position){ icons_css += \' background-position:\' + tp.icon.position + \'; \'; }\r\n								else				{ icons_css += \' background-position:0 0; \'; }\r\n								icons_css += \'} \';\r\n							}\r\n						});\r\n						if(icons_css !== "") { $.vakata.css.add_sheet({ \'str\' : icons_css, title : "jstree-types" }); }\r\n					}, this))\r\n				.bind("before.jstree", $.proxy(function (e, data) { \r\n						var s, t, \r\n							o = this._get_settings().types.use_data ? this._get_node(data.args[0]) : false, \r\n							d = o && o !== -1 && o.length ? o.data("jstree") : false;\r\n						if(d && d.types && d.types[data.func] === false) { e.stopImmediatePropagation(); return false; }\r\n						if($.inArray(data.func, this.data.types.attach_to) !== -1) {\r\n							if(!data.args[0] || (!data.args[0].tagName && !data.args[0].jquery)) { return; }\r\n							s = this._get_settings().types.types;\r\n							t = this._get_type(data.args[0]);\r\n							if(\r\n								( \r\n									(s[t] && typeof s[t][data.func] !== "undefined") || \r\n									(s["default"] && typeof s["default"][data.func] !== "undefined") \r\n								) && this._check(data.func, data.args[0]) === false\r\n							) {\r\n								e.stopImmediatePropagation();\r\n								return false;\r\n							}\r\n						}\r\n					}, this));\r\n			if(is_ie6) {\r\n				this.get_container()\r\n					.bind("load_node.jstree set_type.jstree", $.proxy(function (e, data) {\r\n							var r = data && data.rslt && data.rslt.obj && data.rslt.obj !== -1 ? this._get_node(data.rslt.obj).parent() : this.get_container_ul(),\r\n								c = false,\r\n								s = this._get_settings().types;\r\n							$.each(s.types, function (i, tp) {\r\n								if(tp.icon && (tp.icon.image || tp.icon.position)) {\r\n									c = i === "default" ? r.find("li > a > .jstree-icon") : r.find("li[" + s.type_attr + "=\'" + i + "\'] > a > .jstree-icon");\r\n									if(tp.icon.image) { c.css("backgroundImage","url(" + tp.icon.image + ")"); }\r\n									c.css("backgroundPosition", tp.icon.position || "0 0");\r\n								}\r\n							});\r\n						}, this));\r\n			}\r\n		},\r\n		defaults : {\r\n			// defines maximum number of root nodes (-1 means unlimited, -2 means disable max_children checking)\r\n			max_children		: -1,\r\n			// defines the maximum depth of the tree (-1 means unlimited, -2 means disable max_depth checking)\r\n			max_depth			: -1,\r\n			// defines valid node types for the root nodes\r\n			valid_children		: "all",\r\n\r\n			// whether to use $.data\r\n			use_data : false, \r\n			// where is the type stores (the rel attribute of the LI element)\r\n			type_attr : "rel",\r\n			// a list of types\r\n			types : {\r\n				// the default type\r\n				"default" : {\r\n					"max_children"	: -1,\r\n					"max_depth"		: -1,\r\n					"valid_children": "all"\r\n\r\n					// Bound functions - you can bind any other function here (using boolean or function)\r\n					//"select_node"	: true\r\n				}\r\n			}\r\n		},\r\n		_fn : {\r\n			_types_notify : function (n, data) {\r\n				if(data.type && this._get_settings().types.use_data) {\r\n					this.set_type(data.type, n);\r\n				}\r\n			},\r\n			_get_type : function (obj) {\r\n				obj = this._get_node(obj);\r\n				return (!obj || !obj.length) ? false : obj.attr(this._get_settings().types.type_attr) || "default";\r\n			},\r\n			set_type : function (str, obj) {\r\n				obj = this._get_node(obj);\r\n				var ret = (!obj.length || !str) ? false : obj.attr(this._get_settings().types.type_attr, str);\r\n				if(ret) { this.__callback({ obj : obj, type : str}); }\r\n				return ret;\r\n			},\r\n			_check : function (rule, obj, opts) {\r\n				obj = this._get_node(obj);\r\n				var v = false, t = this._get_type(obj), d = 0, _this = this, s = this._get_settings().types, data = false;\r\n				if(obj === -1) { \r\n					if(!!s[rule]) { v = s[rule]; }\r\n					else { return; }\r\n				}\r\n				else {\r\n					if(t === false) { return; }\r\n					data = s.use_data ? obj.data("jstree") : false;\r\n					if(data && data.types && typeof data.types[rule] !== "undefined") { v = data.types[rule]; }\r\n					else if(!!s.types[t] && typeof s.types[t][rule] !== "undefined") { v = s.types[t][rule]; }\r\n					else if(!!s.types["default"] && typeof s.types["default"][rule] !== "undefined") { v = s.types["default"][rule]; }\r\n				}\r\n				if($.isFunction(v)) { v = v.call(this, obj); }\r\n				if(rule === "max_depth" && obj !== -1 && opts !== false && s.max_depth !== -2 && v !== 0) {\r\n					// also include the node itself - otherwise if root node it is not checked\r\n					obj.children("a:eq(0)").parentsUntil(".jstree","li").each(function (i) {\r\n						// check if current depth already exceeds global tree depth\r\n						if(s.max_depth !== -1 && s.max_depth - (i + 1) <= 0) { v = 0; return false; }\r\n						d = (i === 0) ? v : _this._check(rule, this, false);\r\n						// check if current node max depth is already matched or exceeded\r\n						if(d !== -1 && d - (i + 1) <= 0) { v = 0; return false; }\r\n						// otherwise - set the max depth to the current value minus current depth\r\n						if(d >= 0 && (d - (i + 1) < v || v < 0) ) { v = d - (i + 1); }\r\n						// if the global tree depth exists and it minus the nodes calculated so far is less than `v` or `v` is unlimited\r\n						if(s.max_depth >= 0 && (s.max_depth - (i + 1) < v || v < 0) ) { v = s.max_depth - (i + 1); }\r\n					});\r\n				}\r\n				return v;\r\n			},\r\n			check_move : function () {\r\n				if(!this.__call_old()) { return false; }\r\n				var m  = this._get_move(),\r\n					s  = m.rt._get_settings().types,\r\n					mc = m.rt._check("max_children", m.cr),\r\n					md = m.rt._check("max_depth", m.cr),\r\n					vc = m.rt._check("valid_children", m.cr),\r\n					ch = 0, d = 1, t;\r\n\r\n				if(vc === "none") { return false; } \r\n				if($.isArray(vc) && m.ot && m.ot._get_type) {\r\n					m.o.each(function () {\r\n						if($.inArray(m.ot._get_type(this), vc) === -1) { d = false; return false; }\r\n					});\r\n					if(d === false) { return false; }\r\n				}\r\n				if(s.max_children !== -2 && mc !== -1) {\r\n					ch = m.cr === -1 ? this.get_container().find("> ul > li").not(m.o).length : m.cr.find("> ul > li").not(m.o).length;\r\n					if(ch + m.o.length > mc) { return false; }\r\n				}\r\n				if(s.max_depth !== -2 && md !== -1) {\r\n					d = 0;\r\n					if(md === 0) { return false; }\r\n					if(typeof m.o.d === "undefined") {\r\n						// TODO: deal with progressive rendering and async when checking max_depth (how to know the depth of the moved node)\r\n						t = m.o;\r\n						while(t.length > 0) {\r\n							t = t.find("> ul > li");\r\n							d ++;\r\n						}\r\n						m.o.d = d;\r\n					}\r\n					if(md - m.o.d < 0) { return false; }\r\n				}\r\n				return true;\r\n			},\r\n			create_node : function (obj, position, js, callback, is_loaded, skip_check) {\r\n				if(!skip_check && (is_loaded || this._is_loaded(obj))) {\r\n					var p  = (typeof position == "string" && position.match(/^before|after$/i) && obj !== -1) ? this._get_parent(obj) : this._get_node(obj),\r\n						s  = this._get_settings().types,\r\n						mc = this._check("max_children", p),\r\n						md = this._check("max_depth", p),\r\n						vc = this._check("valid_children", p),\r\n						ch;\r\n					if(typeof js === "string") { js = { data : js }; }\r\n					if(!js) { js = {}; }\r\n					if(vc === "none") { return false; } \r\n					if($.isArray(vc)) {\r\n						if(!js.attr || !js.attr[s.type_attr]) { \r\n							if(!js.attr) { js.attr = {}; }\r\n							js.attr[s.type_attr] = vc[0]; \r\n						}\r\n						else {\r\n							if($.inArray(js.attr[s.type_attr], vc) === -1) { return false; }\r\n						}\r\n					}\r\n					if(s.max_children !== -2 && mc !== -1) {\r\n						ch = p === -1 ? this.get_container().find("> ul > li").length : p.find("> ul > li").length;\r\n						if(ch + 1 > mc) { return false; }\r\n					}\r\n					if(s.max_depth !== -2 && md !== -1 && (md - 1) < 0) { return false; }\r\n				}\r\n				return this.__call_old(true, obj, position, js, callback, is_loaded, skip_check);\r\n			}\r\n		}\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/* \r\n * jsTree HTML plugin\r\n * The HTML data store. Datastores are build by replacing the `load_node` and `_is_loaded` functions.\r\n */\r\n(function ($) {\r\n	$.jstree.plugin("html_data", {\r\n		__init : function () { \r\n			// this used to use html() and clean the whitespace, but this way any attached data was lost\r\n			this.data.html_data.original_container_html = this.get_container().find(" > ul > li").clone(true);\r\n			// remove white space from LI node - otherwise nodes appear a bit to the right\r\n			this.data.html_data.original_container_html.find("li").addBack().contents().filter(function() { return this.nodeType == 3; }).remove();\r\n		},\r\n		defaults : { \r\n			data : false,\r\n			ajax : false,\r\n			correct_state : true\r\n		},\r\n		_fn : {\r\n			load_node : function (obj, s_call, e_call) { var _this = this; this.load_node_html(obj, function () { _this.__callback({ "obj" : _this._get_node(obj) }); s_call.call(this); }, e_call); },\r\n			_is_loaded : function (obj) { \r\n				obj = this._get_node(obj); \r\n				return obj == -1 || !obj || (!this._get_settings().html_data.ajax && !$.isFunction(this._get_settings().html_data.data)) || obj.is(".jstree-open, .jstree-leaf") || obj.children("ul").children("li").length > 0;\r\n			},\r\n			load_node_html : function (obj, s_call, e_call) {\r\n				var d,\r\n					s = this.get_settings().html_data,\r\n					error_func = function () {},\r\n					success_func = function () {};\r\n				obj = this._get_node(obj);\r\n				if(obj && obj !== -1) {\r\n					if(obj.data("jstree_is_loading")) { return; }\r\n					else { obj.data("jstree_is_loading",true); }\r\n				}\r\n				switch(!0) {\r\n					case ($.isFunction(s.data)):\r\n						s.data.call(this, obj, $.proxy(function (d) {\r\n							if(d && d !== "" && d.toString && d.toString().replace(/^[\\s\\n]+$/,"") !== "") {\r\n								d = $(d);\r\n								if(!d.is("ul")) { d = $("<ul />").append(d); }\r\n								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class=\'jstree-icon\'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }\r\n								else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d).children("ul").find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class=\'jstree-icon\'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.removeData("jstree_is_loading"); }\r\n								this.clean_node(obj);\r\n								if(s_call) { s_call.call(this); }\r\n							}\r\n							else {\r\n								if(obj && obj !== -1) {\r\n									obj.children("a.jstree-loading").removeClass("jstree-loading");\r\n									obj.removeData("jstree_is_loading");\r\n									if(s.correct_state) { \r\n										this.correct_state(obj);\r\n										if(s_call) { s_call.call(this); } \r\n									}\r\n								}\r\n								else {\r\n									if(s.correct_state) { \r\n										this.get_container().children("ul").empty();\r\n										if(s_call) { s_call.call(this); } \r\n									}\r\n								}\r\n							}\r\n						}, this));\r\n						break;\r\n					case (!s.data && !s.ajax):\r\n						if(!obj || obj == -1) {\r\n							this.get_container()\r\n								.children("ul").empty()\r\n								.append(this.data.html_data.original_container_html)\r\n								.find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class=\'jstree-icon\'>&#160;</ins>").end()\r\n								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");\r\n							this.clean_node();\r\n						}\r\n						if(s_call) { s_call.call(this); }\r\n						break;\r\n					case (!!s.data && !s.ajax) || (!!s.data && !!s.ajax && (!obj || obj === -1)):\r\n						if(!obj || obj == -1) {\r\n							d = $(s.data);\r\n							if(!d.is("ul")) { d = $("<ul />").append(d); }\r\n							this.get_container()\r\n								.children("ul").empty().append(d.children())\r\n								.find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class=\'jstree-icon\'>&#160;</ins>").end()\r\n								.filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon");\r\n							this.clean_node();\r\n						}\r\n						if(s_call) { s_call.call(this); }\r\n						break;\r\n					case (!s.data && !!s.ajax) || (!!s.data && !!s.ajax && obj && obj !== -1):\r\n						obj = this._get_node(obj);\r\n						error_func = function (x, t, e) {\r\n							var ef = this.get_settings().html_data.ajax.error; \r\n							if(ef) { ef.call(this, x, t, e); }\r\n							if(obj != -1 && obj.length) {\r\n								obj.children("a.jstree-loading").removeClass("jstree-loading");\r\n								obj.removeData("jstree_is_loading");\r\n								if(t === "success" && s.correct_state) { this.correct_state(obj); }\r\n							}\r\n							else {\r\n								if(t === "success" && s.correct_state) { this.get_container().children("ul").empty(); }\r\n							}\r\n							if(e_call) { e_call.call(this); }\r\n						};\r\n						success_func = function (d, t, x) {\r\n							var sf = this.get_settings().html_data.ajax.success; \r\n							if(sf) { d = sf.call(this,d,t,x) || d; }\r\n							if(d === "" || (d && d.toString && d.toString().replace(/^[\\s\\n]+$/,"") === "")) {\r\n								return error_func.call(this, x, t, "");\r\n							}\r\n							if(d) {\r\n								d = $(d);\r\n								if(!d.is("ul")) { d = $("<ul />").append(d); }\r\n								if(obj == -1 || !obj) { this.get_container().children("ul").empty().append(d.children()).find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class=\'jstree-icon\'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); }\r\n								else { obj.children("a.jstree-loading").removeClass("jstree-loading"); obj.append(d).children("ul").find("li, a").filter(function () { return !this.firstChild || !this.firstChild.tagName || this.firstChild.tagName !== "INS"; }).prepend("<ins class=\'jstree-icon\'>&#160;</ins>").end().filter("a").children("ins:first-child").not(".jstree-icon").addClass("jstree-icon"); obj.removeData("jstree_is_loading"); }\r\n								this.clean_node(obj);\r\n								if(s_call) { s_call.call(this); }\r\n							}\r\n							else {\r\n								if(obj && obj !== -1) {\r\n									obj.children("a.jstree-loading").removeClass("jstree-loading");\r\n									obj.removeData("jstree_is_loading");\r\n									if(s.correct_state) { \r\n										this.correct_state(obj);\r\n										if(s_call) { s_call.call(this); } \r\n									}\r\n								}\r\n								else {\r\n									if(s.correct_state) { \r\n										this.get_container().children("ul").empty();\r\n										if(s_call) { s_call.call(this); } \r\n									}\r\n								}\r\n							}\r\n						};\r\n						s.ajax.context = this;\r\n						s.ajax.error = error_func;\r\n						s.ajax.success = success_func;\r\n						if(!s.ajax.dataType) { s.ajax.dataType = "html"; }\r\n						if($.isFunction(s.ajax.url)) { s.ajax.url = s.ajax.url.call(this, obj); }\r\n						if($.isFunction(s.ajax.data)) { s.ajax.data = s.ajax.data.call(this, obj); }\r\n						$.ajax(s.ajax);\r\n						break;\r\n				}\r\n			}\r\n		}\r\n	});\r\n	// include the HTML data plugin by default\r\n	$.jstree.defaults.plugins.push("html_data");\r\n})(jQuery);\r\n//*/\r\n\r\n/* \r\n * jsTree themeroller plugin\r\n * Adds support for jQuery UI themes. Include this at the end of your plugins list, also make sure "themes" is not included.\r\n */\r\n(function ($) {\r\n	$.jstree.plugin("themeroller", {\r\n		__init : function () {\r\n			var s = this._get_settings().themeroller;\r\n			this.get_container()\r\n				.addClass("ui-widget-content")\r\n				.addClass("jstree-themeroller")\r\n				.delegate("a","mouseenter.jstree", function (e) {\r\n					if(!$(e.currentTarget).hasClass("jstree-loading")) {\r\n						$(this).addClass(s.item_h);\r\n					}\r\n				})\r\n				.delegate("a","mouseleave.jstree", function () {\r\n					$(this).removeClass(s.item_h);\r\n				})\r\n				.bind("init.jstree", $.proxy(function (e, data) { \r\n						data.inst.get_container().find("> ul > li > .jstree-loading > ins").addClass("ui-icon-refresh");\r\n						this._themeroller(data.inst.get_container().find("> ul > li"));\r\n					}, this))\r\n				.bind("open_node.jstree create_node.jstree", $.proxy(function (e, data) { \r\n						this._themeroller(data.rslt.obj);\r\n					}, this))\r\n				.bind("loaded.jstree refresh.jstree", $.proxy(function (e) {\r\n						this._themeroller();\r\n					}, this))\r\n				.bind("close_node.jstree", $.proxy(function (e, data) {\r\n						this._themeroller(data.rslt.obj);\r\n					}, this))\r\n				.bind("delete_node.jstree", $.proxy(function (e, data) {\r\n						this._themeroller(data.rslt.parent);\r\n					}, this))\r\n				.bind("correct_state.jstree", $.proxy(function (e, data) {\r\n						data.rslt.obj\r\n							.children("ins.jstree-icon").removeClass(s.opened + " " + s.closed + " ui-icon").end()\r\n							.find("> a > ins.ui-icon")\r\n								.filter(function() { \r\n									return this.className.toString()\r\n										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")\r\n										.indexOf("ui-icon-") === -1; \r\n								}).removeClass(s.item_open + " " + s.item_clsd).addClass(s.item_leaf || "jstree-no-icon");\r\n					}, this))\r\n				.bind("select_node.jstree", $.proxy(function (e, data) {\r\n						data.rslt.obj.children("a").addClass(s.item_a);\r\n					}, this))\r\n				.bind("deselect_node.jstree deselect_all.jstree", $.proxy(function (e, data) {\r\n						this.get_container()\r\n							.find("a." + s.item_a).removeClass(s.item_a).end()\r\n							.find("a.jstree-clicked").addClass(s.item_a);\r\n					}, this))\r\n				.bind("dehover_node.jstree", $.proxy(function (e, data) {\r\n						data.rslt.obj.children("a").removeClass(s.item_h);\r\n					}, this))\r\n				.bind("hover_node.jstree", $.proxy(function (e, data) {\r\n						this.get_container()\r\n							.find("a." + s.item_h).not(data.rslt.obj).removeClass(s.item_h);\r\n						data.rslt.obj.children("a").addClass(s.item_h);\r\n					}, this))\r\n				.bind("move_node.jstree", $.proxy(function (e, data) {\r\n						this._themeroller(data.rslt.o);\r\n						this._themeroller(data.rslt.op);\r\n					}, this));\r\n		},\r\n		__destroy : function () {\r\n			var s = this._get_settings().themeroller,\r\n				c = [ "ui-icon" ];\r\n			$.each(s, function (i, v) {\r\n				v = v.split(" ");\r\n				if(v.length) { c = c.concat(v); }\r\n			});\r\n			this.get_container()\r\n				.removeClass("ui-widget-content")\r\n				.find("." + c.join(", .")).removeClass(c.join(" "));\r\n		},\r\n		_fn : {\r\n			_themeroller : function (obj) {\r\n				var s = this._get_settings().themeroller;\r\n				obj = !obj || obj == -1 ? this.get_container_ul() : this._get_node(obj).parent();\r\n				obj\r\n					.find("li.jstree-closed")\r\n						.children("ins.jstree-icon").removeClass(s.opened).addClass("ui-icon " + s.closed).end()\r\n						.children("a").addClass(s.item)\r\n							.children("ins.jstree-icon").addClass("ui-icon")\r\n								.filter(function() { \r\n									return this.className.toString()\r\n										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")\r\n										.indexOf("ui-icon-") === -1; \r\n								}).removeClass(s.item_leaf + " " + s.item_open).addClass(s.item_clsd || "jstree-no-icon")\r\n								.end()\r\n							.end()\r\n						.end()\r\n					.end()\r\n					.find("li.jstree-open")\r\n						.children("ins.jstree-icon").removeClass(s.closed).addClass("ui-icon " + s.opened).end()\r\n						.children("a").addClass(s.item)\r\n							.children("ins.jstree-icon").addClass("ui-icon")\r\n								.filter(function() { \r\n									return this.className.toString()\r\n										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")\r\n										.indexOf("ui-icon-") === -1; \r\n								}).removeClass(s.item_leaf + " " + s.item_clsd).addClass(s.item_open || "jstree-no-icon")\r\n								.end()\r\n							.end()\r\n						.end()\r\n					.end()\r\n					.find("li.jstree-leaf")\r\n						.children("ins.jstree-icon").removeClass(s.closed + " ui-icon " + s.opened).end()\r\n						.children("a").addClass(s.item)\r\n							.children("ins.jstree-icon").addClass("ui-icon")\r\n								.filter(function() { \r\n									return this.className.toString()\r\n										.replace(s.item_clsd,"").replace(s.item_open,"").replace(s.item_leaf,"")\r\n										.indexOf("ui-icon-") === -1; \r\n								}).removeClass(s.item_clsd + " " + s.item_open).addClass(s.item_leaf || "jstree-no-icon");\r\n			}\r\n		},\r\n		defaults : {\r\n			"opened"	: "ui-icon-triangle-1-se",\r\n			"closed"	: "ui-icon-triangle-1-e",\r\n			"item"		: "ui-state-default",\r\n			"item_h"	: "ui-state-hover",\r\n			"item_a"	: "ui-state-active",\r\n			"item_open"	: "ui-icon-folder-open",\r\n			"item_clsd"	: "ui-icon-folder-collapsed",\r\n			"item_leaf"	: "ui-icon-document"\r\n		}\r\n	});\r\n	$(function() {\r\n		var css_string = \'\' + \r\n			\'.jstree-themeroller .ui-icon { overflow:visible; } \' + \r\n			\'.jstree-themeroller a { padding:0 2px; } \' + \r\n			\'.jstree-themeroller .jstree-no-icon { display:none; }\';\r\n		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/* \r\n * jsTree unique plugin\r\n * Forces different names amongst siblings (still a bit experimental)\r\n * NOTE: does not check language versions (it will not be possible to have nodes with the same title, even in different languages)\r\n */\r\n(function ($) {\r\n	$.jstree.plugin("unique", {\r\n		__init : function () {\r\n			this.get_container()\r\n				.bind("before.jstree", $.proxy(function (e, data) { \r\n						var nms = [], res = true, p, t;\r\n						if(data.func == "move_node") {\r\n							// obj, ref, position, is_copy, is_prepared, skip_check\r\n							if(data.args[4] === true) {\r\n								if(data.args[0].o && data.args[0].o.length) {\r\n									data.args[0].o.children("a").each(function () { nms.push($(this).text().replace(/^\\s+/g,"")); });\r\n									res = this._check_unique(nms, data.args[0].np.find("> ul > li").not(data.args[0].o), "move_node");\r\n								}\r\n							}\r\n						}\r\n						if(data.func == "create_node") {\r\n							// obj, position, js, callback, is_loaded\r\n							if(data.args[4] || this._is_loaded(data.args[0])) {\r\n								p = this._get_node(data.args[0]);\r\n								if(data.args[1] && (data.args[1] === "before" || data.args[1] === "after")) {\r\n									p = this._get_parent(data.args[0]);\r\n									if(!p || p === -1) { p = this.get_container(); }\r\n								}\r\n								if(typeof data.args[2] === "string") { nms.push(data.args[2]); }\r\n								else if(!data.args[2] || !data.args[2].data) { nms.push(this._get_string("new_node")); }\r\n								else { nms.push(data.args[2].data); }\r\n								res = this._check_unique(nms, p.find("> ul > li"), "create_node");\r\n							}\r\n						}\r\n						if(data.func == "rename_node") {\r\n							// obj, val\r\n							nms.push(data.args[1]);\r\n							t = this._get_node(data.args[0]);\r\n							p = this._get_parent(t);\r\n							if(!p || p === -1) { p = this.get_container(); }\r\n							res = this._check_unique(nms, p.find("> ul > li").not(t), "rename_node");\r\n						}\r\n						if(!res) {\r\n							e.stopPropagation();\r\n							return false;\r\n						}\r\n					}, this));\r\n		},\r\n		defaults : { \r\n			error_callback : $.noop\r\n		},\r\n		_fn : { \r\n			_check_unique : function (nms, p, func) {\r\n				var cnms = [];\r\n				p.children("a").each(function () { cnms.push($(this).text().replace(/^\\s+/g,"")); });\r\n				if(!cnms.length || !nms.length) { return true; }\r\n				cnms = cnms.sort().join(",,").replace(/(,|^)([^,]+)(,,\\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",");\r\n				if((cnms.length + nms.length) != cnms.concat(nms).sort().join(",,").replace(/(,|^)([^,]+)(,,\\2)+(,|$)/g,"$1$2$4").replace(/,,+/g,",").replace(/,$/,"").split(",").length) {\r\n					this._get_settings().unique.error_callback.call(null, nms, p, func);\r\n					return false;\r\n				}\r\n				return true;\r\n			},\r\n			check_move : function () {\r\n				if(!this.__call_old()) { return false; }\r\n				var p = this._get_move(), nms = [];\r\n				if(p.o && p.o.length) {\r\n					p.o.children("a").each(function () { nms.push($(this).text().replace(/^\\s+/g,"")); });\r\n					return this._check_unique(nms, p.np.find("> ul > li").not(p.o), "check_move");\r\n				}\r\n				return true;\r\n			}\r\n		}\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/*\r\n * jsTree wholerow plugin\r\n * Makes select and hover work on the entire width of the node\r\n * MAY BE HEAVY IN LARGE DOM\r\n */\r\n(function ($) {\r\n	$.jstree.plugin("wholerow", {\r\n		__init : function () {\r\n			if(!this.data.ui) { throw "jsTree wholerow: jsTree UI plugin not included."; }\r\n			this.data.wholerow.html = false;\r\n			this.data.wholerow.to = false;\r\n			this.get_container()\r\n				.bind("init.jstree", $.proxy(function (e, data) { \r\n						this._get_settings().core.animation = 0;\r\n					}, this))\r\n				.bind("open_node.jstree create_node.jstree clean_node.jstree loaded.jstree", $.proxy(function (e, data) { \r\n						this._prepare_wholerow_span( data && data.rslt && data.rslt.obj ? data.rslt.obj : -1 );\r\n					}, this))\r\n				.bind("search.jstree clear_search.jstree reopen.jstree after_open.jstree after_close.jstree create_node.jstree delete_node.jstree clean_node.jstree", $.proxy(function (e, data) { \r\n						if(this.data.to) { clearTimeout(this.data.to); }\r\n						this.data.to = setTimeout( (function (t, o) { return function() { t._prepare_wholerow_ul(o); }; })(this,  data && data.rslt && data.rslt.obj ? data.rslt.obj : -1), 0);\r\n					}, this))\r\n				.bind("deselect_all.jstree", $.proxy(function (e, data) { \r\n						this.get_container().find(" > .jstree-wholerow .jstree-clicked").removeClass("jstree-clicked " + (this.data.themeroller ? this._get_settings().themeroller.item_a : "" ));\r\n					}, this))\r\n				.bind("select_node.jstree deselect_node.jstree ", $.proxy(function (e, data) { \r\n						data.rslt.obj.each(function () { \r\n							var ref = data.inst.get_container().find(" > .jstree-wholerow li:visible:eq(" + ( parseInt((($(this).offset().top - data.inst.get_container().offset().top + data.inst.get_container()[0].scrollTop) / data.inst.data.core.li_height),10)) + ")");\r\n							// ref.children("a")[e.type === "select_node" ? "addClass" : "removeClass"]("jstree-clicked");\r\n							ref.children("a").attr("class",data.rslt.obj.children("a").attr("class"));\r\n						});\r\n					}, this))\r\n				.bind("hover_node.jstree dehover_node.jstree", $.proxy(function (e, data) { \r\n						this.get_container().find(" > .jstree-wholerow .jstree-hovered").removeClass("jstree-hovered " + (this.data.themeroller ? this._get_settings().themeroller.item_h : "" ));\r\n						if(e.type === "hover_node") {\r\n							var ref = this.get_container().find(" > .jstree-wholerow li:visible:eq(" + ( parseInt(((data.rslt.obj.offset().top - this.get_container().offset().top + this.get_container()[0].scrollTop) / this.data.core.li_height),10)) + ")");\r\n							// ref.children("a").addClass("jstree-hovered");\r\n							ref.children("a").attr("class",data.rslt.obj.children(".jstree-hovered").attr("class"));\r\n						}\r\n					}, this))\r\n				.delegate(".jstree-wholerow-span, ins.jstree-icon, li", "click.jstree", function (e) {\r\n						var n = $(e.currentTarget);\r\n						if(e.target.tagName === "A" || (e.target.tagName === "INS" && n.closest("li").is(".jstree-open, .jstree-closed"))) { return; }\r\n						n.closest("li").children("a:visible:eq(0)").click();\r\n						e.stopImmediatePropagation();\r\n					})\r\n				.delegate("li", "mouseover.jstree", $.proxy(function (e) {\r\n						e.stopImmediatePropagation();\r\n						if($(e.currentTarget).children(".jstree-hovered, .jstree-clicked").length) { return false; }\r\n						this.hover_node(e.currentTarget);\r\n						return false;\r\n					}, this))\r\n				.delegate("li", "mouseleave.jstree", $.proxy(function (e) {\r\n						if($(e.currentTarget).children("a").hasClass("jstree-hovered").length) { return; }\r\n						this.dehover_node(e.currentTarget);\r\n					}, this));\r\n			if(is_ie7 || is_ie6) {\r\n				$.vakata.css.add_sheet({ str : ".jstree-" + this.get_index() + " { position:relative; } ", title : "jstree" });\r\n			}\r\n		},\r\n		defaults : {\r\n		},\r\n		__destroy : function () {\r\n			this.get_container().children(".jstree-wholerow").remove();\r\n			this.get_container().find(".jstree-wholerow-span").remove();\r\n		},\r\n		_fn : {\r\n			_prepare_wholerow_span : function (obj) {\r\n				obj = !obj || obj == -1 ? this.get_container().find("> ul > li") : this._get_node(obj);\r\n				if(obj === false) { return; } // added for removing root nodes\r\n				obj.each(function () {\r\n					$(this).find("li").addBack().each(function () {\r\n						var $t = $(this);\r\n						if($t.children(".jstree-wholerow-span").length) { return true; }\r\n						$t.prepend("<span class=\'jstree-wholerow-span\' style=\'width:" + ($t.parentsUntil(".jstree","li").length * 18) + "px;\'>&#160;</span>");\r\n					});\r\n				});\r\n			},\r\n			_prepare_wholerow_ul : function () {\r\n				var o = this.get_container().children("ul").eq(0), h = o.html();\r\n				o.addClass("jstree-wholerow-real");\r\n				if(this.data.wholerow.last_html !== h) {\r\n					this.data.wholerow.last_html = h;\r\n					this.get_container().children(".jstree-wholerow").remove();\r\n					this.get_container().append(\r\n						o.clone().removeClass("jstree-wholerow-real")\r\n							.wrapAll("<div class=\'jstree-wholerow\' />").parent()\r\n							.width(o.parent()[0].scrollWidth)\r\n							.css("top", (o.height() + ( is_ie7 ? 5 : 0)) * -1 )\r\n							.find("li[id]").each(function () { this.removeAttribute("id"); }).end()\r\n					);\r\n				}\r\n			}\r\n		}\r\n	});\r\n	$(function() {\r\n		var css_string = \'\' + \r\n			\'.jstree .jstree-wholerow-real { position:relative; z-index:1; } \' + \r\n			\'.jstree .jstree-wholerow-real li { cursor:pointer; } \' + \r\n			\'.jstree .jstree-wholerow-real a { border-left-color:transparent !important; border-right-color:transparent !important; } \' + \r\n			\'.jstree .jstree-wholerow { position:relative; z-index:0; height:0; } \' + \r\n			\'.jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { width:100%; } \' + \r\n			\'.jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li, .jstree .jstree-wholerow a { margin:0 !important; padding:0 !important; } \' + \r\n			\'.jstree .jstree-wholerow, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow li { background:transparent !important; }\' + \r\n			\'.jstree .jstree-wholerow ins, .jstree .jstree-wholerow span, .jstree .jstree-wholerow input { display:none !important; }\' + \r\n			\'.jstree .jstree-wholerow a, .jstree .jstree-wholerow a:hover { text-indent:-9999px; !important; width:100%; padding:0 !important; border-right-width:0px !important; border-left-width:0px !important; } \' + \r\n			\'.jstree .jstree-wholerow-span { position:absolute; left:0; margin:0px; padding:0; height:18px; border-width:0; padding:0; z-index:0; }\';\r\n		if(is_ff2) {\r\n			css_string += \'\' + \r\n				\'.jstree .jstree-wholerow a { display:block; height:18px; margin:0; padding:0; border:0; } \' + \r\n				\'.jstree .jstree-wholerow-real a { border-color:transparent !important; } \';\r\n		}\r\n		if(is_ie7 || is_ie6) {\r\n			css_string += \'\' + \r\n				\'.jstree .jstree-wholerow, .jstree .jstree-wholerow li, .jstree .jstree-wholerow ul, .jstree .jstree-wholerow a { margin:0; padding:0; line-height:18px; } \' + \r\n				\'.jstree .jstree-wholerow a { display:block; height:18px; line-height:18px; overflow:hidden; } \';\r\n		}\r\n		$.vakata.css.add_sheet({ str : css_string, title : "jstree" });\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n/*\r\n* jsTree model plugin\r\n* This plugin gets jstree to use a class model to retrieve data, creating great dynamism\r\n*/\r\n(function ($) {\r\n	var nodeInterface = ["getChildren","getChildrenCount","getAttr","getName","getProps"],\r\n		validateInterface = function(obj, inter) {\r\n			var valid = true;\r\n			obj = obj || {};\r\n			inter = [].concat(inter);\r\n			$.each(inter, function (i, v) {\r\n				if(!$.isFunction(obj[v])) { valid = false; return false; }\r\n			});\r\n			return valid;\r\n		};\r\n	$.jstree.plugin("model", {\r\n		__init : function () {\r\n			if(!this.data.json_data) { throw "jsTree model: jsTree json_data plugin not included."; }\r\n			this._get_settings().json_data.data = function (n, b) {\r\n				var obj = (n == -1) ? this._get_settings().model.object : n.data("jstree_model");\r\n				if(!validateInterface(obj, nodeInterface)) { return b.call(null, false); }\r\n				if(this._get_settings().model.async) {\r\n					obj.getChildren($.proxy(function (data) {\r\n						this.model_done(data, b);\r\n					}, this));\r\n				}\r\n				else {\r\n					this.model_done(obj.getChildren(), b);\r\n				}\r\n			};\r\n		},\r\n		defaults : {\r\n			object : false,\r\n			id_prefix : false,\r\n			async : false\r\n		},\r\n		_fn : {\r\n			model_done : function (data, callback) {\r\n				var ret = [], \r\n					s = this._get_settings(),\r\n					_this = this;\r\n\r\n				if(!$.isArray(data)) { data = [data]; }\r\n				$.each(data, function (i, nd) {\r\n					var r = nd.getProps() || {};\r\n					r.attr = nd.getAttr() || {};\r\n					if(nd.getChildrenCount()) { r.state = "closed"; }\r\n					r.data = nd.getName();\r\n					if(!$.isArray(r.data)) { r.data = [r.data]; }\r\n					if(_this.data.types && $.isFunction(nd.getType)) {\r\n						r.attr[s.types.type_attr] = nd.getType();\r\n					}\r\n					if(r.attr.id && s.model.id_prefix) { r.attr.id = s.model.id_prefix + r.attr.id; }\r\n					if(!r.metadata) { r.metadata = { }; }\r\n					r.metadata.jstree_model = nd;\r\n					ret.push(r);\r\n				});\r\n				callback.call(null, ret);\r\n			}\r\n		}\r\n	});\r\n})(jQuery);\r\n//*/\r\n\r\n})();\r\n\n//# sourceURL=/thirdparty/jstree_pre1.0_fix_1/jquery.jstree.js'),define("thirdparty/jstree_pre1.0_fix_1/jquery.jstree",function(){}),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n/**\r\n * PreferenceStorage defines an interface for persisting preference data as\r\n * name/value pairs for a module or plugin.\r\n * \r\n * @deprecated Use PreferencesManager APIs instead.\r\n */\r\ndefine(\'preferences/PreferenceStorage\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'preferences/PreferencesManager\',\'utils/DeprecationWarning\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n    \r\n    var PreferencesManager = require("preferences/PreferencesManager"),\r\n        DeprecationWarning = require("utils/DeprecationWarning");\r\n    \r\n    /**\r\n     * @private\r\n     * Validate JSON keys and values.\r\n     */\r\n    function _validateJSONPair(key, value) {\r\n        if (typeof key === "string") {\r\n            // validate temporary JSON\r\n            var temp = {},\r\n                error = null;\r\n            temp[key] = value;\r\n            \r\n            try {\r\n                temp = JSON.parse(JSON.stringify(temp));\r\n            } catch (err) {\r\n                error = err;\r\n            }\r\n            \r\n            // set value to JSON storage if no errors occurred\r\n            if (!error && (temp[key] !== undefined)) {\r\n                return true;\r\n            } else {\r\n                console.error("Value \'" + value + "\' for key \'" + key + "\' must be a valid JSON value");\r\n                return false;\r\n            }\r\n        } else {\r\n            console.error("Preference key \'" + key + "\' must be a string");\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Save to persistent storage.\r\n     */\r\n    function _commit() {\r\n        PreferencesManager.savePreferences();\r\n    }\r\n    \r\n    /**\r\n     * Creates a new PreferenceStorage object.\r\n     * @param {!string} clientID Unique identifier for PreferencesManager to\r\n     *  associate this PreferenceStorage data with.\r\n     * @param {!object} json JSON object to persist preference data.\r\n     */\r\n    function PreferenceStorage(clientID, json) {\r\n        this._clientID = clientID;\r\n        this._json = json;\r\n    }\r\n    \r\n    /**\r\n     * Unique clientID for this PreferenceStorage object.\r\n     * @return {!string} clientID\r\n     */\r\n    PreferenceStorage.prototype.getClientID = function () {\r\n        return this._clientID;\r\n    };\r\n    \r\n    /**\r\n     * Removes a preference from this PreferenceStorage object.\r\n     * @param {!string} key A unique identifier\r\n     */\r\n    PreferenceStorage.prototype.remove = function (key) {\r\n        DeprecationWarning.deprecationWarning("remove is called to remove a preference \'" + key + ",\' use PreferencesManager.set (with value of undefined) instead.");\r\n        // remove value from JSON storage\r\n        delete this._json[key];\r\n        _commit();\r\n    };\r\n    \r\n    /**\r\n     * Assigns a value for a key. Overwrites existing value if present.\r\n     * @param {!string} key A unique identifier\r\n     * @param {object} value A valid JSON value\r\n     */\r\n    PreferenceStorage.prototype.setValue = function (key, value) {\r\n        DeprecationWarning.deprecationWarning("setValue is called to set preference \'" + key + ",\' use PreferencesManager.set instead.");\r\n        if (_validateJSONPair(key, value)) {\r\n            this._json[key] = value;\r\n            _commit();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Retreive the value associated with the specified key.\r\n     * @param {!string} key Key name to lookup.\r\n     * @return {object} Returns the value for the key or undefined.\r\n     */\r\n    PreferenceStorage.prototype.getValue = function (key) {\r\n        DeprecationWarning.deprecationWarning("getValue is called to get preference \'" + key + ",\' use PreferencesManager.get instead.");\r\n        return this._json[key];\r\n    };\r\n    \r\n    /**\r\n     * Return all name-value pairs as a single JSON object.\r\n     * @return {!object} JSON object containing name/value pairs for all keys\r\n     *  in this PreferenceStorage object.\r\n     */\r\n    PreferenceStorage.prototype.getAllValues = function () {\r\n        return JSON.parse(JSON.stringify(this._json));\r\n    };\r\n    \r\n    /**\r\n     * Writes name-value pairs from a JSON object as preference properties.\r\n     * Invalid JSON values report an error and all changes are discarded.\r\n     *\r\n     * @param {!object} obj A JSON object with zero or more preference properties to write.\r\n     * @param {boolean} append Defaults to false. When true, properties in the JSON object\r\n     *  overwrite and/or append to the existing set of preference properties. When false,\r\n     *  all existing preferences are deleted before writing new properties from the JSON object.\r\n     */\r\n    PreferenceStorage.prototype.setAllValues = function (obj, append) {\r\n        DeprecationWarning.deprecationWarning("setAllValues is called to set preferences \'" + Object.keys(obj) + ",\' use PreferencesManager.set (probably with doNotSave flag) instead.");\r\n\r\n        var self = this,\r\n            error = null;\r\n        \r\n        // validate all name/value pairs before committing\r\n        _.some(obj, function (value, key) {\r\n            try {\r\n                _validateJSONPair(key, value);\r\n            } catch (err) {\r\n                // fail fast\r\n                error = err;\r\n                return true;\r\n            }\r\n        });\r\n        \r\n        // skip changes if any error is detected\r\n        if (error) {\r\n            console.error(error);\r\n            return;\r\n        }\r\n        \r\n        // delete all exiting properties if not appending\r\n        if (!append) {\r\n            _.forEach(this._json, function (value, key) {\r\n                delete self._json[key];\r\n            });\r\n        }\r\n        \r\n        // copy properties from incoming JSON object\r\n        _.forEach(obj, function (value, key) {\r\n            self._json[key] = value;\r\n        });\r\n        \r\n        _commit();\r\n    };\r\n    \r\n    /**\r\n     * Converts preferences to the new-style file-based preferences according to the\r\n     * rules. (See PreferencesManager.ConvertPreferences for information about the rules).\r\n     * \r\n     * @param {Object} rules Conversion rules.\r\n     * @param {Array.<string>} convertedKeys List of keys that were previously converted \r\n     *                                      (will not be reconverted)\r\n     * @param {boolean=} isViewState If it is undefined or false, then the preferences\r\n     *      listed in \'rules\' are those normal user-editable preferences. Otherwise,\r\n     *      they are view state settings.\r\n     * @param {function(string)=} prefCheckCallback Optional callback function that\r\n     *      examines each preference key for migration.\r\n     * @return {Promise} promise that is resolved once the conversion is done. Callbacks are given a\r\n     *                      `complete` flag that denotes whether everything from this object \r\n     *                      was converted (making it safe to delete entirely).\r\n     */\r\n    PreferenceStorage.prototype.convert = function (rules, convertedKeys, isViewState, prefCheckCallback) {\r\n        var prefs = this._json,\r\n            self = this,\r\n            complete = true,\r\n            manager  = isViewState ? PreferencesManager.stateManager : PreferencesManager,\r\n            deferred = new $.Deferred();\r\n        \r\n        if (!convertedKeys) {\r\n            convertedKeys = [];\r\n        }\r\n        \r\n        Object.keys(prefs).forEach(function (key) {\r\n            if (convertedKeys.indexOf(key) > -1) {\r\n                return;\r\n            }\r\n            \r\n            var rule = rules[key];\r\n            if (!rule && prefCheckCallback) {\r\n                rule = prefCheckCallback(key);\r\n            } else if (prefCheckCallback) {\r\n                // Check whether we have a new preference key-value pair\r\n                // for an old preference.\r\n                var newRule = prefCheckCallback(key, prefs[key]);\r\n                if (newRule) {\r\n                    rule = _.cloneDeep(newRule);\r\n                }\r\n            }\r\n            if (!rule) {\r\n                console.warn("Preferences conversion for ", self._clientID, " has no rule for", key);\r\n                complete = false;\r\n            } else if (_.isString(rule)) {\r\n                var parts = rule.split(" ");\r\n                if (parts[0] === "user") {\r\n                    var newKey = parts.length > 1 ? parts[1] : key;\r\n                    var options = null;\r\n                    \r\n                    if (parts.length > 2 && parts[2].indexOf("/") !== -1) {\r\n                        var projectPath = rule.substr(rule.indexOf(parts[2]));\r\n                        options = { location: { scope: "user",\r\n                                                layer: "project",\r\n                                                layerID: projectPath } };\r\n                    }\r\n                    \r\n                    manager.set(newKey, prefs[key], options);\r\n                    convertedKeys.push(key);\r\n                }\r\n            } else if (_.isObject(rule)) {\r\n                Object.keys(rule).forEach(function (ruleKey) {\r\n                    manager.set(ruleKey, rule[ruleKey]);\r\n                });\r\n                convertedKeys.push(key);\r\n            } else {\r\n                complete = false;\r\n            }\r\n        });\r\n        \r\n        if (convertedKeys.length > 0) {\r\n            manager.save().done(function () {\r\n                _commit();\r\n                deferred.resolve(complete, convertedKeys);\r\n            }).fail(function (error) {\r\n                deferred.reject(error);\r\n            });\r\n        } else {\r\n            deferred.resolve(complete, convertedKeys);\r\n        }\r\n        \r\n        return deferred.promise();\r\n    };\r\n    \r\n    exports.PreferenceStorage = PreferenceStorage;\r\n});\n//# sourceURL=/preferences/PreferenceStorage.js'),eval("/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\ndefine('filesystem/WatchedRoot',['require','exports','module'],function (require, exports, module) {\r\n    \"use strict\";\r\n    \r\n    /*\r\n     * Represents file or directory structure watched by the FileSystem. If the\r\n     * entry is a directory, all children (that pass the supplied filter function)\r\n     * are also watched. A WatchedRoot object begins and ends its life in the\r\n     * INACTIVE state. While in the process of starting up watchers, the WatchedRoot\r\n     * is in the STARTING state. When watchers are ready, the WatchedRoot enters\r\n     * the ACTIVE state.\r\n     *\r\n     * See the FileSystem class for more details.\r\n     *\r\n     * @constructor\r\n     * @param {File|Directory} entry \r\n     * @param {function(string, string):boolean} filter \r\n     */\r\n    function WatchedRoot(entry, filter) {\r\n        this.entry = entry;\r\n        this.filter = filter;\r\n    }\r\n\r\n    // Status constants\r\n    WatchedRoot.INACTIVE = 0;\r\n    WatchedRoot.STARTING = 1;\r\n    WatchedRoot.ACTIVE = 2;\r\n\r\n    /**\r\n     * @type {File|Directory}\r\n     */\r\n    WatchedRoot.prototype.entry = null;\r\n    \r\n    /**\r\n     * @type {function(string, string):boolean}\r\n     */\r\n    WatchedRoot.prototype.filter = null;\r\n\r\n    /**\r\n     * @type {number}\r\n     */\r\n    WatchedRoot.prototype.status = WatchedRoot.INACTIVE;\r\n    \r\n    \r\n    // Export this class\r\n    module.exports = WatchedRoot;\r\n});\r\n\n//# sourceURL=/filesystem/WatchedRoot.js"),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\n/*\r\n * To ensure cache coherence, current and future asynchronous state-changing \r\n * operations of FileSystemEntry and its subclasses should implement the \r\n * following high-level sequence of steps:\r\n * \r\n * 1. Block external filesystem change events;\r\n * 2. Execute the low-level state-changing operation;\r\n * 3. Update the internal filesystem state, including caches;\r\n * 4. Apply the callback;\r\n * 5. Fire an appropriate internal change notification; and\r\n * 6. Unblock external change events.\r\n *\r\n * Note that because internal filesystem state is updated first, both the original \r\n * caller and the change notification listeners observe filesystem state that is\r\n * current w.r.t. the operation. Furthermore, because external change events are\r\n * blocked before the operation begins, listeners will only receive the internal\r\n * change event for the operation and not additional (or possibly inconsistent)\r\n * external change events.\r\n * \r\n * State-changing operations that block external filesystem change events must\r\n * take care to always subsequently unblock the external change events in all\r\n * control paths. It is safe to assume, however, that the underlying impl will\r\n * always apply the callback with some value.\r\n \r\n * Caches should be conservative. Consequently, the entry\'s cached data should\r\n * always be cleared if the underlying impl\'s operation fails. This is the case\r\n * event for read-only operations because an unexpected failure implies that the\r\n * system is in an unknown state. The entry should communicate this by failing\r\n * where appropriate, and should not use the cache to hide failure.\r\n * \r\n * Only watched entries should make use of cached data because change events are\r\n * only expected for such entries, and change events are used to granularly\r\n * invalidate out-of-date caches.\r\n *\r\n * By convention, callbacks are optional for asynchronous, state-changing\r\n * operations, but required for read-only operations. The first argument to the\r\n * callback should always be a nullable error string from FileSystemError.\r\n */\r\ndefine(\'filesystem/FileSystemEntry\',[\'require\',\'exports\',\'module\',\'filesystem/FileSystemError\',\'filesystem/WatchedRoot\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var FileSystemError = require("filesystem/FileSystemError"),\r\n        WatchedRoot     = require("filesystem/WatchedRoot");\r\n    \r\n    var VISIT_DEFAULT_MAX_DEPTH = 100,\r\n        VISIT_DEFAULT_MAX_ENTRIES = 30000;\r\n    \r\n    /* Counter to give every entry a unique id */\r\n    var nextId = 0;\r\n    \r\n    /**\r\n     * Model for a file system entry. This is the base class for File and Directory,\r\n     * and is never used directly.\r\n     *\r\n     * See the File, Directory, and FileSystem classes for more details.\r\n     *\r\n     * @constructor\r\n     * @param {string} path The path for this entry.\r\n     * @param {FileSystem} fileSystem The file system associated with this entry.\r\n     */\r\n    function FileSystemEntry(path, fileSystem) {\r\n        this._setPath(path);\r\n        this._fileSystem = fileSystem;\r\n        this._id = nextId++;\r\n    }\r\n    \r\n    // Add "fullPath", "name", "parent", "id", "isFile" and "isDirectory" getters\r\n    Object.defineProperties(FileSystemEntry.prototype, {\r\n        "fullPath": {\r\n            get: function () { return this._path; },\r\n            set: function () { throw new Error("Cannot set fullPath"); }\r\n        },\r\n        "name": {\r\n            get: function () { return this._name; },\r\n            set: function () { throw new Error("Cannot set name"); }\r\n        },\r\n        "parentPath": {\r\n            get: function () { return this._parentPath; },\r\n            set: function () { throw new Error("Cannot set parentPath"); }\r\n        },\r\n        "id": {\r\n            get: function () { return this._id; },\r\n            set: function () { throw new Error("Cannot set id"); }\r\n        },\r\n        "isFile": {\r\n            get: function () { return this._isFile; },\r\n            set: function () { throw new Error("Cannot set isFile"); }\r\n        },\r\n        "isDirectory": {\r\n            get: function () { return this._isDirectory; },\r\n            set: function () { throw new Error("Cannot set isDirectory"); }\r\n        },\r\n        "_impl": {\r\n            get: function () { return this._fileSystem._impl; },\r\n            set: function () { throw new Error("Cannot set _impl"); }\r\n        }\r\n    });\r\n    \r\n    /**\r\n     * Cached stat object for this file.\r\n     * @type {?FileSystemStats}\r\n     */\r\n    FileSystemEntry.prototype._stat = null;\r\n    \r\n    /**\r\n     * Parent file system.\r\n     * @type {!FileSystem}\r\n     */\r\n    FileSystemEntry.prototype._fileSystem = null;\r\n\r\n    /**\r\n     * The path of this entry.\r\n     * @type {string}\r\n     */\r\n    FileSystemEntry.prototype._path = null;\r\n    \r\n    /**\r\n     * The name of this entry.\r\n     * @type {string}\r\n     */\r\n    FileSystemEntry.prototype._name = null;\r\n\r\n    /**\r\n     * The parent of this entry.\r\n     * @type {string}\r\n     */\r\n    FileSystemEntry.prototype._parentPath = null;\r\n    \r\n    /**\r\n     * Whether or not the entry is a file\r\n     * @type {boolean}\r\n     */\r\n    FileSystemEntry.prototype._isFile = false;\r\n    \r\n    /**\r\n     * Whether or not the entry is a directory\r\n     * @type {boolean}\r\n     */\r\n    FileSystemEntry.prototype._isDirectory = false;\r\n    \r\n    /**\r\n     * Cached copy of this entry\'s watched root\r\n     * @type {entry: File|Directory, filter: function(FileSystemEntry):boolean, active: boolean}\r\n     */\r\n    FileSystemEntry.prototype._watchedRoot = null;\r\n\r\n    /**\r\n     * Cached result of _watchedRoot.filter(this.name, this.parentPath).\r\n     * @type {boolean}\r\n     */\r\n    FileSystemEntry.prototype._watchedRootFilterResult = false;\r\n    \r\n    /**\r\n     * Determines whether or not the entry is watched.\r\n     * @param {boolean=} relaxed If falsey, the method will only return true if\r\n     *      the watched root is fully active. If true, the method will return\r\n     *      true if the watched root is either starting up or fully active.\r\n     * @return {boolean}\r\n     */\r\n    FileSystemEntry.prototype._isWatched = function (relaxed) {\r\n        var watchedRoot = this._watchedRoot,\r\n            filterResult = this._watchedRootFilterResult;\r\n        \r\n        if (!watchedRoot) {\r\n            watchedRoot = this._fileSystem._findWatchedRootForPath(this._path);\r\n            \r\n            if (watchedRoot) {\r\n                this._watchedRoot = watchedRoot;\r\n                filterResult = watchedRoot.filter(this._name, this._parentPath);\r\n                this._watchedRootFilterResult = filterResult;\r\n            }\r\n        }\r\n        \r\n        if (watchedRoot) {\r\n            if (watchedRoot.status === WatchedRoot.ACTIVE ||\r\n                    (relaxed && watchedRoot.status === WatchedRoot.STARTING)) {\r\n                return filterResult;\r\n            } else {\r\n                // We had a watched root, but it\'s no longer active, so it must now be invalid.\r\n                this._watchedRoot = undefined;\r\n                this._watchedRootFilterResult = false;\r\n                this._clearCachedData();\r\n            }\r\n        }\r\n        return false;\r\n    };\r\n    \r\n    /**\r\n     * Update the path for this entry\r\n     * @private\r\n     * @param {String} newPath\r\n     */\r\n    FileSystemEntry.prototype._setPath = function (newPath) {\r\n        var parts = newPath.split("/");\r\n        if (this.isDirectory) {\r\n            parts.pop(); // Remove the empty string after last trailing "/"\r\n        }\r\n        this._name = parts[parts.length - 1];\r\n        parts.pop(); // Remove name\r\n        \r\n        if (parts.length > 0) {\r\n            this._parentPath = parts.join("/") + "/";\r\n        } else {\r\n            // root directories have no parent path\r\n            this._parentPath = null;\r\n        }\r\n        \r\n        this._path = newPath;\r\n        \r\n        var watchedRoot = this._watchedRoot;\r\n        if (watchedRoot) {\r\n            if (newPath.indexOf(watchedRoot.entry.fullPath) === 0) {\r\n                // Update watchedRootFilterResult\r\n                this._watchedRootFilterResult = watchedRoot.filter(this._name, this._parentPath);\r\n            } else {\r\n                // The entry was moved outside of the watched root\r\n                this._watchedRoot = null;\r\n                this._watchedRootFilterResult = false;\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Clear any cached data for this entry\r\n     * @private\r\n     */\r\n    FileSystemEntry.prototype._clearCachedData = function () {\r\n        this._stat = undefined;\r\n    };\r\n    \r\n    /**\r\n     * Helpful toString for debugging purposes\r\n     */\r\n    FileSystemEntry.prototype.toString = function () {\r\n        return "[" + (this.isDirectory ? "Directory " : "File ") + this._path + "]";\r\n    };\r\n    \r\n    /**\r\n     * Check to see if the entry exists on disk. Note that there will NOT be an\r\n     * error returned if the file does not exist on the disk; in that case the\r\n     * error parameter will be null and the boolean will be false. The error \r\n     * parameter will only be truthy when an unexpected error was encountered\r\n     * during the test, in which case the state of the entry should be considered\r\n     * unknown.\r\n     *\r\n     * @param {function (?string, boolean)} callback Callback with a FileSystemError\r\n     *      string or a boolean indicating whether or not the file exists.\r\n     */\r\n    FileSystemEntry.prototype.exists = function (callback) {\r\n        if (this._stat) {\r\n            callback(null, true);\r\n            return;\r\n        }\r\n        \r\n        this._impl.exists(this._path, function (err, exists) {\r\n            if (err) {\r\n                this._clearCachedData();\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            if (!exists) {\r\n                this._clearCachedData();\r\n            }\r\n            \r\n            callback(null, exists);\r\n        }.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * Returns the stats for the entry.\r\n     *\r\n     * @param {function (?string, FileSystemStats=)} callback Callback with a\r\n     *      FileSystemError string or FileSystemStats object.\r\n     */\r\n    FileSystemEntry.prototype.stat = function (callback) {\r\n        if (this._stat) {\r\n            callback(null, this._stat);\r\n            return;\r\n        }\r\n        \r\n        this._impl.stat(this._path, function (err, stat) {\r\n            if (err) {\r\n                this._clearCachedData();\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            if (this._isWatched()) {\r\n                this._stat = stat;\r\n            }\r\n            \r\n            callback(null, stat);\r\n        }.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * Rename this entry.\r\n     *\r\n     * @param {string} newFullPath New path & name for this entry.\r\n     * @param {function (?string)=} callback Callback with a single FileSystemError\r\n     *      string parameter.\r\n     */\r\n    FileSystemEntry.prototype.rename = function (newFullPath, callback) {\r\n        callback = callback || function () {};\r\n        \r\n        // Block external change events until after the write has finished\r\n        this._fileSystem._beginChange();\r\n        \r\n        this._impl.rename(this._path, newFullPath, function (err) {\r\n            var oldFullPath = this._path;\r\n            \r\n            try {\r\n                if (err) {\r\n                    this._clearCachedData();\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                \r\n                // Update internal filesystem state\r\n                this._fileSystem._handleRename(this._path, newFullPath, this.isDirectory);\r\n                \r\n                try {\r\n                    // Notify the caller\r\n                    callback(null);\r\n                } finally {\r\n                    // Notify rename listeners\r\n                    this._fileSystem._fireRenameEvent(oldFullPath, newFullPath);\r\n                }\r\n            } finally {\r\n                // Unblock external change events\r\n                this._fileSystem._endChange();\r\n            }\r\n        }.bind(this));\r\n    };\r\n        \r\n    /**\r\n     * Permanently delete this entry. For Directories, this will delete the directory\r\n     * and all of its contents. For reversible delete, see moveToTrash().\r\n     *\r\n     * @param {function (?string)=} callback Callback with a single FileSystemError\r\n     *      string parameter.\r\n     */\r\n    FileSystemEntry.prototype.unlink = function (callback) {\r\n        callback = callback || function () {};\r\n        \r\n        // Block external change events until after the write has finished\r\n        this._fileSystem._beginChange();\r\n        \r\n        this._clearCachedData();\r\n        this._impl.unlink(this._path, function (err) {\r\n            var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\r\n\r\n            // Update internal filesystem state\r\n            this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\r\n                try {\r\n                    // Notify the caller \r\n                    callback(err);\r\n                } finally {\r\n                    // Notify change listeners\r\n                    this._fileSystem._fireChangeEvent(parent, added, removed);\r\n                    \r\n                    // Unblock external change events\r\n                    this._fileSystem._endChange();\r\n                }\r\n            }.bind(this));\r\n        }.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * Move this entry to the trash. If the underlying file system doesn\'t support move\r\n     * to trash, the item is permanently deleted.\r\n     *\r\n     * @param {function (?string)=} callback Callback with a single FileSystemError\r\n     *      string parameter.\r\n     */\r\n    FileSystemEntry.prototype.moveToTrash = function (callback) {\r\n        if (!this._impl.moveToTrash) {\r\n            this.unlink(callback);\r\n            return;\r\n        }\r\n\r\n        callback = callback || function () {};\r\n\r\n        // Block external change events until after the write has finished\r\n        this._fileSystem._beginChange();\r\n        \r\n        this._clearCachedData();\r\n        this._impl.moveToTrash(this._path, function (err) {\r\n            var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\r\n\r\n            // Update internal filesystem state\r\n            this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\r\n                try {\r\n                    // Notify the caller\r\n                    callback(err);\r\n                } finally {\r\n                    // Notify change listeners\r\n                    this._fileSystem._fireChangeEvent(parent, added, removed);\r\n                    \r\n                    // Unblock external change events\r\n                    this._fileSystem._endChange();\r\n                }\r\n            }.bind(this));\r\n        }.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * Private helper function for FileSystemEntry.visit that requires sanitized options.\r\n     *\r\n     * @private\r\n     * @param {FileSystemStats} stats - the stats for this entry\r\n     * @param {{string: boolean}} visitedPaths - the set of fullPaths that have already been visited\r\n     * @param {function(FileSystemEntry): boolean} visitor - A visitor function, which is\r\n     *      applied to descendent FileSystemEntry objects. If the function returns false for\r\n     *      a particular Directory entry, that directory\'s descendents will not be visited.\r\n     * @param {{maxDepth: number, maxEntriesCounter: {value: number}}} options\r\n     * @param {function(?string)=} callback Callback with single FileSystemError string parameter.\r\n     */\r\n    FileSystemEntry.prototype._visitHelper = function (stats, visitedPaths, visitor, options, callback) {\r\n        var maxDepth = options.maxDepth,\r\n            maxEntriesCounter = options.maxEntriesCounter;\r\n        \r\n        if (maxEntriesCounter.value-- <= 0 || maxDepth-- < 0) {\r\n            // The outer FileSystemEntry.visit call is responsible for applying\r\n            // the main callback to FileSystemError.TOO_MANY_FILES in this case\r\n            callback(null);\r\n            return;\r\n        }\r\n        \r\n        if (this.isDirectory) {\r\n            var visitedPath = stats.realPath || this.fullPath;\r\n    \r\n            if (visitedPaths.hasOwnProperty(visitedPath)) {\r\n                // Link cycle detected\r\n                callback(null);\r\n                return;\r\n            }\r\n            \r\n            visitedPaths[visitedPath] = true;\r\n        }\r\n        \r\n        if (!visitor(this) || this.isFile) {\r\n            callback(null);\r\n            return;\r\n        }\r\n        \r\n        this.getContents(function (err, entries, entriesStats) {\r\n            if (err) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            var counter = entries.length;\r\n            if (counter === 0) {\r\n                callback(null);\r\n                return;\r\n            }\r\n\r\n            function helperCallback(err) {\r\n                if (--counter === 0) {\r\n                    callback(null);\r\n                }\r\n            }\r\n            \r\n            var nextOptions = {\r\n                maxDepth: maxDepth,\r\n                maxEntriesCounter: maxEntriesCounter\r\n            };\r\n            \r\n            entries.forEach(function (entry, index) {\r\n                var stats = entriesStats[index];\r\n                entry._visitHelper(stats, visitedPaths, visitor, nextOptions, helperCallback);\r\n            });\r\n        }.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * Visit this entry and its descendents with the supplied visitor function.\r\n     * Correctly handles symbolic link cycles and options can be provided to limit\r\n     * search depth and total number of entries visited. No particular traversal\r\n     * order is guaranteed; instead of relying on such an order, it is preferable\r\n     * to use the visit function to build a list of visited entries, sort those\r\n     * entries as desired, and then process them. Whenever possible, deep\r\n     * filesystem traversals should use this method. \r\n     *\r\n     * @param {function(FileSystemEntry): boolean} visitor - A visitor function, which is\r\n     *      applied to this entry and all descendent FileSystemEntry objects. If the function returns\r\n     *      false for a particular Directory entry, that directory\'s descendents will not be visited.\r\n     * @param {{maxDepth: number=, maxEntries: number=}=} options\r\n     * @param {function(?string)=} callback Callback with single FileSystemError string parameter.\r\n     */\r\n    FileSystemEntry.prototype.visit = function (visitor, options, callback) {\r\n        if (typeof options === "function") {\r\n            callback = options;\r\n            options = {};\r\n        } else {\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n            \r\n            callback = callback || function () {};\r\n        }\r\n        \r\n        if (options.maxDepth === undefined) {\r\n            options.maxDepth = VISIT_DEFAULT_MAX_DEPTH;\r\n        }\r\n        \r\n        if (options.maxEntries === undefined) {\r\n            options.maxEntries = VISIT_DEFAULT_MAX_ENTRIES;\r\n        }\r\n\r\n        options.maxEntriesCounter = { value: options.maxEntries };\r\n        \r\n        this.stat(function (err, stats) {\r\n            if (err) {\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            this._visitHelper(stats, {}, visitor, options, function (err) {\r\n                if (callback) {\r\n                    if (err) {\r\n                        callback(err);\r\n                        return;\r\n                    }\r\n                    \r\n                    if (options.maxEntriesCounter.value < 0) {\r\n                        callback(FileSystemError.TOO_MANY_ENTRIES);\r\n                        return;\r\n                    }\r\n                    \r\n                    callback(null);\r\n                }\r\n            }.bind(this));\r\n        }.bind(this));\r\n    };\r\n    \r\n    // Export this class\r\n    module.exports = FileSystemEntry;\r\n});\r\n\n//# sourceURL=/filesystem/FileSystemEntry.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\ndefine(\'filesystem/Directory\',[\'require\',\'exports\',\'module\',\'filesystem/FileSystemEntry\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var FileSystemEntry = require("filesystem/FileSystemEntry");\r\n    \r\n    /*\r\n     * Model for a file system Directory.\r\n     *\r\n     * This class should *not* be instantiated directly. Use FileSystem.getDirectoryForPath,\r\n     * FileSystem.resolve, or Directory.getContents to create an instance of this class.\r\n     *\r\n     * Note: Directory.fullPath always has a trailing slash.\r\n     *\r\n     * See the FileSystem class for more details.\r\n     *\r\n     * @constructor\r\n     * @param {!string} fullPath The full path for this Directory.\r\n     * @param {!FileSystem} fileSystem The file system associated with this Directory.\r\n     */\r\n    function Directory(fullPath, fileSystem) {\r\n        this._isDirectory = true;\r\n        FileSystemEntry.call(this, fullPath, fileSystem);\r\n    }\r\n    \r\n    Directory.prototype = Object.create(FileSystemEntry.prototype);\r\n    Directory.prototype.constructor = Directory;\r\n    Directory.prototype.parentClass = FileSystemEntry.prototype;\r\n    \r\n    /**\r\n     * The contents of this directory. This "private" property is used by FileSystem.\r\n     * @type {Array<FileSystemEntry>}\r\n     */\r\n    Directory.prototype._contents = null;\r\n\r\n    /**\r\n     * The stats for the contents of this directory, such that this._contentsStats[i]\r\n     * corresponds to this._contents[i].\r\n     * @type {Array.<FileSystemStats>}\r\n     */\r\n    Directory.prototype._contentsStats = null;\r\n    \r\n    /**\r\n     * The stats errors for the contents of this directory.\r\n     * @type {object.<string: string>} fullPaths are mapped to FileSystemError strings\r\n     */\r\n    Directory.prototype._contentsStatsErrors = null;\r\n    \r\n    /**\r\n     * Clear any cached data for this directory. By default, we clear the contents\r\n     * of immediate children as well, because in some cases file watchers fail \r\n     * provide precise change notifications. (Sometimes, like after a "git\r\n     * checkout", they just report that some directory has changed when in fact\r\n     * many of the file within the directory have changed.\r\n     * \r\n     * @private\r\n     * @param {boolean=} preserveImmediateChildren\r\n     */\r\n    Directory.prototype._clearCachedData = function (preserveImmediateChildren) {\r\n        FileSystemEntry.prototype._clearCachedData.apply(this);\r\n        \r\n        if (!preserveImmediateChildren) {\r\n            if (this._contents) {\r\n                this._contents.forEach(function (child) {\r\n                    child._clearCachedData(true);\r\n                });\r\n            } else {\r\n                // No cached _contents, but child entries may still exist.\r\n                // Scan the full index to catch all of them.\r\n                var dirPath = this.fullPath;\r\n                this._fileSystem._index.visitAll(function (entry) {\r\n                    if (entry.parentPath === dirPath) {\r\n                        entry._clearCachedData(true);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        \r\n        this._contents = undefined;\r\n        this._contentsStats = undefined;\r\n        this._contentsStatsErrors = undefined;\r\n    };\r\n    \r\n    /**\r\n     * Apply each callback in a list to the provided arguments. Callbacks\r\n     * can throw without preventing other callbacks from being applied.\r\n     * \r\n     * @private\r\n     * @param {Array.<function>} callbacks The callbacks to apply\r\n     * @param {Array} args The arguments to which each callback is applied\r\n     */\r\n    function _applyAllCallbacks(callbacks, args) {\r\n        if (callbacks.length > 0) {\r\n            var callback = callbacks.pop();\r\n            try {\r\n                callback.apply(undefined, args);\r\n            } finally {\r\n                _applyAllCallbacks(callbacks, args);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Read the contents of a Directory. If this Directory is under a watch root,\r\n     * the listing will exclude any items filtered out by the watch root\'s filter\r\n     * function.\r\n     *\r\n     * @param {Directory} directory Directory whose contents you want to get\r\n     * @param {function (?string, Array.<FileSystemEntry>=, Array.<FileSystemStats>=, Object.<string, string>=)} callback\r\n     *          Callback that is passed an error code or the stat-able contents\r\n     *          of the directory along with the stats for these entries and a\r\n     *          fullPath-to-FileSystemError string map of unstat-able entries\r\n     *          and their stat errors. If there are no stat errors then the last\r\n     *          parameter shall remain undefined.\r\n     */\r\n    Directory.prototype.getContents = function (callback) {\r\n        if (this._contentsCallbacks) {\r\n            // There is already a pending call for this directory\'s contents.\r\n            // Push the new callback onto the stack and return.\r\n            this._contentsCallbacks.push(callback);\r\n            return;\r\n        }\r\n\r\n        // Return cached contents if the directory is watched\r\n        if (this._contents) {\r\n            callback(null, this._contents, this._contentsStats, this._contentsStatsErrors);\r\n            return;\r\n        }\r\n        \r\n        this._contentsCallbacks = [callback];\r\n        \r\n        this._impl.readdir(this.fullPath, function (err, names, stats) {\r\n            var contents = [],\r\n                contentsStats = [],\r\n                contentsStatsErrors;\r\n            \r\n            if (err) {\r\n                this._clearCachedData();\r\n            } else {\r\n                // Use the "relaxed" parameter to _isWatched because it\'s OK to\r\n                // cache data even while watchers are still starting up\r\n                var watched = this._isWatched(true);\r\n                \r\n                names.forEach(function (name, index) {\r\n                    var entryPath = this.fullPath + name;\r\n                    \r\n                    if (this._fileSystem._indexFilter(entryPath, name)) {\r\n                        var entryStats = stats[index],\r\n                            entry;\r\n                        \r\n                        // Note: not all entries necessarily have associated stats.\r\n                        if (typeof entryStats === "string") {\r\n                            // entryStats is an error string\r\n                            if (contentsStatsErrors === undefined) {\r\n                                contentsStatsErrors = {};\r\n                            }\r\n                            contentsStatsErrors[entryPath] = entryStats;\r\n                        } else {\r\n                            // entryStats is a FileSystemStats object\r\n                            if (entryStats.isFile) {\r\n                                entry = this._fileSystem.getFileForPath(entryPath);\r\n                            } else {\r\n                                entry = this._fileSystem.getDirectoryForPath(entryPath);\r\n                            }\r\n                            \r\n                            if (watched) {\r\n                                entry._stat = entryStats;\r\n                            }\r\n                            \r\n                            contents.push(entry);\r\n                            contentsStats.push(entryStats);\r\n                        }\r\n                    }\r\n                }, this);\r\n\r\n                if (watched) {\r\n                    this._contents = contents;\r\n                    this._contentsStats = contentsStats;\r\n                    this._contentsStatsErrors = contentsStatsErrors;\r\n                }\r\n            }\r\n            \r\n            // Reset the callback list before we begin calling back so that\r\n            // synchronous reentrant calls are handled correctly.\r\n            var currentCallbacks = this._contentsCallbacks;\r\n            \r\n            this._contentsCallbacks = null;\r\n            \r\n            // Invoke all saved callbacks\r\n            var callbackArgs = [err, contents, contentsStats, contentsStatsErrors];\r\n            _applyAllCallbacks(currentCallbacks, callbackArgs);\r\n        }.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * Create a directory\r\n     *\r\n     * @param {function (?string, FileSystemStats=)=} callback Callback resolved with a\r\n     *      FileSystemError string or the stat object for the created directory.\r\n     */\r\n    Directory.prototype.create = function (callback) {\r\n        callback = callback || function () {};\r\n        \r\n        // Block external change events until after the write has finished\r\n        this._fileSystem._beginChange();\r\n        \r\n        this._impl.mkdir(this._path, function (err, stat) {\r\n            if (err) {\r\n                this._clearCachedData();\r\n                try {\r\n                    callback(err);\r\n                    return;\r\n                } finally {\r\n                    // Unblock external change events\r\n                    this._fileSystem._endChange();\r\n                }\r\n            }\r\n\r\n            var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\r\n            \r\n            // Update internal filesystem state\r\n            if (this._isWatched()) {\r\n                this._stat = stat;\r\n            }\r\n            \r\n            this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\r\n                try {\r\n                    callback(null, stat);\r\n                } finally {\r\n                    this._fileSystem._fireChangeEvent(parent, added, removed);\r\n                    // Unblock external change events\r\n                    this._fileSystem._endChange();\r\n                }\r\n            }.bind(this));\r\n        }.bind(this));\r\n    };\r\n    \r\n    // Export this class\r\n    module.exports = Directory;\r\n});\r\n\n//# sourceURL=/filesystem/Directory.js'),eval("/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\ndefine('filesystem/File',['require','exports','module','filesystem/FileSystemEntry','filesystem/FileSystemError'],function (require, exports, module) {\r\n    \"use strict\";\r\n    \r\n    var FileSystemEntry = require(\"filesystem/FileSystemEntry\"),\r\n        FileSystemError = require(\"filesystem/FileSystemError\");\r\n    \r\n    \r\n    /*\r\n     * Model for a File.\r\n     *\r\n     * This class should *not* be instantiated directly. Use FileSystem.getFileForPath,\r\n     * FileSystem.resolve, or Directory.getContents to create an instance of this class.\r\n     *\r\n     * See the FileSystem class for more details.\r\n     *\r\n     * @constructor\r\n     * @param {!string} fullPath The full path for this File.\r\n     * @param {!FileSystem} fileSystem The file system associated with this File.\r\n     */\r\n    function File(fullPath, fileSystem) {\r\n        this._isFile = true;\r\n        FileSystemEntry.call(this, fullPath, fileSystem);\r\n    }\r\n    \r\n    File.prototype = Object.create(FileSystemEntry.prototype);\r\n    File.prototype.constructor = File;\r\n    File.prototype.parentClass = FileSystemEntry.prototype;\r\n    \r\n    /**\r\n     * Cached contents of this file. This value is nullable but should NOT be undefined.\r\n     * @private\r\n     * @type {?string}\r\n     */\r\n    File.prototype._contents = null;\r\n    \r\n    /**\r\n     * Consistency hash for this file. Reads and writes update this value, and\r\n     * writes confirm the hash before overwriting existing files. The type of\r\n     * this object is dependent on the FileSystemImpl; the only constraint is\r\n     * that === can be used as an equality relation on hashes.\r\n     * @private\r\n     * @type {?object}\r\n     */\r\n    File.prototype._hash = null;\r\n    \r\n    /**\r\n     * Clear any cached data for this file. Note that this explicitly does NOT\r\n     * clear the file's hash.\r\n     * @private\r\n     */\r\n    File.prototype._clearCachedData = function () {\r\n        FileSystemEntry.prototype._clearCachedData.apply(this);\r\n        this._contents = null;\r\n    };\r\n    \r\n    /**\r\n     * Read a file.\r\n     *\r\n     * @param {Object=} options Currently unused.\r\n     * @param {function (?string, string=, FileSystemStats=)} callback Callback that is passed the\r\n     *              FileSystemError string or the file's contents and its stats.\r\n     */\r\n    File.prototype.read = function (options, callback) {\r\n        if (typeof (options) === \"function\") {\r\n            callback = options;\r\n            options = {};\r\n        }\r\n        \r\n        // We don't need to check isWatched() here because contents are only saved\r\n        // for watched files. Note that we need to explicitly test this._contents\r\n        // for a default value; otherwise it could be the empty string, which is\r\n        // falsey.\r\n        if (this._contents !== null && this._stat) {\r\n            callback(null, this._contents, this._stat);\r\n            return;\r\n        }\r\n        \r\n        var watched = this._isWatched();\r\n        if (watched) {\r\n            options.stat = this._stat;\r\n        }\r\n        \r\n        this._impl.readFile(this._path, options, function (err, data, stat) {\r\n            if (err) {\r\n                this._clearCachedData();\r\n                callback(err);\r\n                return;\r\n            }\r\n            \r\n            // Always store the hash\r\n            this._hash = stat._hash;\r\n            \r\n            // Only cache data for watched files\r\n            if (watched) {\r\n                this._stat = stat;\r\n                this._contents = data;\r\n            }\r\n            \r\n            callback(err, data, stat);\r\n        }.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * Write a file.\r\n     *\r\n     * @param {string} data Data to write.\r\n     * @param {object=} options Currently unused.\r\n     * @param {function (?string, FileSystemStats=)=} callback Callback that is passed the\r\n     *              FileSystemError string or the file's new stats.\r\n     */\r\n    File.prototype.write = function (data, options, callback) {\r\n        if (typeof options === \"function\") {\r\n            callback = options;\r\n            options = {};\r\n        } else {\r\n            if (options === undefined) {\r\n                options = {};\r\n            }\r\n            \r\n            callback = callback || function () {};\r\n        }\r\n        \r\n        // Request a consistency check if the write is not blind\r\n        if (!options.blind) {\r\n            options.expectedHash = this._hash;\r\n            options.expectedContents = this._contents;\r\n        }\r\n        \r\n        // Block external change events until after the write has finished\r\n        this._fileSystem._beginChange();\r\n        \r\n        this._impl.writeFile(this._path, data, options, function (err, stat, created) {\r\n            if (err) {\r\n                this._clearCachedData();\r\n                try {\r\n                    callback(err);\r\n                    return;\r\n                } finally {\r\n                    // Always unblock external change events\r\n                    this._fileSystem._endChange();\r\n                }\r\n            }\r\n            \r\n            // Always store the hash\r\n            this._hash = stat._hash;\r\n            \r\n            // Only cache data for watched files\r\n            if (this._isWatched()) {\r\n                this._stat = stat;\r\n                this._contents = data;\r\n            }\r\n            \r\n            if (created) {\r\n                var parent = this._fileSystem.getDirectoryForPath(this.parentPath);\r\n                this._fileSystem._handleDirectoryChange(parent, function (added, removed) {\r\n                    try {\r\n                        // Notify the caller\r\n                        callback(null, stat);\r\n                    } finally {\r\n                        // If the write succeeded, fire a synthetic change event\r\n                        this._fileSystem._fireChangeEvent(parent, added, removed);\r\n                        \r\n                        // Always unblock external change events\r\n                        this._fileSystem._endChange();\r\n                    }\r\n                }.bind(this));\r\n            } else {\r\n                try {\r\n                    // Notify the caller\r\n                    callback(null, stat);\r\n                } finally {\r\n                    // existing file modified\r\n                    this._fileSystem._fireChangeEvent(this);\r\n                    \r\n                    // Always unblock external change events\r\n                    this._fileSystem._endChange();\r\n                }\r\n            }\r\n        }.bind(this));\r\n    };\r\n    \r\n    // Export this class\r\n    module.exports = File;\r\n});\r\n\n//# sourceURL=/filesystem/File.js"),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\n/**\r\n * FileIndex is an internal module used by FileSystem to maintain an index of all files and directories.\r\n *\r\n * This module is *only* used by FileSystem, and should not be called directly.\r\n */\r\ndefine(\'filesystem/FileIndex\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    /**\r\n     * @constructor\r\n     */\r\n    function FileIndex() {\r\n        this._index = {};\r\n    }\r\n    \r\n    /**\r\n     * Master index\r\n     * \r\n     * @type {Object.<string, File|Directory>} Maps a fullPath to a File or Directory object\r\n     */\r\n    FileIndex.prototype._index = null;\r\n    \r\n    /**\r\n     * Clear the file index cache.\r\n     */\r\n    FileIndex.prototype.clear = function () {\r\n        this._index = {};\r\n    };\r\n    \r\n    /**\r\n     * Visits every entry in the entire index; no stopping condition.\r\n     * @param {!function(FileSystemEntry, string):void} Called with an entry and its fullPath\r\n     */\r\n    FileIndex.prototype.visitAll = function (visitor) {\r\n        var path;\r\n        for (path in this._index) {\r\n            if (this._index.hasOwnProperty(path)) {\r\n                visitor(this._index[path], path);\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Add an entry.\r\n     *\r\n     * @param {FileSystemEntry} entry The entry to add.\r\n     */\r\n    FileIndex.prototype.addEntry = function (entry) {\r\n        this._index[entry.fullPath] = entry;\r\n    };\r\n    \r\n    /**\r\n     * Remove an entry.\r\n     * \r\n     * @param {FileSystemEntry} entry The entry to remove.\r\n     */\r\n    FileIndex.prototype.removeEntry = function (entry) {\r\n        var path = entry.fullPath,\r\n            property,\r\n            member;\r\n        \r\n        function replaceMember(property) {\r\n            var member = entry[property];\r\n            if (typeof member === "function") {\r\n                entry[property] = function () {\r\n                    console.warn("FileSystemEntry used after being removed from index: ", path);\r\n                    return member.apply(entry, arguments);\r\n                };\r\n            }\r\n        }\r\n        \r\n        delete this._index[path];\r\n        \r\n        for (property in entry) {\r\n            if (entry.hasOwnProperty(property)) {\r\n                replaceMember(property);\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Notify the index that an entry has been renamed. This updates\r\n     * all affected entries in the index.\r\n     *\r\n     * @param {string} oldPath\r\n     * @param {string} newPath\r\n     * @param {boolean} isDirectory\r\n     */\r\n    FileIndex.prototype.entryRenamed = function (oldPath, newPath, isDirectory) {\r\n        var path,\r\n            splitName = oldPath.split("/"),\r\n            finalPart = splitName.length - 1,\r\n            renameMap = {};\r\n        \r\n        // Find all entries affected by the rename and put into a separate map.\r\n        for (path in this._index) {\r\n            if (this._index.hasOwnProperty(path)) {\r\n                // See if we have a match. For directories, see if the path\r\n                // starts with the old name. This is safe since paths always end\r\n                // with \'/\'. For files, see if there is an exact match between\r\n                // the path and the old name.\r\n                if (isDirectory ? path.indexOf(oldPath) === 0 : path === oldPath) {\r\n                    renameMap[path] = newPath + path.substr(oldPath.length);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Do the rename. \r\n        for (path in renameMap) {\r\n            if (renameMap.hasOwnProperty(path)) {\r\n                var item = this._index[path];\r\n                \r\n                // Sanity check to make sure the item and path still match\r\n                console.assert(item.fullPath === path);\r\n                \r\n                delete this._index[path];\r\n                this._index[renameMap[path]] = item;\r\n                item._setPath(renameMap[path]);\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Returns the cached entry for the specified path, or undefined\r\n     * if the path has not been cached.\r\n     * \r\n     * @param {string} path The path of the entry to return.\r\n     * @return {File|Directory} The entry for the path, or undefined if it hasn\'t \r\n     *              been cached yet.\r\n     */\r\n    FileIndex.prototype.getEntry = function (path) {\r\n        return this._index[path];\r\n    };\r\n    \r\n    // Export public API\r\n    module.exports = FileIndex;\r\n});\r\n\n//# sourceURL=/filesystem/FileIndex.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\n/**\r\n * The FileSystemStats represents a particular FileSystemEntry\'s stats.\r\n */\r\ndefine(\'filesystem/FileSystemStats\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    /**\r\n     * @constructor\r\n     * @param {{isFile: boolean, mtime: Date, size: Number, realPath: ?string, hash: object}} options\r\n     */\r\n    function FileSystemStats(options) {\r\n        var isFile = options.isFile;\r\n        \r\n        this._isFile = isFile;\r\n        this._isDirectory = !isFile;\r\n        this._mtime = options.mtime;\r\n        this._size = options.size;\r\n        this._hash = options.hash;\r\n        \r\n        var realPath = options.realPath;\r\n        if (realPath) {\r\n            if (!isFile && realPath[realPath.length - 1] !== "/") {\r\n                realPath += "/";\r\n            }\r\n        \r\n            this._realPath = realPath;\r\n        }\r\n    }\r\n    \r\n    // Add "isFile", "isDirectory", "mtime" and "size" getters\r\n    Object.defineProperties(FileSystemStats.prototype, {\r\n        "isFile": {\r\n            get: function () { return this._isFile; },\r\n            set: function () { throw new Error("Cannot set isFile"); }\r\n        },\r\n        "isDirectory": {\r\n            get: function () { return this._isDirectory; },\r\n            set: function () { throw new Error("Cannot set isDirectory"); }\r\n        },\r\n        "mtime": {\r\n            get: function () { return this._mtime; },\r\n            set: function () { throw new Error("Cannot set mtime"); }\r\n        },\r\n        "size": {\r\n            get: function () { return this._size; },\r\n            set: function () { throw new Error("Cannot set size"); }\r\n        },\r\n        "realPath": {\r\n            get: function () { return this._realPath; },\r\n            set: function () { throw new Error("Cannot set realPath"); }\r\n        }\r\n    });\r\n    \r\n    /**\r\n     * Whether or not this is a stats object for a file\r\n     * @type {boolean}\r\n     */\r\n    FileSystemStats.prototype._isFile = false;\r\n\r\n    /**\r\n     * Whether or not this is a stats object for a directory\r\n     * @type {boolean}\r\n     */\r\n    FileSystemStats.prototype._isDirectory = false;\r\n    \r\n    /**\r\n     * Modification time for a file\r\n     * @type {Date}\r\n     */\r\n    FileSystemStats.prototype._mtime = null;\r\n\r\n    /**\r\n     * Size in bytes of a file\r\n     * @type {Number}\r\n     */\r\n    FileSystemStats.prototype._size = null;\r\n\r\n    /**\r\n     * Consistency hash for a file\r\n     * @type {object}\r\n     */\r\n    FileSystemStats.prototype._hash = null;\r\n    \r\n    /**\r\n     * The canonical path of this file or directory ONLY if it is a symbolic link,\r\n     * and null otherwise.\r\n     * \r\n     * @type {?string}\r\n     */\r\n    FileSystemStats.prototype._realPath = null;\r\n\r\n    module.exports = FileSystemStats;\r\n});\r\n\n//# sourceURL=/filesystem/FileSystemStats.js'),eval("!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define('thirdparty/makedrive/client/dist/makedrive',[],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.MakeDrive=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (global){\n/**\n * In node.js we want to use the ws module for WebSocket. In the\n * browser we can just use the native WebSocket. Here we adapt\n * the browser's WebSocket interface to more closely match ws\n * so that we can use either.\n *\n * This module gets used by browserify, see package.json\n */\n\nglobal.WebSocket.prototype.on = global.WebSocket.prototype.on || function(event, listener) {\n  this.addEventListener(event, listener);\n};\n\nglobal.WebSocket.prototype.removeListener = global.WebSocket.prototype.removeListener || function(event, listener) {\n  this.removeEventListener(event, listener);\n};\n\nglobal.WebSocket.prototype.once = global.WebSocket.prototype.once || function(event, listener) {\n  var ws = this;\n  this.addEventListener(event, function onEvent() {\n    ws.removeEventListener(event, onEvent);\n    listener.apply(null, arguments);\n  });\n};\n\nmodule.exports = global.WebSocket;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],2:[function(require,module,exports){\n(function (global){\n/**\n * MakeDrive is a single/shared Filer filesystem instance with\n * manual- and auto-sync'ing features. A client first gets the\n * filesystem instance like so:\n *\n * var fs = MakeDrive.fs();\n *\n * Multiple calls to MakeDrive.fs() will return the same instance.\n *\n * A number of configuration options can be passed to the fs() function.\n * These include:\n *\n * - manual=true - by default the filesystem syncs automatically in\n * the background. This disables it.\n *\n * - memory=<Boolean> - by default we use a persistent store (indexeddb\n * or websql). Using memory=true overrides and uses a temporary ram disk.\n *\n * - provider=<Object> - a Filer data provider to use instead of the\n * default provider normally used. The provider given should already\n * be instantiated (i.e., don't pass a constructor function).\n *\n * - forceCreate=<Boolean> - by default we return the same fs instance with\n * every call to MakeDrive.fs(). In some cases it is necessary to have\n * multiple instances.  Using forceCreate=true does this.\n *\n * - interval=<Number> - by default, the filesystem syncs every minute if\n * auto syncing is turned on otherwise the interval between syncs can be\n * specified in ms.\n *\n * Various bits of Filer are available on MakeDrive, including:\n *\n * - MakeDrive.Buffer\n * - MakeDrive.Path\n * - MakeDrive.Errors\n *\n * The filesystem instance returned by MakeDrive.fs() also includes\n * a new property `sync`.  The fs.sync property is an EventEmitter\n * which emits the following events:\n *\n * - 'error': an error occured while connecting/syncing. The error\n * object is passed as the first arg to the event.\n *\n * - 'connected': a connection was established with the sync server\n *\n * - 'disconnected': the connection to the sync server was lost, either\n * due to the client or server.\n *\n * - 'syncing': a sync with the server has begun. A subsequent 'completed'\n * or 'error' event should follow at some point, indicating whether\n * or not the sync was successful.\n *\n * - 'completed': a sync has completed and was successful.\n *\n *\n * The `sync` property also exposes a number of methods, including:\n *\n * - connect(url, [token]): try to connect to the specified sync server URL.\n * An 'error' or 'connected' event will follow, depending on success. If the\n * token parameter is provided, that authentication token will be used. Otherwise\n * the client will try to obtain one from the server's /api/sync route. This\n * requires the user to be authenticated previously with Webmaker.\n *\n * - disconnect(): disconnect from the sync server.\n *\n * - request(path): request a sync with the server for the specified\n * path. Such requests may or may not be processed right away.\n *\n *\n * Finally, the `sync` propery also exposes a `state`, which is the\n * current sync state and can be one of:\n *\n * sync.SYNC_DISCONNECTED = \"SYNC DISCONNECTED\" (also the initial state)\n * sync.SYNC_CONNECTING = \"SYNC CONNECTING\"\n * sync.SYNC_CONNECTED = \"SYNC CONNECTED\"\n * sync.SYNC_SYNCING = \"SYNC SYNCING\"\n * sync.SYNC_ERROR = \"SYNC ERROR\"\n */\n\nvar SyncManager = require('./sync-manager.js');\nvar SyncFileSystem = require('./sync-filesystem.js');\nvar Filer = require('../../lib/filer.js');\nvar resolvePath = require('../../lib/sync-path-resolver').resolve;\nvar EventEmitter = require('events').EventEmitter;\nvar request = require('request');\n\nvar MakeDrive = {};\nmodule.exports = MakeDrive;\n\nfunction createFS(options) {\n  options.manual = options.manual === true;\n  options.memory = options.memory === true;\n\n  // Use a supplied provider, in memory RAM disk, or Fallback provider (default).\n  var provider;\n  if(options.provider) {\n    provider = options.provider;\n  } else if(options.memory) {\n    provider = new Filer.FileSystem.providers.Memory('makedrive');\n  } else {\n    provider = new Filer.FileSystem.providers.Fallback('makedrive');\n  }\n\n  // Our fs instance is a modified Filer fs, with extra sync awareness\n  // for conflict mediation, etc.  We keep an internal reference to the\n  // raw Filer fs, and use the SyncFileSystem instance externally.\n  var _fs = new Filer.FileSystem({provider: provider});\n  var fs = new SyncFileSystem(_fs);\n  var sync = fs.sync = new EventEmitter();\n  var manager;\n\n  // Auto-sync handles\n  var autoSync;\n  var pathCache;\n\n  // State of the sync connection\n  sync.SYNC_DISCONNECTED = \"SYNC DISCONNECTED\";\n  sync.SYNC_CONNECTING = \"SYNC CONNECTING\";\n  sync.SYNC_CONNECTED = \"SYNC CONNECTED\";\n  sync.SYNC_SYNCING = \"SYNC SYNCING\";\n  sync.SYNC_ERROR = \"SYNC ERROR\";\n\n  // Intitially we are not connected\n  sync.state = sync.SYNC_DISCONNECTED;\n\n  // Optionally warn when closing the window if still syncing\n  function windowCloseHandler(event) {\n    if(!options.windowCloseWarning) {\n      return;\n    }\n\n    if(sync.state !== sync.SYNC_SYNCING) {\n      return;\n    }\n\n    var confirmationMessage = \"Sync currently underway, are you sure you want to close?\";\n    (event || global.event).returnValue = confirmationMessage;\n\n    return confirmationMessage;\n  }\n\n  function cleanupManager() {\n    if(!manager) {\n      return;\n    }\n    manager.close();\n    manager = null;\n  }\n\n  // Turn on auto-syncing if its not already on\n  sync.auto = function(interval) {\n    var syncInterval = interval|0 > 0 ? interval|0 : 60 * 1000;\n\n    if(autoSync) {\n      clearInterval(autoSync);\n    }\n\n    autoSync = setInterval(sync.request, syncInterval);\n  };\n\n  // Turn off auto-syncing and turn on manual syncing\n  sync.manual = function() {\n    if(autoSync) {\n      clearInterval(autoSync);\n      autoSync = null;\n    }\n  };\n\n  sync.onError = function(err) {\n    // Regress to the path that needed to be synced but failed\n    // (likely because of a sync LOCK)\n    fs.pathToSync = pathCache;\n    sync.state = sync.SYNC_ERROR;\n    sync.emit('error', err);\n  };\n\n  sync.onDisconnected = function() {\n    // Remove listeners so we don't leak instance variables\n    if(\"onbeforeunload\" in global) {\n      global.removeEventListener('beforeunload', windowCloseHandler);\n    }\n    if(\"onunload\" in global){\n      global.removeEventListener('unload', cleanupManager);\n    }\n\n    sync.state = sync.SYNC_DISCONNECTED;\n    sync.emit('disconnected');\n  };\n\n  // Request that a sync begin.\n  sync.request = function() {\n    // If we're not connected (or are already syncing), ignore this request\n    if(sync.state === sync.SYNC_DISCONNECTED || sync.state === sync.SYNC_ERROR) {\n      sync.emit('error', new Error('Invalid state. Expected ' + sync.SYNC_CONNECTED + ', got ' + sync.state));\n      return;\n    }\n\n    // If there were no changes to the filesystem, ignore this request\n    if(!fs.pathToSync) {\n      return;\n    }\n\n    // Cache the path that needs to be synced for error recovery\n    pathCache = fs.pathToSync;\n    fs.pathToSync = null;\n    manager.syncPath(pathCache);\n  };\n\n  // Try to connect to the server.\n  sync.connect = function(url, token) {\n    // Bail if we're already connected\n    if(sync.state !== sync.SYNC_DISCONNECTED &&\n       sync.state !== sync.ERROR) {\n      sync.emit('error', new Error(\"MakeDrive: Attempted to connect to \\\"\" + url + \"\\\", but a connection already exists!\"));\n      return;\n    }\n\n    // Also bail if we already have a SyncManager\n    if(manager) {\n      return;\n    }\n\n    // Upgrade connection state to `connecting`\n    sync.state = sync.SYNC_CONNECTING;\n\n    function downstreamSyncCompleted() {\n      // Re-wire message handler functions for regular syncing\n      // now that initial downstream sync is completed.\n      sync.onSyncing = function() {\n        sync.state = sync.SYNC_SYNCING;\n        sync.emit('syncing');\n      };\n\n      sync.onCompleted = function(paths) {\n        // If changes happened to the files that needed to be synced\n        // during the sync itself, they will be overwritten\n        // https://github.com/mozilla/makedrive/issues/129 and\n        // https://github.com/mozilla/makedrive/issues/3\n\n        function complete() {\n          sync.state = sync.SYNC_CONNECTED;\n          sync.emit('completed');\n        }\n\n        if(!paths) {\n          return complete();\n        }\n\n        manager.resetUnsynced(paths, function(err) {\n          if(err) {\n            return sync.onError(err);\n          }\n\n          complete();\n        });\n      };\n\n      // Upgrade connection state to 'connected'\n      sync.state = sync.SYNC_CONNECTED;\n\n      // If we're in manual mode, bail before starting auto-sync\n      if(options.manual) {\n        sync.manual();\n      } else {\n        sync.auto(options.interval);\n      }\n\n      // In a browser, try to clean-up after ourselves when window goes away\n      if(\"onbeforeunload\" in global) {\n        global.addEventListener('beforeunload', windowCloseHandler);\n      }\n      if(\"onunload\" in global){\n        global.addEventListener('unload', cleanupManager);\n      }\n\n      sync.emit('connected');\n    }\n\n    function connect(token) {\n      // Try to connect to provided server URL. Use the raw Filer fs\n      // instance for all rsync operations on the filesystem, so that we\n      // can untangle changes done by user vs. sync code.\n      manager = new SyncManager(sync, _fs);\n      manager.init(url, token, function(err) {\n        if(err) {\n          sync.onError(err);\n          return;\n        }\n\n        // Wait on initial downstream sync events to complete\n        sync.onSyncing = function() {\n          // do nothing, wait for onCompleted()\n        };\n        sync.onCompleted = function() {\n          // Downstream sync is done, finish connect() setup\n          downstreamSyncCompleted();\n        };\n      });\n    }\n\n    // If we were provided a token, we can connect right away, otherwise\n    // we need to get one first via the /api/sync route\n    if(token) {\n      connect(token);\n    } else {\n      // Remove WebSocket protocol from URL, and swap for http:// or https://\n      // ws://drive.webmaker.org/ -> http://drive.webmaker.org/api/sync\n      var apiSync = url.replace(/^([^\\/]*\\/\\/)?/, function(match, p1) {\n        return p1 === 'wss://' ? 'https://' : 'http://';\n      });\n      // Also add /api/sync to the end:\n      apiSync = apiSync.replace(/\\/?$/, '/api/sync');\n\n      request({\n        url: apiSync,\n        method: 'GET',\n        json: true,\n        withCredentials: true\n      }, function(err, msg, body) {\n        var statusCode;\n        var error;\n\n        statusCode = msg && msg.statusCode;\n        error = statusCode !== 200 ?\n          { message: err || 'Unable to get token', code: statusCode } : null;\n\n        if(error) {\n          sync.onError(error);\n        } else {\n          connect(body);\n        }\n      });\n    }\n  };\n\n  // Disconnect from the server\n  sync.disconnect = function() {\n    // Bail if we're not already connected\n    if(sync.state === sync.SYNC_DISCONNECTED ||\n       sync.state === sync.ERROR) {\n      sync.emit('error', new Error(\"MakeDrive: Attempted to disconnect, but no server connection exists!\"));\n      return;\n    }\n\n    // Stop auto-syncing\n    if(autoSync) {\n      clearInterval(autoSync);\n      autoSync = null;\n      fs.pathToSync = null;\n    }\n\n    // Do a proper network shutdown\n    cleanupManager();\n\n    sync.onDisconnected();\n  };\n\n  return fs;\n}\n\n// Manage single instance of a Filer filesystem with auto-sync'ing\nvar sharedFS;\n\nMakeDrive.fs = function(options) {\n  options = options || {};\n\n  // We usually only want to hand out a single, shared instance\n  // for every call, but sometimes you need multiple (e.g., tests)\n  if(options.forceCreate) {\n    return createFS(options);\n  }\n\n  if(!sharedFS) {\n    sharedFS = createFS(options);\n  }\n  return sharedFS;\n};\n\n// Expose bits of Filer that clients will need on MakeDrive\nMakeDrive.Buffer = Filer.Buffer;\nMakeDrive.Path = Filer.Path;\nMakeDrive.Errors = Filer.Errors;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../../lib/filer.js\":13,\"../../lib/sync-path-resolver\":17,\"./sync-filesystem.js\":4,\"./sync-manager.js\":5,\"events\":23,\"request\":22}],3:[function(require,module,exports){\nvar SyncMessage = require('../../lib/syncmessage');\nvar rsync = require('../../lib/rsync');\nvar rsyncOptions = require('../../lib/constants').rsyncDefaults;\nvar serializeDiff = require('../../lib/diff').serialize;\nvar deserializeDiff = require('../../lib/diff').deserialize;\nvar states = require('./sync-states');\nvar steps = require('./sync-steps');\nvar dirname = require('../../lib/filer').Path.dirname;\n\nfunction onError(syncManager, err) {\n  syncManager.session.step = steps.FAILED;\n  syncManager.sync.onError(err);\n}\n\n// Checks if path is in masterPath\nfunction hasCommonPath(masterPath, path) {\n  if(masterPath === path) {\n    return true;\n  }\n\n  if(path === '/') {\n    return false;\n  }\n\n  return hasCommonPath(masterPath, dirname(path));\n}\n\nfunction handleRequest(syncManager, data) {\n  var fs = syncManager.fs;\n  var sync = syncManager.sync;\n  var session = syncManager.session;\n  var socket = syncManager.socket;\n\n  function handleChecksumRequest() {\n    var srcList = session.srcList = data.content.srcList;\n    session.path = data.content.path;\n    fs.modifiedPath = null;\n    sync.onSyncing();\n\n    rsync.checksums(fs, session.path, srcList, rsyncOptions, function(err, checksums) {\n      if (err) {\n        return onError(syncManager, err);\n      }\n\n      session.step = steps.PATCH;\n\n      var message = SyncMessage.request.diffs;\n      message.content = {checksums: checksums};\n      socket.send(message.stringify());\n    });\n  }\n\n  function handleDiffRequest() {\n    rsync.diff(fs, session.path, data.content.checksums, rsyncOptions, function(err, diffs) {\n      if(err){\n        return onError(syncManager, err);\n      }\n\n      session.step = steps.PATCH;\n\n      var message = SyncMessage.response.diffs;\n      message.content = {diffs: serializeDiff(diffs)};\n      socket.send(message.stringify());\n    });\n  }\n\n\n  if(data.is.chksum && session.is.ready &&\n     (session.is.synced || session.is.failed)) {\n    // DOWNSTREAM - CHKSUM\n    handleChecksumRequest();\n  } else if(data.is.diffs && session.is.syncing && session.is.diffs) {\n    // UPSTREAM - DIFFS\n    handleDiffRequest();\n  } else {\n    onError(syncManager, new Error('Failed to sync with the server. Current step is: ' +\n                                    session.step + '. Current state is: ' + session.state));  }\n}\n\nfunction handleResponse(syncManager, data) {\n  var fs = syncManager.fs;\n  var sync = syncManager.sync;\n  var session = syncManager.session;\n  var socket = syncManager.socket;\n\n  function resendChecksums() {\n    if(!session.srcList) {\n      // Sourcelist was somehow reset, the entire downstream sync\n      // needs to be restarted\n      session.step = steps.FAILED;\n      socket.send(SyncMessage.response.reset.stringify());\n      return onError(syncManager, new Error('Fatal Error: Could not sync filesystem from server...trying again!'));\n    }\n\n    rsync.checksums(fs, session.path, session.srcList, rsyncOptions, function(err, checksums) {\n      if(err) {\n        socket.send(SyncMessage.response.reset.stringify());\n        return onError(syncManager, err);\n      }\n\n      var message = SyncMessage.request.diffs;\n      message.content = {checksums: checksums};\n      socket.send(message.stringify());\n    });\n  }\n\n  function handleSrcListResponse() {\n    session.state = states.SYNCING;\n    session.step = steps.INIT;\n    session.path = data.content.path;\n    sync.onSyncing();\n\n    rsync.sourceList(fs, session.path, rsyncOptions, function(err, srcList) {\n      if(err){\n        socket.send(SyncMessage.request.reset.stringify());\n        return onError(syncManager, err);\n      }\n\n      session.step = steps.DIFFS;\n\n      var message = SyncMessage.request.chksum;\n      message.content = {srcList: srcList};\n      socket.send(message.stringify());\n    });\n  }\n\n  function handlePatchAckResponse() {\n    session.state = states.READY;\n    session.step = steps.SYNCED;\n    sync.onCompleted(data.content.syncedPaths);\n  }\n\n  function handlePatchResponse() {\n    var modifiedPath = fs.modifiedPath;\n    fs.modifiedPath = null;\n\n    // If there was a change to the filesystem that shares a common path with\n    // the path being synced, regenerate the checksums and send them\n    // (even if it is the initial one)\n    if(modifiedPath && hasCommonPath(session.path, modifiedPath)) {\n      return resendChecksums();\n    }\n\n    var diffs = data.content.diffs;\n    diffs = deserializeDiff(diffs);\n\n    rsync.patch(fs, session.path, diffs, rsyncOptions, function(err, paths) {\n      if (err) {\n        var message = SyncMessage.response.reset;\n        socket.send(message.stringify());\n        return onError(syncManager, err);\n      }\n\n      var size = rsyncOptions.size || 5;\n\n      rsync.pathChecksums(fs, paths.synced, size, function(err, checksums) {\n        if(err) {\n          var message = SyncMessage.response.reset;\n          socket.send(message.stringify());\n          return onError(syncManager, err);\n        }\n\n        var message = SyncMessage.response.patch;\n        message.content = {checksums: checksums, size: size};\n        socket.send(message.stringify());\n      });\n    });\n  }\n\n  function handleVerificationResponse() {\n    session.srcList = null;\n    session.step = steps.SYNCED;\n    sync.onCompleted();\n  }\n\n  function handleUpstreamResetResponse() {\n    var message = SyncMessage.request.sync;\n    message.content = {path: session.path};\n    socket.send(message.stringify());\n  }\n\n  if(data.is.sync) {\n    // UPSTREAM - INIT\n    handleSrcListResponse();\n  } else if(data.is.patch && session.is.syncing && session.is.patch) {\n    // UPSTREAM - PATCH\n    handlePatchAckResponse();\n  } else if(data.is.diffs && session.is.ready && session.is.patch) {\n    // DOWNSTREAM - PATCH\n    handlePatchResponse();\n  } else if(data.is.verification && session.is.ready && session.is.patch) {\n    // DOWNSTREAM - PATCH VERIFICATION\n    handleVerificationResponse();\n  }  else if (data.is.reset && session.is.failed) {\n    handleUpstreamResetResponse();\n  } else {\n    onError(syncManager, new Error('Failed to sync with the server. Current step is: ' +\n                                    session.step + '. Current state is: ' + session.state));  }\n}\n\nfunction handleError(syncManager, data) {\n  var sync = syncManager.sync;\n  var session = syncManager.session;\n  var socket = syncManager.socket;\n  var message = SyncMessage.response.reset;\n\n  // DOWNSTREAM - ERROR\n  if((((data.is.srclist && session.is.synced)) ||\n      (data.is.diffs && session.is.patch) && (session.is.ready || session.is.syncing))) {\n    session.state = states.READY;\n    session.step = steps.SYNCED;\n\n    socket.send(message.stringify());\n    onError(syncManager, new Error('Could not sync filesystem from server... trying again'));\n  } else if(data.is.verification && session.is.patch && session.is.ready) {\n    socket.send(message.stringify());\n    onError(syncManager, new Error('Could not sync filesystem from server... trying again'));\n  } else if(data.is.locked && session.is.ready && session.is.synced) {\n    // UPSTREAM - LOCK\n    onError(syncManager, new Error('Current sync in progress! Try again later!'));\n  } else if(((data.is.chksum && session.is.diffs) ||\n             (data.is.patch && session.is.patch)) &&\n            session.is.syncing) {\n    // UPSTREAM - ERROR\n    var message = SyncMessage.request.reset;\n    socket.send(message.stringify());\n    onError(syncManager, new Error('Could not sync filesystem from server... trying again'));\n  } else {\n    onError(syncManager, new Error('Failed to sync with the server. Current step is: ' +\n                                    session.step + '. Current state is: ' + session.state));\n  }\n}\n\nfunction handleMessage(syncManager, data) {\n  try {\n    data = JSON.parse(data);\n    data = SyncMessage.parse(data);\n  } catch(e) {\n    return onError(syncManager, e);\n  }\n\n  if (data.is.request) {\n    handleRequest(syncManager, data);\n  } else if(data.is.response){\n    handleResponse(syncManager, data);\n  } else if(data.is.error){\n    handleError(syncManager, data);\n  } else {\n    onError(syncManager, new Error('Cannot handle message'));\n  }\n}\n\nmodule.exports = handleMessage;\n\n},{\"../../lib/constants\":10,\"../../lib/diff\":11,\"../../lib/filer\":13,\"../../lib/rsync\":16,\"../../lib/syncmessage\":18,\"./sync-states\":6,\"./sync-steps\":7}],4:[function(require,module,exports){\n/**\n * An extended Filer FileSystem with wrapped methods\n * for writing that manage file metadata (xattribs)\n * reflecting sync state.\n */\n\nvar Filer = require('../../lib/filer.js');\nvar Shell = require('../../lib/filer-shell.js');\nvar Path = Filer.Path;\nvar fsUtils = require('../../lib/fs-utils.js');\nvar conflict = require('../../lib/conflict.js');\nvar constants = require('../../lib/constants.js');\nvar resolvePath = require('../../lib/sync-path-resolver.js').resolve;\n\nfunction SyncFileSystem(fs) {\n  var self = this;\n  var pathToSync;\n  var modifiedPath;\n\n  // Manage path resolution for sync path\n  Object.defineProperty(self, 'pathToSync', {\n    get: function() { return pathToSync; },\n    set: function(path) {\n      if(path) {\n        pathToSync = resolvePath(pathToSync, path);\n      } else {\n        pathToSync = null;\n      }\n    }\n  });\n\n  // Record modifications to the filesystem during a sync\n  Object.defineProperty(fs, 'modifiedPath', {\n    get: function() { return modifiedPath; },\n    set: function(path) {\n      if(path) {\n        modifiedPath = resolvePath(modifiedPath, path);\n      } else {\n        modifiedPath = null;\n      }\n    }\n  });\n\n  // The following non-modifying fs operations can be run as normal,\n  // and are simply forwarded to the fs instance. NOTE: we have\n  // included setting xattributes since we don't sync these to the server (yet).\n  ['stat', 'fstat', 'lstat', 'exists', 'readlink', 'realpath',\n   'readdir', 'open', 'close', 'fsync', 'read', 'readFile',\n   'setxattr', 'fsetxattr', 'getxattr', 'fgetxattr', 'removexattr',\n   'fremovexattr', 'watch'].forEach(function(method) {\n     self[method] = function() {\n       fs[method].apply(fs, arguments);\n     };\n  });\n\n  function fsetUnsynced(fd, callback) {\n    fsUtils.fsetUnsynced(fs, fd, callback);\n  }\n\n  function setUnsynced(path, callback) {\n    fsUtils.setUnsynced(fs, path, callback);\n  }\n\n  // We wrap all fs methods that modify the filesystem in some way that matters\n  // for syncing (i.e., changes we need to sync back to the server), such that we\n  // can track things. Different fs methods need to do this in slighly different ways,\n  // but the overall logic is the same.  The wrapMethod() fn defines this logic.\n  function wrapMethod(method, pathArgPos, setUnsyncedFn, useParentPath) {\n    return function() {\n      var args = Array.prototype.slice.call(arguments, 0);\n      var lastIdx = args.length - 1;\n      var callback = args[lastIdx];\n\n      // Grab the path or fd so we can use it to set the xattribute.\n      // Most methods take `path` or `fd` as the first arg, but it's\n      // second for some.\n      var pathOrFD = args[pathArgPos];\n\n      // In most cases we want to use the path itself, but in the case\n      // that a node is being removed, we want the parent dir.\n      pathOrFD = useParentPath ? Path.dirname(pathOrFD) : pathOrFD;\n\n      // Check to see if it is a path or an open file descriptor\n      // TODO: Deal with a case of fs.open for a path with a write flag\n      // https://github.com/mozilla/makedrive/issues/210.\n      if(!fs.openFiles[pathOrFD]) {\n        self.pathToSync = pathOrFD;\n        // Record the path that was modified on the fs\n        fs.modifiedPath = pathOrFD;\n      }\n\n      args[lastIdx] = function wrappedCallback() {\n        var args = Array.prototype.slice.call(arguments, 0);\n        if(args[0]) {\n          return callback(args[0]);\n        }\n\n        setUnsyncedFn(pathOrFD, function(err) {\n          if(err) {\n            return callback(err);\n          }\n          callback.apply(null, args);\n        });\n      };\n\n      fs[method].apply(fs, args);\n    };\n  }\n\n  // Wrapped fs methods that have path at first arg position and use paths\n  ['truncate', 'mknod', 'mkdir', 'utimes', 'writeFile',\n   'appendFile'].forEach(function(method) {\n     self[method] = wrapMethod(method, 0, setUnsynced);\n  });\n\n  // Wrapped fs methods that have path at second arg position\n  ['link', 'symlink'].forEach(function(method) {\n    self[method] = wrapMethod(method, 1, setUnsynced);\n  });\n\n  // Wrapped fs methods that have path at second arg position, and need to use the parent path.\n  ['rename'].forEach(function(method) {\n    self[method] = wrapMethod(method, 1, setUnsynced, true);\n  });\n\n  // Wrapped fs methods that use file descriptors\n  ['ftruncate', 'futimes', 'write'].forEach(function(method) {\n    self[method] = wrapMethod(method, 0, fsetUnsynced);\n  });\n\n  // Wrapped fs methods that have path at first arg position and use parent\n  // path for writing unsynced metadata (i.e., removes node)\n  ['rmdir', 'unlink'].forEach(function(method) {\n    self[method] = wrapMethod(method, 0, setUnsynced, true);\n  });\n\n  // We also want to do extra work in the case of a rename.\n  // If a file is a conflicted copy, and a rename is done,\n  // remove the conflict.\n  var rename = self.rename;\n  self.rename = function(oldPath, newPath, callback) {\n    rename(oldPath, newPath, function(err) {\n      if(err) {\n        return callback(err);\n      }\n\n      conflict.isConflictedCopy(fs, newPath, function(err, conflicted) {\n        if(err) {\n          return callback(err);\n        }\n\n        if(conflicted) {\n          conflict.removeFileConflict(fs, newPath, callback);\n        } else {\n          callback();\n        }\n      });\n    });\n  };\n\n  // Expose fs.Shell() but use wrapped sync filesystem instance vs fs.\n  // This is a bit brittle, but since Filer doesn't expose the Shell()\n  // directly, we deal with it by doing a deep require into Filer's code\n  // ourselves. The other down side of this is that we're now including\n  // the Shell code twice (once in filer.js, once here). We need to\n  // optimize this when we look at making MakeDrive smaller.\n  self.Shell = function(options) {\n    return new Shell(self, options);\n  };\n\n  // Expose extra operations for checking whether path/fd is unsynced\n  self.getUnsynced = function(path, callback) {\n    fsUtils.getUnsynced(fs, path, callback);\n  };\n  self.fgetUnsynced = function(fd, callback) {\n    fsUtils.fgetUnsynced(fs, fd, callback);\n  };\n}\n\nmodule.exports = SyncFileSystem;\n\n},{\"../../lib/conflict.js\":9,\"../../lib/constants.js\":10,\"../../lib/filer-shell.js\":12,\"../../lib/filer.js\":13,\"../../lib/fs-utils.js\":14,\"../../lib/sync-path-resolver.js\":17}],5:[function(require,module,exports){\nvar SyncMessage = require( '../../lib/syncmessage' ),\n    messageHandler = require('./message-handler'),\n    states = require('./sync-states'),\n    steps = require('./sync-steps'),\n    WebSocket = require('ws'),\n    fsUtils = require('../../lib/fs-utils'),\n    async = require('../../lib/async-lite.js');\n\nfunction SyncManager(sync, fs) {\n  var manager = this;\n\n  manager.sync = sync;\n  manager.fs = fs;\n  manager.session = {\n    state: states.CLOSED,\n    step: steps.SYNCED,\n    path: '/',\n\n    is: Object.create(Object.prototype, {\n      // States\n      syncing: {\n        get: function() { return manager.session.state === states.SYNCING; }\n      },\n      ready: {\n        get: function() { return manager.session.state === states.READY; }\n      },\n      error: {\n        get: function() { return manager.session.state === states.ERROR; }\n      },\n      closed: {\n        get: function() { return manager.session.state === states.CLOSED; }\n      },\n\n      // Steps\n      init: {\n        get: function() { return manager.session.step === steps.INIT; }\n      },\n      chksum: {\n        get: function() { return manager.session.step === steps.CHKSUM; }\n      },\n      diffs: {\n        get: function() { return manager.session.step === steps.DIFFS; }\n      },\n      patch: {\n        get: function() { return manager.session.step === steps.PATCH; }\n      },\n      synced: {\n        get: function() { return manager.session.step === steps.SYNCED; }\n      },\n      failed: {\n        get: function() { return manager.session.step === steps.FAILED; }\n      }\n    })\n  };\n}\n\nSyncManager.prototype.init = function(url, token, callback) {\n  var manager = this;\n  var session = manager.session;\n  var sync = manager.sync;\n\n  function handleAuth(event) {\n    var data = event.data || event;\n\n    try {\n      data = JSON.parse(data);\n      data = SyncMessage.parse(data);\n    } catch(e) {\n      return callback(e);\n    }\n\n    if(data.is.response && data.is.authz) {\n      session.state = states.READY;\n      session.step = steps.SYNCED;\n\n      socket.onmessage = function(event) {\n        var data = event.data || event;\n        messageHandler(manager, data);\n      };\n      socket.send(SyncMessage.response.authz.stringify());\n\n      callback();\n    } else {\n      callback(new Error('Cannot handle message'));\n    }\n  }\n\n  function handleClose(info) {\n    var reason = info.reason || 'WebSocket closed unexpectedly';\n    var error = new Error(info.code + ': ' + reason);\n\n    manager.close();\n    manager.socket = null;\n\n    sync.onError(error);\n    sync.onDisconnected();\n  }\n\n  var socket = manager.socket = new WebSocket(url);\n  socket.onmessage = handleAuth;\n  socket.onclose = handleClose;\n  socket.onopen = function() {\n    socket.send(JSON.stringify({token: token}));\n  };\n};\n\nSyncManager.prototype.syncPath = function(path) {\n  var manager = this;\n  var syncRequest;\n\n  if(!manager.socket) {\n    throw new Error('sync called before init');\n  }\n\n  syncRequest = SyncMessage.request.sync;\n  syncRequest.content = {path: path};\n  manager.socket.send(syncRequest.stringify());\n};\n\n// Remove the unsynced attribute for a list of paths\nSyncManager.prototype.resetUnsynced = function(paths, callback) {\n  var fs = this.fs;\n\n  function removeUnsyncedAttr(path, callback) {\n    fsUtils.removeUnsynced(fs, path, function(err) {\n      if(err && err.code !== 'ENOENT') {\n        return callback(err);\n      }\n\n      callback();\n    });\n  }\n\n  async.eachSeries(paths, removeUnsyncedAttr, function(err) {\n    if(err) {\n      return callback(err);\n    }\n\n    callback();\n  });\n};\n\nSyncManager.prototype.close = function() {\n  var manager = this;\n  var socket = manager.socket;\n\n  if(socket) {\n    socket.onmessage = function(){};\n    socket.onopen = function(){};\n\n    if(socket.readyState === 1) {\n      socket.onclose = function(){\n        manager.socket = null;\n      };\n      socket.close();\n    } else {\n      manager.socket = null;\n    }\n  }\n};\n\nmodule.exports = SyncManager;\n\n},{\"../../lib/async-lite.js\":8,\"../../lib/fs-utils\":14,\"../../lib/syncmessage\":18,\"./message-handler\":3,\"./sync-states\":6,\"./sync-steps\":7,\"ws\":1}],6:[function(require,module,exports){\nmodule.exports = {\n  SYNCING: \"SYNC IN PROGRESS\",\n  READY: \"READY\",\n  ERROR: \"ERROR\",\n  CLOSED: \"CLOSED\"\n};\n},{}],7:[function(require,module,exports){\nmodule.exports = {\n  INIT: \"SYNC INITIALIZED\",\n  CHKSUM: \"CHECKSUM\",\n  DIFFS: \"DIFFS\",\n  PATCH: \"PATCH\",\n  SYNCED: \"SYNCED\",\n  FAILED: \"FAILED\"\n};\n},{}],8:[function(require,module,exports){\n// We're sharing Filer's same stripped-down version of async, in order to save space.\nmodule.exports = require('../node_modules/filer/lib/async.js');\n\n},{\"../node_modules/filer/lib/async.js\":24}],9:[function(require,module,exports){\n/**\n * Utility functions for working with Conflicted Files.\n */\nvar Filer = require('./filer.js');\nvar Path = Filer.Path;\nvar constants = require('./constants.js');\nvar fsUtils = require('./fs-utils.js');\n\n// Turn \"/index.html\" into \"/index.html (Conflicted Copy 2014-07-23 12:00:00).html\"\nfunction generateConflictedPath(fs, path, callback) {\n  var dirname = Path.dirname(path);\n  var basename = Path.basename(path);\n  var extname = Path.extname(path);\n\n  var now = new Date();\n  var dateStamp = now.getFullYear() + '-' +\n        now.getMonth() + '-' +\n        now.getDay() + ' ' +\n        now.getHours() + ':' +\n        now.getMinutes() + ':' +\n        now.getSeconds();\n  var conflictedCopy = ' (Conflicted Copy ' + dateStamp + ')';\n  var conflictedPath = Path.join(dirname, basename + conflictedCopy + extname);\n\n  // Copy the file using the conflicted filename. If there is\n  // already a conflicted file, replace it with this one.\n  fsUtils.forceCopy(fs, path, conflictedPath, function(err) {\n    if(err) {\n      return callback(err);\n    }\n\n    // Send the new path back on the callback\n    callback(null, conflictedPath);\n  });\n}\n\nfunction filenameContainsConflicted(path) {\n  // Look for path to be a conflicted copy, e.g.,\n  // /dir/index (Conflicted Copy 2014-07-23 12:00:00).html\n  return /\\(Conflicted Copy \\d{4}-\\d{1,2}-\\d{1,2} \\d{1,2}:\\d{1,2}:\\d{1,2}\\)/.test(path);\n}\n\nfunction isConflictedCopy(fs, path, callback) {\n  fs.getxattr(path, constants.attributes.conflict, function(err, value) {\n    if(err && err.code !== 'ENOATTR') {\n      return callback(err);\n    }\n\n    callback(null, !!value);\n  });\n}\n\nfunction makeConflictedCopy(fs, path, callback) {\n  fs.lstat(path, function(err, stats) {\n    if(err) {\n      return callback(err);\n    }\n\n    // If this is a dir, err now\n    if(stats.isDirectory()) {\n      return callback(new Filer.Errors.EISDIR('conflict not permitted on directory'));\n    }\n\n    // Otherwise, copy to a conflicted filename, and mark as makedrive-conflict\n    generateConflictedPath(fs, path, function(err, conflictedPath) {\n      if(err) {\n        return callback(err);\n      }\n      fs.setxattr(conflictedPath, constants.attributes.conflict, true, function(err) {\n        if(err) {\n          return callback(err);\n        }\n\n        callback(null, conflictedPath);\n      });\n    });\n  });\n}\n\nfunction removeFileConflict(fs, path, callback) {\n  fs.removexattr(path, constants.attributes.conflict, function(err) {\n    if(err && err.code !== 'ENOATTR') {\n      return callback(err);\n    }\n\n    callback();\n  });\n}\n\nmodule.exports = {\n  filenameContainsConflicted: filenameContainsConflicted,\n  isConflictedCopy: isConflictedCopy,\n  makeConflictedCopy: makeConflictedCopy,\n  removeFileConflict: removeFileConflict\n};\n\n},{\"./constants.js\":10,\"./filer.js\":13,\"./fs-utils.js\":14}],10:[function(require,module,exports){\nmodule.exports = {\n  rsyncDefaults: {\n    size: 5,\n    time: true,\n    recursive: true\n  },\n\n  attributes: {\n    unsynced: 'makedrive-unsynced',\n    conflict: 'makedrive-conflict'\n  }\n};\n\n},{}],11:[function(require,module,exports){\n/**\n * Functions to process lists of Node Diff objects (i.e.,\n * diffs of files, folders). A Node Diff object takes the\n * following form:\n *\n * // Node Diff for file path (note presence of .diffs)\n * {\n *   modified: 1404926919696,\n *   path: 'index.html',\n *   diffs: [\n *     {\n *       length: 56,\n *       index: 17,\n *       data: Buffer([...])\n *     },\n *     ...\n *   ]\n * }\n *\n * // Node Diff for directory path (note presence of .contents)\n * {\n *   modified: 1404926919696,\n *   path: 'index.html',\n *   contents: [\n *     nodeDiffObject,\n *     ...\n *   ]\n * }\n */\n\n var Buffer = require('./filer.js').Buffer;\n\nfunction processNodeDiff(nodeDiff, processDataFn) {\n  // Check if this is a directory or file, process, and return\n  if(nodeDiff.contents) {\n    nodeDiff.contents = nodeDiff.contents.map(function(nodeDiff) {\n      return processNodeDiff(nodeDiff, processDataFn);\n    });\n  } else {\n    nodeDiff.diffs = nodeDiff.diffs.map(function(diff) {\n      diff.data = processDataFn(diff.data);\n      return diff;\n    });\n  }\n\n  return nodeDiff;\n}\n\nfunction bufferToJSON(data) {\n  if(!Buffer.isBuffer(data)) {\n    return data;\n  }\n  var json = data.toJSON();\n  // Note: when we're in node.js, json will be the raw array.\n  // In browserify it will be {type:'Buffer', data:[...]}\n  return json.data || json;\n}\n\nfunction jsonToBuffer(data) {\n  return new Buffer(data);\n}\n\nfunction processFn(nodeDiffs, processDataFn) {\n  if(!nodeDiffs.length) {\n    return nodeDiffs;\n  }\n  return nodeDiffs.map(function(nodeDiff){\n    return processNodeDiff(nodeDiff, processDataFn);\n  });\n}\n\nmodule.exports.serialize = function(nodeDiffs) {\n  return processFn(nodeDiffs, bufferToJSON);\n};\n\nmodule.exports.deserialize = function(nodeDiffs) {\n  return processFn(nodeDiffs, jsonToBuffer);\n};\n\n},{\"./filer.js\":13}],12:[function(require,module,exports){\n// Filer doesn't expose the Shell() ctor directly, so provide a shortcut.\n// See client/src/sync-filesystem.js\nmodule.exports = require('../node_modules/filer/src/shell/shell.js');\n\n},{\"../node_modules/filer/src/shell/shell.js\":47}],13:[function(require,module,exports){\nmodule.exports = require('filer');\n\n},{\"filer\":37}],14:[function(require,module,exports){\n/**\n * Extra common fs operations we do throughout MakeDrive.\n */\nvar constants = require('./constants.js');\n\n// copy oldPath to newPath, deleting newPath if it exists\nfunction forceCopy(fs, oldPath, newPath, callback) {\n  fs.unlink(newPath, function(err) {\n    if(err && err.code !== 'ENOENT') {\n      return callback(err);\n    }\n\n    fs.readFile(oldPath, function(err, buf) {\n      if(err) {\n        return callback(err);\n      }\n\n      fs.writeFile(newPath, buf, callback);\n    });\n  });\n}\n\n// See if a given path a) exists, and whether it is marked unsynced.\nfunction isPathUnsynced(fs, path, callback) {\n  fs.getxattr(path, constants.attributes.unsynced, function(err, unsynced) {\n    // File doesn't exist locally at all\n    if(err && err.code === 'ENOENT') {\n      return callback(null, false);\n    }\n\n    // Deal with unexpected error\n    if(err && err.code !== 'ENOATTR') {\n      return callback(err);\n    }\n\n    callback(null, !!unsynced);\n  });\n}\n\n// Remove the unsynced metadata from a path\nfunction removeUnsynced(fs, path, callback) {\n  fs.removexattr(path, constants.attributes.unsynced, function(err) {\n    if(err && err.code !== 'ENOATTR') {\n      return callback(err);\n    }\n\n    callback();\n  });\n}\nfunction fremoveUnsynced(fs, fd, callback) {\n  fs.fremovexattr(fd, constants.attributes.unsynced, function(err) {\n    if(err && err.code !== 'ENOATTR') {\n      return callback(err);\n    }\n\n    callback();\n  });\n}\n\n// Set the unsynced metadata for a path\nfunction setUnsynced(fs, path, callback) {\n  fs.setxattr(path, constants.attributes.unsynced, Date.now(), function(err) {\n    if(err) {\n      return callback(err);\n    }\n\n    callback();\n  });\n}\nfunction fsetUnsynced(fs, fd, callback) {\n  fs.fsetxattr(fd, constants.attributes.unsynced, Date.now(), function(err) {\n    if(err) {\n      return callback(err);\n    }\n\n    callback();\n  });\n}\n\n// Get the unsynced metadata for a path\nfunction getUnsynced(fs, path, callback) {\n  fs.getxattr(path, constants.attributes.unsynced, function(err, value) {\n    if(err && err.code !== 'ENOATTR') {\n      return callback(err);\n    }\n\n    callback(null, value);\n  });\n}\nfunction fgetUnsynced(fs, fd, callback) {\n  fs.fgetxattr(fd, constants.attributes.unsynced, function(err, value) {\n    if(err && err.code !== 'ENOATTR') {\n      return callback(err);\n    }\n\n    callback(null, value);\n  });\n}\n\nmodule.exports = {\n  forceCopy: forceCopy,\n  isPathUnsynced: isPathUnsynced,\n  removeUnsynced: removeUnsynced,\n  fremoveUnsynced: fremoveUnsynced,\n  setUnsynced: setUnsynced,\n  fsetUnsynced: fsetUnsynced,\n  getUnsynced: getUnsynced,\n  fgetUnsynced: fgetUnsynced\n};\n\n},{\"./constants.js\":10}],15:[function(require,module,exports){\nmodule.exports = {\n  difference: function(arr,farr) {\n    return arr.filter(function(v) {\n      return farr.indexOf(v) === -1;\n    });\n  },\n  sortBy: function(list,prop) {\n    return list.sort(function(a,b) {\n      a = a[prop];\n      b = b[prop];\n      return (a === b) ? 0 : (a < b) ? -1 : 1;\n    });\n  },\n  isArray: Array.isArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  },\n  map: function(input, fn) {\n    if (this.isArray(input)) {\n      return input.map(fn);\n    }\n    return Object.keys(input).map(function(v) {\n      return fn(input[v]);\n    });\n  },\n  values: function(obj) {\n    return Object.keys(obj).map(function(v) {\n      return obj[v];\n    });\n  }\n};\n\n},{}],16:[function(require,module,exports){\n// rsync.js\n// Implement rsync to sync between two Filer filesystems\n// Portions used from Node.js Anchor module\n// Copyright(c) 2011 Mihai Tomescu <matomesc@gmail.com>\n// Copyright(c) 2011 Tolga Tezel <tolgatezel11@gmail.com>\n// MIT Licensed\n// https://github.com/ttezel/anchor\n\nvar Filer = require('./filer.js');\nvar Buffer = Filer.Buffer;\nvar Path = Filer.Path;\nvar fsUtils = require('./fs-utils.js');\nvar Errors = Filer.Errors;\nvar async = require('./async-lite.js');\nvar MD5 = require('MD5');\nvar rsync = {};\nvar constants = require('./constants.js');\nvar conflict = require('./conflict.js');\nvar ld_shim = require('./lodash-lite.js');\n\n// Rsync Options that can be passed are:\n// size       -   the size of each chunk of data in bytes that should be checksumed\n// checksum   -   true: always calculate checksums [default]\n//                false: ignore checksums for identical files\n// recursive  -   true: sync each contained node in the path provided\n//                false: only sync the node for the path provided [default]\n// time       -   true: sync modified times of source/destination files\n//                false: do not change modified times of destination files [default]\n// links      -   true: sync symbolic links as links in destination\n//                false: sync symbolic links as the files they link to in destination [default]\nfunction configureOptions(options) {\n  if(!options || typeof options === 'function') {\n    options = {};\n  }\n\n  options.size = options.size || 512;\n  options.checksum = 'checksum' in options ? options.checksum : true;\n  options.recursive = options.recursive || false;\n  options.time = options.time || false;\n  options.links = options.links || false;\n\n  return options;\n}\n\n// Set the callback in case options are not provided\nfunction findCallback(callback, options) {\n  if(!callback && typeof options === 'function') {\n    callback = options;\n  }\n\n  return callback;\n}\n\n// Validate the parameters sent to each rsync method\nfunction validateParams(fs, path) {\n  if(!fs) {\n    return new Errors.EINVAL('No filesystem provided');\n  }\n\n  if(!path) {\n    return new Errors.EINVAL('Path must be specified');\n  }\n\n  return null;\n}\n\n// Get the 'directory' path from the given path for an entry\n// /dir/file.txt returns /dir\n// /dir/folder returns /dir/folder\nfunction getDirPath(path, entry) {\n  if(Path.basename(path) === entry) {\n   return Path.dirname(path);\n  }\n  return path;\n}\n\n// MD5 hashing for RSync\nfunction md5sum(data) {\n  return MD5(data).toString();\n}\n\n// Weak32 hashing for RSync based on Mark Adler's 32bit checksum algorithm\nfunction calcWeak32(data, prev, start, end) {\n  var a = 0;\n  var b = 0;\n  var sum = 0;\n  var M = 1 << 16;\n  var N = 65521;\n\n  if (!prev) {\n    var len = (start >= 0 && end >= 0) ? (end - start + 1) : data.length;\n    var datai;\n    for (var i = 0; i < len; i++) {\n      datai = data[i];\n      a += datai;\n      b += ((len - i) * datai);\n    }\n\n    a %= N;\n    b %= N;\n  } else {\n    var k = start;\n    var l = end - 1;\n    var prev_k = k - 1;\n    var prev_l = l - 1;\n    var prev_first = data[prev_k];\n    var prev_last = data[prev_l];\n    var curr_first = data[k];\n    var curr_last = data[l];\n\n    a = (prev.a - prev_first + curr_last) % N;\n    b = (prev.b - (prev_l - prev_k + 1) * prev_first + a) % N;\n  }\n  return { a: a, b: b, sum: a + b * M };\n}\n\n// Weak16 hashing for RSync\nfunction calcWeak16(data) {\n  return 0xffff & (data >> 16 ^ data * 1009);\n}\n\n// RSync algorithm to create a hashtable from checksums\nfunction createHashtable(checksums) {\n  var hashtable = {};\n  var len = checksums.length;\n  var checksum;\n  var weak16;\n\n  for (var i = 0; i < len; i++) {\n    checksum = checksums[i];\n    weak16 = calcWeak16(checksum.weak);\n    if (hashtable[weak16]) {\n      hashtable[weak16].push(checksum);\n    } else {\n      hashtable[weak16] = [checksum];\n    }\n  }\n  return hashtable;\n}\n\n// RSync algorithm to perform data rolling\nfunction roll(data, checksums, chunkSize) {\n  var results = [];\n  var hashtable = createHashtable(checksums);\n  var length = data.length;\n  var start = 0;\n  var end = chunkSize > length ? length : chunkSize;\n  // Updated when a block matches\n  var lastMatchedEnd = 0;\n  // This gets updated every iteration with the previous weak 32bit hash\n  var prevRollingWeak = null;\n  var weak;\n  var weak16;\n  var match;\n  var d;\n  var len;\n  var mightMatch;\n  var chunk;\n  var strong;\n  var hashtable_weak16;\n  var hashtable_weak16i;\n\n  for (; end <= length; start++, end++) {\n    weak = calcWeak32(data, prevRollingWeak, start, end);\n    weak16 = calcWeak16(weak.sum);\n    match = false;\n    d = null;\n    prevRollingWeak = weak;\n    hashtable_weak16 = hashtable[weak16];\n\n    if (hashtable_weak16) {\n      len = hashtable_weak16.length;\n      for (var i = 0; i < len; i++) {\n        hashtable_weak16i = hashtable_weak16[i];\n        if (hashtable_weak16i.weak === weak.sum) {\n          mightMatch = hashtable_weak16i;\n          chunk = data.slice(start, end);\n          strong = md5sum(chunk);\n\n          if (mightMatch.strong === strong) {\n            match = mightMatch;\n            break;\n          }\n        }\n      }\n    }\n    if (match) {\n      if(start < lastMatchedEnd) {\n        d = data.slice(lastMatchedEnd - 1, end);\n        results.push({\n          data: d,\n          index: match.index\n        });\n      } else if (start - lastMatchedEnd > 0) {\n        d = data.slice(lastMatchedEnd, start);\n        results.push({\n          data: d,\n          index: match.index\n        });\n      } else {\n        results.push({\n          index: match.index\n        });\n      }\n      lastMatchedEnd = end;\n    } else if (end === length) {\n      // No match and last block\n      d = data.slice(lastMatchedEnd);\n      results.push({\n        data: d\n      });\n    }\n  }\n  return results;\n}\n\n// RSync function to calculate checksums\nfunction checksum (fs, path, size, callback) {\n  var cache = {};\n\n  fs.readFile(path, function (err, data) {\n    if (!err) {\n      // cache file\n      cache[path] = data;\n    } else if (err && err.code === 'ENOENT') {\n      cache[path] = [];\n    } else {\n      return callback(err);\n    }\n\n    var length = cache[path].length;\n    var incr = size;\n    var start = 0;\n    var end = incr > length ? length : incr;\n    var blockIndex = 0;\n    var result = [];\n    var chunk;\n    var weak;\n    var strong;\n\n    while (start < length) {\n      chunk  = cache[path].slice(start, end);\n      weak   = calcWeak32(chunk).sum;\n      strong = md5sum(chunk);\n\n      result.push({\n        index: blockIndex,\n        weak: weak,\n        strong: strong\n      });\n      // update slice indices\n      start += incr;\n      end = (end + incr) > length ? length : end + incr;\n      // update block index\n      blockIndex++;\n    }\n\n    callback(null, result);\n  });\n}\n\nfunction extractPathsFromDiffs(path, diffs) {\n  var diffPaths = [];\n\n  function extractPath(diff, index, array) {\n    var dirPath = getDirPath(path, diff.path);\n    var nodePath = Path.join(dirPath, diff.path);\n\n    if(!diff.identical) {\n      diffPaths.push(nodePath);\n    }\n\n    if(diff.contents) {\n      var contentPaths = extractPathsFromDiffs(nodePath, diff.contents);\n      diffPaths = diffPaths.concat(contentPaths);\n    }\n  }\n\n  diffs.forEach(extractPath);\n  return diffPaths;\n}\n\n// Generate the list of paths at the source file system\nrsync.sourceList = function getSrcList(fs, path, options, callback) {\n  callback = findCallback(callback, options);\n\n  var paramError = validateParams(fs, path);\n\n  if(paramError) {\n    return callback(paramError);\n  }\n\n  options = configureOptions(options);\n\n  var sourceList = [];\n\n  fs.lstat(path, function(err, stats) {\n    if(err) {\n      return callback(err);\n    }\n\n    // File or Link\n    if(!stats.isDirectory()) {\n      // Make sure this isn't a conflicted copy before adding\n      // (we don't send these to the server in a sync)\n      conflict.isConflictedCopy(fs, path, function(err, conflicted) {\n        if(err) {\n          return callback(err);\n        }\n\n        if(!conflicted) {\n          var node = {\n            path: Path.basename(path),\n            size: stats.size,\n            type: stats.type,\n            modified: stats.mtime\n          };\n          sourceList.push(node);\n        }\n\n        callback(null, sourceList);\n      });\n\n      return;\n    }\n    // Directory\n    fs.readdir(path, function(err, entries) {\n      if(err) {\n        return callback(err);\n      }\n\n      function getSrcContents(_name, callback) {\n        var name = Path.join(path, _name);\n\n        fs.lstat(name, function(err, stats) {\n          if(err) {\n            return callback(err);\n          }\n\n          var node = {\n            path: Path.basename(name),\n            modified: stats.mtime,\n            size: stats.size,\n            type: stats.type\n          };\n\n          // Directory\n          if(options.recursive && stats.isDirectory()) {\n            getSrcList(fs, name, options, function(err, items) {\n              if(err) {\n                return callback(err);\n              }\n\n              node.contents = items;\n\n              sourceList.push(node);\n              callback();\n            });\n          }\n          // File or Link\n          else {\n            // Make sure this isn't a conflicted copy before adding\n            // (we don't send these to the server in a sync)\n            conflict.isConflictedCopy(fs, name, function(err, conflicted) {\n              if(err) {\n                return callback(err);\n              }\n\n              if(!conflicted) {\n                sourceList.push(node);\n              }\n\n              callback();\n            });\n          }\n        });\n      }\n\n      async.eachSeries(entries, getSrcContents, function(err) {\n        if(err) {\n          return callback(err);\n        }\n\n        callback(null, sourceList);\n      });\n    });\n  });\n};\n\n// Generate checksums for every node in a given destination path\nrsync.checksums = function(fs, path, srcList, options, callback) {\n  callback = findCallback(callback, options);\n\n  var paramError = validateParams(fs, path);\n\n  if(paramError) {\n    return callback(paramError);\n  }\n\n  options = configureOptions(options);\n\n  var nodeChecksums = [];\n\n  function checksumsForDir(nodeChecksum, entry, callback) {\n    var dir = Path.join(path, entry.path);\n\n    // Create the directory if it does not exist\n    fs.mkdir(dir, function(err) {\n      if(err && err.code !== 'EEXIST') {\n        return callback(err);\n      }\n\n      rsync.checksums(fs, dir, entry.contents, options, function(err, dirChecksums) {\n        if(err) {\n          return callback(err);\n        }\n\n        // For empty directories, force an empty array\n        nodeChecksum.contents = dirChecksums || [];\n\n        nodeChecksums.push(nodeChecksum);\n        callback();\n      });\n    });\n  }\n\n  function checksumsForFile(nodeChecksum, entry, dirPath, absPath, callback) {\n    if(!options.checksum || options.recursive) {\n      fs.stat(absPath, function(err, stat) {\n        if(err && err.code !== 'ENOENT') {\n          return callback(err);\n        }\n\n        // Add `identical` if the modified time and size of the existing file match\n        if(stat && stat.mtime === entry.modified && stat.size === entry.size) {\n          nodeChecksum.checksums = [];\n          nodeChecksum.modified = entry.modified;\n          nodeChecksum.identical = true;\n\n          nodeChecksums.push(nodeChecksum);\n          callback();\n        } else {\n          checksum(fs, absPath, options.size, function(err, checksums) {\n            if(err) {\n              return callback(err);\n            }\n\n            nodeChecksum.checksums = checksums;\n            nodeChecksum.modified = entry.modified;\n\n            nodeChecksums.push(nodeChecksum);\n            callback();\n          });\n        }\n      });\n    } else {\n      checksum(fs, absPath, options.size, function(err, checksums) {\n        if(err) {\n          return callback(err);\n        }\n\n        nodeChecksum.checksums = checksums;\n        nodeChecksum.modified = entry.modified;\n\n        nodeChecksums.push(nodeChecksum);\n        callback();\n      });\n    }\n  }\n\n  function checksumsForLink(nodeChecksum, entry, dirPath, absPath, callback) {\n    nodeChecksum.link = true;\n\n    if(!options.checksum || options.recursive) {\n      fs.stat(absPath, function(err, stat){\n        if(err && err.code !== 'ENOENT') {\n          return callback(err);\n        }\n\n        // Add `identical` if the modified time and size of the existing file match\n        if(stat && stat.mtime === entry.modified && stat.size === entry.size) {\n          nodeChecksum.identical = true;\n        }\n\n        nodeChecksums.push(nodeChecksum);\n        callback();\n      });\n    } else {\n      nodeChecksums.push(nodeChecksum);\n      callback();\n    }\n  }\n\n  function getDirChecksums(entry, callback) {\n    var nodeChecksum = { path: entry.path };\n    var dirPath = getDirPath(path, entry.path);\n    var absPath = Path.join(dirPath, entry.path);\n\n    // Create any parent directories that do not exist\n    fs.Shell().mkdirp(dirPath, function(err) {\n      if(err && err.code !== 'EEXIST') {\n        return callback(err);\n      }\n\n      // Directory\n      if(options.recursive && entry.type === 'DIRECTORY') {\n        checksumsForDir(nodeChecksum, entry, callback);\n      }\n      // File or Link\n      else {\n        if(entry.type === 'FILE' || !options.links) {\n          checksumsForFile(nodeChecksum, entry, dirPath, absPath, callback);\n        } else if(entry.type === 'SYMLINK'){\n          checksumsForLink(nodeChecksum, entry, dirPath, absPath, callback);\n        }\n      }\n    });\n  }\n\n  async.eachSeries(srcList, getDirChecksums, function(err) {\n    if(err) {\n      callback(err);\n    } else {\n      callback(null, nodeChecksums);\n    }\n  });\n};\n\n// Generate diffs from the source based on destination checksums\nrsync.diff = function(fs, path, checksums, options, callback) {\n  callback = findCallback(callback, options);\n\n  var paramError = validateParams(fs, path);\n\n  if(paramError) {\n    return callback(paramError);\n  }\n\n  options = configureOptions(options);\n\n  if(options.checksum && !checksums) {\n    return callback(new Errors.EINVAL('Checksums must be provided'));\n  }\n\n  var nodeDiffs = [];\n\n  function getDiff(entry, callback) {\n    var entryPath = Path.join(path, entry.path);\n\n    // Directory\n    if(entry.contents) {\n      rsync.diff(fs, entryPath, entry.contents, options, function(err, diffs) {\n        if(err) {\n          return callback(err);\n        }\n\n        nodeDiffs.push({\n          path: entry.path,\n          contents: diffs\n        });\n\n        callback();\n      });\n    }\n    // Link\n    else if (entry.link) {\n      fs.readlink(entryPath, function(err, linkContents) {\n        if(err) {\n          return callback(err);\n        }\n\n        fs.lstat(entryPath, function(err, stats){\n          if(err) {\n            return callback(err);\n          }\n\n          nodeDiffs.push({\n            link: linkContents,\n            modified: stats.mtime,\n            path: entry.path\n          });\n\n          callback(null, nodeDiffs);\n        });\n      });\n    }\n    // File\n    else {\n      if(entry.identical) {\n        nodeDiffs.push({\n          diffs: [],\n          modified: entry.modified,\n          path: entry.path,\n          // Indicates that since the checksum was identical to the source, no diffs should be applied\n          identical: true\n        });\n\n        callback(null, nodeDiffs);\n      } else {\n        fs.readFile(entryPath, function (err, data) {\n          if (err) {\n            return callback(err);\n          }\n\n          nodeDiffs.push({\n            diffs: roll(data, entry.checksums, options.size),\n            modified: entry.modified,\n            path: entry.path\n          });\n\n          callback(null, nodeDiffs);\n        });\n      }\n    }\n  }\n\n  fs.lstat(path, function(err, stat) {\n    if(err) {\n      return callback(err);\n    }\n    // Directory\n    if(stat.isDirectory()) {\n      async.eachSeries(checksums, getDiff, function(err) {\n        if(err) {\n          return callback(err);\n        }\n\n        callback(null, nodeDiffs);\n      });\n    }\n    // File\n    else if (stat.isFile() || !options.links) {\n      if(checksums[0].identical) {\n        nodeDiffs.push({\n          diffs: [],\n          modified: checksums[0].modified,\n          path: checksums[0].path,\n          identical: true\n        });\n\n        return callback(null, nodeDiffs);\n      }\n\n      fs.readFile(path, function (err, data) {\n        if (err) {\n          return callback(err);\n        }\n\n        nodeDiffs.push({\n          diffs: roll(data, checksums[0].checksums, options.size),\n          modified: checksums[0].modified,\n          path: checksums[0].path\n        });\n\n        callback(null, nodeDiffs);\n      });\n    }\n    // Link\n    else if (stat.isSymbolicLink()) {\n      fs.readlink(path, function(err, linkContents) {\n        if(err) {\n          return callback(err);\n        }\n\n        fs.lstat(path, function(err, stats){\n          if(err) {\n            return callback(err);\n          }\n\n          nodeDiffs.push({\n            link: linkContents,\n            modified: stats.mtime,\n            path: checksums[0].path\n          });\n\n          callback(null, nodeDiffs);\n        });\n      });\n    }\n  });\n};\n\n// Path the destination filesystem by applying diffs\nrsync.patch = function(fs, path, diff, options, callback) {\n  callback = findCallback(callback, options);\n\n  var paramError = validateParams(fs, path);\n  var paths = {\n    synced: [],\n    failed: [],\n    update: function(newPaths) {\n      this.synced = this.synced.concat(newPaths.synced);\n      this.failed = this.failed.concat(newPaths.failed);\n    }\n  };\n  var pathsToSync = extractPathsFromDiffs(path, diff);\n\n  if(paramError) {\n    return callback(paramError, paths);\n  }\n\n  options = configureOptions(options);\n\n  function handleError(err, callback) {\n    // Determine the node paths for those that were not synced\n    // by getting the difference between the paths that needed to\n    // be synced and the paths that were synced\n    var failedPaths = ld_shim.difference(pathsToSync, paths.synced);\n    paths.failed = paths.failed.concat(failedPaths);\n    callback(err, paths);\n  }\n\n  // Remove the nodes in the patched directory that are no longer\n  // present in the source. The only exception to this is any file\n  // locally that hasn't been synced to the server yet (i.e.,\n  // we don't want to delete things in a downstream sync because they\n  // don't exist upstream yet, since an upstream sync will add them).\n  function removeNodes(path, entryDiff, callback) {\n    if(typeof entryDiff === 'function') {\n      callback = entryDiff;\n      entryDiff = null;\n    }\n\n    fs.readdir(path, function(err, destContents) {\n      if(err) {\n        return handleError(err, callback);\n      }\n\n      var deletedNodes = destContents;\n\n      if(entryDiff) {\n        var srcContents = entryDiff.map(function(element) {\n          return element.path;\n        });\n        deletedNodes = ld_shim.difference(destContents, srcContents);\n      }\n\n      function maybeUnlink(item, callback) {\n        var deletePath = Path.join(path, item);\n\n        // Make sure this file isn't unsynced before deleting\n        fsUtils.isPathUnsynced(fs, deletePath, function(err, unsynced) {\n          if(err) {\n            return handleError(err, callback);\n          }\n\n          if(unsynced) {\n            // Don't delete\n            return callback();\n          }\n\n          paths.synced.push(deletePath);\n          fs.unlink(deletePath, callback);\n        });\n      }\n\n      async.eachSeries(deletedNodes, maybeUnlink, function(err) {\n        if(err) {\n          return callback(err, paths);\n        }\n\n        callback(null, paths);\n      });\n    });\n  }\n\n  function syncEach(entry, callback) {\n    var dirPath = getDirPath(path, entry.path);\n    var syncPath = Path.join(dirPath, entry.path);\n\n    // Directory\n    if(entry.contents) {\n      return rsync.patch(fs, Path.join(path, entry.path), entry.contents, options, function(err, dirPaths) {\n        if(err) {\n          paths.update(dirPaths);\n          return handleError(err, callback);\n        }\n\n        paths.synced.push(syncPath);\n        paths.update(dirPaths);\n        removeNodes(Path.join(path, entry.path), entry.contents, callback);\n      });\n    }\n    // Link\n    else if (entry.link) {\n      return fs.symlink(entry.link, syncPath, function(err){\n        if(err) {\n          return handleError(err, callback);\n        }\n\n        paths.synced.push(syncPath);\n        callback(null, paths);\n      });\n    }\n    // File\n    if(entry.identical) {\n      return callback(null, paths);\n    }\n\n    fs.readFile(syncPath, function(err, data) {\n      var raw;\n\n      // Get slice of raw file from block's index\n      function rawslice(index) {\n        var start = index * options.size;\n        var end = start + options.size > raw.length ? raw.length : start + options.size;\n\n        return raw.slice(start, end);\n      }\n\n      if(err) {\n        if(err.code !== 'ENOENT') {\n          return handleError(err, callback);\n        }\n        raw = new Buffer(0);\n      } else {\n        raw = data;\n      }\n\n      var len = entry.diffs.length;\n      var chunks = [];\n\n      for(var i = 0; i < len; i++) {\n        var chunk = entry.diffs[i];\n\n        if(!chunk.data) {\n          // Use slice of original file\n          chunks.push(rawslice(chunk.index));\n        } else {\n          chunks.push(chunk.data);\n          if(chunk.index) {\n            chunks.push(rawslice(chunk.index));\n          }\n        }\n      }\n\n      // Before we alter the local file, make sure we don't\n      // need a conflicted copy before proceeding.\n      fsUtils.isPathUnsynced(fs, syncPath, function(err, unsynced) {\n        if(err) {\n          return handleError(err, callback);\n        }\n\n        function write() {\n          var buf = Buffer.concat(chunks);\n          fs.writeFile(syncPath, buf, function(err) {\n            if(err) {\n              return handleError(err, callback);\n            }\n\n            if(!options.time) {\n              paths.synced.push(syncPath);\n              return callback(null, paths);\n            }\n\n            // Updates the modified time of the node\n            fs.utimes(syncPath, entry.modified, entry.modified, function(err) {\n              if(err) {\n                return handleError(err, callback);\n              }\n\n              paths.synced.push(syncPath);\n              callback(null, paths);\n            });\n          });\n        }\n\n        if(unsynced) {\n          conflict.makeConflictedCopy(fs, syncPath, function(err) {\n            if(err) {\n              return handleError(err, callback);\n            }\n\n            // Because we'll overwrite the file with upstream changes,\n            // remove the unsynced attribute (local changes are in\n            // the conflicted copy now).\n            fsUtils.removeUnsynced(fs, syncPath, function(err) {\n              if(err) {\n                return handleError(err, callback);\n              }\n\n              write();\n            });\n          });\n        } else {\n          write();\n        }\n      });\n    });\n  }\n\n  // Remove deleted nodes in the destination path\n  function removeNodesInParent(diff, callback) {\n    callback = findCallback(callback, diff);\n    fs.lstat(path, function(err, stats) {\n      if(err) {\n        return handleError(err, callback);\n      }\n\n      if(!stats.isDirectory()) {\n        return callback(null, paths);\n      }\n\n      removeNodes(path, diff, callback);\n    });\n  }\n\n  if(diff && diff.length) {\n    async.eachSeries(diff, syncEach, function(err) {\n      if(err) {\n        callback(err, paths);\n      } else {\n        removeNodesInParent(diff, callback);\n      }\n    });\n  } else {\n    fs.Shell().mkdirp(path, function(err) {\n      if(err && err !== 'EEXIST') {\n        callback(err, paths);\n      } else {\n        removeNodesInParent(callback);\n      }\n    });\n  }\n};\n\n// Generate checksums for an array of paths to be used for comparison\nrsync.pathChecksums = function(fs, paths, chunkSize, callback) {\n  var paramError = validateParams(fs, paths);\n  var checksums = [];\n\n  if(!chunkSize || typeof callback !== 'function') {\n    return callback(new Errors.EINVAL('Insufficient data provided'));\n  }\n\n  if(paramError) {\n    return callback(paramError);\n  }\n\n  function generateChecksum(path, callback) {\n    var entry = {path: path};\n\n    fs.lstat(path, function(err, stat) {\n      if(err) {\n        if(err.code !== 'ENOENT') {\n          return callback(err);\n        }\n\n        // Node does not exist\n        entry.checksum = [];\n        checksums.push(entry);\n        return callback();\n      }\n\n      // Use contents of directory instead of checksums\n      if(stat.isDirectory()) {\n        return fs.readdir(path, function(err, nodeList) {\n          if(err) {\n            return callback(err);\n          }\n\n          entry.contents = nodeList;\n          checksums.push(entry);\n          callback();\n        });\n      }\n\n      // Calculate checksums for file or symbolic links\n      checksum(fs, path, chunkSize, function(err, chksum) {\n        if(err) {\n          return callback(err);\n        }\n\n        entry.checksum = chksum;\n        checksums.push(entry);\n        callback();\n      });\n    });\n  }\n\n  async.eachSeries(paths, generateChecksum, function(err) {\n    if(err) {\n      return callback(err);\n    }\n\n    callback(null, checksums);\n  });\n};\n\n// Compare two filesystem contents by comparing checksums\nrsync.compareContents = function(fs, checksums, chunkSize, callback) {\n  var EDIFF = 'DIFF';\n  var paramError = validateParams(fs, checksums);\n\n  if(!chunkSize || typeof callback !== 'function') {\n    return callback(new Errors.EINVAL('Insufficient data provided'));\n  }\n\n  if(paramError) {\n    return callback(paramError);\n  }\n\n  // Check if two checksum arrays are equal\n  function isEqual(checksum1, checksum2) {\n    var comparisonLength = checksum2.length;\n    var checksum1i, checksum2i;\n\n    if(checksum1.length !== comparisonLength) {\n      return false;\n    }\n\n    // Sort the checksum objects in each array by the 'index' property\n    checksum1 = ld_shim.map(ld_shim.sortBy(checksum1, 'index'), ld_shim.values);\n    checksum2 = ld_shim.map(ld_shim.sortBy(checksum2, 'index'), ld_shim.values);\n\n    // Compare each object's checksums\n    for(var i = 0; i < comparisonLength; i++) {\n      checksum1i = checksum1[i];\n      checksum2i = checksum2[i];\n\n      if(checksum1i[1] !== checksum2i[1] ||\n        checksum1i[2] !== checksum2i[2]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function compare(entry, callback) {\n    var path = entry.path;\n\n    fs.lstat(path, function(err, stat) {\n      if(err) {\n        if(err.code !== 'ENOENT') {\n          return callback(err);\n        }\n\n        // Checksums for a non-existent path are empty\n        if(entry.checksum && !entry.checksum.length) {\n          return callback();\n        }\n\n        return callback(EDIFF);\n      }\n\n      // Directory comparison of contents\n      if(stat.isDirectory()) {\n        return fs.readdir(path, function(err, nodeList) {\n          if(err) {\n            return callback(err);\n          }\n\n          if(!entry.contents || ld_shim.difference(entry.contents, nodeList).length) {\n            return callback(EDIFF);\n          }\n\n          callback();\n        });\n      }\n\n      if(!entry.checksum) {\n        return callback(EDIFF);\n      }\n\n      // Compare checksums for two files/symbolic links\n      checksum(fs, path, chunkSize, function(err, checksum) {\n        if(err) {\n          return callback(err);\n        }\n\n        if(!isEqual(checksum, entry.checksum)) {\n          return callback(EDIFF);\n        }\n\n        callback();\n      });\n    });\n  }\n\n  async.eachSeries(checksums, compare, function(err) {\n    if(err && err !== EDIFF) {\n      return callback(err, false);\n    }\n\n    if(err === EDIFF) {\n      return callback(null, false);\n    }\n\n    callback(null, true);\n  });\n};\n\nmodule.exports = rsync;\n\n},{\"./async-lite.js\":8,\"./conflict.js\":9,\"./constants.js\":10,\"./filer.js\":13,\"./fs-utils.js\":14,\"./lodash-lite.js\":15,\"MD5\":19}],17:[function(require,module,exports){\n/**\n * Sync path resolver is a library that provides\n * functionality to determine 'syncable' paths\n * It exposes the following method:\n *\n * resolve      - This method takes two paths as arguments.\n *                The goal is to find the most common ancestor\n *                between them. For e.g. the most common ancestor\n *                between '/dir' and '/dir/file.txt' is '/dir' while\n *                between '/dir' and '/file.txt' would be '/'.\n *\n*/\n\nvar pathResolver = {};\nvar dirname = require('./filer').Path.dirname;\n\nfunction getDepth(path) {\n  if(path === '/') {\n    return 0;\n  }\n\n  return 1 + getDepth(dirname(path));\n}\n\nfunction commonAncestor(path1, depth1, path2, depth2) {\n  if(path1 === path2) {\n    return path1;\n  }\n\n  // Regress the appropriate path\n  if(depth1 === depth2) {\n    path1 = dirname(path1);\n    depth1--;\n    path2 = dirname(path2);\n    depth2--;\n  } else if(depth1 > depth2) {\n    path1 = dirname(path1);\n    depth1--;\n  } else {\n    path2 = dirname(path2);\n    depth2--;\n  }\n\n  return commonAncestor(path1, depth1, path2, depth2);\n}\n\npathResolver.resolve = function(path1, path2) {\n  if(!path1 && !path2) {\n    return '/';\n  }\n\n  if(!path1 || !path2) {\n    return path1 || path2;\n  }\n\n  var path1Depth = getDepth(path1);\n  var path2Depth = getDepth(path2);\n\n  return commonAncestor(path1, path1Depth, path2, path2Depth);\n};\n\nmodule.exports = pathResolver;\n\n},{\"./filer\":13}],18:[function(require,module,exports){\n// Constructor\nfunction SyncMessage(type, name, content) {\n  if(!isValidType(type)) {\n    throw \"Invalid type\";\n  }\n  if(!isValidName(name)) {\n    throw \"Invalid name\";\n  }\n\n  this.type = type;\n  this.name = name;\n  this.content = content || null;\n\n  // Sugar for testing instance data\n  var that = this;\n  this.is = {\n    // Types\n    get request() {\n      return that.type === SyncMessage.REQUEST;\n    },\n    get response() {\n      return that.type === SyncMessage.RESPONSE;\n    },\n    get error() {\n      return that.type === SyncMessage.ERROR;\n    },\n\n    // Names\n    get srclist() {\n      return that.name === SyncMessage.SRCLIST;\n    },\n    get sync() {\n      return that.name === SyncMessage.SYNC;\n    },\n    get chksum() {\n      return that.name === SyncMessage.CHKSUM;\n    },\n    get diffs() {\n      return that.name === SyncMessage.DIFFS;\n    },\n    get patch() {\n      return that.name === SyncMessage.PATCH;\n    },\n    get verification() {\n      return that.name === SyncMessage.VERIFICATION;\n    },\n    get reset() {\n      return that.name === SyncMessage.RESET;\n    },\n    get locked() {\n      return that.name === SyncMessage.LOCKED;\n    },\n    get authz() {\n      return that.name === SyncMessage.AUTHZ;\n    },\n    get impl() {\n      return that.name === SyncMessage.IMPL;\n    },\n    get serverReset() {\n      return that.name === SyncMessage.SERVER_RESET;\n    },\n    get downstreamLocked() {\n      return that.name === SyncMessage.DOWNSTREAM_LOCKED;\n    }\n  };\n}\n\nSyncMessage.prototype.stringify = function() {\n  return JSON.stringify({\n    type: this.type,\n    name: this.name,\n    content: this.content\n  });\n};\n\n// Try to parse data back into a SyncMessage object. If the\n// data is invalid, return a format error message instead.\nSyncMessage.parse = function(data) {\n  if(!data || !isValidType(data.type) || !isValidName(data.name)) {\n    return SyncMessage.error.format;\n  }\n\n  return new SyncMessage(data.type, data.name, data.content);\n};\n\n// SyncMessage Type constants\nSyncMessage.REQUEST = \"REQUEST\";\nSyncMessage.RESPONSE = \"RESPONSE\";\nSyncMessage.ERROR = \"ERROR\";\n\n// SyncMessage Name constants\nSyncMessage.SRCLIST = \"SRCLIST\";\nSyncMessage.SYNC = \"SYNC\";\nSyncMessage.CHKSUM = \"CHKSUM\";\nSyncMessage.DIFFS = \"DIFFS\";\nSyncMessage.PATCH = \"PATCH\";\nSyncMessage.VERIFICATION = \"VERIFICATION\";\nSyncMessage.RESET = \"RESET\";\nSyncMessage.LOCKED = \"LOCKED\";\nSyncMessage.AUTHZ = \"AUTHORIZED\";\nSyncMessage.IMPL = \"IMPLEMENTATION\";\nSyncMessage.SERVER_RESET = \"SERVER_RESET\";\nSyncMessage.DOWNSTREAM_LOCKED = \"DOWNSTREAM_LOCKED\";\n\n// SyncMessage Error constants\nSyncMessage.INFRMT = \"INVALID FORMAT\";\nSyncMessage.INCONT = \"INVALID CONTENT\";\n\nfunction isValidName(name) {\n  return name === SyncMessage.SRCLIST      ||\n         name === SyncMessage.CHKSUM       ||\n         name === SyncMessage.DIFFS        ||\n         name === SyncMessage.LOCKED       ||\n         name === SyncMessage.PATCH        ||\n         name === SyncMessage.VERIFICATION ||\n         name === SyncMessage.SYNC         ||\n         name === SyncMessage.RESET        ||\n         name === SyncMessage.AUTHZ        ||\n         name === SyncMessage.IMPL         ||\n         name === SyncMessage.INFRMT       ||\n         name === SyncMessage.INCONT       ||\n         name === SyncMessage.SERVER_RESET ||\n         name === SyncMessage.DOWNSTREAM_LOCKED;\n}\n\nfunction isValidType(type) {\n  return type === SyncMessage.REQUEST  ||\n         type === SyncMessage.RESPONSE ||\n         type === SyncMessage.ERROR;\n}\n\n// Sugar for getting message instances\nSyncMessage.request = {\n  get diffs() {\n    return new SyncMessage(SyncMessage.REQUEST, SyncMessage.DIFFS);\n  },\n  get chksum() {\n    return new SyncMessage(SyncMessage.REQUEST, SyncMessage.CHKSUM);\n  },\n  get sync() {\n    return new SyncMessage(SyncMessage.REQUEST, SyncMessage.SYNC);\n  },\n  get reset() {\n    return new SyncMessage(SyncMessage.REQUEST, SyncMessage.RESET);\n  }\n};\nSyncMessage.response = {\n  get diffs() {\n    return new SyncMessage(SyncMessage.RESPONSE, SyncMessage.DIFFS);\n  },\n  get patch() {\n    return new SyncMessage(SyncMessage.RESPONSE, SyncMessage.PATCH);\n  },\n  get verification() {\n    return new SyncMessage(SyncMessage.RESPONSE, SyncMessage.VERIFICATION);\n  },\n  get authz() {\n    return new SyncMessage(SyncMessage.RESPONSE, SyncMessage.AUTHZ);\n  },\n  get sync() {\n    return new SyncMessage(SyncMessage.RESPONSE, SyncMessage.SYNC);\n  },\n  get reset() {\n    return new SyncMessage(SyncMessage.RESPONSE, SyncMessage.RESET);\n  }\n};\nSyncMessage.error = {\n  get srclist() {\n    return new SyncMessage(SyncMessage.ERROR, SyncMessage.SRCLIST);\n  },\n  get diffs() {\n    return new SyncMessage(SyncMessage.ERROR, SyncMessage.DIFFS);\n  },\n  get locked() {\n    return new SyncMessage(SyncMessage.ERROR, SyncMessage.LOCKED);\n  },\n  get chksum() {\n    return new SyncMessage(SyncMessage.ERROR, SyncMessage.CHKSUM);\n  },\n  get patch() {\n    return new SyncMessage(SyncMessage.ERROR, SyncMessage.PATCH);\n  },\n  get impl() {\n    return new SyncMessage(SyncMessage.ERROR, SyncMessage.IMPL);\n  },\n  get serverReset() {\n    return new SyncMessage(SyncMessage.ERROR, SyncMessage.SERVER_RESET);\n  },\n  get downstreamLocked() {\n    return new SyncMessage(SyncMessage.ERROR, SyncMessage.DOWNSTREAM_LOCKED, 'Downstream syncs are locked!');\n  },\n  get verification() {\n    return new SyncMessage(SyncMessage.ERROR,\n                           SyncMessage.VERIFICATION,\n                           'Patch could not be verified');\n  },\n  get format() {\n    return new SyncMessage(SyncMessage.ERROR,\n                           SyncMessage.INFRMT,\n                           'Message must be formatted as a sync message');\n  },\n  get content() {\n    return new SyncMessage(SyncMessage.ERROR,\n                           SyncMessage.INCONT,\n                           'Invalid content provided');\n  }\n};\n\nmodule.exports = SyncMessage;\n\n},{}],19:[function(require,module,exports){\n(function (Buffer){\n(function(){\r\n  var crypt = require('crypt'),\r\n      utf8 = require('charenc').utf8,\r\n      bin = require('charenc').bin,\r\n\r\n  // The core\r\n  md5 = function (message, options) {\r\n    // Convert to byte array\r\n    if (message.constructor == String)\r\n      if (options && options.encoding === 'binary')\r\n        message = bin.stringToBytes(message);\r\n      else\r\n        message = utf8.stringToBytes(message);\r\n    else if (typeof Buffer != 'undefined' &&\r\n        typeof Buffer.isBuffer == 'function' && Buffer.isBuffer(message))\r\n      message = Array.prototype.slice.call(message, 0);\r\n    else if (!Array.isArray(message))\r\n      message = message.toString();\r\n    // else, assume byte array already\r\n\r\n    var m = crypt.bytesToWords(message),\r\n        l = message.length * 8,\r\n        a =  1732584193,\r\n        b = -271733879,\r\n        c = -1732584194,\r\n        d =  271733878;\r\n\r\n    // Swap endian\r\n    for (var i = 0; i < m.length; i++) {\r\n      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |\r\n             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;\r\n    }\r\n\r\n    // Padding\r\n    m[l >>> 5] |= 0x80 << (l % 32);\r\n    m[(((l + 64) >>> 9) << 4) + 14] = l;\r\n\r\n    // Method shortcuts\r\n    var FF = md5._ff,\r\n        GG = md5._gg,\r\n        HH = md5._hh,\r\n        II = md5._ii;\r\n\r\n    for (var i = 0; i < m.length; i += 16) {\r\n\r\n      var aa = a,\r\n          bb = b,\r\n          cc = c,\r\n          dd = d;\r\n\r\n      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);\r\n      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);\r\n      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);\r\n      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);\r\n      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);\r\n      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);\r\n      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);\r\n      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);\r\n      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);\r\n      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);\r\n      c = FF(c, d, a, b, m[i+10], 17, -42063);\r\n      b = FF(b, c, d, a, m[i+11], 22, -1990404162);\r\n      a = FF(a, b, c, d, m[i+12],  7,  1804603682);\r\n      d = FF(d, a, b, c, m[i+13], 12, -40341101);\r\n      c = FF(c, d, a, b, m[i+14], 17, -1502002290);\r\n      b = FF(b, c, d, a, m[i+15], 22,  1236535329);\r\n\r\n      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);\r\n      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);\r\n      c = GG(c, d, a, b, m[i+11], 14,  643717713);\r\n      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);\r\n      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);\r\n      d = GG(d, a, b, c, m[i+10],  9,  38016083);\r\n      c = GG(c, d, a, b, m[i+15], 14, -660478335);\r\n      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);\r\n      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);\r\n      d = GG(d, a, b, c, m[i+14],  9, -1019803690);\r\n      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);\r\n      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);\r\n      a = GG(a, b, c, d, m[i+13],  5, -1444681467);\r\n      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);\r\n      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);\r\n      b = GG(b, c, d, a, m[i+12], 20, -1926607734);\r\n\r\n      a = HH(a, b, c, d, m[i+ 5],  4, -378558);\r\n      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);\r\n      c = HH(c, d, a, b, m[i+11], 16,  1839030562);\r\n      b = HH(b, c, d, a, m[i+14], 23, -35309556);\r\n      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);\r\n      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);\r\n      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);\r\n      b = HH(b, c, d, a, m[i+10], 23, -1094730640);\r\n      a = HH(a, b, c, d, m[i+13],  4,  681279174);\r\n      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);\r\n      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);\r\n      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);\r\n      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);\r\n      d = HH(d, a, b, c, m[i+12], 11, -421815835);\r\n      c = HH(c, d, a, b, m[i+15], 16,  530742520);\r\n      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);\r\n\r\n      a = II(a, b, c, d, m[i+ 0],  6, -198630844);\r\n      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);\r\n      c = II(c, d, a, b, m[i+14], 15, -1416354905);\r\n      b = II(b, c, d, a, m[i+ 5], 21, -57434055);\r\n      a = II(a, b, c, d, m[i+12],  6,  1700485571);\r\n      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);\r\n      c = II(c, d, a, b, m[i+10], 15, -1051523);\r\n      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);\r\n      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);\r\n      d = II(d, a, b, c, m[i+15], 10, -30611744);\r\n      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);\r\n      b = II(b, c, d, a, m[i+13], 21,  1309151649);\r\n      a = II(a, b, c, d, m[i+ 4],  6, -145523070);\r\n      d = II(d, a, b, c, m[i+11], 10, -1120210379);\r\n      c = II(c, d, a, b, m[i+ 2], 15,  718787259);\r\n      b = II(b, c, d, a, m[i+ 9], 21, -343485551);\r\n\r\n      a = (a + aa) >>> 0;\r\n      b = (b + bb) >>> 0;\r\n      c = (c + cc) >>> 0;\r\n      d = (d + dd) >>> 0;\r\n    }\r\n\r\n    return crypt.endian([a, b, c, d]);\r\n  };\r\n\r\n  // Auxiliary functions\r\n  md5._ff  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & c | ~b & d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._gg  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & d | c & ~d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._hh  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b ^ c ^ d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._ii  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n\r\n  // Package private blocksize\r\n  md5._blocksize = 16;\r\n  md5._digestsize = 16;\r\n\r\n  module.exports = function (message, options) {\r\n    if(typeof message == 'undefined')\r\n      return;\r\n\r\n    var digestbytes = crypt.wordsToBytes(md5(message, options));\r\n    return options && options.asBytes ? digestbytes :\r\n        options && options.asString ? bin.bytesToString(digestbytes) :\r\n        crypt.bytesToHex(digestbytes);\r\n  };\r\n\r\n})();\r\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":50,\"charenc\":20,\"crypt\":21}],20:[function(require,module,exports){\nvar charenc = {\n  // UTF-8 encoding\n  utf8: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));\n    }\n  },\n\n  // Binary encoding\n  bin: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      for (var bytes = [], i = 0; i < str.length; i++)\n        bytes.push(str.charCodeAt(i) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      for (var str = [], i = 0; i < bytes.length; i++)\n        str.push(String.fromCharCode(bytes[i]));\n      return str.join('');\n    }\n  }\n};\n\nmodule.exports = charenc;\n\n},{}],21:[function(require,module,exports){\n(function() {\n  var base64map\n      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n\n  crypt = {\n    // Bit-wise rotation left\n    rotl: function(n, b) {\n      return (n << b) | (n >>> (32 - b));\n    },\n\n    // Bit-wise rotation right\n    rotr: function(n, b) {\n      return (n << (32 - b)) | (n >>> b);\n    },\n\n    // Swap big-endian to little-endian and vice versa\n    endian: function(n) {\n      // If number given, swap endian\n      if (n.constructor == Number) {\n        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;\n      }\n\n      // Else, assume array and swap all items\n      for (var i = 0; i < n.length; i++)\n        n[i] = crypt.endian(n[i]);\n      return n;\n    },\n\n    // Generate an array of any length of random bytes\n    randomBytes: function(n) {\n      for (var bytes = []; n > 0; n--)\n        bytes.push(Math.floor(Math.random() * 256));\n      return bytes;\n    },\n\n    // Convert a byte array to big-endian 32-bit words\n    bytesToWords: function(bytes) {\n      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)\n        words[b >>> 5] |= bytes[i] << (24 - b % 32);\n      return words;\n    },\n\n    // Convert big-endian 32-bit words to a byte array\n    wordsToBytes: function(words) {\n      for (var bytes = [], b = 0; b < words.length * 32; b += 8)\n        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a hex string\n    bytesToHex: function(bytes) {\n      for (var hex = [], i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n      }\n      return hex.join('');\n    },\n\n    // Convert a hex string to a byte array\n    hexToBytes: function(hex) {\n      for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n      return bytes;\n    },\n\n    // Convert a byte array to a base-64 string\n    bytesToBase64: function(bytes) {\n      for (var base64 = [], i = 0; i < bytes.length; i += 3) {\n        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        for (var j = 0; j < 4; j++)\n          if (i * 8 + j * 6 <= bytes.length * 8)\n            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\n          else\n            base64.push('=');\n      }\n      return base64.join('');\n    },\n\n    // Convert a base-64 string to a byte array\n    base64ToBytes: function(base64) {\n      // Remove non-base-64 characters\n      base64 = base64.replace(/[^A-Z0-9+\\/]/ig, '');\n\n      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;\n          imod4 = ++i % 4) {\n        if (imod4 == 0) continue;\n        bytes.push(((base64map.indexOf(base64.charAt(i - 1))\n            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))\n            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\n      }\n      return bytes;\n    }\n  };\n\n  module.exports = crypt;\n})();\n\n},{}],22:[function(require,module,exports){\n(function (Buffer){\n// Browser Request\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar XHR = XMLHttpRequest\nif (!XHR) throw new Error('missing XMLHttpRequest')\nrequest.log = {\n  'trace': noop, 'debug': noop, 'info': noop, 'warn': noop, 'error': noop\n}\n\nvar DEFAULT_TIMEOUT = 3 * 60 * 1000 // 3 minutes\n\n//\n// request\n//\n\nfunction request(options, callback) {\n  // The entry-point to the API: prep the options object and pass the real work to run_xhr.\n  if(typeof callback !== 'function')\n    throw new Error('Bad callback given: ' + callback)\n\n  if(!options)\n    throw new Error('No options given')\n\n  var options_onResponse = options.onResponse; // Save this for later.\n\n  if(typeof options === 'string')\n    options = {'uri':options};\n  else\n    options = JSON.parse(JSON.stringify(options)); // Use a duplicate for mutating.\n\n  options.onResponse = options_onResponse // And put it back.\n\n  if (options.verbose) request.log = getLogger();\n\n  if(options.url) {\n    options.uri = options.url;\n    delete options.url;\n  }\n\n  if(!options.uri && options.uri !== \"\")\n    throw new Error(\"options.uri is a required argument\");\n\n  if(typeof options.uri != \"string\")\n    throw new Error(\"options.uri must be a string\");\n\n  var unsupported_options = ['proxy', '_redirectsFollowed', 'maxRedirects', 'followRedirect']\n  for (var i = 0; i < unsupported_options.length; i++)\n    if(options[ unsupported_options[i] ])\n      throw new Error(\"options.\" + unsupported_options[i] + \" is not supported\")\n\n  options.callback = callback\n  options.method = options.method || 'GET';\n  options.headers = options.headers || {};\n  options.body    = options.body || null\n  options.timeout = options.timeout || request.DEFAULT_TIMEOUT\n\n  if(options.headers.host)\n    throw new Error(\"Options.headers.host is not supported\");\n\n  if(options.json) {\n    options.headers.accept = options.headers.accept || 'application/json'\n    if(options.method !== 'GET')\n      options.headers['content-type'] = 'application/json'\n\n    if(typeof options.json !== 'boolean')\n      options.body = JSON.stringify(options.json)\n    else if(typeof options.body !== 'string')\n      options.body = JSON.stringify(options.body)\n  }\n  \n  //BEGIN QS Hack\n  var serialize = function(obj) {\n    var str = [];\n    for(var p in obj)\n      if (obj.hasOwnProperty(p)) {\n        str.push(encodeURIComponent(p) + \"=\" + encodeURIComponent(obj[p]));\n      }\n    return str.join(\"&\");\n  }\n  \n  if(options.qs){\n    var qs = (typeof options.qs == 'string')? options.qs : serialize(options.qs);\n    if(options.uri.indexOf('?') !== -1){ //no get params\n        options.uri = options.uri+'&'+qs;\n    }else{ //existing get params\n        options.uri = options.uri+'?'+qs;\n    }\n  }\n  //END QS Hack\n  \n  //BEGIN FORM Hack\n  var multipart = function(obj) {\n    //todo: support file type (useful?)\n    var result = {};\n    result.boundry = '-------------------------------'+Math.floor(Math.random()*1000000000);\n    var lines = [];\n    for(var p in obj){\n        if (obj.hasOwnProperty(p)) {\n            lines.push(\n                '--'+result.boundry+\"\\n\"+\n                'Content-Disposition: form-data; name=\"'+p+'\"'+\"\\n\"+\n                \"\\n\"+\n                obj[p]+\"\\n\"\n            );\n        }\n    }\n    lines.push( '--'+result.boundry+'--' );\n    result.body = lines.join('');\n    result.length = result.body.length;\n    result.type = 'multipart/form-data; boundary='+result.boundry;\n    return result;\n  }\n  \n  if(options.form){\n    if(typeof options.form == 'string') throw('form name unsupported');\n    if(options.method === 'POST'){\n        var encoding = (options.encoding || 'application/x-www-form-urlencoded').toLowerCase();\n        options.headers['content-type'] = encoding;\n        switch(encoding){\n            case 'application/x-www-form-urlencoded':\n                options.body = serialize(options.form).replace(/%20/g, \"+\");\n                break;\n            case 'multipart/form-data':\n                var multi = multipart(options.form);\n                //options.headers['content-length'] = multi.length;\n                options.body = multi.body;\n                options.headers['content-type'] = multi.type;\n                break;\n            default : throw new Error('unsupported encoding:'+encoding);\n        }\n    }\n  }\n  //END FORM Hack\n\n  // If onResponse is boolean true, call back immediately when the response is known,\n  // not when the full request is complete.\n  options.onResponse = options.onResponse || noop\n  if(options.onResponse === true) {\n    options.onResponse = callback\n    options.callback = noop\n  }\n\n  // XXX Browsers do not like this.\n  //if(options.body)\n  //  options.headers['content-length'] = options.body.length;\n\n  // HTTP basic authentication\n  if(!options.headers.authorization && options.auth)\n    options.headers.authorization = 'Basic ' + b64_enc(options.auth.username + ':' + options.auth.password);\n\n  return run_xhr(options)\n}\n\nvar req_seq = 0\nfunction run_xhr(options) {\n  var xhr = new XHR\n    , timed_out = false\n    , is_cors = is_crossDomain(options.uri)\n    , supports_cors = ('withCredentials' in xhr)\n\n  req_seq += 1\n  xhr.seq_id = req_seq\n  xhr.id = req_seq + ': ' + options.method + ' ' + options.uri\n  xhr._id = xhr.id // I know I will type \"_id\" from habit all the time.\n\n  if(is_cors && !supports_cors) {\n    var cors_err = new Error('Browser does not support cross-origin request: ' + options.uri)\n    cors_err.cors = 'unsupported'\n    return options.callback(cors_err, xhr)\n  }\n\n  xhr.timeoutTimer = setTimeout(too_late, options.timeout)\n  function too_late() {\n    timed_out = true\n    var er = new Error('ETIMEDOUT')\n    er.code = 'ETIMEDOUT'\n    er.duration = options.timeout\n\n    request.log.error('Timeout', { 'id':xhr._id, 'milliseconds':options.timeout })\n    return options.callback(er, xhr)\n  }\n\n  // Some states can be skipped over, so remember what is still incomplete.\n  var did = {'response':false, 'loading':false, 'end':false}\n\n  xhr.onreadystatechange = on_state_change\n  xhr.open(options.method, options.uri, true) // asynchronous\n  // Deal with requests for raw buffer response\n  if(options.encoding === null) {\n    xhr.responseType = 'arraybuffer';\n  }\n  if(is_cors)\n    xhr.withCredentials = !! options.withCredentials\n  xhr.send(options.body)\n  return xhr\n\n  function on_state_change(event) {\n    if(timed_out)\n      return request.log.debug('Ignoring timed out state change', {'state':xhr.readyState, 'id':xhr.id})\n\n    request.log.debug('State change', {'state':xhr.readyState, 'id':xhr.id, 'timed_out':timed_out})\n\n    if(xhr.readyState === XHR.OPENED) {\n      request.log.debug('Request started', {'id':xhr.id})\n      for (var key in options.headers)\n        xhr.setRequestHeader(key, options.headers[key])\n    }\n\n    else if(xhr.readyState === XHR.HEADERS_RECEIVED)\n      on_response()\n\n    else if(xhr.readyState === XHR.LOADING) {\n      on_response()\n      on_loading()\n    }\n\n    else if(xhr.readyState === XHR.DONE) {\n      on_response()\n      on_loading()\n      on_end()\n    }\n  }\n\n  function on_response() {\n    if(did.response)\n      return\n\n    did.response = true\n    request.log.debug('Got response', {'id':xhr.id, 'status':xhr.status})\n    clearTimeout(xhr.timeoutTimer)\n    xhr.statusCode = xhr.status // Node request compatibility\n\n    // Detect failed CORS requests.\n    if(is_cors && xhr.statusCode == 0) {\n      var cors_err = new Error('CORS request rejected: ' + options.uri)\n      cors_err.cors = 'rejected'\n\n      // Do not process this request further.\n      did.loading = true\n      did.end = true\n\n      return options.callback(cors_err, xhr)\n    }\n\n    options.onResponse(null, xhr)\n  }\n\n  function on_loading() {\n    if(did.loading)\n      return\n\n    did.loading = true\n    request.log.debug('Response body loading', {'id':xhr.id})\n    // TODO: Maybe simulate \"data\" events by watching xhr.responseText\n  }\n\n  function on_end() {\n    if(did.end)\n      return\n\n    did.end = true\n    request.log.debug('Request done', {'id':xhr.id})\n\n    if(options.encoding === null) {\n      xhr.body = new Buffer(new Uint8Array(xhr.response));\n    } else {\n      xhr.body = xhr.responseText\n      if(options.json) {\n        try        { xhr.body = JSON.parse(xhr.responseText) }\n        catch (er) { return options.callback(er, xhr)        }\n      }\n    }\n\n    options.callback(null, xhr, xhr.body)\n  }\n\n} // request\n\nrequest.withCredentials = false;\nrequest.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;\n\n//\n// defaults\n//\n\nrequest.defaults = function(options, requester) {\n  var def = function (method) {\n    var d = function (params, callback) {\n      if(typeof params === 'string')\n        params = {'uri': params};\n      else {\n        params = JSON.parse(JSON.stringify(params));\n      }\n      for (var i in options) {\n        if (params[i] === undefined) params[i] = options[i]\n      }\n      return method(params, callback)\n    }\n    return d\n  }\n  var de = def(request)\n  de.get = def(request.get)\n  de.post = def(request.post)\n  de.put = def(request.put)\n  de.head = def(request.head)\n  return de\n}\n\n//\n// HTTP method shortcuts\n//\n\nvar shortcuts = [ 'get', 'put', 'post', 'head' ];\nshortcuts.forEach(function(shortcut) {\n  var method = shortcut.toUpperCase();\n  var func   = shortcut.toLowerCase();\n\n  request[func] = function(opts) {\n    if(typeof opts === 'string')\n      opts = {'method':method, 'uri':opts};\n    else {\n      opts = JSON.parse(JSON.stringify(opts));\n      opts.method = method;\n    }\n\n    var args = [opts].concat(Array.prototype.slice.apply(arguments, [1]));\n    return request.apply(this, args);\n  }\n})\n\n//\n// CouchDB shortcut\n//\n\nrequest.couch = function(options, callback) {\n  if(typeof options === 'string')\n    options = {'uri':options}\n\n  // Just use the request API to do JSON.\n  options.json = true\n  if(options.body)\n    options.json = options.body\n  delete options.body\n\n  callback = callback || noop\n\n  var xhr = request(options, couch_handler)\n  return xhr\n\n  function couch_handler(er, resp, body) {\n    if(er)\n      return callback(er, resp, body)\n\n    if((resp.statusCode < 200 || resp.statusCode > 299) && body.error) {\n      // The body is a Couch JSON object indicating the error.\n      er = new Error('CouchDB error: ' + (body.error.reason || body.error.error))\n      for (var key in body)\n        er[key] = body[key]\n      return callback(er, resp, body);\n    }\n\n    return callback(er, resp, body);\n  }\n}\n\n//\n// Utility\n//\n\nfunction noop() {}\n\nfunction getLogger() {\n  var logger = {}\n    , levels = ['trace', 'debug', 'info', 'warn', 'error']\n    , level, i\n\n  for(i = 0; i < levels.length; i++) {\n    level = levels[i]\n\n    logger[level] = noop\n    if(typeof console !== 'undefined' && console && console[level])\n      logger[level] = formatted(console, level)\n  }\n\n  return logger\n}\n\nfunction formatted(obj, method) {\n  return formatted_logger\n\n  function formatted_logger(str, context) {\n    if(typeof context === 'object')\n      str += ' ' + JSON.stringify(context)\n\n    return obj[method].call(obj, str)\n  }\n}\n\n// Return whether a URL is a cross-domain request.\nfunction is_crossDomain(url) {\n  var rurl = /^([\\w\\+\\.\\-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+))?)?/\n\n  // jQuery #8138, IE may throw an exception when accessing\n  // a field from window.location if document.domain has been set\n  var ajaxLocation\n  try { ajaxLocation = location.href }\n  catch (e) {\n    // Use the href attribute of an A element since IE will modify it given document.location\n    ajaxLocation = document.createElement( \"a\" );\n    ajaxLocation.href = \"\";\n    ajaxLocation = ajaxLocation.href;\n  }\n\n  var ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []\n    , parts = rurl.exec(url.toLowerCase() )\n\n  var result = !!(\n    parts &&\n    (  parts[1] != ajaxLocParts[1]\n    || parts[2] != ajaxLocParts[2]\n    || (parts[3] || (parts[1] === \"http:\" ? 80 : 443)) != (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? 80 : 443))\n    )\n  )\n\n  //console.debug('is_crossDomain('+url+') -> ' + result)\n  return result\n}\n\n// MIT License from http://phpjs.org/functions/base64_encode:358\nfunction b64_enc (data) {\n    // Encodes string using MIME base64 algorithm\n    var b64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0, ac = 0, enc=\"\", tmp_arr = [];\n\n    if (!data) {\n        return data;\n    }\n\n    // assume utf8 data\n    // data = this.utf8_encode(data+'');\n\n    do { // pack three octets into four hexets\n        o1 = data.charCodeAt(i++);\n        o2 = data.charCodeAt(i++);\n        o3 = data.charCodeAt(i++);\n\n        bits = o1<<16 | o2<<8 | o3;\n\n        h1 = bits>>18 & 0x3f;\n        h2 = bits>>12 & 0x3f;\n        h3 = bits>>6 & 0x3f;\n        h4 = bits & 0x3f;\n\n        // use hexets to index into b64, and append result to encoded string\n        tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);\n    } while (i < data.length);\n\n    enc = tmp_arr.join('');\n\n    switch (data.length % 3) {\n        case 1:\n            enc = enc.slice(0, -2) + '==';\n        break;\n        case 2:\n            enc = enc.slice(0, -1) + '=';\n        break;\n    }\n\n    return enc;\n}\nmodule.exports = request;\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":50}],23:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],24:[function(require,module,exports){\n(function (process){\n/*global setImmediate: false, setTimeout: false, console: false */\n\n/**\n * async.js shim, based on https://raw.github.com/caolan/async/master/lib/async.js Feb 18, 2014\n * Used under MIT - https://github.com/caolan/async/blob/master/LICENSE\n */\n\n(function () {\n\n    var async = {};\n\n    // async.js functions used in Filer\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n\n}).call(this,require('_process'))\n},{\"_process\":53}],25:[function(require,module,exports){\n// Based on https://github.com/diy/intercom.js/blob/master/lib/events.js\n// Copyright 2012 DIY Co Apache License, Version 2.0\n// http://www.apache.org/licenses/LICENSE-2.0\n\nfunction removeItem(item, array) {\n  for (var i = array.length - 1; i >= 0; i--) {\n    if (array[i] === item) {\n      array.splice(i, 1);\n    }\n  }\n  return array;\n}\n\nvar EventEmitter = function() {};\n\nEventEmitter.createInterface = function(space) {\n  var methods = {};\n\n  methods.on = function(name, fn) {\n    if (typeof this[space] === 'undefined') {\n      this[space] = {};\n    }\n    if (!this[space].hasOwnProperty(name)) {\n      this[space][name] = [];\n    }\n    this[space][name].push(fn);\n  };\n\n  methods.off = function(name, fn) {\n    if (typeof this[space] === 'undefined') return;\n    if (this[space].hasOwnProperty(name)) {\n      removeItem(fn, this[space][name]);\n    }\n  };\n\n  methods.trigger = function(name) {\n    if (typeof this[space] !== 'undefined' && this[space].hasOwnProperty(name)) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      for (var i = 0; i < this[space][name].length; i++) {\n        this[space][name][i].apply(this[space][name][i], args);\n      }\n    }\n  };\n\n  methods.removeAllListeners = function(name) {\n    if (typeof this[space] === 'undefined') return;\n    var self = this;\n    self[space][name].forEach(function(fn) {\n      self.off(name, fn);\n    });\n  };\n\n  return methods;\n};\n\nvar pvt = EventEmitter.createInterface('_handlers');\nEventEmitter.prototype._on = pvt.on;\nEventEmitter.prototype._off = pvt.off;\nEventEmitter.prototype._trigger = pvt.trigger;\n\nvar pub = EventEmitter.createInterface('handlers');\nEventEmitter.prototype.on = function() {\n  pub.on.apply(this, arguments);\n  Array.prototype.unshift.call(arguments, 'on');\n  this._trigger.apply(this, arguments);\n};\nEventEmitter.prototype.off = pub.off;\nEventEmitter.prototype.trigger = pub.trigger;\nEventEmitter.prototype.removeAllListeners = pub.removeAllListeners;\n\nmodule.exports = EventEmitter;\n\n},{}],26:[function(require,module,exports){\n(function (global){\n// Based on https://github.com/diy/intercom.js/blob/master/lib/intercom.js\n// Copyright 2012 DIY Co Apache License, Version 2.0\n// http://www.apache.org/licenses/LICENSE-2.0\n\nvar EventEmitter = require('./eventemitter.js');\nvar guid = require('../src/shared.js').guid;\n\nfunction throttle(delay, fn) {\n  var last = 0;\n  return function() {\n    var now = Date.now();\n    if (now - last > delay) {\n      last = now;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nfunction extend(a, b) {\n  if (typeof a === 'undefined' || !a) { a = {}; }\n  if (typeof b === 'object') {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n  }\n  return a;\n}\n\nvar localStorage = (function(window) {\n  if (typeof window === 'undefined' ||\n      typeof window.localStorage === 'undefined') {\n    return {\n      getItem : function() {},\n      setItem : function() {},\n      removeItem : function() {}\n    };\n  }\n  return window.localStorage;\n}(global));\n\nfunction Intercom() {\n  var self = this;\n  var now = Date.now();\n\n  this.origin         = guid();\n  this.lastMessage    = now;\n  this.receivedIDs    = {};\n  this.previousValues = {};\n\n  var storageHandler = function() {\n    self._onStorageEvent.apply(self, arguments);\n  };\n\n  // If we're in node.js, skip event registration\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  if (document.attachEvent) {\n    document.attachEvent('onstorage', storageHandler);\n  } else {\n    global.addEventListener('storage', storageHandler, false);\n  }\n}\n\nIntercom.prototype._transaction = function(fn) {\n  var TIMEOUT   = 1000;\n  var WAIT      = 20;\n  var self      = this;\n  var executed  = false;\n  var listening = false;\n  var waitTimer = null;\n\n  function lock() {\n    if (executed) {\n      return;\n    }\n\n    var now = Date.now();\n    var activeLock = localStorage.getItem(INDEX_LOCK)|0;\n    if (activeLock && now - activeLock < TIMEOUT) {\n      if (!listening) {\n        self._on('storage', lock);\n        listening = true;\n      }\n      waitTimer = setTimeout(lock, WAIT);\n      return;\n    }\n    executed = true;\n    localStorage.setItem(INDEX_LOCK, now);\n\n    fn();\n    unlock();\n  }\n\n  function unlock() {\n    if (listening) {\n      self._off('storage', lock);\n    }\n    if (waitTimer) {\n      clearTimeout(waitTimer);\n    }\n    localStorage.removeItem(INDEX_LOCK);\n  }\n\n  lock();\n};\n\nIntercom.prototype._cleanup_emit = throttle(100, function() {\n  var self = this;\n\n  self._transaction(function() {\n    var now = Date.now();\n    var threshold = now - THRESHOLD_TTL_EMIT;\n    var changed = 0;\n    var messages;\n\n    try {\n      messages = JSON.parse(localStorage.getItem(INDEX_EMIT) || '[]');\n    } catch(e) {\n      messages = [];\n    }\n    for (var i = messages.length - 1; i >= 0; i--) {\n      if (messages[i].timestamp < threshold) {\n        messages.splice(i, 1);\n        changed++;\n      }\n    }\n    if (changed > 0) {\n      localStorage.setItem(INDEX_EMIT, JSON.stringify(messages));\n    }\n  });\n});\n\nIntercom.prototype._cleanup_once = throttle(100, function() {\n  var self = this;\n\n  self._transaction(function() {\n    var timestamp, ttl, key;\n    var table;\n    var now  = Date.now();\n    var changed = 0;\n\n    try {\n      table = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');\n    } catch(e) {\n      table = {};\n    }\n    for (key in table) {\n      if (self._once_expired(key, table)) {\n        delete table[key];\n        changed++;\n      }\n    }\n\n    if (changed > 0) {\n      localStorage.setItem(INDEX_ONCE, JSON.stringify(table));\n    }\n  });\n});\n\nIntercom.prototype._once_expired = function(key, table) {\n  if (!table) {\n    return true;\n  }\n  if (!table.hasOwnProperty(key)) {\n    return true;\n  }\n  if (typeof table[key] !== 'object') {\n    return true;\n  }\n\n  var ttl = table[key].ttl || THRESHOLD_TTL_ONCE;\n  var now = Date.now();\n  var timestamp = table[key].timestamp;\n  return timestamp < now - ttl;\n};\n\nIntercom.prototype._localStorageChanged = function(event, field) {\n  if (event && event.key) {\n    return event.key === field;\n  }\n\n  var currentValue = localStorage.getItem(field);\n  if (currentValue === this.previousValues[field]) {\n    return false;\n  }\n  this.previousValues[field] = currentValue;\n  return true;\n};\n\nIntercom.prototype._onStorageEvent = function(event) {\n  event = event || global.event;\n  var self = this;\n\n  if (this._localStorageChanged(event, INDEX_EMIT)) {\n    this._transaction(function() {\n      var now = Date.now();\n      var data = localStorage.getItem(INDEX_EMIT);\n      var messages;\n\n      try {\n        messages = JSON.parse(data || '[]');\n      } catch(e) {\n        messages = [];\n      }\n      for (var i = 0; i < messages.length; i++) {\n        if (messages[i].origin === self.origin) continue;\n        if (messages[i].timestamp < self.lastMessage) continue;\n        if (messages[i].id) {\n          if (self.receivedIDs.hasOwnProperty(messages[i].id)) continue;\n          self.receivedIDs[messages[i].id] = true;\n        }\n        self.trigger(messages[i].name, messages[i].payload);\n      }\n      self.lastMessage = now;\n    });\n  }\n\n  this._trigger('storage', event);\n};\n\nIntercom.prototype._emit = function(name, message, id) {\n  id = (typeof id === 'string' || typeof id === 'number') ? String(id) : null;\n  if (id && id.length) {\n    if (this.receivedIDs.hasOwnProperty(id)) return;\n    this.receivedIDs[id] = true;\n  }\n\n  var packet = {\n    id        : id,\n    name      : name,\n    origin    : this.origin,\n    timestamp : Date.now(),\n    payload   : message\n  };\n\n  var self = this;\n  this._transaction(function() {\n    var data = localStorage.getItem(INDEX_EMIT) || '[]';\n    var delimiter = (data === '[]') ? '' : ',';\n    data = [data.substring(0, data.length - 1), delimiter, JSON.stringify(packet), ']'].join('');\n    localStorage.setItem(INDEX_EMIT, data);\n    self.trigger(name, message);\n\n    setTimeout(function() {\n      self._cleanup_emit();\n    }, 50);\n  });\n};\n\nIntercom.prototype.emit = function(name, message) {\n  this._emit.apply(this, arguments);\n  this._trigger('emit', name, message);\n};\n\nIntercom.prototype.once = function(key, fn, ttl) {\n  if (!Intercom.supported) {\n    return;\n  }\n\n  var self = this;\n  this._transaction(function() {\n    var data;\n    try {\n      data = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');\n    } catch(e) {\n      data = {};\n    }\n    if (!self._once_expired(key, data)) {\n      return;\n    }\n\n    data[key] = {};\n    data[key].timestamp = Date.now();\n    if (typeof ttl === 'number') {\n      data[key].ttl = ttl * 1000;\n    }\n\n    localStorage.setItem(INDEX_ONCE, JSON.stringify(data));\n    fn();\n\n    setTimeout(function() {\n      self._cleanup_once();\n    }, 50);\n  });\n};\n\nextend(Intercom.prototype, EventEmitter.prototype);\n\nIntercom.supported = (typeof localStorage !== 'undefined');\n\nvar INDEX_EMIT = 'intercom';\nvar INDEX_ONCE = 'intercom_once';\nvar INDEX_LOCK = 'intercom_lock';\n\nvar THRESHOLD_TTL_EMIT = 50000;\nvar THRESHOLD_TTL_ONCE = 1000 * 3600;\n\nIntercom.destroy = function() {\n  localStorage.removeItem(INDEX_LOCK);\n  localStorage.removeItem(INDEX_EMIT);\n  localStorage.removeItem(INDEX_ONCE);\n};\n\nIntercom.getInstance = (function() {\n  var intercom;\n  return function() {\n    if (!intercom) {\n      intercom = new Intercom();\n    }\n    return intercom;\n  };\n})();\n\nmodule.exports = Intercom;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../src/shared.js\":45,\"./eventemitter.js\":25}],27:[function(require,module,exports){\n// Cherry-picked bits of underscore.js, lodash.js\n\n/**\n * Lo-Dash 2.4.0 <http://lodash.com/>\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar ArrayProto = Array.prototype;\nvar nativeForEach = ArrayProto.forEach;\nvar nativeIndexOf = ArrayProto.indexOf;\nvar nativeSome = ArrayProto.some;\n\nvar ObjProto = Object.prototype;\nvar hasOwnProperty = ObjProto.hasOwnProperty;\nvar nativeKeys = Object.keys;\n\nvar breaker = {};\n\nfunction has(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\nvar keys = nativeKeys || function(obj) {\n  if (obj !== Object(obj)) throw new TypeError('Invalid object');\n  var keys = [];\n  for (var key in obj) if (has(obj, key)) keys.push(key);\n  return keys;\n};\n\nfunction size(obj) {\n  if (obj == null) return 0;\n  return (obj.length === +obj.length) ? obj.length : keys(obj).length;\n}\n\nfunction identity(value) {\n  return value;\n}\n\nfunction each(obj, iterator, context) {\n  var i, length;\n  if (obj == null) return;\n  if (nativeForEach && obj.forEach === nativeForEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length === +obj.length) {\n    for (i = 0, length = obj.length; i < length; i++) {\n      if (iterator.call(context, obj[i], i, obj) === breaker) return;\n    }\n  } else {\n    var keys = keys(obj);\n    for (i = 0, length = keys.length; i < length; i++) {\n      if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n    }\n  }\n};\n\nfunction any(obj, iterator, context) {\n  iterator || (iterator = identity);\n  var result = false;\n  if (obj == null) return result;\n  if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n  each(obj, function(value, index, list) {\n    if (result || (result = iterator.call(context, value, index, list))) return breaker;\n  });\n  return !!result;\n};\n\nfunction contains(obj, target) {\n  if (obj == null) return false;\n  if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n  return any(obj, function(value) {\n    return value === target;\n  });\n};\n\nfunction Wrapped(value) {\n  this.value = value;\n}\nWrapped.prototype.has = function(key) {\n  return has(this.value, key);\n};\nWrapped.prototype.contains = function(target) {\n  return contains(this.value, target);\n};\nWrapped.prototype.size = function() {\n  return size(this.value);\n};\n\nfunction nodash(value) {\n  // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor\n  return (value && typeof value == 'object' && !Array.isArray(value) && hasOwnProperty.call(value, '__wrapped__'))\n    ? value\n    : new Wrapped(value);\n}\n\nmodule.exports = nodash;\n\n},{}],28:[function(require,module,exports){\n/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(chars){\n  \"use strict\";\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = chars.indexOf(base64[i]);\n      encoded2 = chars.indexOf(base64[i+1]);\n      encoded3 = chars.indexOf(base64[i+2]);\n      encoded4 = chars.indexOf(base64[i+3]);\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\");\n\n},{}],29:[function(require,module,exports){\n(function (Buffer){\nfunction FilerBuffer (subject, encoding, nonZero) {\n\n  // Automatically turn ArrayBuffer into Uint8Array so that underlying\n  // Buffer code doesn't just throw away and ignore ArrayBuffer data.\n  if (subject instanceof ArrayBuffer) {\n    subject = new Uint8Array(subject);\n  }\n\n  return new Buffer(subject, encoding, nonZero);\n};\n\n// Inherit prototype from Buffer\nFilerBuffer.prototype = Object.create(Buffer.prototype);\nFilerBuffer.prototype.constructor = FilerBuffer;\n\n// Also copy static methods onto FilerBuffer ctor\nObject.keys(Buffer).forEach(function (p) {\n  if (Buffer.hasOwnProperty(p)) {\n    FilerBuffer[p] = Buffer[p];\n  }\n});\n\nmodule.exports = FilerBuffer;\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":50}],30:[function(require,module,exports){\nvar O_READ = 'READ';\nvar O_WRITE = 'WRITE';\nvar O_CREATE = 'CREATE';\nvar O_EXCLUSIVE = 'EXCLUSIVE';\nvar O_TRUNCATE = 'TRUNCATE';\nvar O_APPEND = 'APPEND';\nvar XATTR_CREATE = 'CREATE';\nvar XATTR_REPLACE = 'REPLACE';\n\nmodule.exports = {\n  FILE_SYSTEM_NAME: 'local',\n\n  FILE_STORE_NAME: 'files',\n\n  IDB_RO: 'readonly',\n  IDB_RW: 'readwrite',\n\n  WSQL_VERSION: \"1\",\n  WSQL_SIZE: 5 * 1024 * 1024,\n  WSQL_DESC: \"FileSystem Storage\",\n\n  MODE_FILE: 'FILE',\n  MODE_DIRECTORY: 'DIRECTORY',\n  MODE_SYMBOLIC_LINK: 'SYMLINK',\n  MODE_META: 'META',\n\n  SYMLOOP_MAX: 10,\n\n  BINARY_MIME_TYPE: 'application/octet-stream',\n  JSON_MIME_TYPE: 'application/json',\n\n  ROOT_DIRECTORY_NAME: '/', // basename(normalize(path))\n\n  // FS Mount Flags\n  FS_FORMAT: 'FORMAT',\n  FS_NOCTIME: 'NOCTIME',\n  FS_NOMTIME: 'NOMTIME',\n  FS_NODUPEIDCHECK: 'FS_NODUPEIDCHECK',\n\n  // FS File Open Flags\n  O_READ: O_READ,\n  O_WRITE: O_WRITE,\n  O_CREATE: O_CREATE,\n  O_EXCLUSIVE: O_EXCLUSIVE,\n  O_TRUNCATE: O_TRUNCATE,\n  O_APPEND: O_APPEND,\n\n  O_FLAGS: {\n    'r': [O_READ],\n    'r+': [O_READ, O_WRITE],\n    'w': [O_WRITE, O_CREATE, O_TRUNCATE],\n    'w+': [O_WRITE, O_READ, O_CREATE, O_TRUNCATE],\n    'wx': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],\n    'wx+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],\n    'a': [O_WRITE, O_CREATE, O_APPEND],\n    'a+': [O_WRITE, O_READ, O_CREATE, O_APPEND],\n    'ax': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_APPEND],\n    'ax+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_APPEND]\n  },\n\n  XATTR_CREATE: XATTR_CREATE,\n  XATTR_REPLACE: XATTR_REPLACE,\n\n  FS_READY: 'READY',\n  FS_PENDING: 'PENDING',\n  FS_ERROR: 'ERROR',\n\n  SUPER_NODE_ID: '00000000-0000-0000-0000-000000000000',\n\n  // Reserved File Descriptors for streams\n  STDIN: 0,\n  STDOUT: 1,\n  STDERR: 2,\n  FIRST_DESCRIPTOR: 3,\n\n  ENVIRONMENT: {\n    TMP: '/tmp',\n    PATH: ''\n  }\n};\n\n},{}],31:[function(require,module,exports){\nvar MODE_FILE = require('./constants.js').MODE_FILE;\n\nmodule.exports = function DirectoryEntry(id, type) {\n  this.id = id;\n  this.type = type || MODE_FILE;\n};\n\n},{\"./constants.js\":30}],32:[function(require,module,exports){\n(function (Buffer){\n// Adapt encodings to work with Buffer or Uint8Array, they expect the latter\nfunction decode(buf) {\n  return buf.toString('utf8');\n}\n\nfunction encode(string) {\n  return new Buffer(string, 'utf8');\n}\n\nmodule.exports = {\n  encode: encode,\n  decode: decode\n};\n\n}).call(this,require(\"buffer\").Buffer)\n},{\"buffer\":50}],33:[function(require,module,exports){\nvar errors = {};\n[\n  /**\n   * node.js errors - we only use some of these, add as needed.\n   */\n  //'-1:UNKNOWN:unknown error',\n  //'0:OK:success',\n  //'1:EOF:end of file',\n  //'2:EADDRINFO:getaddrinfo error',\n  //'3:EACCES:permission denied',\n  //'4:EAGAIN:resource temporarily unavailable',\n  //'5:EADDRINUSE:address already in use',\n  //'6:EADDRNOTAVAIL:address not available',\n  //'7:EAFNOSUPPORT:address family not supported',\n  //'8:EALREADY:connection already in progress',\n  '9:EBADF:bad file descriptor',\n  '10:EBUSY:resource busy or locked',\n  //'11:ECONNABORTED:software caused connection abort',\n  //'12:ECONNREFUSED:connection refused',\n  //'13:ECONNRESET:connection reset by peer',\n  //'14:EDESTADDRREQ:destination address required',\n  //'15:EFAULT:bad address in system call argument',\n  //'16:EHOSTUNREACH:host is unreachable',\n  //'17:EINTR:interrupted system call',\n  '18:EINVAL:invalid argument',\n  //'19:EISCONN:socket is already connected',\n  //'20:EMFILE:too many open files',\n  //'21:EMSGSIZE:message too long',\n  //'22:ENETDOWN:network is down',\n  //'23:ENETUNREACH:network is unreachable',\n  //'24:ENFILE:file table overflow',\n  //'25:ENOBUFS:no buffer space available',\n  //'26:ENOMEM:not enough memory',\n  '27:ENOTDIR:not a directory',\n  '28:EISDIR:illegal operation on a directory',\n  //'29:ENONET:machine is not on the network',\n  // errno 30 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n  //'31:ENOTCONN:socket is not connected',\n  //'32:ENOTSOCK:socket operation on non-socket',\n  //'33:ENOTSUP:operation not supported on socket',\n  '34:ENOENT:no such file or directory',\n  //'35:ENOSYS:function not implemented',\n  //'36:EPIPE:broken pipe',\n  //'37:EPROTO:protocol error',\n  //'38:EPROTONOSUPPORT:protocol not supported',\n  //'39:EPROTOTYPE:protocol wrong type for socket',\n  //'40:ETIMEDOUT:connection timed out',\n  //'41:ECHARSET:invalid Unicode character',\n  //'42:EAIFAMNOSUPPORT:address family for hostname not supported',\n  // errno 43 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n  //'44:EAISERVICE:servname not supported for ai_socktype',\n  //'45:EAISOCKTYPE:ai_socktype not supported',\n  //'46:ESHUTDOWN:cannot send after transport endpoint shutdown',\n  '47:EEXIST:file already exists',\n  //'48:ESRCH:no such process',\n  //'49:ENAMETOOLONG:name too long',\n  //'50:EPERM:operation not permitted',\n  '51:ELOOP:too many symbolic links encountered',\n  //'52:EXDEV:cross-device link not permitted',\n  '53:ENOTEMPTY:directory not empty',\n  //'54:ENOSPC:no space left on device',\n  '55:EIO:i/o error',\n  //'56:EROFS:read-only file system',\n  //'57:ENODEV:no such device',\n  //'58:ESPIPE:invalid seek',\n  //'59:ECANCELED:operation canceled',\n\n  /**\n   * Filer specific errors\n   */\n  '1000:ENOTMOUNTED:not mounted',\n  '1001:EFILESYSTEMERROR:missing super node, use \\'FORMAT\\' flag to format filesystem.',\n  '1002:ENOATTR:attribute does not exist'\n\n].forEach(function(e) {\n  e = e.split(':');\n  var errno = +e[0];\n  var errName = e[1];\n  var defaultMessage = e[2];\n\n  function FilerError(msg, path) {\n    Error.call(this);\n\n    this.name = errName;\n    this.code = errName;\n    this.errno = errno;\n    this.message = msg || defaultMessage;\n    if(path) {\n      this.path = path;\n    }\n    this.stack = (new Error(this.message)).stack;\n  }\n  FilerError.prototype = Object.create(Error.prototype);\n  FilerError.prototype.constructor = FilerError;\n  FilerError.prototype.toString = function() {\n    var pathInfo = this.path ? (', \\'' + this.path + '\\'') : '';\n    return this.name + ': ' + this.message + pathInfo;\n  };\n\n  // We expose the error as both Errors.EINVAL and Errors[18]\n  errors[errName] = errors[errno] = FilerError;\n});\n\nmodule.exports = errors;\n\n},{}],34:[function(require,module,exports){\nvar _ = require('../../lib/nodash.js');\n\nvar Path = require('../path.js');\nvar normalize = Path.normalize;\nvar dirname = Path.dirname;\nvar basename = Path.basename;\nvar isAbsolutePath = Path.isAbsolute;\nvar isNullPath = Path.isNull;\n\nvar Constants = require('../constants.js');\nvar MODE_FILE = Constants.MODE_FILE;\nvar MODE_DIRECTORY = Constants.MODE_DIRECTORY;\nvar MODE_SYMBOLIC_LINK = Constants.MODE_SYMBOLIC_LINK;\nvar MODE_META = Constants.MODE_META;\n\nvar ROOT_DIRECTORY_NAME = Constants.ROOT_DIRECTORY_NAME;\nvar SUPER_NODE_ID = Constants.SUPER_NODE_ID;\nvar SYMLOOP_MAX = Constants.SYMLOOP_MAX;\n\nvar O_READ = Constants.O_READ;\nvar O_WRITE = Constants.O_WRITE;\nvar O_CREATE = Constants.O_CREATE;\nvar O_EXCLUSIVE = Constants.O_EXCLUSIVE;\nvar O_TRUNCATE = Constants.O_TRUNCATE;\nvar O_APPEND = Constants.O_APPEND;\nvar O_FLAGS = Constants.O_FLAGS;\n\nvar XATTR_CREATE = Constants.XATTR_CREATE;\nvar XATTR_REPLACE = Constants.XATTR_REPLACE;\nvar FS_NOMTIME = Constants.FS_NOMTIME;\nvar FS_NOCTIME = Constants.FS_NOCTIME;\n\nvar Encoding = require('../encoding.js');\nvar Errors = require('../errors.js');\nvar DirectoryEntry = require('../directory-entry.js');\nvar OpenFileDescription = require('../open-file-description.js');\nvar SuperNode = require('../super-node.js');\nvar Node = require('../node.js');\nvar Stats = require('../stats.js');\nvar Buffer = require('../buffer.js');\n\n/**\n * Many functions below use this callback pattern. If it's not\n * re-defined, we use this to generate a callback. NOTE: this\n * can be use for callbacks of both forms without problem (i.e.,\n * since result will be undefined if not returned):\n *  - callback(error)\n *  - callback(error, result)\n */\nfunction standard_check_result_cb(callback) {\n  return function(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, result);\n    }\n  };\n}\n\n/**\n * Update node times. Only passed times are modified (undefined times are ignored)\n * and filesystem flags are examined in order to override update logic.\n */\nfunction update_node_times(context, path, node, times, callback) {\n  // Honour mount flags for how we update times\n  var flags = context.flags;\n  if(_(flags).contains(FS_NOCTIME)) {\n    delete times.ctime;\n  }\n  if(_(flags).contains(FS_NOMTIME)) {\n    delete times.mtime;\n  }\n\n  // Only do the update if required (i.e., times are still present)\n  var update = false;\n  if(times.ctime) {\n    node.ctime = times.ctime;\n    // We don't do atime tracking for perf reasons, but do mirror ctime\n    node.atime = times.ctime;\n    update = true;\n  }\n  if(times.atime) {\n    // The only time we explicitly pass atime is when utimes(), futimes() is called.\n    // Override ctime mirror here if so\n    node.atime = times.atime;\n    update = true;\n  }\n  if(times.mtime) {\n    node.mtime = times.mtime;\n    update = true;\n  }\n\n  function complete(error) {\n    // Queue this change so we can send watch events.\n    // Unlike node.js, we send the full path vs. basename/dirname only.\n    context.changes.push({ event: 'change', path: path });\n    callback(error);\n  }\n\n  if(update) {\n    context.putObject(node.id, node, complete);\n  } else {\n    complete();\n  }\n}\n\n/**\n * make_node()\n */\n// in: file or directory path\n// out: new node representing file/directory\nfunction make_node(context, path, mode, callback) {\n  if(mode !== MODE_DIRECTORY && mode !== MODE_FILE) {\n    return callback(new Errors.EINVAL('mode must be a directory or file', path));\n  }\n\n  path = normalize(path);\n\n  var name = basename(path);\n  var parentPath = dirname(path);\n  var parentNode;\n  var parentNodeData;\n  var node;\n\n  // Check if the parent node exists\n  function create_node_in_parent(error, parentDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(parentDirectoryNode.mode !== MODE_DIRECTORY) {\n      callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));\n    } else {\n      parentNode = parentDirectoryNode;\n      find_node(context, path, check_if_node_exists);\n    }\n  }\n\n  // Check if the node to be created already exists\n  function check_if_node_exists(error, result) {\n    if(!error && result) {\n      callback(new Errors.EEXIST('path name already exists', path));\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      context.getObject(parentNode.data, create_node);\n    }\n  }\n\n  // Create the new node\n  function create_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentNodeData = result;\n      Node.create({guid: context.guid, mode: mode}, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        node = result;\n        node.nlinks += 1;\n        context.putObject(node.id, node, update_parent_node_data);\n      });\n    }\n  }\n\n  // Update parent node time\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, node, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  // Update the parent nodes data\n  function update_parent_node_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      parentNodeData[name] = new DirectoryEntry(node.id, mode);\n      context.putObject(parentNode.data, parentNodeData, update_time);\n    }\n  }\n\n  // Find the parent node\n  find_node(context, parentPath, create_node_in_parent);\n}\n\n/**\n * find_node\n */\n// in: file or directory path\n// out: node structure, or error\nfunction find_node(context, path, callback) {\n  path = normalize(path);\n  if(!path) {\n    return callback(new Errors.ENOENT('path is an empty string'));\n  }\n  var name = basename(path);\n  var parentPath = dirname(path);\n  var followedCount = 0;\n\n  function read_root_directory_node(error, superNode) {\n    if(error) {\n      callback(error);\n    } else if(!superNode || superNode.mode !== MODE_META || !superNode.rnode) {\n      callback(new Errors.EFILESYSTEMERROR());\n    } else {\n      context.getObject(superNode.rnode, check_root_directory_node);\n    }\n  }\n\n  function check_root_directory_node(error, rootDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(!rootDirectoryNode) {\n      callback(new Errors.ENOENT());\n    } else {\n      callback(null, rootDirectoryNode);\n    }\n  }\n\n  // in: parent directory node\n  // out: parent directory data\n  function read_parent_directory_data(error, parentDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(parentDirectoryNode.mode !== MODE_DIRECTORY || !parentDirectoryNode.data) {\n      callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));\n    } else {\n      context.getObject(parentDirectoryNode.data, get_node_from_parent_directory_data);\n    }\n  }\n\n  // in: parent directory data\n  // out: searched node\n  function get_node_from_parent_directory_data(error, parentDirectoryData) {\n    if(error) {\n      callback(error);\n    } else {\n      if(!_(parentDirectoryData).has(name)) {\n        callback(new Errors.ENOENT(null, path));\n      } else {\n        var nodeId = parentDirectoryData[name].id;\n        context.getObject(nodeId, is_symbolic_link);\n      }\n    }\n  }\n\n  function is_symbolic_link(error, node) {\n    if(error) {\n      callback(error);\n    } else {\n      if(node.mode == MODE_SYMBOLIC_LINK) {\n        followedCount++;\n        if(followedCount > SYMLOOP_MAX){\n          callback(new Errors.ELOOP(null, path));\n        } else {\n          follow_symbolic_link(node.data);\n        }\n      } else {\n        callback(null, node);\n      }\n    }\n  }\n\n  function follow_symbolic_link(data) {\n    data = normalize(data);\n    parentPath = dirname(data);\n    name = basename(data);\n    if(ROOT_DIRECTORY_NAME == name) {\n      context.getObject(SUPER_NODE_ID, read_root_directory_node);\n    } else {\n      find_node(context, parentPath, read_parent_directory_data);\n    }\n  }\n\n  if(ROOT_DIRECTORY_NAME == name) {\n    context.getObject(SUPER_NODE_ID, read_root_directory_node);\n  } else {\n    find_node(context, parentPath, read_parent_directory_data);\n  }\n}\n\n\n/**\n * set extended attribute (refactor)\n */\nfunction set_extended_attribute (context, path_or_fd, name, value, flag, callback) {\n  var path;\n\n  function set_xattr (error, node) {\n    var xattr = (node ? node.xattrs[name] : null);\n\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    if (error) {\n      callback(error);\n    }\n    else if (flag === XATTR_CREATE && node.xattrs.hasOwnProperty(name)) {\n      callback(new Errors.EEXIST('attribute already exists', path_or_fd));\n    }\n    else if (flag === XATTR_REPLACE && !node.xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR(null, path_or_fd));\n    }\n    else {\n      node.xattrs[name] = value;\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof path_or_fd == 'string') {\n    path = path_or_fd;\n    find_node(context, path_or_fd, set_xattr);\n  }\n  else if (typeof path_or_fd == 'object' && typeof path_or_fd.id == 'string') {\n    path = path_or_fd.path;\n    context.getObject(path_or_fd.id, set_xattr);\n  }\n  else {\n    callback(new Errors.EINVAL('path or file descriptor of wrong type', path_or_fd));\n  }\n}\n\n/**\n * ensure_root_directory. Creates a root node if necessary.\n *\n * Note: this should only be invoked when formatting a new file system.\n * Multiple invocations of this by separate instances will still result\n * in only a single super node.\n */\nfunction ensure_root_directory(context, callback) {\n  var superNode;\n  var directoryNode;\n  var directoryData;\n\n  function ensure_super_node(error, existingNode) {\n    if(!error && existingNode) {\n      // Another instance has beat us and already created the super node.\n      callback();\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      SuperNode.create({guid: context.guid}, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        superNode = result;\n        context.putObject(superNode.id, superNode, write_directory_node);\n      });\n    }\n  }\n\n  function write_directory_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      Node.create({guid: context.guid, id: superNode.rnode, mode: MODE_DIRECTORY}, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        directoryNode = result;\n        directoryNode.nlinks += 1;\n        context.putObject(directoryNode.id, directoryNode, write_directory_data);\n      });\n    }\n  }\n\n  function write_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = {};\n      context.putObject(directoryNode.data, directoryData, callback);\n    }\n  }\n\n  context.getObject(SUPER_NODE_ID, ensure_super_node);\n}\n\n/**\n * make_directory\n */\nfunction make_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var parentDirectoryNode;\n  var parentDirectoryData;\n\n  function check_if_directory_exists(error, result) {\n    if(!error && result) {\n      callback(new Errors.EEXIST(null, path));\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      find_node(context, parentPath, read_parent_directory_data);\n    }\n  }\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryNode = result;\n      context.getObject(parentDirectoryNode.data, write_directory_node);\n    }\n  }\n\n  function write_directory_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryData = result;\n      Node.create({guid: context.guid, mode: MODE_DIRECTORY}, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        directoryNode = result;\n        directoryNode.nlinks += 1;\n        context.putObject(directoryNode.id, directoryNode, write_directory_data);\n      });\n    }\n  }\n\n  function write_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = {};\n      context.putObject(directoryNode.data, directoryData, update_parent_directory_data);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, parentDirectoryNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_parent_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryData[name] = new DirectoryEntry(directoryNode.id, MODE_DIRECTORY);\n      context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);\n    }\n  }\n\n  find_node(context, path, check_if_directory_exists);\n}\n\n/**\n * remove_directory\n */\nfunction remove_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var parentDirectoryNode;\n  var parentDirectoryData;\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryNode = result;\n      context.getObject(parentDirectoryNode.data, check_if_node_exists);\n    }\n  }\n\n  function check_if_node_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else if(ROOT_DIRECTORY_NAME == name) {\n      callback(new Errors.EBUSY(null, path));\n    } else if(!_(result).has(name)) {\n      callback(new Errors.ENOENT(null, path));\n    } else {\n      parentDirectoryData = result;\n      directoryNode = parentDirectoryData[name].id;\n      context.getObject(directoryNode, check_if_node_is_directory);\n    }\n  }\n\n  function check_if_node_is_directory(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.mode != MODE_DIRECTORY) {\n      callback(new Errors.ENOTDIR(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_directory_is_empty);\n    }\n  }\n\n  function check_if_directory_is_empty(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(_(directoryData).size() > 0) {\n        callback(new Errors.ENOTEMPTY(null, path));\n      } else {\n        remove_directory_entry_from_parent_directory_node();\n      }\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, parentDirectoryNode, { mtime: now, ctime: now }, remove_directory_node);\n    }\n  }\n\n  function remove_directory_entry_from_parent_directory_node() {\n    delete parentDirectoryData[name];\n    context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);\n  }\n\n  function remove_directory_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(directoryNode.id, remove_directory_data);\n    }\n  }\n\n  function remove_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(directoryNode.data, callback);\n    }\n  }\n\n  find_node(context, parentPath, read_parent_directory_data);\n}\n\nfunction open_file(context, path, flags, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var directoryEntry;\n  var fileNode;\n  var fileData;\n\n  var followedCount = 0;\n\n  if(ROOT_DIRECTORY_NAME == name) {\n    if(_(flags).contains(O_WRITE)) {\n      callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n    } else {\n      find_node(context, path, set_file_node);\n    }\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.mode !== MODE_DIRECTORY) {\n      callback(new Errors.ENOENT(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(_(directoryData).has(name)) {\n        if(_(flags).contains(O_EXCLUSIVE)) {\n          callback(new Errors.ENOENT('O_CREATE and O_EXCLUSIVE are set, and the named file exists', path));\n        } else {\n          directoryEntry = directoryData[name];\n          if(directoryEntry.type == MODE_DIRECTORY && _(flags).contains(O_WRITE)) {\n            callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n          } else {\n            context.getObject(directoryEntry.id, check_if_symbolic_link);\n          }\n        }\n      } else {\n        if(!_(flags).contains(O_CREATE)) {\n          callback(new Errors.ENOENT('O_CREATE is not set and the named file does not exist', path));\n        } else {\n          write_file_node();\n        }\n      }\n    }\n  }\n\n  function check_if_symbolic_link(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var node = result;\n      if(node.mode == MODE_SYMBOLIC_LINK) {\n        followedCount++;\n        if(followedCount > SYMLOOP_MAX){\n          callback(new Errors.ELOOP(null, path));\n        } else {\n          follow_symbolic_link(node.data);\n        }\n      } else {\n        set_file_node(undefined, node);\n      }\n    }\n  }\n\n  function follow_symbolic_link(data) {\n    data = normalize(data);\n    parentPath = dirname(data);\n    name = basename(data);\n    if(ROOT_DIRECTORY_NAME == name) {\n      if(_(flags).contains(O_WRITE)) {\n        callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n      } else {\n        find_node(context, path, set_file_node);\n      }\n    }\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function set_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      callback(null, fileNode);\n    }\n  }\n\n  function write_file_node() {\n    Node.create({guid: context.guid, mode: MODE_FILE}, function(error, result) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      fileNode = result;\n      fileNode.nlinks += 1;\n      context.putObject(fileNode.id, fileNode, write_file_data);\n    });\n  }\n\n  function write_file_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = new Buffer(0);\n      fileData.fill(0);\n      context.putBuffer(fileNode.data, fileData, update_directory_data);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, handle_update_result);\n    }\n  }\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData[name] = new DirectoryEntry(fileNode.id, MODE_FILE);\n      context.putObject(directoryNode.data, directoryData, update_time);\n    }\n  }\n\n  function handle_update_result(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, fileNode);\n    }\n  }\n}\n\nfunction replace_data(context, ofd, buffer, offset, length, callback) {\n  var fileNode;\n\n  function return_nbytes(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, length);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, return_nbytes);\n    }\n  }\n\n  function update_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function write_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      var newData = new Buffer(length);\n      newData.fill(0);\n      buffer.copy(newData, 0, offset, offset + length);\n      ofd.position = length;\n\n      fileNode.size = length;\n      fileNode.version += 1;\n\n      context.putBuffer(fileNode.data, newData, update_file_node);\n    }\n  }\n\n  context.getObject(ofd.id, write_file_data);\n}\n\nfunction write_data(context, ofd, buffer, offset, length, position, callback) {\n  var fileNode;\n  var fileData;\n\n  function return_nbytes(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, length);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, return_nbytes);\n    }\n  }\n\n  function update_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function update_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = result;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var _position = (!(undefined === position || null === position)) ? position : ofd.position;\n      var newSize = Math.max(fileData.length, _position + length);\n      var newData = new Buffer(newSize);\n      newData.fill(0);\n      if(fileData) {\n        fileData.copy(newData);\n      }\n      buffer.copy(newData, _position, offset, offset + length);\n      if(undefined === position) {\n        ofd.position += length;\n      }\n\n      fileNode.size = newSize;\n      fileNode.version += 1;\n\n      context.putBuffer(fileNode.data, newData, update_file_node);\n    }\n  }\n\n  function read_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      context.getBuffer(fileNode.data, update_file_data);\n    }\n  }\n\n  context.getObject(ofd.id, read_file_data);\n}\n\nfunction read_data(context, ofd, buffer, offset, length, position, callback) {\n  var fileNode;\n  var fileData;\n\n  function handle_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = result;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var _position = (!(undefined === position || null === position)) ? position : ofd.position;\n      length = (_position + length > buffer.length) ? length - _position : length;\n      fileData.copy(buffer, offset, _position, _position + length);\n      if(undefined === position) {\n        ofd.position += length;\n      }\n      callback(null, length);\n    }\n  }\n\n  function read_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      context.getBuffer(fileNode.data, handle_file_data);\n    }\n  }\n\n  context.getObject(ofd.id, read_file_data);\n}\n\nfunction stat_file(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  find_node(context, path, standard_check_result_cb(callback));\n}\n\nfunction fstat_file(context, ofd, callback) {\n  context.getObject(ofd.id, standard_check_result_cb(callback));\n}\n\nfunction lstat_file(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n\n  if(ROOT_DIRECTORY_NAME == name) {\n    find_node(context, path, standard_check_result_cb(callback));\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!_(directoryData).has(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', path));\n      } else {\n        context.getObject(directoryData[name].id, standard_check_result_cb(callback));\n      }\n    }\n  }\n}\n\nfunction link_node(context, oldpath, newpath, callback) {\n  oldpath = normalize(oldpath);\n  var oldname = basename(oldpath);\n  var oldParentPath = dirname(oldpath);\n\n  newpath = normalize(newpath);\n  var newname = basename(newpath);\n  var newParentPath = dirname(newpath);\n\n  var oldDirectoryNode;\n  var oldDirectoryData;\n  var newDirectoryNode;\n  var newDirectoryData;\n  var fileNode;\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      update_node_times(context, newpath,  fileNode, { ctime: Date.now() }, callback);\n    }\n  }\n\n  function update_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      fileNode.nlinks += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function read_directory_entry(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      context.getObject(newDirectoryData[newname].id, update_file_node);\n    }\n  }\n\n  function check_if_new_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newDirectoryData = result;\n      if(_(newDirectoryData).has(newname)) {\n        callback(new Errors.EEXIST('newpath resolves to an existing file', newname));\n      } else {\n        newDirectoryData[newname] = oldDirectoryData[oldname];\n        context.putObject(newDirectoryNode.data, newDirectoryData, read_directory_entry);\n      }\n    }\n  }\n\n  function read_new_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newDirectoryNode = result;\n      context.getObject(newDirectoryNode.data, check_if_new_file_exists);\n    }\n  }\n\n  function check_if_old_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldDirectoryData = result;\n      if(!_(oldDirectoryData).has(oldname)) {\n        callback(new Errors.ENOENT('a component of either path prefix does not exist', oldname));\n      } else {\n        find_node(context, newParentPath, read_new_directory_data);\n      }\n    }\n  }\n\n  function read_old_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldDirectoryNode = result;\n      context.getObject(oldDirectoryNode.data, check_if_old_file_exists);\n    }\n  }\n\n  find_node(context, oldParentPath, read_old_directory_data);\n}\n\nfunction unlink_node(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var fileNode;\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      delete directoryData[name];\n      context.putObject(directoryNode.data, directoryData, function(error) {\n        var now = Date.now();\n        update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, callback);\n      });\n    }\n  }\n\n  function delete_file_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(fileNode.data, update_directory_data);\n    }\n  }\n\n  function update_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      fileNode.nlinks -= 1;\n      if(fileNode.nlinks < 1) {\n        context.delete(fileNode.id, delete_file_data);\n      } else {\n        context.putObject(fileNode.id, fileNode, function(error) {\n          update_node_times(context, path, fileNode, { ctime: Date.now() }, update_directory_data);\n        });\n      }\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!_(directoryData).has(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', name));\n      } else {\n        context.getObject(directoryData[name].id, update_file_node);\n      }\n    }\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  find_node(context, parentPath, read_directory_data);\n}\n\nfunction read_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n\n  var directoryNode;\n  var directoryData;\n\n  function handle_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      var files = Object.keys(directoryData);\n      callback(null, files);\n    }\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.mode !== MODE_DIRECTORY) {\n      callback(new Errors.ENOTDIR(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, handle_directory_data);\n    }\n  }\n\n  find_node(context, path, read_directory_data);\n}\n\nfunction make_symbolic_link(context, srcpath, dstpath, callback) {\n  dstpath = normalize(dstpath);\n  var name = basename(dstpath);\n  var parentPath = dirname(dstpath);\n\n  var directoryNode;\n  var directoryData;\n  var fileNode;\n\n  if(ROOT_DIRECTORY_NAME == name) {\n    callback(new Errors.EEXIST(null, name));\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(_(directoryData).has(name)) {\n        callback(new Errors.EEXIST(null, name));\n      } else {\n        write_file_node();\n      }\n    }\n  }\n\n  function write_file_node() {\n    Node.create({guid: context.guid, mode: MODE_SYMBOLIC_LINK}, function(error, result) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      fileNode = result;\n      fileNode.nlinks += 1;\n      fileNode.size = srcpath.length;\n      fileNode.data = srcpath;\n      context.putObject(fileNode.id, fileNode, update_directory_data);\n    });\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData[name] = new DirectoryEntry(fileNode.id, MODE_SYMBOLIC_LINK);\n      context.putObject(directoryNode.data, directoryData, update_time);\n    }\n  }\n}\n\nfunction read_link(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n\n  find_node(context, parentPath, read_directory_data);\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!_(directoryData).has(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', name));\n      } else {\n        context.getObject(directoryData[name].id, check_if_symbolic);\n      }\n    }\n  }\n\n  function check_if_symbolic(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      if(result.mode != MODE_SYMBOLIC_LINK) {\n        callback(new Errors.EINVAL('path not a symbolic link', path));\n      } else {\n        callback(null, result.data);\n      }\n    }\n  }\n}\n\nfunction truncate_file(context, path, length, callback) {\n  path = normalize(path);\n\n  var fileNode;\n\n  function read_file_data (error, node) {\n    if (error) {\n      callback(error);\n    } else if(node.mode == MODE_DIRECTORY ) {\n      callback(new Errors.EISDIR(null, path));\n    } else{\n      fileNode = node;\n      context.getBuffer(fileNode.data, truncate_file_data);\n    }\n  }\n\n  function truncate_file_data(error, fileData) {\n    if (error) {\n      callback(error);\n    } else {\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var data = new Buffer(length);\n      data.fill(0);\n      if(fileData) {\n        fileData.copy(data);\n      }\n      context.putBuffer(fileNode.data, data, update_file_node);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, path, fileNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_file_node (error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode.size = length;\n      fileNode.version += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  if(length < 0) {\n    callback(new Errors.EINVAL('length cannot be negative'));\n  } else {\n    find_node(context, path, read_file_data);\n  }\n}\n\nfunction ftruncate_file(context, ofd, length, callback) {\n  var fileNode;\n\n  function read_file_data (error, node) {\n    if (error) {\n      callback(error);\n    } else if(node.mode == MODE_DIRECTORY ) {\n      callback(new Errors.EISDIR());\n    } else{\n      fileNode = node;\n      context.getBuffer(fileNode.data, truncate_file_data);\n    }\n  }\n\n  function truncate_file_data(error, fileData) {\n    if (error) {\n      callback(error);\n    } else {\n      var data;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      if(fileData) {\n        data = fileData.slice(0, length);\n      } else {\n        data = new Buffer(length);\n        data.fill(0);\n      }\n      context.putBuffer(fileNode.data, data, update_file_node);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_file_node (error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode.size = length;\n      fileNode.version += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  if(length < 0) {\n    callback(new Errors.EINVAL('length cannot be negative'));\n  } else {\n    context.getObject(ofd.id, read_file_data);\n  }\n}\n\nfunction utimes_file(context, path, atime, mtime, callback) {\n  path = normalize(path);\n\n  function update_times(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      update_node_times(context, path, node, { atime: atime, ctime: mtime, mtime: mtime }, callback);\n    }\n  }\n\n  if (typeof atime != 'number' || typeof mtime != 'number') {\n    callback(new Errors.EINVAL('atime and mtime must be number', path));\n  }\n  else if (atime < 0 || mtime < 0) {\n    callback(new Errors.EINVAL('atime and mtime must be positive integers', path));\n  }\n  else {\n    find_node(context, path, update_times);\n  }\n}\n\nfunction futimes_file(context, ofd, atime, mtime, callback) {\n\n  function update_times (error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      update_node_times(context, ofd.path, node, { atime: atime, ctime: mtime, mtime: mtime }, callback);\n    }\n  }\n\n  if (typeof atime != 'number' || typeof mtime != 'number') {\n    callback(new Errors.EINVAL('atime and mtime must be a number'));\n  }\n  else if (atime < 0 || mtime < 0) {\n    callback(new Errors.EINVAL('atime and mtime must be positive integers'));\n  }\n  else {\n    context.getObject(ofd.id, update_times);\n  }\n}\n\nfunction setxattr_file(context, path, name, value, flag, callback) {\n  path = normalize(path);\n\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else if (flag !== null &&\n           flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {\n    callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE', path));\n  }\n  else {\n    set_extended_attribute(context, path, name, value, flag, callback);\n  }\n}\n\nfunction fsetxattr_file (context, ofd, name, value, flag, callback) {\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string'));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else if (flag !== null &&\n           flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {\n    callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE'));\n  }\n  else {\n    set_extended_attribute(context, ofd, name, value, flag, callback);\n  }\n}\n\nfunction getxattr_file (context, path, name, callback) {\n  path = normalize(path);\n\n  function get_xattr(error, node) {\n    var xattr = (node ? node.xattrs[name] : null);\n\n    if (error) {\n      callback (error);\n    }\n    else if (!node.xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR(null, path));\n    }\n    else {\n      callback(null, node.xattrs[name]);\n    }\n  }\n\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else {\n    find_node(context, path, get_xattr);\n  }\n}\n\nfunction fgetxattr_file (context, ofd, name, callback) {\n\n  function get_xattr (error, node) {\n    var xattr = (node ? node.xattrs[name] : null);\n\n    if (error) {\n      callback(error);\n    }\n    else if (!node.xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR());\n    }\n    else {\n      callback(null, node.xattrs[name]);\n    }\n  }\n\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL());\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else {\n    context.getObject(ofd.id, get_xattr);\n  }\n}\n\nfunction removexattr_file (context, path, name, callback) {\n  path = normalize(path);\n\n  function remove_xattr (error, node) {\n    var xattr = (node ? node.xattrs : null);\n\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    if (error) {\n      callback(error);\n    }\n    else if (!xattr.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR(null, path));\n    }\n    else {\n      delete node.xattrs[name];\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else {\n    find_node(context, path, remove_xattr);\n  }\n}\n\nfunction fremovexattr_file (context, ofd, name, callback) {\n\n  function remove_xattr (error, node) {\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, ofd.path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    if (error) {\n      callback(error);\n    }\n    else if (!node.xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR());\n    }\n    else {\n      delete node.xattrs[name];\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string'));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else {\n    context.getObject(ofd.id, remove_xattr);\n  }\n}\n\nfunction validate_flags(flags) {\n  if(!_(O_FLAGS).has(flags)) {\n    return null;\n  }\n  return O_FLAGS[flags];\n}\n\nfunction validate_file_options(options, enc, fileMode){\n  if(!options) {\n    options = { encoding: enc, flag: fileMode };\n  } else if(typeof options === \"function\") {\n    options = { encoding: enc, flag: fileMode };\n  } else if(typeof options === \"string\") {\n    options = { encoding: options, flag: fileMode };\n  }\n  return options;\n}\n\nfunction pathCheck(path, callback) {\n  var err;\n\n  if(!path) {\n    err = new Errors.EINVAL('Path must be a string', path);\n  } else if(isNullPath(path)) {\n    err = new Errors.EINVAL('Path must be a string without null bytes.', path);\n  } else if(!isAbsolutePath(path)) {\n    err = new Errors.EINVAL('Path must be absolute.', path);\n  }\n\n  if(err) {\n    callback(err);\n    return false;\n  }\n  return true;\n}\n\n\nfunction open(fs, context, path, flags, mode, callback) {\n  // NOTE: we support the same signature as node with a `mode` arg,\n  // but ignore it.\n  callback = arguments[arguments.length - 1];\n  if(!pathCheck(path, callback)) return;\n\n  function check_result(error, fileNode) {\n    if(error) {\n      callback(error);\n    } else {\n      var position;\n      if(_(flags).contains(O_APPEND)) {\n        position = fileNode.size;\n      } else {\n        position = 0;\n      }\n      var openFileDescription = new OpenFileDescription(path, fileNode.id, flags, position);\n      var fd = fs.allocDescriptor(openFileDescription);\n      callback(null, fd);\n    }\n  }\n\n  flags = validate_flags(flags);\n  if(!flags) {\n    callback(new Errors.EINVAL('flags is not valid'), path);\n  }\n\n  open_file(context, path, flags, check_result);\n}\n\nfunction close(fs, context, fd, callback) {\n  if(!_(fs.openFiles).has(fd)) {\n    callback(new Errors.EBADF());\n  } else {\n    fs.releaseDescriptor(fd);\n    callback(null);\n  }\n}\n\nfunction mknod(fs, context, path, mode, callback) {\n  if(!pathCheck(path, callback)) return;\n  make_node(context, path, mode, callback);\n}\n\nfunction mkdir(fs, context, path, mode, callback) {\n  // NOTE: we support passing a mode arg, but we ignore it internally for now.\n  callback = arguments[arguments.length - 1];\n  if(!pathCheck(path, callback)) return;\n  make_directory(context, path, standard_check_result_cb(callback));\n}\n\nfunction rmdir(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  remove_directory(context, path, standard_check_result_cb(callback));\n}\n\nfunction stat(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(result, fs.name);\n      callback(null, stats);\n    }\n  }\n\n  stat_file(context, path, check_result);\n}\n\nfunction fstat(fs, context, fd, callback) {\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(result, fs.name);\n      callback(null, stats);\n    }\n  }\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else {\n    fstat_file(context, ofd, check_result);\n  }\n}\n\nfunction link(fs, context, oldpath, newpath, callback) {\n  if(!pathCheck(oldpath, callback)) return;\n  if(!pathCheck(newpath, callback)) return;\n  link_node(context, oldpath, newpath, standard_check_result_cb(callback));\n}\n\nfunction unlink(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  unlink_node(context, path, standard_check_result_cb(callback));\n}\n\nfunction read(fs, context, fd, buffer, offset, length, position, callback) {\n  // Follow how node.js does this\n  function wrapped_cb(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, bytesRead || 0, buffer);\n  }\n\n  offset = (undefined === offset) ? 0 : offset;\n  length = (undefined === length) ? buffer.length - offset : length;\n  callback = arguments[arguments.length - 1];\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!_(ofd.flags).contains(O_READ)) {\n    callback(new Errors.EBADF('descriptor does not permit reading'));\n  } else {\n    read_data(context, ofd, buffer, offset, length, position, standard_check_result_cb(wrapped_cb));\n  }\n}\n\nfunction readFile(fs, context, path, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, null, 'r');\n\n  if(!pathCheck(path, callback)) return;\n\n  var flags = validate_flags(options.flag || 'r');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);\n    var fd = fs.allocDescriptor(ofd);\n\n    function cleanup() {\n      fs.releaseDescriptor(fd);\n    }\n\n    fstat_file(context, ofd, function(err, fstatResult) {\n      if(err) {\n        cleanup();\n        return callback(err);\n      }\n\n      var stats = new Stats(fstatResult, fs.name);\n\n      if(stats.isDirectory()) {\n        cleanup();\n        return callback(new Errors.EISDIR('illegal operation on directory', path));\n      }\n\n      var size = stats.size;\n      var buffer = new Buffer(size);\n      buffer.fill(0);\n\n      read_data(context, ofd, buffer, 0, size, 0, function(err, nbytes) {\n        cleanup();\n\n        if(err) {\n          return callback(err);\n        }\n\n        var data;\n        if(options.encoding === 'utf8') {\n          data = Encoding.decode(buffer);\n        } else {\n          data = buffer;\n        }\n        callback(null, data);\n      });\n    });\n  });\n}\n\nfunction write(fs, context, fd, buffer, offset, length, position, callback) {\n  callback = arguments[arguments.length - 1];\n  offset = (undefined === offset) ? 0 : offset;\n  length = (undefined === length) ? buffer.length - offset : length;\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!_(ofd.flags).contains(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else if(buffer.length - offset < length) {\n    callback(new Errors.EIO('intput buffer is too small'));\n  } else {\n    write_data(context, ofd, buffer, offset, length, position, standard_check_result_cb(callback));\n  }\n}\n\nfunction writeFile(fs, context, path, data, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, 'utf8', 'w');\n\n  if(!pathCheck(path, callback)) return;\n\n  var flags = validate_flags(options.flag || 'w');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  data = data || '';\n  if(typeof data === \"number\") {\n    data = '' + data;\n  }\n  if(typeof data === \"string\" && options.encoding === 'utf8') {\n    data = Encoding.encode(data);\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);\n    var fd = fs.allocDescriptor(ofd);\n\n    replace_data(context, ofd, data, 0, data.length, function(err, nbytes) {\n      fs.releaseDescriptor(fd);\n\n      if(err) {\n        return callback(err);\n      }\n      callback(null);\n    });\n  });\n}\n\nfunction appendFile(fs, context, path, data, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, 'utf8', 'a');\n\n  if(!pathCheck(path, callback)) return;\n\n  var flags = validate_flags(options.flag || 'a');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  data = data || '';\n  if(typeof data === \"number\") {\n    data = '' + data;\n  }\n  if(typeof data === \"string\" && options.encoding === 'utf8') {\n    data = Encoding.encode(data);\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, fileNode.size);\n    var fd = fs.allocDescriptor(ofd);\n\n    write_data(context, ofd, data, 0, data.length, ofd.position, function(err, nbytes) {\n      fs.releaseDescriptor(fd);\n\n      if(err) {\n        return callback(err);\n      }\n      callback(null);\n    });\n  });\n}\n\nfunction exists(fs, context, path, callback) {\n  function cb(err, stats) {\n    callback(err ? false : true);\n  }\n  stat(fs, context, path, cb);\n}\n\nfunction getxattr(fs, context, path, name, callback) {\n  if (!pathCheck(path, callback)) return;\n  getxattr_file(context, path, name, standard_check_result_cb(callback));\n}\n\nfunction fgetxattr(fs, context, fd, name, callback) {\n  var ofd = fs.openFiles[fd];\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else {\n    fgetxattr_file(context, ofd, name, standard_check_result_cb(callback));\n  }\n}\n\nfunction setxattr(fs, context, path, name, value, flag, callback) {\n  if(typeof flag === 'function') {\n    callback = flag;\n    flag = null;\n  }\n\n  if (!pathCheck(path, callback)) return;\n  setxattr_file(context, path, name, value, flag, standard_check_result_cb(callback));\n}\n\nfunction fsetxattr(fs, context, fd, name, value, flag, callback) {\n  if(typeof flag === 'function') {\n    callback = flag;\n    flag = null;\n  }\n\n  var ofd = fs.openFiles[fd];\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else if (!_(ofd.flags).contains(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  }\n  else {\n    fsetxattr_file(context, ofd, name, value, flag, standard_check_result_cb(callback));\n  }\n}\n\nfunction removexattr(fs, context, path, name, callback) {\n  if (!pathCheck(path, callback)) return;\n  removexattr_file(context, path, name, standard_check_result_cb(callback));\n}\n\nfunction fremovexattr(fs, context, fd, name, callback) {\n  var ofd = fs.openFiles[fd];\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else if (!_(ofd.flags).contains(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  }\n  else {\n    fremovexattr_file(context, ofd, name, standard_check_result_cb(callback));\n  }\n}\n\nfunction lseek(fs, context, fd, offset, whence, callback) {\n  function update_descriptor_position(error, stats) {\n    if(error) {\n      callback(error);\n    } else {\n      if(stats.size + offset < 0) {\n        callback(new Errors.EINVAL('resulting file offset would be negative'));\n      } else {\n        ofd.position = stats.size + offset;\n        callback(null, ofd.position);\n      }\n    }\n  }\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  }\n\n  if('SET' === whence) {\n    if(offset < 0) {\n      callback(new Errors.EINVAL('resulting file offset would be negative'));\n    } else {\n      ofd.position = offset;\n      callback(null, ofd.position);\n    }\n  } else if('CUR' === whence) {\n    if(ofd.position + offset < 0) {\n      callback(new Errors.EINVAL('resulting file offset would be negative'));\n    } else {\n      ofd.position += offset;\n      callback(null, ofd.position);\n    }\n  } else if('END' === whence) {\n    fstat_file(context, ofd, update_descriptor_position);\n  } else {\n    callback(new Errors.EINVAL('whence argument is not a proper value'));\n  }\n}\n\nfunction readdir(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  read_directory(context, path, standard_check_result_cb(callback));\n}\n\nfunction utimes(fs, context, path, atime, mtime, callback) {\n  if(!pathCheck(path, callback)) return;\n\n  var currentTime = Date.now();\n  atime = (atime) ? atime : currentTime;\n  mtime = (mtime) ? mtime : currentTime;\n\n  utimes_file(context, path, atime, mtime, standard_check_result_cb(callback));\n}\n\nfunction futimes(fs, context, fd, atime, mtime, callback) {\n  var currentTime = Date.now();\n  atime = (atime) ? atime : currentTime;\n  mtime = (mtime) ? mtime : currentTime;\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!_(ofd.flags).contains(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    futimes_file(context, ofd, atime, mtime, standard_check_result_cb(callback));\n  }\n}\n\nfunction rename(fs, context, oldpath, newpath, callback) {\n  if(!pathCheck(oldpath, callback)) return;\n  if(!pathCheck(newpath, callback)) return;\n\n  function unlink_old_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      unlink_node(context, oldpath, standard_check_result_cb(callback));\n    }\n  }\n\n  link_node(context, oldpath, newpath, unlink_old_node);\n}\n\nfunction symlink(fs, context, srcpath, dstpath, type, callback) {\n  // NOTE: we support passing the `type` arg, but ignore it.\n  callback = arguments[arguments.length - 1];\n  if(!pathCheck(srcpath, callback)) return;\n  if(!pathCheck(dstpath, callback)) return;\n  make_symbolic_link(context, srcpath, dstpath, standard_check_result_cb(callback));\n}\n\nfunction readlink(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  read_link(context, path, standard_check_result_cb(callback));\n}\n\nfunction lstat(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(result, fs.name);\n      callback(null, stats);\n    }\n  }\n\n  lstat_file(context, path, check_result);\n}\n\nfunction truncate(fs, context, path, length, callback) {\n  // NOTE: length is optional\n  callback = arguments[arguments.length - 1];\n  length = length || 0;\n\n  if(!pathCheck(path, callback)) return;\n  truncate_file(context, path, length, standard_check_result_cb(callback));\n}\n\nfunction ftruncate(fs, context, fd, length, callback) {\n  // NOTE: length is optional\n  callback = arguments[arguments.length - 1];\n  length = length || 0;\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!_(ofd.flags).contains(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    ftruncate_file(context, ofd, length, standard_check_result_cb(callback));\n  }\n}\n\nmodule.exports = {\n  ensureRootDirectory: ensure_root_directory,\n  open: open,\n  close: close,\n  mknod: mknod,\n  mkdir: mkdir,\n  rmdir: rmdir,\n  unlink: unlink,\n  stat: stat,\n  fstat: fstat,\n  link: link,\n  read: read,\n  readFile: readFile,\n  write: write,\n  writeFile: writeFile,\n  appendFile: appendFile,\n  exists: exists,\n  getxattr: getxattr,\n  fgetxattr: fgetxattr,\n  setxattr: setxattr,\n  fsetxattr: fsetxattr,\n  removexattr: removexattr,\n  fremovexattr: fremovexattr,\n  lseek: lseek,\n  readdir: readdir,\n  utimes: utimes,\n  futimes: futimes,\n  rename: rename,\n  symlink: symlink,\n  readlink: readlink,\n  lstat: lstat,\n  truncate: truncate,\n  ftruncate: ftruncate\n};\n\n},{\"../../lib/nodash.js\":27,\"../buffer.js\":29,\"../constants.js\":30,\"../directory-entry.js\":31,\"../encoding.js\":32,\"../errors.js\":33,\"../node.js\":38,\"../open-file-description.js\":39,\"../path.js\":40,\"../stats.js\":48,\"../super-node.js\":49}],35:[function(require,module,exports){\nvar _ = require('../../lib/nodash.js');\n\nvar isNullPath = require('../path.js').isNull;\nvar nop = require('../shared.js').nop;\n\nvar Constants = require('../constants.js');\nvar FILE_SYSTEM_NAME = Constants.FILE_SYSTEM_NAME;\nvar FS_FORMAT = Constants.FS_FORMAT;\nvar FS_READY = Constants.FS_READY;\nvar FS_PENDING = Constants.FS_PENDING;\nvar FS_ERROR = Constants.FS_ERROR;\nvar FS_NODUPEIDCHECK = Constants.FS_NODUPEIDCHECK;\n\nvar providers = require('../providers/index.js');\n\nvar Shell = require('../shell/shell.js');\nvar Intercom = require('../../lib/intercom.js');\nvar FSWatcher = require('../fs-watcher.js');\nvar Errors = require('../errors.js');\nvar defaultGuidFn = require('../shared.js').guid;\n\nvar STDIN = Constants.STDIN;\nvar STDOUT = Constants.STDOUT;\nvar STDERR = Constants.STDERR;\nvar FIRST_DESCRIPTOR = Constants.FIRST_DESCRIPTOR;\n\n// The core fs operations live on impl\nvar impl = require('./implementation.js');\n\n// node.js supports a calling pattern that leaves off a callback.\nfunction maybeCallback(callback) {\n  if(typeof callback === \"function\") {\n    return callback;\n  }\n  return function(err) {\n    if(err) {\n      throw err;\n    }\n  };\n}\n\n/**\n * FileSystem\n *\n * A FileSystem takes an `options` object, which can specify a number of,\n * options.  All options are optional, and include:\n *\n * name: the name of the file system, defaults to \"local\"\n *\n * flags: one or more flags to use when creating/opening the file system.\n *        For example: \"FORMAT\" will cause the file system to be formatted.\n *        No explicit flags are set by default.\n *\n * provider: an explicit storage provider to use for the file\n *           system's database context provider.  A number of context\n *           providers are included (see /src/providers), and users\n *           can write one of their own and pass it in to be used.\n *           By default an IndexedDB provider is used.\n *\n * guid: a function for generating unique IDs for nodes in the filesystem.\n *       Use this to override the built-in UUID generation. (Used mainly for tests).\n *\n * callback: a callback function to be executed when the file system becomes\n *           ready for use. Depending on the context provider used, this might\n *           be right away, or could take some time. The callback should expect\n *           an `error` argument, which will be null if everything worked.  Also\n *           users should check the file system's `readyState` and `error`\n *           properties to make sure it is usable.\n */\nfunction FileSystem(options, callback) {\n  options = options || {};\n  callback = callback || nop;\n\n  var flags = options.flags;\n  var guid = options.guid ? options.guid : defaultGuidFn;\n  var provider = options.provider || new providers.Default(options.name || FILE_SYSTEM_NAME);\n  // If we're given a provider, match its name unless we get an explicit name\n  var name = options.name || provider.name;\n  var forceFormatting = _(flags).contains(FS_FORMAT);\n\n  var fs = this;\n  fs.readyState = FS_PENDING;\n  fs.name = name;\n  fs.error = null;\n\n  fs.stdin = STDIN;\n  fs.stdout = STDOUT;\n  fs.stderr = STDERR;\n\n  // Safely expose the list of open files and file\n  // descriptor management functions\n  var openFiles = {};\n  var nextDescriptor = FIRST_DESCRIPTOR;\n  Object.defineProperty(this, \"openFiles\", {\n    get: function() { return openFiles; }\n  });\n  this.allocDescriptor = function(openFileDescription) {\n    var fd = nextDescriptor ++;\n    openFiles[fd] = openFileDescription;\n    return fd;\n  };\n  this.releaseDescriptor = function(fd) {\n    delete openFiles[fd];\n  };\n\n  // Safely expose the operation queue\n  var queue = [];\n  this.queueOrRun = function(operation) {\n    var error;\n\n    if(FS_READY == fs.readyState) {\n      operation.call(fs);\n    } else if(FS_ERROR == fs.readyState) {\n      error = new Errors.EFILESYSTEMERROR('unknown error');\n    } else {\n      queue.push(operation);\n    }\n\n    return error;\n  };\n  function runQueued() {\n    queue.forEach(function(operation) {\n      operation.call(this);\n    }.bind(fs));\n    queue = null;\n  }\n\n  // We support the optional `options` arg from node, but ignore it\n  this.watch = function(filename, options, listener) {\n    if(isNullPath(filename)) {\n      throw new Error('Path must be a string without null bytes.');\n    }\n    if(typeof options === 'function') {\n      listener = options;\n      options = {};\n    }\n    options = options || {};\n    listener = listener || nop;\n\n    var watcher = new FSWatcher();\n    watcher.start(filename, false, options.recursive);\n    watcher.on('change', listener);\n\n    return watcher;\n  };\n\n  // Deal with various approaches to node ID creation\n  function wrappedGuidFn(context) {\n    return function(callback) {\n      // Skip the duplicate ID check if asked to\n      if(_(flags).contains(FS_NODUPEIDCHECK)) {\n        callback(null, guid());\n        return;\n      }\n\n      // Otherwise (default) make sure this id is unused first\n      function guidWithCheck(callback) {\n        var id = guid();\n        context.getObject(id, function(err, value) {\n          if(err) {\n            callback(err);\n            return;\n          }\n\n          // If this id is unused, use it, otherwise find another\n          if(!value) {\n            callback(null, id);\n          } else {\n            guidWithCheck(callback);\n          }\n        });\n      }\n      guidWithCheck(callback);\n    };\n  }\n\n  // Let other instances (in this or other windows) know about\n  // any changes to this fs instance.\n  function broadcastChanges(changes) {\n    if(!changes.length) {\n      return;\n    }\n    var intercom = Intercom.getInstance();\n    changes.forEach(function(change) {\n      intercom.emit(change.event, change.path);\n    });\n  }\n\n  // Open file system storage provider\n  provider.open(function(err) {\n    function complete(error) {\n      function wrappedContext(methodName) {\n        var context = provider[methodName]();\n        context.flags = flags;\n        context.changes = [];\n        context.guid = wrappedGuidFn(context);\n\n        // When the context is finished, let the fs deal with any change events\n        context.close = function() {\n          var changes = context.changes;\n          broadcastChanges(changes);\n          changes.length = 0;\n        };\n\n        return context;\n      }\n\n      // Wrap the provider so we can extend the context with fs flags and\n      // an array of changes (e.g., watch event 'change' and 'rename' events\n      // for paths updated during the lifetime of the context). From this\n      // point forward we won't call open again, so it's safe to drop it.\n      fs.provider = {\n        openReadWriteContext: function() {\n          return wrappedContext('getReadWriteContext');\n        },\n        openReadOnlyContext: function() {\n          return wrappedContext('getReadOnlyContext');\n        }\n      };\n\n      if(error) {\n        fs.readyState = FS_ERROR;\n      } else {\n        fs.readyState = FS_READY;\n      }\n      runQueued();\n      callback(error, fs);\n    }\n\n    if(err) {\n      return complete(err);\n    }\n\n    var context = provider.getReadWriteContext();\n    context.guid = wrappedGuidFn(context);\n\n    // Mount the filesystem, formatting if necessary\n    if(forceFormatting) {\n      // Wipe the storage provider, then write root block\n      context.clear(function(err) {\n        if(err) {\n          return complete(err);\n        }\n        impl.ensureRootDirectory(context, complete);\n      });\n    } else {\n      // Use existing (or create new) root and mount\n      impl.ensureRootDirectory(context, complete);\n    }\n  });\n}\n\n// Expose storage providers on FileSystem constructor\nFileSystem.providers = providers;\n\n/**\n * Public API for FileSystem\n */\n[\n  'open',\n  'close',\n  'mknod',\n  'mkdir',\n  'rmdir',\n  'stat',\n  'fstat',\n  'link',\n  'unlink',\n  'read',\n  'readFile',\n  'write',\n  'writeFile',\n  'appendFile',\n  'exists',\n  'lseek',\n  'readdir',\n  'rename',\n  'readlink',\n  'symlink',\n  'lstat',\n  'truncate',\n  'ftruncate',\n  'utimes',\n  'futimes',\n  'setxattr',\n  'getxattr',\n  'fsetxattr',\n  'fgetxattr',\n  'removexattr',\n  'fremovexattr'\n].forEach(function(methodName) {\n  FileSystem.prototype[methodName] = function() {\n    var fs = this;\n    var args = Array.prototype.slice.call(arguments, 0);\n    var lastArgIndex = args.length - 1;\n\n    // We may or may not get a callback, and since node.js supports\n    // fire-and-forget style fs operations, we have to dance a bit here.\n    var missingCallback = typeof args[lastArgIndex] !== 'function';\n    var callback = maybeCallback(args[lastArgIndex]);\n\n    var error = fs.queueOrRun(function() {\n      var context = fs.provider.openReadWriteContext();\n\n      // Fail early if the filesystem is in an error state (e.g.,\n      // provider failed to open.\n      if(FS_ERROR === fs.readyState) {\n        var err = new Errors.EFILESYSTEMERROR('filesystem unavailable, operation canceled');\n        return callback.call(fs, err);\n      }\n\n      // Wrap the callback so we can explicitly close the context\n      function complete() {\n        context.close();\n        callback.apply(fs, arguments);\n      }\n\n      // Either add or replace the callback with our wrapper complete()\n      if(missingCallback) {\n        args.push(complete);\n      } else {\n        args[lastArgIndex] = complete;\n      }\n\n      // Forward this call to the impl's version, using the following\n      // call signature, with complete() as the callback/last-arg now:\n      // fn(fs, context, arg0, arg1, ... , complete);\n      var fnArgs = [fs, context].concat(args);\n      impl[methodName].apply(null, fnArgs);\n    });\n    if(error) {\n      callback(error);\n    }\n  };\n});\n\nFileSystem.prototype.Shell = function(options) {\n  return new Shell(this, options);\n};\n\nmodule.exports = FileSystem;\n\n},{\"../../lib/intercom.js\":26,\"../../lib/nodash.js\":27,\"../constants.js\":30,\"../errors.js\":33,\"../fs-watcher.js\":36,\"../path.js\":40,\"../providers/index.js\":41,\"../shared.js\":45,\"../shell/shell.js\":47,\"./implementation.js\":34}],36:[function(require,module,exports){\nvar EventEmitter = require('../lib/eventemitter.js');\nvar Path = require('./path.js');\nvar Intercom = require('../lib/intercom.js');\n\n/**\n * FSWatcher based on node.js' FSWatcher\n * see https://github.com/joyent/node/blob/master/lib/fs.js\n */\nfunction FSWatcher() {\n  EventEmitter.call(this);\n  var self = this;\n  var recursive = false;\n  var recursivePathPrefix;\n  var filename;\n\n  function onchange(path) {\n    // Watch for exact filename, or parent path when recursive is true.\n    if(filename === path || (recursive && path.indexOf(recursivePathPrefix) === 0)) {\n      self.trigger('change', 'change', path);\n    }\n  }\n\n  // We support, but ignore the second arg, which node.js uses.\n  self.start = function(filename_, persistent_, recursive_) {\n    // Bail if we've already started (and therefore have a filename);\n    if(filename) {\n      return;\n    }\n\n    if(Path.isNull(filename_)) {\n      throw new Error('Path must be a string without null bytes.');\n    }\n\n    // TODO: get realpath for symlinks on filename...\n\n    // Filer's Path.normalize strips trailing slashes, which we use here.\n    // See https://github.com/js-platform/filer/issues/105\n    filename = Path.normalize(filename_);\n\n    // Whether to watch beneath this path or not\n    recursive = recursive_ === true;\n    // If recursive, construct a path prefix portion for comparisons later\n    // (i.e., '/path' becomes '/path/' so we can search within a filename for the\n    // prefix). We also take care to allow for '/' on its own.\n    if(recursive) {\n      recursivePathPrefix = filename === '/' ? '/' : filename + '/';\n    }\n\n    var intercom = Intercom.getInstance();\n    intercom.on('change', onchange);\n  };\n\n  self.close = function() {\n    var intercom = Intercom.getInstance();\n    intercom.off('change', onchange);\n    self.removeAllListeners('change');\n  };\n}\nFSWatcher.prototype = new EventEmitter();\nFSWatcher.prototype.constructor = FSWatcher;\n\nmodule.exports = FSWatcher;\n\n},{\"../lib/eventemitter.js\":25,\"../lib/intercom.js\":26,\"./path.js\":40}],37:[function(require,module,exports){\nmodule.exports = {\n  FileSystem: require('./filesystem/interface.js'),\n  Buffer: require('./buffer.js'),\n  Path: require('./path.js'),\n  Errors: require('./errors.js')\n};\n\n},{\"./buffer.js\":29,\"./errors.js\":33,\"./filesystem/interface.js\":35,\"./path.js\":40}],38:[function(require,module,exports){\nvar MODE_FILE = require('./constants.js').MODE_FILE;\n\nfunction Node(options) {\n  var now = Date.now();\n\n  this.id = options.id;\n  this.mode = options.mode || MODE_FILE;  // node type (file, directory, etc)\n  this.size = options.size || 0; // size (bytes for files, entries for directories)\n  this.atime = options.atime || now; // access time (will mirror ctime after creation)\n  this.ctime = options.ctime || now; // creation/change time\n  this.mtime = options.mtime || now; // modified time\n  this.flags = options.flags || []; // file flags\n  this.xattrs = options.xattrs || {}; // extended attributes\n  this.nlinks = options.nlinks || 0; // links count\n  this.version = options.version || 0; // node version\n  this.blksize = undefined; // block size\n  this.nblocks = 1; // blocks count\n  this.data = options.data; // id for data object\n}\n\n// Make sure the options object has an id on property,\n// either from caller or one we generate using supplied guid fn.\nfunction ensureID(options, prop, callback) {\n  if(options[prop]) {\n    callback(null);\n  } else {\n    options.guid(function(err, id) {\n      options[prop] = id;\n      callback(err);\n    });\n  }\n}\n\nNode.create = function(options, callback) {\n  // We expect both options.id and options.data to be provided/generated.\n  ensureID(options, 'id', function(err) {\n    if(err) {\n      callback(err);\n      return;\n    }\n\n    ensureID(options, 'data', function(err) {\n      if(err) {\n        callback(err);\n        return;\n      }\n\n      callback(null, new Node(options));\n    });\n  });\n};\n\nmodule.exports = Node;\n\n},{\"./constants.js\":30}],39:[function(require,module,exports){\nmodule.exports = function OpenFileDescription(path, id, flags, position) {\n  this.path = path;\n  this.id = id;\n  this.flags = flags;\n  this.position = position;\n};\n\n},{}],40:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Based on https://github.com/joyent/node/blob/41e53e557992a7d552a8e23de035f9463da25c99/lib/path.js\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n      /^(\\/?)([\\s\\S]+\\/(?!$)|\\/)?((?:\\.{1,2}$|[\\s\\S]+?)?(\\.[^.\\/]*)?)$/;\nvar splitPath = function(filename) {\n  var result = splitPathRe.exec(filename);\n  return [result[1] || '', result[2] || '', result[3] || '', result[4] || ''];\n};\n\n// path.resolve([from ...], to)\nfunction resolve() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    // XXXidbfs: we don't have process.cwd() so we use '/' as a fallback\n    var path = (i >= 0) ? arguments[i] : '/';\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string' || !path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n}\n\n// path.normalize(path)\nfunction normalize(path) {\n  var isAbsolute = path.charAt(0) === '/',\n      trailingSlash = path.substr(-1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(path.split('/').filter(function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  /*\n   if (path && trailingSlash) {\n   path += '/';\n   }\n   */\n\n  return (isAbsolute ? '/' : '') + path;\n}\n\nfunction join() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return normalize(paths.filter(function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n}\n\n// path.relative(from, to)\nfunction relative(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n}\n\nfunction dirname(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n}\n\nfunction basename(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  // XXXidbfs: node.js just does `return f`\n  return f === \"\" ? \"/\" : f;\n}\n\nfunction extname(path) {\n  return splitPath(path)[3];\n}\n\nfunction isAbsolute(path) {\n  if(path.charAt(0) === '/') {\n    return true;\n  }\n  return false;\n}\n\nfunction isNull(path) {\n  if (('' + path).indexOf('\\u0000') !== -1) {\n    return true;\n  }\n  return false;\n}\n\n// XXXidbfs: we don't support path.exists() or path.existsSync(), which\n// are deprecated, and need a FileSystem instance to work. Use fs.stat().\n\nmodule.exports = {\n  normalize: normalize,\n  resolve: resolve,\n  join: join,\n  relative: relative,\n  sep: '/',\n  delimiter: ':',\n  dirname: dirname,\n  basename: basename,\n  extname: extname,\n  isAbsolute: isAbsolute,\n  isNull: isNull\n};\n\n},{}],41:[function(require,module,exports){\nvar IndexedDB = require('./indexeddb.js');\nvar WebSQL = require('./websql.js');\nvar Memory = require('./memory.js');\n\nmodule.exports = {\n  IndexedDB: IndexedDB,\n  WebSQL: WebSQL,\n  Memory: Memory,\n\n  /**\n   * Convenience Provider references\n   */\n\n  // The default provider to use when none is specified\n  Default: IndexedDB,\n\n  // The Fallback provider does automatic fallback checks\n  Fallback: (function() {\n    if(IndexedDB.isSupported()) {\n      return IndexedDB;\n    }\n\n    if(WebSQL.isSupported()) {\n      return WebSQL;\n    }\n\n    function NotSupported() {\n      throw \"[Filer Error] Your browser doesn't support IndexedDB or WebSQL.\";\n    }\n    NotSupported.isSupported = function() {\n      return false;\n    };\n    return NotSupported;\n  }())\n};\n\n},{\"./indexeddb.js\":42,\"./memory.js\":43,\"./websql.js\":44}],42:[function(require,module,exports){\n(function (global){\nvar FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\nvar FILE_STORE_NAME = require('../constants.js').FILE_STORE_NAME;\nvar IDB_RW = require('../constants.js').IDB_RW;\nvar IDB_RO = require('../constants.js').IDB_RO;\nvar Errors = require('../errors.js');\nvar FilerBuffer = require('../buffer.js');\n\nvar indexedDB = global.indexedDB       ||\n                global.mozIndexedDB    ||\n                global.webkitIndexedDB ||\n                global.msIndexedDB;\n\nfunction IndexedDBContext(db, mode) {\n  var transaction = db.transaction(FILE_STORE_NAME, mode);\n  this.objectStore = transaction.objectStore(FILE_STORE_NAME);\n}\n\nIndexedDBContext.prototype.clear = function(callback) {\n  try {\n    var request = this.objectStore.clear();\n    request.onsuccess = function(event) {\n      callback();\n    };\n    request.onerror = function(error) {\n      callback(error);\n    };\n  } catch(e) {\n    callback(e);\n  }\n};\n\nfunction _get(objectStore, key, callback) {\n  try {\n    var request = objectStore.get(key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function onerror(error) {\n      callback(error);\n    };\n  } catch(e) {\n    callback(e);\n  }\n}\nIndexedDBContext.prototype.getObject = function(key, callback) {\n  _get(this.objectStore, key, callback);\n};\nIndexedDBContext.prototype.getBuffer = function(key, callback) {\n  _get(this.objectStore, key, function(err, arrayBuffer) {\n    if(err) {\n      return callback(err);\n    }\n    callback(null, new FilerBuffer(arrayBuffer));\n  });\n};\n\nfunction _put(objectStore, key, value, callback) {\n  try {\n    var request = objectStore.put(value, key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function onerror(error) {\n      callback(error);\n    };\n  } catch(e) {\n    callback(e);\n  }\n}\nIndexedDBContext.prototype.putObject = function(key, value, callback) {\n  _put(this.objectStore, key, value, callback);\n};\nIndexedDBContext.prototype.putBuffer = function(key, uint8BackedBuffer, callback) {\n  _put(this.objectStore, key, uint8BackedBuffer.buffer, callback);\n};\n\nIndexedDBContext.prototype.delete = function(key, callback) {\n  try {\n    var request = this.objectStore.delete(key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function(error) {\n      callback(error);\n    };\n  } catch(e) {\n    callback(e);\n  }\n};\n\n\nfunction IndexedDB(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n  this.db = null;\n}\nIndexedDB.isSupported = function() {\n  return !!indexedDB;\n};\n\nIndexedDB.prototype.open = function(callback) {\n  var that = this;\n\n  // Bail if we already have a db open\n  if(that.db) {\n    return callback();\n  }\n\n  // NOTE: we're not using versioned databases.\n  var openRequest = indexedDB.open(that.name);\n\n  // If the db doesn't exist, we'll create it\n  openRequest.onupgradeneeded = function onupgradeneeded(event) {\n    var db = event.target.result;\n\n    if(db.objectStoreNames.contains(FILE_STORE_NAME)) {\n      db.deleteObjectStore(FILE_STORE_NAME);\n    }\n    db.createObjectStore(FILE_STORE_NAME);\n  };\n\n  openRequest.onsuccess = function onsuccess(event) {\n    that.db = event.target.result;\n    callback();\n  };\n  openRequest.onerror = function onerror(error) {\n    callback(new Errors.EINVAL('IndexedDB cannot be accessed. If private browsing is enabled, disable it.'));\n  };\n};\nIndexedDB.prototype.getReadOnlyContext = function() {\n  // Due to timing issues in Chrome with readwrite vs. readonly indexeddb transactions\n  // always use readwrite so we can make sure pending commits finish before callbacks.\n  // See https://github.com/js-platform/filer/issues/128\n  return new IndexedDBContext(this.db, IDB_RW);\n};\nIndexedDB.prototype.getReadWriteContext = function() {\n  return new IndexedDBContext(this.db, IDB_RW);\n};\n\nmodule.exports = IndexedDB;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../buffer.js\":29,\"../constants.js\":30,\"../errors.js\":33}],43:[function(require,module,exports){\nvar FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\n// NOTE: prefer setImmediate to nextTick for proper recursion yielding.\n// see https://github.com/js-platform/filer/pull/24\nvar asyncCallback = require('../../lib/async.js').setImmediate;\n\n/**\n * Make shared in-memory DBs possible when using the same name.\n */\nvar createDB = (function() {\n  var pool = {};\n  return function getOrCreate(name) {\n    if(!pool.hasOwnProperty(name)) {\n      pool[name] = {};\n    }\n    return pool[name];\n  };\n}());\n\nfunction MemoryContext(db, readOnly) {\n  this.readOnly = readOnly;\n  this.objectStore = db;\n}\n\nMemoryContext.prototype.clear = function(callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback(\"[MemoryContext] Error: write operation on read only context\");\n    });\n    return;\n  }\n  var objectStore = this.objectStore;\n  Object.keys(objectStore).forEach(function(key){\n    delete objectStore[key];\n  });\n  asyncCallback(callback);\n};\n\n// Memory context doesn't care about differences between Object and Buffer\nMemoryContext.prototype.getObject =\nMemoryContext.prototype.getBuffer =\nfunction(key, callback) {\n  var that = this;\n  asyncCallback(function() {\n    callback(null, that.objectStore[key]);\n  });\n};\nMemoryContext.prototype.putObject =\nMemoryContext.prototype.putBuffer =\nfunction(key, value, callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback(\"[MemoryContext] Error: write operation on read only context\");\n    });\n    return;\n  }\n  this.objectStore[key] = value;\n  asyncCallback(callback);\n};\n\nMemoryContext.prototype.delete = function(key, callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback(\"[MemoryContext] Error: write operation on read only context\");\n    });\n    return;\n  }\n  delete this.objectStore[key];\n  asyncCallback(callback);\n};\n\n\nfunction Memory(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n}\nMemory.isSupported = function() {\n  return true;\n};\n\nMemory.prototype.open = function(callback) {\n  this.db = createDB(this.name);\n  asyncCallback(callback);\n};\nMemory.prototype.getReadOnlyContext = function() {\n  return new MemoryContext(this.db, true);\n};\nMemory.prototype.getReadWriteContext = function() {\n  return new MemoryContext(this.db, false);\n};\n\nmodule.exports = Memory;\n\n},{\"../../lib/async.js\":24,\"../constants.js\":30}],44:[function(require,module,exports){\n(function (global){\nvar FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\nvar FILE_STORE_NAME = require('../constants.js').FILE_STORE_NAME;\nvar WSQL_VERSION = require('../constants.js').WSQL_VERSION;\nvar WSQL_SIZE = require('../constants.js').WSQL_SIZE;\nvar WSQL_DESC = require('../constants.js').WSQL_DESC;\nvar Errors = require('../errors.js');\nvar FilerBuffer = require('../buffer.js');\nvar base64ArrayBuffer = require('base64-arraybuffer');\n\nfunction WebSQLContext(db, isReadOnly) {\n  var that = this;\n  this.getTransaction = function(callback) {\n    if(that.transaction) {\n      callback(that.transaction);\n      return;\n    }\n    // Either do readTransaction() (read-only) or transaction() (read/write)\n    db[isReadOnly ? 'readTransaction' : 'transaction'](function(transaction) {\n      that.transaction = transaction;\n      callback(transaction);\n    });\n  };\n}\n\nWebSQLContext.prototype.clear = function(callback) {\n  function onError(transaction, error) {\n    callback(error);\n  }\n  function onSuccess(transaction, result) {\n    callback(null);\n  }\n  this.getTransaction(function(transaction) {\n    transaction.executeSql(\"DELETE FROM \" + FILE_STORE_NAME + \";\",\n                           [], onSuccess, onError);\n  });\n};\n\nfunction _get(getTransaction, key, callback) {\n  function onSuccess(transaction, result) {\n    // If the key isn't found, return null\n    var value = result.rows.length === 0 ? null : result.rows.item(0).data;\n    callback(null, value);\n  }\n  function onError(transaction, error) {\n    callback(error);\n  }\n  getTransaction(function(transaction) {\n    transaction.executeSql(\"SELECT data FROM \" + FILE_STORE_NAME + \" WHERE id = ? LIMIT 1;\",\n                           [key], onSuccess, onError);\n  });\n}\nWebSQLContext.prototype.getObject = function(key, callback) {\n  _get(this.getTransaction, key, function(err, result) {\n    if(err) {\n      return callback(err);\n    }\n\n    try {\n      if(result) {\n        result = JSON.parse(result);\n      }\n    } catch(e) {\n      return callback(e);\n    }\n\n    callback(null, result);\n  });\n};\nWebSQLContext.prototype.getBuffer = function(key, callback) {\n  _get(this.getTransaction, key, function(err, result) {\n    if(err) {\n      return callback(err);\n    }\n\n    // Deal with zero-length ArrayBuffers, which will be encoded as ''\n    if(result || result === '') {\n      var arrayBuffer = base64ArrayBuffer.decode(result);\n      result = new FilerBuffer(arrayBuffer);\n    }\n\n    callback(null, result);\n  });\n};\n\nfunction _put(getTransaction, key, value, callback) {\n  function onSuccess(transaction, result) {\n    callback(null);\n  }\n  function onError(transaction, error) {\n    callback(error);\n  }\n  getTransaction(function(transaction) {\n    transaction.executeSql(\"INSERT OR REPLACE INTO \" + FILE_STORE_NAME + \" (id, data) VALUES (?, ?);\",\n                           [key, value], onSuccess, onError);\n  });\n}\nWebSQLContext.prototype.putObject = function(key, value, callback) {\n  var json = JSON.stringify(value);\n  _put(this.getTransaction, key, json, callback);\n};\nWebSQLContext.prototype.putBuffer = function(key, uint8BackedBuffer, callback) {\n  var base64 = base64ArrayBuffer.encode(uint8BackedBuffer.buffer);\n  _put(this.getTransaction, key, base64, callback);\n};\n\nWebSQLContext.prototype.delete = function(key, callback) {\n  function onSuccess(transaction, result) {\n    callback(null);\n  }\n  function onError(transaction, error) {\n    callback(error);\n  }\n  this.getTransaction(function(transaction) {\n    transaction.executeSql(\"DELETE FROM \" + FILE_STORE_NAME + \" WHERE id = ?;\",\n                           [key], onSuccess, onError);\n  });\n};\n\n\nfunction WebSQL(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n  this.db = null;\n}\nWebSQL.isSupported = function() {\n  return !!global.openDatabase;\n};\n\nWebSQL.prototype.open = function(callback) {\n  var that = this;\n\n  // Bail if we already have a db open\n  if(that.db) {\n    return callback();\n  }\n\n  var db = global.openDatabase(that.name, WSQL_VERSION, WSQL_DESC, WSQL_SIZE);\n  if(!db) {\n    callback(\"[WebSQL] Unable to open database.\");\n    return;\n  }\n\n  function onError(transaction, error) {\n    if (error.code === 5) {\n      callback(new Errors.EINVAL('WebSQL cannot be accessed. If private browsing is enabled, disable it.'));\n    }\n    callback(error);\n  }\n  function onSuccess(transaction, result) {\n    that.db = db;\n    callback();\n  }\n\n  // Create the table and index we'll need to store the fs data.\n  db.transaction(function(transaction) {\n    function createIndex(transaction) {\n      transaction.executeSql(\"CREATE INDEX IF NOT EXISTS idx_\" + FILE_STORE_NAME + \"_id\" +\n                             \" on \" + FILE_STORE_NAME + \" (id);\",\n                             [], onSuccess, onError);\n    }\n    transaction.executeSql(\"CREATE TABLE IF NOT EXISTS \" + FILE_STORE_NAME + \" (id unique, data TEXT);\",\n                           [], createIndex, onError);\n  });\n};\nWebSQL.prototype.getReadOnlyContext = function() {\n  return new WebSQLContext(this.db, true);\n};\nWebSQL.prototype.getReadWriteContext = function() {\n  return new WebSQLContext(this.db, false);\n};\n\nmodule.exports = WebSQL;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../buffer.js\":29,\"../constants.js\":30,\"../errors.js\":33,\"base64-arraybuffer\":28}],45:[function(require,module,exports){\nfunction guid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n    return v.toString(16);\n  }).toUpperCase();\n}\n\nfunction nop() {}\n\n/**\n * Convert a Uint8Array to a regular array\n */\nfunction u8toArray(u8) {\n  var array = [];\n  var len = u8.length;\n  for(var i = 0; i < len; i++) {\n    array[i] = u8[i];\n  }\n  return array;\n}\n\nmodule.exports = {\n  guid: guid,\n  u8toArray: u8toArray,\n  nop: nop\n};\n\n},{}],46:[function(require,module,exports){\nvar defaults = require('../constants.js').ENVIRONMENT;\n\nmodule.exports = function Environment(env) {\n  env = env || {};\n  env.TMP = env.TMP || defaults.TMP;\n  env.PATH = env.PATH || defaults.PATH;\n\n  this.get = function(name) {\n    return env[name];\n  };\n\n  this.set = function(name, value) {\n    env[name] = value;\n  };\n};\n\n},{\"../constants.js\":30}],47:[function(require,module,exports){\nvar Path = require('../path.js');\nvar Errors = require('../errors.js');\nvar Environment = require('./environment.js');\nvar async = require('../../lib/async.js');\nvar Encoding = require('../encoding.js');\n\nfunction Shell(fs, options) {\n  options = options || {};\n\n  var env = new Environment(options.env);\n  var cwd = '/';\n\n  /**\n   * The bound FileSystem (cannot be changed)\n   */\n  Object.defineProperty(this, 'fs', {\n    get: function() { return fs; },\n    enumerable: true\n  });\n\n  /**\n   * The shell's environment (e.g., for things like\n   * path, tmp, and other env vars). Use env.get()\n   * and env.set() to work with variables.\n   */\n  Object.defineProperty(this, 'env', {\n    get: function() { return env; },\n    enumerable: true\n  });\n\n  /**\n   * Change the current working directory. We\n   * include `cd` on the `this` vs. proto so that\n   * we can access cwd without exposing it externally.\n   */\n  this.cd = function(path, callback) {\n    path = Path.resolve(cwd, path);\n    // Make sure the path actually exists, and is a dir\n    fs.stat(path, function(err, stats) {\n      if(err) {\n        callback(new Errors.ENOTDIR(null, path));\n        return;\n      }\n      if(stats.type === 'DIRECTORY') {\n        cwd = path;\n        callback();\n      } else {\n        callback(new Errors.ENOTDIR(null, path));\n      }\n    });\n  };\n\n  /**\n   * Get the current working directory (changed with `cd()`)\n   */\n  this.pwd = function() {\n    return cwd;\n  };\n}\n\n/**\n * Execute the .js command located at `path`. Such commands\n * should assume the existence of 3 arguments, which will be\n * defined at runtime:\n *\n *   * fs - the current shell's bound filesystem object\n *   * args - a list of arguments for the command, or an empty list if none\n *   * callback - a callback function(error, result) to call when done.\n *\n * The .js command's contents should be the body of a function\n * that looks like this:\n *\n * function(fs, args, callback) {\n *   // .js code here\n * }\n */\nShell.prototype.exec = function(path, args, callback) {\n  /* jshint evil:true */\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof args === 'function') {\n    callback = args;\n    args = [];\n  }\n  args = args || [];\n  callback = callback || function(){};\n  path = Path.resolve(sh.pwd(), path);\n\n  fs.readFile(path, \"utf8\", function(error, data) {\n    if(error) {\n      callback(error);\n      return;\n    }\n    try {\n      var cmd = new Function('fs', 'args', 'callback', data);\n      cmd(fs, args, callback);\n    } catch(e) {\n      callback(e);\n    }\n  });\n};\n\n/**\n * Create a file if it does not exist, or update access and\n * modified times if it does. Valid options include:\n *\n *  * updateOnly - whether to create the file if missing (defaults to false)\n *  * date - use the provided Date value instead of current date/time\n */\nShell.prototype.touch = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n  path = Path.resolve(sh.pwd(), path);\n\n  function createFile(path) {\n    fs.writeFile(path, '', callback);\n  }\n\n  function updateTimes(path) {\n    var now = Date.now();\n    var atime = options.date || now;\n    var mtime = options.date || now;\n\n    fs.utimes(path, atime, mtime, callback);\n  }\n\n  fs.stat(path, function(error, stats) {\n    if(error) {\n      if(options.updateOnly === true) {\n        callback();\n      } else {\n        createFile(path);\n      }\n    } else {\n      updateTimes(path);\n    }\n  });\n};\n\n/**\n * Concatenate multiple files into a single String, with each\n * file separated by a newline. The `files` argument should\n * be a String (path to single file) or an Array of Strings\n * (multiple file paths).\n */\nShell.prototype.cat = function(files, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  var all = '';\n  callback = callback || function(){};\n\n  if(!files) {\n    callback(new Errors.EINVAL('Missing files argument'));\n    return;\n  }\n\n  files = typeof files === 'string' ? [ files ] : files;\n\n  function append(item, callback) {\n    var filename = Path.resolve(sh.pwd(), item);\n    fs.readFile(filename, 'utf8', function(error, data) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      all += data + '\\n';\n      callback();\n    });\n  }\n\n  async.eachSeries(files, append, function(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, all.replace(/\\n$/, ''));\n    }\n  });\n};\n\n/**\n * Get the listing of a directory, returning an array of\n * file entries in the following form:\n *\n * {\n *   path: <String> the basename of the directory entry\n *   links: <Number> the number of links to the entry\n *   size: <Number> the size in bytes of the entry\n *   modified: <Number> the last modified date/time\n *   type: <String> the type of the entry\n *   contents: <Array> an optional array of child entries\n * }\n *\n * By default ls() gives a shallow listing. If you want\n * to follow directories as they are encountered, use\n * the `recursive=true` option.\n */\nShell.prototype.ls = function(dir, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  if(!dir) {\n    callback(new Errors.EINVAL('Missing dir argument'));\n    return;\n  }\n\n  function list(path, callback) {\n    var pathname = Path.resolve(sh.pwd(), path);\n    var result = [];\n\n    fs.readdir(pathname, function(error, entries) {\n      if(error) {\n        callback(error);\n        return;\n      }\n\n      function getDirEntry(name, callback) {\n        name = Path.join(pathname, name);\n        fs.stat(name, function(error, stats) {\n          if(error) {\n            callback(error);\n            return;\n          }\n          var entry = {\n            path: Path.basename(name),\n            links: stats.nlinks,\n            size: stats.size,\n            modified: stats.mtime,\n            type: stats.type\n          };\n\n          if(options.recursive && stats.type === 'DIRECTORY') {\n            list(Path.join(pathname, entry.path), function(error, items) {\n              if(error) {\n                callback(error);\n                return;\n              }\n              entry.contents = items;\n              result.push(entry);\n              callback();\n            });\n          } else {\n            result.push(entry);\n            callback();\n          }\n        });\n      }\n\n      async.eachSeries(entries, getDirEntry, function(error) {\n        callback(error, result);\n      });\n    });\n  }\n\n  list(dir, callback);\n};\n\n/**\n * Removes the file or directory at `path`. If `path` is a file\n * it will be removed. If `path` is a directory, it will be\n * removed if it is empty, otherwise the callback will receive\n * an error. In order to remove non-empty directories, use the\n * `recursive=true` option.\n */\nShell.prototype.rm = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n\n  function remove(pathname, callback) {\n    pathname = Path.resolve(sh.pwd(), pathname);\n    fs.stat(pathname, function(error, stats) {\n      if(error) {\n        callback(error);\n        return;\n      }\n\n      // If this is a file, delete it and we're done\n      if(stats.type === 'FILE') {\n        fs.unlink(pathname, callback);\n        return;\n      }\n\n      // If it's a dir, check if it's empty\n      fs.readdir(pathname, function(error, entries) {\n        if(error) {\n          callback(error);\n          return;\n        }\n\n        // If dir is empty, delete it and we're done\n        if(entries.length === 0) {\n          fs.rmdir(pathname, callback);\n          return;\n        }\n\n        // If not, see if we're allowed to delete recursively\n        if(!options.recursive) {\n          callback(new Errors.ENOTEMPTY(null, pathname));\n          return;\n        }\n\n        // Remove each dir entry recursively, then delete the dir.\n        entries = entries.map(function(filename) {\n          // Root dir entries absolutely\n          return Path.join(pathname, filename);\n        });\n        async.eachSeries(entries, remove, function(error) {\n          if(error) {\n            callback(error);\n            return;\n          }\n          fs.rmdir(pathname, callback);\n        });\n      });\n    });\n  }\n\n  remove(path, callback);\n};\n\n/**\n * Gets the path to the temporary directory, creating it if not\n * present. The directory used is the one specified in\n * env.TMP. The callback receives (error, tempDirName).\n */\nShell.prototype.tempDir = function(callback) {\n  var sh = this;\n  var fs = sh.fs;\n  var tmp = sh.env.get('TMP');\n  callback = callback || function(){};\n\n  // Try and create it, and it will either work or fail\n  // but either way it's now there.\n  fs.mkdir(tmp, function(err) {\n    callback(null, tmp);\n  });\n};\n\n/**\n * Recursively creates the directory at `path`. If the parent\n * of `path` does not exist, it will be created.\n * Based off EnsureDir by Sam X. Xu\n * https://www.npmjs.org/package/ensureDir\n * MIT License\n */\nShell.prototype.mkdirp = function(path, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  callback = callback || function(){};\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n  else if (path === '/') {\n    callback();\n    return;\n  }\n  function _mkdirp(path, callback) {\n    fs.stat(path, function (err, stat) {\n      if(stat) {\n        if(stat.isDirectory()) {\n          callback();\n          return;\n        }\n        else if (stat.isFile()) {\n          callback(new Errors.ENOTDIR(null, path));\n          return;\n        }\n      }\n      else if (err && err.code !== 'ENOENT') {\n        callback(err);\n        return;\n      }\n      else {\n        var parent = Path.dirname(path);\n        if(parent === '/') {\n          fs.mkdir(path, function (err) {\n            if (err && err.code != 'EEXIST') {\n              callback(err);\n              return;\n            }\n            callback();\n            return;\n          });\n        }\n        else {\n          _mkdirp(parent, function (err) {\n            if (err) return callback(err);\n            fs.mkdir(path, function (err) {\n              if (err && err.code != 'EEXIST') {\n                callback(err);\n                return;\n              }\n              callback();\n              return;\n            });\n          });\n        }\n      }\n    });\n  }\n\n  _mkdirp(path, callback);\n};\n\nmodule.exports = Shell;\n\n},{\"../../lib/async.js\":24,\"../encoding.js\":32,\"../errors.js\":33,\"../path.js\":40,\"./environment.js\":46}],48:[function(require,module,exports){\nvar Constants = require('./constants.js');\n\nfunction Stats(fileNode, devName) {\n  this.node = fileNode.id;\n  this.dev = devName;\n  this.size = fileNode.size;\n  this.nlinks = fileNode.nlinks;\n  this.atime = fileNode.atime;\n  this.mtime = fileNode.mtime;\n  this.ctime = fileNode.ctime;\n  this.type = fileNode.mode;\n}\n\nStats.prototype.isFile = function() {\n  return this.type === Constants.MODE_FILE;\n};\n\nStats.prototype.isDirectory = function() {\n  return this.type === Constants.MODE_DIRECTORY;\n};\n\nStats.prototype.isSymbolicLink = function() {\n  return this.type === Constants.MODE_SYMBOLIC_LINK;\n};\n\n// These will always be false in Filer.\nStats.prototype.isSocket          =\nStats.prototype.isFIFO            =\nStats.prototype.isCharacterDevice =\nStats.prototype.isBlockDevice     =\nfunction() {\n  return false;\n};\n\nmodule.exports = Stats;\n\n},{\"./constants.js\":30}],49:[function(require,module,exports){\nvar Constants = require('./constants.js');\n\nfunction SuperNode(options) {\n  var now = Date.now();\n\n  this.id = Constants.SUPER_NODE_ID;\n  this.mode = Constants.MODE_META;\n  this.atime = options.atime || now;\n  this.ctime = options.ctime || now;\n  this.mtime = options.mtime || now;\n  // root node id (randomly generated)\n  this.rnode = options.rnode;\n}\n\nSuperNode.create = function(options, callback) {\n  options.guid(function(err, rnode) {\n    if(err) {\n      callback(err);\n      return;\n    }\n    options.rnode = options.rnode || rnode;\n    callback(null, new SuperNode(options));\n  });\n};\n\nmodule.exports = SuperNode;\n\n},{\"./constants.js\":30}],50:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = Buffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192\n\n/**\n * If `TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Note:\n *\n * - Implementation must support adding new properties to `Uint8Array` instances.\n *   Firefox 4-29 lacked support, fixed in Firefox 30+.\n *   See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *  - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *  - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *    incorrect length in some situations.\n *\n * We detect these buggy browsers and set `TYPED_ARRAY_SUPPORT` to `false` so they will\n * get the Object implementation, which is slower but will work correctly.\n */\nvar TYPED_ARRAY_SUPPORT = (function () {\n  try {\n    var buf = new ArrayBuffer(0)\n    var arr = new Uint8Array(buf)\n    arr.foo = function () { return 42 }\n    return 42 === arr.foo() && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        new Uint8Array(1).subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n})()\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (subject, encoding, noZero) {\n  if (!(this instanceof Buffer))\n    return new Buffer(subject, encoding, noZero)\n\n  var type = typeof subject\n\n  // Find the length\n  var length\n  if (type === 'number')\n    length = subject > 0 ? subject >>> 0 : 0\n  else if (type === 'string') {\n    if (encoding === 'base64')\n      subject = base64clean(subject)\n    length = Buffer.byteLength(subject, encoding)\n  } else if (type === 'object' && subject !== null) { // assume object is array-like\n    if (subject.type === 'Buffer' && isArray(subject.data))\n      subject = subject.data\n    length = +subject.length > 0 ? Math.floor(+subject.length) : 0\n  } else\n    throw new Error('First argument needs to be a number, array or string.')\n\n  var buf\n  if (TYPED_ARRAY_SUPPORT) {\n    // Preferred: Return an augmented `Uint8Array` instance for best performance\n    buf = Buffer._augment(new Uint8Array(length))\n  } else {\n    // Fallback: Return THIS instance of Buffer (created by `new`)\n    buf = this\n    buf.length = length\n    buf._isBuffer = true\n  }\n\n  var i\n  if (TYPED_ARRAY_SUPPORT && typeof subject.byteLength === 'number') {\n    // Speed optimization -- use set if we're copying from a typed array\n    buf._set(subject)\n  } else if (isArrayish(subject)) {\n    // Treat array-ish objects as a byte array\n    if (Buffer.isBuffer(subject)) {\n      for (i = 0; i < length; i++)\n        buf[i] = subject.readUInt8(i)\n    } else {\n      for (i = 0; i < length; i++)\n        buf[i] = ((subject[i] % 256) + 256) % 256\n    }\n  } else if (type === 'string') {\n    buf.write(subject, 0, encoding)\n  } else if (type === 'number' && !TYPED_ARRAY_SUPPORT && !noZero) {\n    for (i = 0; i < length; i++) {\n      buf[i] = 0\n    }\n  }\n\n  return buf\n}\n\n// STATIC METHODS\n// ==============\n\nBuffer.isEncoding = function (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.isBuffer = function (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.byteLength = function (str, encoding) {\n  var ret\n  str = str.toString()\n  switch (encoding || 'utf8') {\n    case 'hex':\n      ret = str.length / 2\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8ToBytes(str).length\n      break\n    case 'ascii':\n    case 'binary':\n    case 'raw':\n      ret = str.length\n      break\n    case 'base64':\n      ret = base64ToBytes(str).length\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = str.length * 2\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.concat = function (list, totalLength) {\n  assert(isArray(list), 'Usage: Buffer.concat(list[, length])')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  } else if (list.length === 1) {\n    return list[0]\n  }\n\n  var i\n  if (totalLength === undefined) {\n    totalLength = 0\n    for (i = 0; i < list.length; i++) {\n      totalLength += list[i].length\n    }\n  }\n\n  var buf = new Buffer(totalLength)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nBuffer.compare = function (a, b) {\n  assert(Buffer.isBuffer(a) && Buffer.isBuffer(b), 'Arguments must be Buffers')\n  var x = a.length\n  var y = b.length\n  for (var i = 0, len = Math.min(x, y); i < len && a[i] === b[i]; i++) {}\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n  if (x < y) {\n    return -1\n  }\n  if (y < x) {\n    return 1\n  }\n  return 0\n}\n\n// BUFFER INSTANCE METHODS\n// =======================\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  assert(strLen % 2 === 0, 'Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var byte = parseInt(string.substr(i * 2, 2), 16)\n    assert(!isNaN(byte), 'Invalid hex string')\n    buf[offset + i] = byte\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  var charsWritten = blitBuffer(utf8ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  var charsWritten = blitBuffer(asciiToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  var charsWritten = blitBuffer(base64ToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nfunction utf16leWrite (buf, string, offset, length) {\n  var charsWritten = blitBuffer(utf16leToBytes(string), buf, offset, length)\n  return charsWritten\n}\n\nBuffer.prototype.write = function (string, offset, length, encoding) {\n  // Support both (string, offset, length, encoding)\n  // and the legacy (string, encoding, offset, length)\n  if (isFinite(offset)) {\n    if (!isFinite(length)) {\n      encoding = length\n      length = undefined\n    }\n  } else {  // legacy\n    var swap = encoding\n    encoding = offset\n    offset = length\n    length = swap\n  }\n\n  offset = Number(offset) || 0\n  var remaining = this.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n  encoding = String(encoding || 'utf8').toLowerCase()\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = hexWrite(this, string, offset, length)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8Write(this, string, offset, length)\n      break\n    case 'ascii':\n      ret = asciiWrite(this, string, offset, length)\n      break\n    case 'binary':\n      ret = binaryWrite(this, string, offset, length)\n      break\n    case 'base64':\n      ret = base64Write(this, string, offset, length)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = utf16leWrite(this, string, offset, length)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toString = function (encoding, start, end) {\n  var self = this\n\n  encoding = String(encoding || 'utf8').toLowerCase()\n  start = Number(start) || 0\n  end = (end === undefined) ? self.length : Number(end)\n\n  // Fastpath empty strings\n  if (end === start)\n    return ''\n\n  var ret\n  switch (encoding) {\n    case 'hex':\n      ret = hexSlice(self, start, end)\n      break\n    case 'utf8':\n    case 'utf-8':\n      ret = utf8Slice(self, start, end)\n      break\n    case 'ascii':\n      ret = asciiSlice(self, start, end)\n      break\n    case 'binary':\n      ret = binarySlice(self, start, end)\n      break\n    case 'base64':\n      ret = base64Slice(self, start, end)\n      break\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      ret = utf16leSlice(self, start, end)\n      break\n    default:\n      throw new Error('Unknown encoding')\n  }\n  return ret\n}\n\nBuffer.prototype.toJSON = function () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nBuffer.prototype.equals = function (b) {\n  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.compare = function (b) {\n  assert(Buffer.isBuffer(b), 'Argument must be a Buffer')\n  return Buffer.compare(this, b)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function (target, target_start, start, end) {\n  var source = this\n\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (!target_start) target_start = 0\n\n  // Copy 0 bytes; we're done\n  if (end === start) return\n  if (target.length === 0 || source.length === 0) return\n\n  // Fatal error conditions\n  assert(end >= start, 'sourceEnd < sourceStart')\n  assert(target_start >= 0 && target_start < target.length,\n      'targetStart out of bounds')\n  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')\n  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length)\n    end = this.length\n  if (target.length - target_start < end - start)\n    end = target.length - target_start + start\n\n  var len = end - start\n\n  if (len < 100 || !TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < len; i++) {\n      target[i + target_start] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), target_start)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  var res = ''\n  var tmp = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    if (buf[i] <= 0x7F) {\n      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])\n      tmp = ''\n    } else {\n      tmp += '%' + buf[i].toString(16)\n    }\n  }\n\n  return res + decodeUtf8Char(tmp)\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  return asciiSlice(buf, start, end)\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len;\n    if (start < 0)\n      start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0)\n      end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start)\n    end = start\n\n  if (TYPED_ARRAY_SUPPORT) {\n    return Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    var newBuf = new Buffer(sliceLen, undefined, true)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n    return newBuf\n  }\n}\n\n// `get` will be removed in Node 0.13+\nBuffer.prototype.get = function (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` will be removed in Node 0.13+\nBuffer.prototype.set = function (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nBuffer.prototype.readUInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  return this[offset]\n}\n\nfunction readUInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    val = buf[offset]\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n  } else {\n    val = buf[offset] << 8\n    if (offset + 1 < len)\n      val |= buf[offset + 1]\n  }\n  return val\n}\n\nBuffer.prototype.readUInt16LE = function (offset, noAssert) {\n  return readUInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt16BE = function (offset, noAssert) {\n  return readUInt16(this, offset, false, noAssert)\n}\n\nfunction readUInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val\n  if (littleEndian) {\n    if (offset + 2 < len)\n      val = buf[offset + 2] << 16\n    if (offset + 1 < len)\n      val |= buf[offset + 1] << 8\n    val |= buf[offset]\n    if (offset + 3 < len)\n      val = val + (buf[offset + 3] << 24 >>> 0)\n  } else {\n    if (offset + 1 < len)\n      val = buf[offset + 1] << 16\n    if (offset + 2 < len)\n      val |= buf[offset + 2] << 8\n    if (offset + 3 < len)\n      val |= buf[offset + 3]\n    val = val + (buf[offset] << 24 >>> 0)\n  }\n  return val\n}\n\nBuffer.prototype.readUInt32LE = function (offset, noAssert) {\n  return readUInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readUInt32BE = function (offset, noAssert) {\n  return readUInt32(this, offset, false, noAssert)\n}\n\nBuffer.prototype.readInt8 = function (offset, noAssert) {\n  if (!noAssert) {\n    assert(offset !== undefined && offset !== null,\n        'missing offset')\n    assert(offset < this.length, 'Trying to read beyond buffer length')\n  }\n\n  if (offset >= this.length)\n    return\n\n  var neg = this[offset] & 0x80\n  if (neg)\n    return (0xff - this[offset] + 1) * -1\n  else\n    return this[offset]\n}\n\nfunction readInt16 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = readUInt16(buf, offset, littleEndian, true)\n  var neg = val & 0x8000\n  if (neg)\n    return (0xffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt16LE = function (offset, noAssert) {\n  return readInt16(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt16BE = function (offset, noAssert) {\n  return readInt16(this, offset, false, noAssert)\n}\n\nfunction readInt32 (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  var val = readUInt32(buf, offset, littleEndian, true)\n  var neg = val & 0x80000000\n  if (neg)\n    return (0xffffffff - val + 1) * -1\n  else\n    return val\n}\n\nBuffer.prototype.readInt32LE = function (offset, noAssert) {\n  return readInt32(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readInt32BE = function (offset, noAssert) {\n  return readInt32(this, offset, false, noAssert)\n}\n\nfunction readFloat (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 23, 4)\n}\n\nBuffer.prototype.readFloatLE = function (offset, noAssert) {\n  return readFloat(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readFloatBE = function (offset, noAssert) {\n  return readFloat(this, offset, false, noAssert)\n}\n\nfunction readDouble (buf, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')\n  }\n\n  return ieee754.read(buf, offset, littleEndian, 52, 8)\n}\n\nBuffer.prototype.readDoubleLE = function (offset, noAssert) {\n  return readDouble(this, offset, true, noAssert)\n}\n\nBuffer.prototype.readDoubleBE = function (offset, noAssert) {\n  return readDouble(this, offset, false, noAssert)\n}\n\nBuffer.prototype.writeUInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xff)\n  }\n\n  if (offset >= this.length) return\n\n  this[offset] = value\n  return offset + 1\n}\n\nfunction writeUInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {\n    buf[offset + i] =\n        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n            (littleEndian ? i : 1 - i) * 8\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16LE = function (value, offset, noAssert) {\n  return writeUInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt16BE = function (value, offset, noAssert) {\n  return writeUInt16(this, value, offset, false, noAssert)\n}\n\nfunction writeUInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')\n    verifuint(value, 0xffffffff)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {\n    buf[offset + i] =\n        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32LE = function (value, offset, noAssert) {\n  return writeUInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeUInt32BE = function (value, offset, noAssert) {\n  return writeUInt32(this, value, offset, false, noAssert)\n}\n\nBuffer.prototype.writeInt8 = function (value, offset, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset < this.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7f, -0x80)\n  }\n\n  if (offset >= this.length)\n    return\n\n  if (value >= 0)\n    this.writeUInt8(value, offset, noAssert)\n  else\n    this.writeUInt8(0xff + value + 1, offset, noAssert)\n  return offset + 1\n}\n\nfunction writeInt16 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fff, -0x8000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    writeUInt16(buf, value, offset, littleEndian, noAssert)\n  else\n    writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16LE = function (value, offset, noAssert) {\n  return writeInt16(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt16BE = function (value, offset, noAssert) {\n  return writeInt16(this, value, offset, false, noAssert)\n}\n\nfunction writeInt32 (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifsint(value, 0x7fffffff, -0x80000000)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  if (value >= 0)\n    writeUInt32(buf, value, offset, littleEndian, noAssert)\n  else\n    writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32LE = function (value, offset, noAssert) {\n  return writeInt32(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeInt32BE = function (value, offset, noAssert) {\n  return writeInt32(this, value, offset, false, noAssert)\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')\n    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    assert(value !== undefined && value !== null, 'missing value')\n    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')\n    assert(offset !== undefined && offset !== null, 'missing offset')\n    assert(offset + 7 < buf.length,\n        'Trying to write beyond buffer length')\n    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n\n  var len = buf.length\n  if (offset >= len)\n    return\n\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  assert(end >= start, 'end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  assert(start >= 0 && start < this.length, 'start out of bounds')\n  assert(end >= 0 && end <= this.length, 'end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\nBuffer.prototype.inspect = function () {\n  var out = []\n  var len = this.length\n  for (var i = 0; i < len; i++) {\n    out[i] = toHex(this[i])\n    if (i === exports.INSPECT_MAX_BYTES) {\n      out[i + 1] = '...'\n      break\n    }\n  }\n  return '<Buffer ' + out.join(' ') + '>'\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new Error('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function (arr) {\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array get/set methods before overwriting\n  arr._get = arr.get\n  arr._set = arr.set\n\n  // deprecated, will be removed in node 0.13+\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-z]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction isArray (subject) {\n  return (Array.isArray || function (subject) {\n    return Object.prototype.toString.call(subject) === '[object Array]'\n  })(subject)\n}\n\nfunction isArrayish (subject) {\n  return isArray(subject) || Buffer.isBuffer(subject) ||\n      subject && typeof subject === 'object' &&\n      typeof subject.length === 'number'\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    var b = str.charCodeAt(i)\n    if (b <= 0x7F) {\n      byteArray.push(b)\n    } else {\n      var start = i\n      if (b >= 0xD800 && b <= 0xDFFF) i++\n      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')\n      for (var j = 0; j < h.length; j++) {\n        byteArray.push(parseInt(h[j], 16))\n      }\n    }\n  }\n  return byteArray\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(str)\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length))\n      break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction decodeUtf8Char (str) {\n  try {\n    return decodeURIComponent(str)\n  } catch (err) {\n    return String.fromCharCode(0xFFFD) // UTF 8 invalid char\n  }\n}\n\n/*\n * We have to make sure that the value is a valid integer. This means that it\n * is non-negative. It has no fractional component and that it does not\n * exceed the maximum allowed value.\n */\nfunction verifuint (value, max) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value >= 0, 'specified a negative value for writing an unsigned value')\n  assert(value <= max, 'value is larger than maximum value for type')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifsint (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n  assert(Math.floor(value) === value, 'value has a fractional component')\n}\n\nfunction verifIEEE754 (value, max, min) {\n  assert(typeof value === 'number', 'cannot write a non-number as a number')\n  assert(value <= max, 'value larger than maximum allowed value')\n  assert(value >= min, 'value smaller than minimum allowed value')\n}\n\nfunction assert (test, message) {\n  if (!test) throw new Error(message || 'Failed assertion')\n}\n\n},{\"base64-js\":51,\"ieee754\":52}],51:[function(require,module,exports){\nvar lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n	'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n	var PLUS   = '+'.charCodeAt(0)\n	var SLASH  = '/'.charCodeAt(0)\n	var NUMBER = '0'.charCodeAt(0)\n	var LOWER  = 'a'.charCodeAt(0)\n	var UPPER  = 'A'.charCodeAt(0)\n\n	function decode (elt) {\n		var code = elt.charCodeAt(0)\n		if (code === PLUS)\n			return 62 // '+'\n		if (code === SLASH)\n			return 63 // '/'\n		if (code < NUMBER)\n			return -1 //no match\n		if (code < NUMBER + 10)\n			return code - NUMBER + 26 + 26\n		if (code < UPPER + 26)\n			return code - UPPER\n		if (code < LOWER + 26)\n			return code - LOWER + 26\n	}\n\n	function b64ToByteArray (b64) {\n		var i, j, l, tmp, placeHolders, arr\n\n		if (b64.length % 4 > 0) {\n			throw new Error('Invalid string. Length must be a multiple of 4')\n		}\n\n		// the number of equal signs (place holders)\n		// if there are two placeholders, than the two characters before it\n		// represent one byte\n		// if there is only one, then the three characters before it represent 2 bytes\n		// this is just a cheap hack to not do indexOf twice\n		var len = b64.length\n		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n		// base64 is 4/3 + up to two characters of the original data\n		arr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n		// if there are placeholders, only get up to the last complete 4 chars\n		l = placeHolders > 0 ? b64.length - 4 : b64.length\n\n		var L = 0\n\n		function push (v) {\n			arr[L++] = v\n		}\n\n		for (i = 0, j = 0; i < l; i += 4, j += 3) {\n			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n			push((tmp & 0xFF0000) >> 16)\n			push((tmp & 0xFF00) >> 8)\n			push(tmp & 0xFF)\n		}\n\n		if (placeHolders === 2) {\n			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n			push(tmp & 0xFF)\n		} else if (placeHolders === 1) {\n			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n			push((tmp >> 8) & 0xFF)\n			push(tmp & 0xFF)\n		}\n\n		return arr\n	}\n\n	function uint8ToBase64 (uint8) {\n		var i,\n			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n			output = \"\",\n			temp, length\n\n		function encode (num) {\n			return lookup.charAt(num)\n		}\n\n		function tripletToBase64 (num) {\n			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n		}\n\n		// go through the array every three bytes, we'll deal with trailing stuff later\n		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n			output += tripletToBase64(temp)\n		}\n\n		// pad the end with zeros, but make sure to not forget the extra bytes\n		switch (extraBytes) {\n			case 1:\n				temp = uint8[uint8.length - 1]\n				output += encode(temp >> 2)\n				output += encode((temp << 4) & 0x3F)\n				output += '=='\n				break\n			case 2:\n				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n				output += encode(temp >> 10)\n				output += encode((temp >> 4) & 0x3F)\n				output += encode((temp << 2) & 0x3F)\n				output += '='\n				break\n		}\n\n		return output\n	}\n\n	exports.toByteArray = b64ToByteArray\n	exports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n\n},{}],52:[function(require,module,exports){\nexports.read = function(buffer, offset, isLE, mLen, nBytes) {\n  var e, m,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      nBits = -7,\n      i = isLE ? (nBytes - 1) : 0,\n      d = isLE ? -1 : 1,\n      s = buffer[offset + i];\n\n  i += d;\n\n  e = s & ((1 << (-nBits)) - 1);\n  s >>= (-nBits);\n  nBits += eLen;\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  m = e & ((1 << (-nBits)) - 1);\n  e >>= (-nBits);\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);\n\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity);\n  } else {\n    m = m + Math.pow(2, mLen);\n    e = e - eBias;\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n};\n\nexports.write = function(buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c,\n      eLen = nBytes * 8 - mLen - 1,\n      eMax = (1 << eLen) - 1,\n      eBias = eMax >> 1,\n      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),\n      i = isLE ? 0 : (nBytes - 1),\n      d = isLE ? 1 : -1,\n      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;\n\n  value = Math.abs(value);\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0;\n    e = eMax;\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2);\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * Math.pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n      e = 0;\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);\n\n  e = (e << mLen) | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);\n\n  buffer[offset + i - d] |= s * 128;\n};\n\n},{}],53:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    if (canPost) {\n        var queue = [];\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n}\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n},{}]},{},[2])(2)\n});\n//# sourceURL=/thirdparty/makedrive/client/dist/makedrive.js"),eval('define(\'text!filesystem/impls/makedrive/open-dialog.html\',[],function () { return \'<div class="makedrive modal">\\r\\n    <div class="modal-header">\\r\\n        <h1 class="dialog-title">{{title}}</h1>\\r\\n    </div>\\r\\n\\r\\n    <div class="modal-body">\\r\\n      <div class="open-files-container jstree-makedrive"></div>\\r\\n    </div>\\r\\n\\r\\n    <div class="modal-footer">\\r\\n        <button class="dialog-button btn" data-button-id="cancel">{{cancel}}</button>\\r\\n        <button class="dialog-button btn" data-button-id="open">{{open}}</button>\\r\\n    </div>\\r\\n</div>\\r\\n\';});\n\n//# sourceURL=/text!filesystem/impls/makedrive/open-dialog.html'),eval('/*global define, $, brackets, Mustache, console */\r\ndefine(\'filesystem/impls/makedrive/open-dialog\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'widgets/Dialogs\',\'filesystem/FileSystem\',\'text!filesystem/impls/makedrive/open-dialog.html\'],function (require, exports, module) {\r\n  "use strict";\r\n\r\n  var _ = require("thirdparty/lodash");\r\n  var Dialogs = require("widgets/Dialogs");\r\n  var FileSystem = require("filesystem/FileSystem");\r\n  var ViewUtils = brackets.getModule("utils/ViewUtils");\r\n  var openDialog = require("text!filesystem/impls/makedrive/open-dialog.html");\r\n\r\n  var nodeId = 0;\r\n\r\n  function fileToTreeJSON(file) {\r\n    var json = {\r\n      data: file.name,\r\n      attr: { id: "node" + nodeId++ },\r\n      metadata: {\r\n        file: file\r\n      }\r\n    };\r\n\r\n    if (file.isDirectory) {\r\n      json.children = [];\r\n      json.state = "closed";\r\n      json.data = _.escape(json.data);\r\n    } else {\r\n      json.data = ViewUtils.getFileEntryDisplay(file);\r\n    }\r\n\r\n    return json;\r\n  }\r\n\r\n  // TODO: support all args here\r\n  function showOpenDialog(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback) {\r\n\r\n    function initializeEventHandlers($dialog) {\r\n      $dialog.find(".dialog-button[data-button-id=\'cancel\']")\r\n        .on("click", closeModal);\r\n\r\n      $(window).on(\'keydown.makedrive\', function (event) {\r\n        if (event.keyCode === 27) {\r\n          closeModal();\r\n        }\r\n      });\r\n\r\n      $dialog.find(".dialog-button[data-button-id=\'open\']").on("click", function () {\r\n        var paths = $dialog.find(\'.jstree-clicked\')\r\n          .closest(\'li\')\r\n          .map(function() {\r\n            return $(this).data().file.fullPath;\r\n          })\r\n          .get();\r\n\r\n        if (!paths.length) { return; }\r\n\r\n        closeModal();\r\n        callback(null, paths);\r\n      });\r\n    }\r\n\r\n    function fileTreeDataProvider($tree, callback) {\r\n      var directory;\r\n\r\n      // $tree is -1 when requesting the root\r\n      if ($tree === -1) {\r\n        directory = FileSystem.getDirectoryForPath(initialPath);\r\n      } else {\r\n        directory = $tree.data(\'file\');\r\n      }\r\n\r\n      directory.getContents(function(err, files) {\r\n        var json = files.map(fileToTreeJSON);\r\n        callback(json);\r\n      });\r\n    }\r\n\r\n    function handleFileDoubleClick(event) {\r\n      var file = $(event.target).closest(\'li\').data(\'file\');\r\n\r\n      if (file && file.isFile) {\r\n        callback(null, [file.fullPath]);\r\n        closeModal();\r\n      }\r\n    }\r\n\r\n    function closeModal() {\r\n      if(dialog) {\r\n        dialog.close();\r\n      }\r\n    }\r\n\r\n    var data = {\r\n      title: title,\r\n      cancel: "Cancel",\r\n      open: "Open"\r\n    };\r\n\r\n    var dialog = Dialogs.showModalDialogUsingTemplate(Mustache.render(openDialog, data), false);\r\n\r\n    var $dialog = $(".makedrive.instance");\r\n\r\n    initializeEventHandlers($dialog);\r\n\r\n    var $container = $dialog.find(\'.open-files-container\');\r\n\r\n    var jstree = $container.jstree({\r\n      plugins: ["ui", "themes", "json_data", "crrm"],\r\n      json_data: {\r\n        data: fileTreeDataProvider,\r\n        correct_state: false },\r\n      core: {\r\n        html_titles: true,\r\n        animation: 0,\r\n        strings : {\r\n          loading : "Loading",\r\n          new_node : "New node"\r\n        }\r\n      },\r\n      themes: {\r\n        theme: "brackets",\r\n        url: "styles/jsTreeTheme.css",\r\n        dots: false,\r\n        icons: false\r\n      }\r\n    });\r\n\r\n    jstree.on(\'dblclick.jstree\', handleFileDoubleClick);\r\n  }\r\n\r\n  exports.showOpenDialog = showOpenDialog;\r\n\r\n});\r\n\n//# sourceURL=/filesystem/impls/makedrive/open-dialog.js'),eval("/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, appshell, $, window */\r\n\r\ndefine('fileSystemImpl',['require','exports','module','filesystem/FileSystemError','filesystem/FileSystemStats','widgets/Dialogs','widgets/DefaultDialogs','thirdparty/makedrive/client/dist/makedrive','filesystem/impls/makedrive/open-dialog'],function (require, exports, module) {\r\n    \"use strict\";\r\n\r\n    var FileSystemError = require(\"filesystem/FileSystemError\"),\r\n        FileSystemStats = require(\"filesystem/FileSystemStats\"),\r\n        Dialogs         = require(\"widgets/Dialogs\"),\r\n        DefaultDialogs  = require(\"widgets/DefaultDialogs\"),\r\n        // TODO: we have to figure out how we're going to build/deploy makedrive.js, this is hacky.\r\n        // since it requires a manual `grunt build` step in src/thirdparty/makedrive\r\n        MakeDrive       = require(\"thirdparty/makedrive/client/dist/makedrive\"),\r\n        OpenDialog      = require(\"filesystem/impls/makedrive/open-dialog\");\r\n\r\n    var fs              = MakeDrive.fs(),\r\n        Path            = MakeDrive.Path,\r\n        watchers        = {};\r\n\r\n    var _changeCallback;            // Callback to notify FileSystem of watcher changes\r\n\r\n    // Give extensions access to MakeDrive's sync functionality. The hosting app\r\n    // needs to call sync.connect(serverURL) when the user is logged in, for example.\r\n    appshell.MakeDrive = MakeDrive;\r\n\r\n    var sync = fs.sync;\r\n\r\n    // Try to upgrade to a syncing filesystem\r\n    sync.connect('ws://localhost:9090');\r\n\r\n    //TODO: Do we want to do anything other than console.log for all these events?\r\n    sync.on('syncing', function() {\r\n        console.log('sync started');\r\n    });\r\n    sync.on('error', function(e) {\r\n        console.log('sync error: ', e);\r\n    });\r\n    sync.on('completed', function() {\r\n        console.log('sync completed');\r\n    });\r\n    sync.on('updates', function() {\r\n        console.log('server has updates');\r\n    });\r\n\r\n    function showOpenDialog(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback) {\r\n        OpenDialog.showOpenDialog.apply(null, arguments);\r\n    }\r\n\r\n    function showSaveDialog(title, initialPath, defaultName, callback) {\r\n        var selectedPath;\r\n        var saveResponse = window.prompt(title, defaultName);\r\n        if(saveResponse){\r\n            initialPath = initialPath || '/';\r\n            selectedPath = initialPath + saveResponse;\r\n            callback(null, selectedPath);\r\n        }\r\n        else{\r\n            callback();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert Filer error codes to FileSystemError values.\r\n     *\r\n     * @param {?number} err A Filer error code\r\n     * @return {?string} A FileSystemError string, or null if there was no error code.\r\n     * @private\r\n     **/\r\n    function _mapError(err) {\r\n        if (!err) {\r\n            return null;\r\n        }\r\n\r\n        switch (err.code) {\r\n        case 'EINVAL':\r\n            return FileSystemError.INVALID_PARAMS;\r\n        case 'ENOENT':\r\n            return FileSystemError.NOT_FOUND;\r\n        case 'EROFS':\r\n            return FileSystemError.NOT_WRITABLE;\r\n        case 'ENOSPC':\r\n            return FileSystemError.OUT_OF_SPACE;\r\n        case 'ENOTEMPTY':\r\n        case 'EEXIST':\r\n            return FileSystemError.ALREADY_EXISTS;\r\n        case 'ENOTDIR':\r\n            return FileSystemError.INVALID_PARAMS;\r\n        case 'EBADF':\r\n            return FileSystemError.NOT_READABLE;\r\n        }\r\n\r\n        return FileSystemError.UNKNOWN;\r\n    }\r\n\r\n    /**\r\n     * Convert a callback to one that transforms its first parameter from a\r\n     * Filer error code to a FileSystemError string.\r\n     *\r\n     * @param {function(?number)} cb A callback that expects an Filer error code\r\n     * @return {function(?string)} A callback that expects a FileSystemError string\r\n     * @private\r\n     **/\r\n    function _wrap(cb) {\r\n        return function (err) {\r\n            var args = Array.prototype.slice.call(arguments);\r\n            args[0] = _mapError(args[0]);\r\n            cb.apply(null, args);\r\n        };\r\n    }\r\n\r\n    function stat(path, callback) {\r\n        fs.stat(path, function(err, stats) {\r\n            if (err){\r\n                callback(_mapError(err));\r\n                return;\r\n            }\r\n\r\n            var mtime = new Date(stats.mtime);\r\n\r\n            var options = {\r\n                isFile: stats.isFile(),\r\n                mtime: mtime,\r\n                size: stats.size,\r\n                // TODO: figure out how to deal with realPath\r\n                realPath: path,\r\n                hash: mtime.getTime()\r\n            };\r\n\r\n            var fsStats = new FileSystemStats(options);\r\n\r\n            callback(null, fsStats);\r\n        });\r\n    }\r\n\r\n\r\n    function exists(path, callback) {\r\n        fs.exists(path, function(exists) {\r\n            callback(null, exists);\r\n        });\r\n    }\r\n\r\n    function readdir(path, callback) {\r\n        path = Path.normalize(path);\r\n\r\n        fs.readdir(path, function (err, contents) {\r\n            if (err) {\r\n                callback(_mapError(err));\r\n                return;\r\n            }\r\n\r\n            var count = contents.length;\r\n            if (!count) {\r\n                callback(null, [], []);\r\n                return;\r\n            }\r\n\r\n            var stats = [];\r\n            contents.forEach(function (val, idx) {\r\n                stat(Path.join(path, val), function (err, stat) {\r\n                    stats[idx] = err || stat;\r\n                    count--;\r\n                    if (count <= 0) {\r\n                        callback(null, contents, stats);\r\n                    }\r\n                });\r\n            });\r\n        });\r\n    }\r\n\r\n    function mkdir(path, mode, callback) {\r\n        if(typeof mode === 'function') {\r\n            callback = mode;\r\n        }\r\n\r\n        fs.mkdir(path, mode, function (err) {\r\n            if (err) {\r\n                callback(_mapError(err));\r\n                return;\r\n            }\r\n            stat(path, callback);\r\n        });\r\n    }\r\n\r\n    function rename(oldPath, newPath, callback) {\r\n        fs.rename(oldPath, newPath, _wrap(callback));\r\n    }\r\n\r\n    function readFile(path, options, callback) {\r\n        if(typeof options === 'function') {\r\n            callback = options;\r\n        }\r\n        options = options || {};\r\n\r\n        var encoding = options.encoding || \"utf8\";\r\n\r\n        // Execute the read and stat calls in parallel. Callback early if the\r\n        // read call completes first with an error; otherwise wait for both\r\n        // to finish.\r\n        var done = false, data, stat, err;\r\n\r\n        if (options.stat) {\r\n            done = true;\r\n            stat = options.stat;\r\n        } else {\r\n            exports.stat(path, function (_err, _stat) {\r\n                if (done) {\r\n                    callback(_err, _err ? null : data, _stat);\r\n                } else {\r\n                    done = true;\r\n                    stat = _stat;\r\n                    err = _err;\r\n                }\r\n            });\r\n        }\r\n\r\n        fs.readFile(path, encoding, function (_err, _data) {\r\n            if (_err) {\r\n                callback(_mapError(_err));\r\n                return;\r\n            }\r\n\r\n            if (done) {\r\n                callback(err, err ? null : _data, stat);\r\n            } else {\r\n                done = true;\r\n                data = _data;\r\n            }\r\n        });\r\n    }\r\n\r\n    function writeFile(path, data, options, callback) {\r\n        if(typeof options === 'function') {\r\n            callback = options;\r\n        }\r\n        options = options || {};\r\n\r\n        var encoding = options.encoding || \"utf8\";\r\n\r\n        function _finishWrite(created) {\r\n            fs.writeFile(path, data, encoding, function (err) {\r\n                if (err) {\r\n                    callback(_mapError(err));\r\n                    return;\r\n                }\r\n                stat(path, function (err, stat) {\r\n                    callback(err, stat, created);\r\n                });\r\n            });\r\n        }\r\n\r\n        stat(path, function (err, stats) {\r\n            if (err) {\r\n                switch (err) {\r\n                case FileSystemError.NOT_FOUND:\r\n                    _finishWrite(true);\r\n                    break;\r\n                default:\r\n                    callback(err);\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (options.hasOwnProperty(\"expectedHash\") && options.expectedHash !== stats._hash) {\r\n                console.error(\"Blind write attempted: \", path, stats._hash, options.expectedHash);\r\n\r\n                if (options.hasOwnProperty(\"expectedContents\")) {\r\n                    fs.readFile(path, encoding, function (_err, _data) {\r\n                        if (_err || _data !== options.expectedContents) {\r\n                            callback(FileSystemError.CONTENTS_MODIFIED);\r\n                            return;\r\n                        }\r\n\r\n                        _finishWrite(false);\r\n                    });\r\n                    return;\r\n                } else {\r\n                    callback(FileSystemError.CONTENTS_MODIFIED);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            _finishWrite(false);\r\n        });\r\n    }\r\n\r\n    function unlink(path, callback) {\r\n        fs.unlink(path, function(err){\r\n            callback(_mapError(err));\r\n        });\r\n    }\r\n\r\n    function moveToTrash(path, callback) {\r\n        // TODO: do we want to support a .trash/ dir or the like?\r\n        unlink(path, callback);\r\n    }\r\n\r\n    function initWatchers(changeCallback, offlineCallback) {\r\n        _changeCallback = changeCallback;\r\n    }\r\n\r\n    function watchPath(path, callback) {\r\n        path = Path.normalize(path);\r\n\r\n        if(watchers[path]) {\r\n            return;\r\n        }\r\n        watchers[path] = fs.watch(path, {recursive: true}, function(event, filename) {\r\n            stat(filename, function(err, stats) {\r\n              if(err) {\r\n                  return;\r\n              }\r\n              _changeCallback(filename, stats);\r\n            });\r\n        });\r\n        callback();\r\n    }\r\n\r\n    function unwatchPath(path, callback) {\r\n        path = Path.normalize(path);\r\n\r\n        if(watchers[path]) {\r\n            watchers[path].close();\r\n            delete watchers[path];\r\n        }\r\n        callback();\r\n    }\r\n\r\n    function unwatchAll(callback) {\r\n        Object.keys(watchers).forEach(function(path) {\r\n            unwatchPath(path, function(){});\r\n        });\r\n        callback();\r\n    }\r\n\r\n    // Export public API\r\n    exports.showOpenDialog  = showOpenDialog;\r\n    exports.showSaveDialog  = showSaveDialog;\r\n    exports.exists          = exists;\r\n    exports.readdir         = readdir;\r\n    exports.mkdir           = mkdir;\r\n    exports.rename          = rename;\r\n    exports.stat            = stat;\r\n    exports.readFile        = readFile;\r\n    exports.writeFile       = writeFile;\r\n    exports.unlink          = unlink;\r\n    exports.moveToTrash     = moveToTrash;\r\n    exports.initWatchers    = initWatchers;\r\n    exports.watchPath       = watchPath;\r\n    exports.unwatchPath     = unwatchPath;\r\n    exports.unwatchAll      = unwatchAll;\r\n\r\n    exports.recursiveWatch    = true;\r\n    exports.normalizeUNCPaths = false;\r\n});\r\n\n//# sourceURL=/filesystem/impls/makedrive/MakeDriveFileSystem.js"),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n/**\r\n * FileSystem is a model object representing a complete file system. This object creates\r\n * and manages File and Directory instances, dispatches events when the file system changes,\r\n * and provides methods for showing \'open\' and \'save\' dialogs.\r\n *\r\n * FileSystem automatically initializes when loaded. It depends on a pluggable "impl" layer, which\r\n * it loads itself but must be designated in the require.config() that loads FileSystem. For details\r\n * see: https://github.com/adobe/brackets/wiki/File-System-Implementations\r\n *\r\n * There are three ways to get File or Directory instances:\r\n *    * Use FileSystem.resolve() to convert a path to a File/Directory object. This will only\r\n *      succeed if the file/directory already exists.\r\n *    * Use FileSystem.getFileForPath()/FileSystem.getDirectoryForPath() if you know the\r\n *      file/directory already exists, or if you want to create a new entry.\r\n *    * Use Directory.getContents() to return all entries for the specified Directory.\r\n * \r\n * All paths passed *to* FileSystem APIs must be in the following format:\r\n *    * The path separator is "/" regardless of platform\r\n *    * Paths begin with "/" on Mac/Linux and "c:/" (or some other drive letter) on Windows\r\n * \r\n * All paths returned *from* FileSystem APIs additionally meet the following guarantees:\r\n *    * No ".." segments\r\n *    * No consecutive "/"s\r\n *    * Paths to a directory always end with a trailing "/"\r\n * (Because FileSystem normalizes paths automatically, paths passed *to* FileSystem do not need\r\n * to meet these requirements)\r\n * \r\n * FileSystem dispatches the following events:\r\n * (NOTE: attach to these events via `FileSystem.on()` - not `$(FileSystem).on()`)\r\n * \r\n * __change__ - Sent whenever there is a change in the file system. The handler\r\n *   is passed up to three arguments: the changed entry and, if that changed entry \r\n *   is a Directory, a list of entries added to the directory and a list of entries \r\n *   removed from the Directory. The entry argument can be:\r\n *   *  a File - the contents of the file have changed, and should be reloaded.\r\n *   *  a Directory - an immediate child of the directory has been added, removed,\r\n *      or renamed/moved. Not triggered for "grandchildren".\r\n *      - If the added & removed arguments are null, we don\'t know what was added/removed:\r\n *        clients should assume the whole subtree may have changed.\r\n *      - If the added & removed arguments are 0-length, there\'s no net change in the set\r\n *        of files but a file may have been replaced: clients should assume the contents\r\n *        of any immediate child file may have changed.\r\n *   *  null - a \'wholesale\' change happened, and you should assume everything may\r\n *      have changed.\r\n *   For changes made externally, there may be a significant delay before a "change" event\r\n *   is dispatched.\r\n *\r\n * __rename__ - Sent whenever a File or Directory is renamed. All affected File and Directory\r\n *   objects have been updated to reflect the new path by the time this event is dispatched.\r\n *   This event should be used to trigger any UI updates that may need to occur when a path\r\n *   has changed. Note that these events will only be sent for rename operations that happen\r\n *   within the filesystem. If a file is renamed externally, a change event on the parent\r\n *   directory will be sent instead.\r\n * \r\n * FileSystem may perform caching. But it guarantees:\r\n *    * File contents & metadata - reads are guaranteed to be up to date (cached data is not used\r\n *      without first veryifying it is up to date).\r\n *    * Directory structure / file listing - reads may return cached data immediately, which may not\r\n *      reflect external changes made recently. (However, changes made via FileSystem itself are always\r\n *      reflected immediately, as soon as the change operation\'s callback signals success).\r\n *\r\n * The FileSystem doesn\'t directly read or write contents--this work is done by a low-level\r\n * implementation object. This allows client code to use the FileSystem API without having to\r\n * worry about the underlying storage, which could be a local filesystem or a remote server.\r\n */\r\ndefine(\'filesystem/FileSystem\',[\'require\',\'exports\',\'module\',\'filesystem/Directory\',\'filesystem/File\',\'filesystem/FileIndex\',\'filesystem/FileSystemError\',\'filesystem/WatchedRoot\',\'fileSystemImpl\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var Directory       = require("filesystem/Directory"),\r\n        File            = require("filesystem/File"),\r\n        FileIndex       = require("filesystem/FileIndex"),\r\n        FileSystemError = require("filesystem/FileSystemError"),\r\n        WatchedRoot     = require("filesystem/WatchedRoot");\r\n    \r\n    /**\r\n     * The FileSystem is not usable until init() signals its callback.\r\n     * @constructor\r\n     */\r\n    function FileSystem() {\r\n        // Create a file index\r\n        this._index = new FileIndex();\r\n        \r\n        // Initialize the set of watched roots\r\n        this._watchedRoots = {};\r\n\r\n        // Initialize the watch/unwatch request queue\r\n        this._watchRequests = [];\r\n        \r\n        // Initialize the queue of pending external changes\r\n        this._externalChanges = [];\r\n    }\r\n    \r\n    /**\r\n     * The low-level file system implementation used by this object. \r\n     * This is set in the init() function and cannot be changed.\r\n     */\r\n    FileSystem.prototype._impl = null;\r\n    \r\n    /**\r\n     * The FileIndex used by this object. This is initialized in the constructor.\r\n     */\r\n    FileSystem.prototype._index = null;\r\n    \r\n    /**\r\n     * Refcount of any pending filesystem mutation operations (e.g., writes,\r\n     * unlinks, etc.). Used to ensure that external change events aren\'t processed\r\n     * until after index fixups, operation-specific callbacks, and internal change\r\n     * events are complete. (This is important for distinguishing rename from\r\n     * an unrelated delete-add pair).\r\n     * @type {number}\r\n     */\r\n    FileSystem.prototype._activeChangeCount = 0;\r\n    \r\n    // For unit testing only\r\n    FileSystem.prototype._getActiveChangeCount = function () {\r\n        return this._activeChangeCount;\r\n    };\r\n    \r\n    /**\r\n     * Queue of arguments with which to invoke _handleExternalChanges(); triggered\r\n     * once _activeChangeCount drops to zero.\r\n     * @type {!Array.<{path:?string, stat:FileSystemStats=}>}\r\n     */\r\n    FileSystem.prototype._externalChanges = null;\r\n    \r\n    /** Process all queued watcher results, by calling _handleExternalChange() on each */\r\n    FileSystem.prototype._triggerExternalChangesNow = function () {\r\n        this._externalChanges.forEach(function (info) {\r\n            this._handleExternalChange(info.path, info.stat);\r\n        }, this);\r\n        this._externalChanges.length = 0;\r\n    };\r\n    \r\n    /**\r\n     * Receives a result from the impl\'s watcher callback, and either processes it\r\n     * immediately (if _activeChangeCount is 0) or otherwise stores it for later\r\n     * processing.\r\n     * @param {?string} path The fullPath of the changed entry\r\n     * @param {FileSystemStats=} stat An optional stat object for the changed entry\r\n     */\r\n    FileSystem.prototype._enqueueExternalChange = function (path, stat) {\r\n        this._externalChanges.push({path: path, stat: stat});\r\n        if (!this._activeChangeCount) {\r\n            this._triggerExternalChangesNow();\r\n        }\r\n    };\r\n    \r\n\r\n    /**\r\n     * The queue of pending watch/unwatch requests.\r\n     * @type {Array.<{fn: function(), cb: function()}>}\r\n     */\r\n    FileSystem.prototype._watchRequests = null;\r\n    \r\n    /**\r\n     * Dequeue and process all pending watch/unwatch requests\r\n     */\r\n    FileSystem.prototype._dequeueWatchRequest = function () {\r\n        if (this._watchRequests.length > 0) {\r\n            var request = this._watchRequests[0];\r\n            \r\n            request.fn.call(null, function () {\r\n                // Apply the given callback\r\n                var callbackArgs = arguments;\r\n                try {\r\n                    request.cb.apply(null, callbackArgs);\r\n                } finally {\r\n                    // Process the remaining watch/unwatch requests\r\n                    this._watchRequests.shift();\r\n                    this._dequeueWatchRequest();\r\n                }\r\n            }.bind(this));\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Enqueue a new watch/unwatch request.\r\n     *\r\n     * @param {function()} fn - The watch/unwatch request function.\r\n     * @param {callback()} cb - The callback for the provided watch/unwatch\r\n     *      request function.\r\n     */\r\n    FileSystem.prototype._enqueueWatchRequest = function (fn, cb) {\r\n        // Enqueue the given watch/unwatch request\r\n        this._watchRequests.push({fn: fn, cb: cb});\r\n\r\n        // Begin processing the queue if it is not already being processed\r\n        if (this._watchRequests.length === 1) {\r\n            this._dequeueWatchRequest();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * The set of watched roots, encoded as a mapping from full paths to WatchedRoot\r\n     * objects which contain a file entry, filter function, and an indication of\r\n     * whether the watched root is inactive, starting up or fully active.\r\n     * \r\n     * @type {Object.<string, WatchedRoot>}\r\n     */\r\n    FileSystem.prototype._watchedRoots = null;\r\n    \r\n    /**\r\n     * Finds a parent watched root for a given path, or returns null if a parent\r\n     * watched root does not exist.\r\n     * \r\n     * @param {string} fullPath The child path for which a parent watched root is to be found\r\n     * @return {?{entry: FileSystemEntry, filter: function(string) boolean}} The parent\r\n     *      watched root, if it exists, or null.\r\n     */\r\n    FileSystem.prototype._findWatchedRootForPath = function (fullPath) {\r\n        var watchedRoot = null;\r\n        \r\n        Object.keys(this._watchedRoots).some(function (watchedPath) {\r\n            if (fullPath.indexOf(watchedPath) === 0) {\r\n                watchedRoot = this._watchedRoots[watchedPath];\r\n                return true;\r\n            }\r\n        }, this);\r\n        \r\n        return watchedRoot;\r\n    };\r\n    \r\n    /**\r\n     * Helper function to watch or unwatch a filesystem entry beneath a given\r\n     * watchedRoot.\r\n     * \r\n     * @private\r\n     * @param {FileSystemEntry} entry - The FileSystemEntry to watch. Must be a\r\n     *      non-strict descendent of watchedRoot.entry.\r\n     * @param {WatchedRoot} watchedRoot - See FileSystem._watchedRoots.\r\n     * @param {function(?string)} callback - A function that is called once the\r\n     *      watch is complete, possibly with a FileSystemError string.\r\n     * @param {boolean} shouldWatch - Whether the entry should be watched (true)\r\n     *      or unwatched (false).\r\n     */\r\n    FileSystem.prototype._watchOrUnwatchEntry = function (entry, watchedRoot, callback, shouldWatch) {\r\n        var impl = this._impl,\r\n            recursiveWatch = impl.recursiveWatch,\r\n            commandName = shouldWatch ? "watchPath" : "unwatchPath";\r\n\r\n        if (recursiveWatch) {\r\n            // The impl can watch the entire subtree with one call on the root (we also fall into this case for\r\n            // unwatch, although that never requires us to do the recursion - see similar final case below)\r\n            if (entry !== watchedRoot.entry) {\r\n                // Watch and unwatch calls to children of the watched root are\r\n                // no-ops if the impl supports recursiveWatch\r\n                callback(null);\r\n            } else {\r\n                // The impl will handle finding all subdirectories to watch. \r\n                this._enqueueWatchRequest(function (requestCb) {\r\n                    impl[commandName].call(impl, entry.fullPath, requestCb);\r\n                }.bind(this), callback);\r\n            }\r\n        } else if (shouldWatch) {\r\n            // The impl can\'t handle recursive watch requests, so it\'s up to the\r\n            // filesystem to recursively watch all subdirectories.\r\n            this._enqueueWatchRequest(function (requestCb) {\r\n                // First construct a list of entries to watch or unwatch\r\n                var entriesToWatch = [];\r\n                \r\n                var visitor = function (child) {\r\n                    if (watchedRoot.filter(child.name, child.parentPath)) {\r\n                        if (child.isDirectory || child === watchedRoot.entry) {\r\n                            entriesToWatch.push(child);\r\n                        }\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                };\r\n                \r\n                entry.visit(visitor, function (err) {\r\n                    if (err) {\r\n                        // Unexpected error\r\n                        requestCb(err);\r\n                        return;\r\n                    }\r\n                    \r\n                    // Then watch or unwatched all these entries\r\n                    var count = entriesToWatch.length;\r\n                    if (count === 0) {\r\n                        requestCb(null);\r\n                        return;\r\n                    }\r\n                    \r\n                    var watchCallback = function () {\r\n                        if (--count === 0) {\r\n                            requestCb(null);\r\n                        }\r\n                    };\r\n                    \r\n                    entriesToWatch.forEach(function (entry) {\r\n                        impl.watchPath(entry.fullPath, watchCallback);\r\n                    });\r\n                });\r\n            }, callback);\r\n        } else {\r\n            // Unwatching never requires enumerating the subfolders (which is good, since after a\r\n            // delete/rename we may be unable to do so anyway)\r\n            this._enqueueWatchRequest(function (requestCb) {\r\n                impl.unwatchPath(entry.fullPath, requestCb);\r\n            }, callback);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Watch a filesystem entry beneath a given watchedRoot.\r\n     * \r\n     * @private\r\n     * @param {FileSystemEntry} entry - The FileSystemEntry to watch. Must be a\r\n     *      non-strict descendent of watchedRoot.entry.\r\n     * @param {WatchedRoot} watchedRoot - See FileSystem._watchedRoots.\r\n     * @param {function(?string)} callback - A function that is called once the\r\n     *      watch is complete, possibly with a FileSystemError string.\r\n     */\r\n    FileSystem.prototype._watchEntry = function (entry, watchedRoot, callback) {\r\n        this._watchOrUnwatchEntry(entry, watchedRoot, callback, true);\r\n    };\r\n\r\n    /**\r\n     * Unwatch a filesystem entry beneath a given watchedRoot.\r\n     * \r\n     * @private\r\n     * @param {FileSystemEntry} entry - The FileSystemEntry to watch. Must be a\r\n     *      non-strict descendent of watchedRoot.entry.\r\n     * @param {WatchedRoot} watchedRoot - See FileSystem._watchedRoots.\r\n     * @param {function(?string)} callback - A function that is called once the\r\n     *      watch is complete, possibly with a FileSystemError string.\r\n     */\r\n    FileSystem.prototype._unwatchEntry = function (entry, watchedRoot, callback) {\r\n        this._watchOrUnwatchEntry(entry, watchedRoot, function (err) {\r\n            // Make sure to clear cached data for all unwatched entries because\r\n            // entries always return cached data if it exists!\r\n            this._index.visitAll(function (child) {\r\n                if (child.fullPath.indexOf(entry.fullPath) === 0) {\r\n                    // \'true\' so entry doesn\'t try to clear its immediate childrens\' caches too. That would be redundant\r\n                    // with the visitAll() here, and could be slow if we\'ve already cleared its parent (#7150).\r\n                    child._clearCachedData(true);\r\n                }\r\n            }.bind(this));\r\n            \r\n            callback(err);\r\n        }.bind(this), false);\r\n    };\r\n    \r\n    /**\r\n     * Initialize this FileSystem instance.\r\n     * \r\n     * @param {FileSystemImpl} impl The back-end implementation for this\r\n     *      FileSystem instance.\r\n     */\r\n    FileSystem.prototype.init = function (impl) {\r\n        console.assert(!this._impl, "This FileSystem has already been initialized!");\r\n        \r\n        var changeCallback = this._enqueueExternalChange.bind(this),\r\n            offlineCallback = this._unwatchAll.bind(this);\r\n                \r\n        this._impl = impl;\r\n        this._impl.initWatchers(changeCallback, offlineCallback);\r\n    };\r\n    \r\n    /**\r\n     * Close a file system. Clear all caches, indexes, and file watchers.\r\n     */\r\n    FileSystem.prototype.close = function () {\r\n        this._impl.unwatchAll();\r\n        this._index.clear();\r\n    };\r\n    \r\n    /**\r\n     * Returns true if the given path should be automatically added to the index & watch list when one of its ancestors\r\n     * is a watch-root. (Files are added automatically when the watch-root is first established, or later when a new\r\n     * directory is created and its children enumerated).\r\n     * \r\n     * Entries explicitly created via FileSystem.getFile/DirectoryForPath() are *always* added to the index regardless\r\n     * of this filtering - but they will not be watched if the watch-root\'s filter excludes them.\r\n     * \r\n     * @param {string} path Full path\r\n     * @param {string} name Name portion of the path\r\n     */\r\n    FileSystem.prototype._indexFilter = function (path, name) {\r\n        var parentRoot = this._findWatchedRootForPath(path);\r\n                \r\n        if (parentRoot) {\r\n            return parentRoot.filter(name, path);\r\n        }\r\n        \r\n        // It might seem more sensible to return false (exclude) for files outside the watch roots, but\r\n        // that would break usage of appFileSystem for \'system\'-level things like enumerating extensions.\r\n        // (Or in general, Directory.getContents() for any Directory outside the watch roots).\r\n        return true;\r\n    };\r\n    \r\n    /**\r\n     * Indicates that a filesystem-mutating operation has begun. As long as there\r\n     * are changes taking place, change events from the external watchers are\r\n     * blocked and queued, to be handled once changes have finished. This is done\r\n     * because for mutating operations that originate from within the filesystem,\r\n     * synthetic change events are fired that do not depend on external file\r\n     * watchers, and we prefer the former over the latter for the following\r\n     * reasons: 1) there is no delay; and 2) they may have higher fidelity --- \r\n     * e.g., a rename operation can be detected as such, instead of as a nearly\r\n     * simultaneous addition and deletion.\r\n     * \r\n     * All operations that mutate the file system MUST begin with a call to \r\n     * _beginChange and must end with a call to _endChange.\r\n     */\r\n    FileSystem.prototype._beginChange = function () {\r\n        this._activeChangeCount++;\r\n        //console.log("> beginChange  -> " + this._activeChangeCount);\r\n    };\r\n    \r\n    /**\r\n     * Indicates that a filesystem-mutating operation has completed. See \r\n     * FileSystem._beginChange above.\r\n     */\r\n    FileSystem.prototype._endChange = function () {\r\n        this._activeChangeCount--;\r\n        //console.log("< endChange    -> " + this._activeChangeCount);\r\n        \r\n        if (this._activeChangeCount < 0) {\r\n            console.error("FileSystem _activeChangeCount has fallen below zero!");\r\n        }\r\n        \r\n        if (!this._activeChangeCount) {\r\n            this._triggerExternalChangesNow();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Determines whether or not the supplied path is absolute, as opposed to relative.\r\n     *\r\n     * @param {!string} fullPath\r\n     * @return {boolean} True if the fullPath is absolute and false otherwise.\r\n     */\r\n    FileSystem.isAbsolutePath = function (fullPath) {\r\n        return (fullPath[0] === "/" || (fullPath[1] === ":" && fullPath[2] === "/"));\r\n    };\r\n\r\n    function _ensureTrailingSlash(path) {\r\n        if (path[path.length - 1] !== "/") {\r\n            path += "/";\r\n        }\r\n\r\n        return path;\r\n    }\r\n    \r\n    /*\r\n     * Matches continguous groups of forward slashes\r\n     * @const\r\n     */\r\n    var _DUPLICATED_SLASH_RE = /\\/{2,}/g;\r\n    \r\n    /**\r\n     * Returns a canonical version of the path: no duplicated "/"es, no ".."s,\r\n     * and directories guaranteed to end in a trailing "/"\r\n     * @param {!string} path  Absolute path, using "/" as path separator\r\n     * @param {boolean=} isDirectory\r\n     * @return {!string}\r\n     */\r\n    FileSystem.prototype._normalizePath = function (path, isDirectory) {\r\n        \r\n        if (!FileSystem.isAbsolutePath(path)) {\r\n            throw new Error("Paths must be absolute: \'" + path + "\'");  // expect only absolute paths\r\n        }\r\n        \r\n        var isUNCPath = this._impl.normalizeUNCPaths && path.search(_DUPLICATED_SLASH_RE) === 0;\r\n        \r\n        // Remove duplicated "/"es\r\n        path = path.replace(_DUPLICATED_SLASH_RE, "/");\r\n        \r\n        // Remove ".." segments\r\n        if (path.indexOf("..") !== -1) {\r\n            var segments = path.split("/"),\r\n                i;\r\n            for (i = 1; i < segments.length; i++) {\r\n                if (segments[i] === "..") {\r\n                    if (i < 2) {\r\n                        throw new Error("Invalid absolute path: \'" + path + "\'");\r\n                    }\r\n                    segments.splice(i - 1, 2);\r\n                    i -= 2; // compensate so we start on the right index next iteration\r\n                }\r\n            }\r\n            path = segments.join("/");\r\n        }\r\n        \r\n        if (isDirectory) {\r\n            // Make sure path DOES include trailing slash\r\n            path = _ensureTrailingSlash(path);\r\n        }\r\n        \r\n        if (isUNCPath) {\r\n            // Restore the leading double slash that was removed previously\r\n            path = "/" + path;\r\n        }\r\n        \r\n        return path;\r\n    };\r\n\r\n    /**\r\n     * Return a (strict subclass of a) FileSystemEntry object for the specified\r\n     * path using the provided constuctor. For now, the provided constructor\r\n     * should be either File or Directory.\r\n     *\r\n     * @private\r\n     * @param {function(string, FileSystem)} EntryConstructor Constructor with\r\n     *      which to initialize new FileSystemEntry objects.\r\n     * @param {string} path Absolute path of file. \r\n     * @return {File|Directory} The File or Directory object. This file may not\r\n     *      yet exist on disk.\r\n     */\r\n    FileSystem.prototype._getEntryForPath = function (EntryConstructor, path) {\r\n        var isDirectory = EntryConstructor === Directory;\r\n        path = this._normalizePath(path, isDirectory);\r\n        var entry = this._index.getEntry(path);\r\n        \r\n        if (!entry) {\r\n            entry = new EntryConstructor(path, this);\r\n            this._index.addEntry(entry);\r\n        }\r\n                \r\n        return entry;\r\n    };\r\n    \r\n    /**\r\n     * Return a File object for the specified path.\r\n     *\r\n     * @param {string} path Absolute path of file. \r\n     *\r\n     * @return {File} The File object. This file may not yet exist on disk.\r\n     */\r\n    FileSystem.prototype.getFileForPath = function (path) {\r\n        return this._getEntryForPath(File, path);\r\n    };\r\n     \r\n    /**\r\n     * Return a Directory object for the specified path.\r\n     *\r\n     * @param {string} path Absolute path of directory.\r\n     *\r\n     * @return {Directory} The Directory object. This directory may not yet exist on disk.\r\n     */\r\n    FileSystem.prototype.getDirectoryForPath = function (path) {\r\n        return this._getEntryForPath(Directory, path);\r\n    };\r\n    \r\n    /**\r\n     * Resolve a path.\r\n     *\r\n     * @param {string} path The path to resolve\r\n     * @param {function (?string, FileSystemEntry=, FileSystemStats=)} callback Callback resolved\r\n     *      with a FileSystemError string or with the entry for the provided path.\r\n     */\r\n    FileSystem.prototype.resolve = function (path, callback) {\r\n        var normalizedPath = this._normalizePath(path, false),\r\n            item = this._index.getEntry(normalizedPath);\r\n\r\n        if (!item) {\r\n            normalizedPath = _ensureTrailingSlash(normalizedPath);\r\n            item = this._index.getEntry(normalizedPath);\r\n        }\r\n        \r\n        if (item) {\r\n            item.stat(function (err, stat) {\r\n                if (err) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                \r\n                callback(null, item, stat);\r\n            });\r\n        } else {\r\n            this._impl.stat(path, function (err, stat) {\r\n                if (err) {\r\n                    callback(err);\r\n                    return;\r\n                }\r\n                \r\n                if (stat.isFile) {\r\n                    item = this.getFileForPath(path);\r\n                } else {\r\n                    item = this.getDirectoryForPath(path);\r\n                }\r\n                \r\n                if (item._isWatched()) {\r\n                    item._stat = stat;\r\n                }\r\n                \r\n                callback(null, item, stat);\r\n            }.bind(this));\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Show an "Open" dialog and return the file(s)/directories selected by the user.\r\n     *\r\n     * @param {boolean} allowMultipleSelection Allows selecting more than one file at a time\r\n     * @param {boolean} chooseDirectories Allows directories to be opened\r\n     * @param {string} title The title of the dialog\r\n     * @param {string} initialPath The folder opened inside the window initially. If initialPath\r\n     *                          is not set, or it doesn\'t exist, the window would show the last\r\n     *                          browsed folder depending on the OS preferences\r\n     * @param {?Array.<string>} fileTypes (Currently *ignored* except on Mac - https://trello.com/c/430aXkpq)\r\n     *                          List of extensions that are allowed to be opened, without leading ".".\r\n     *                          Null or empty array allows all files to be selected. Not applicable\r\n     *                          when chooseDirectories = true.\r\n     * @param {function (?string, Array.<string>=)} callback Callback resolved with a FileSystemError\r\n     *                          string or the selected file(s)/directories. If the user cancels the\r\n     *                          open dialog, the error will be falsy and the file/directory array will\r\n     *                          be empty.\r\n     */\r\n    FileSystem.prototype.showOpenDialog = function (allowMultipleSelection,\r\n                            chooseDirectories,\r\n                            title,\r\n                            initialPath,\r\n                            fileTypes,\r\n                            callback) {\r\n        \r\n        this._impl.showOpenDialog(allowMultipleSelection, chooseDirectories, title, initialPath, fileTypes, callback);\r\n    };\r\n    \r\n    /**\r\n     * Show a "Save" dialog and return the path of the file to save.\r\n     *\r\n     * @param {string} title The title of the dialog.\r\n     * @param {string} initialPath The folder opened inside the window initially. If initialPath\r\n     *                          is not set, or it doesn\'t exist, the window would show the last\r\n     *                          browsed folder depending on the OS preferences.\r\n     * @param {string} proposedNewFilename Provide a new file name for the user. This could be based on\r\n     *                          on the current file name plus an additional suffix\r\n     * @param {function (?string, string=)} callback Callback that is resolved with a FileSystemError\r\n     *                          string or the name of the file to save. If the user cancels the save,\r\n     *                          the error will be falsy and the name will be empty.\r\n     */\r\n    FileSystem.prototype.showSaveDialog = function (title, initialPath, proposedNewFilename, callback) {\r\n        this._impl.showSaveDialog(title, initialPath, proposedNewFilename, callback);\r\n    };\r\n\r\n    /**\r\n     * Fire a rename event. Clients listen for these events using FileSystem.on.\r\n     * \r\n     * @param {string} oldPath The entry\'s previous fullPath\r\n     * @param {string} newPath The entry\'s current fullPath\r\n     */\r\n    FileSystem.prototype._fireRenameEvent = function (oldPath, newPath) {\r\n        $(this).trigger("rename", [oldPath, newPath]);\r\n    };\r\n\r\n    /**\r\n     * Fire a change event. Clients listen for these events using FileSystem.on.\r\n     * \r\n     * @param {File|Directory} entry The entry that has changed\r\n     * @param {Array<File|Directory>=} added If the entry is a directory, this\r\n     *      is a set of new entries in the directory.\r\n     * @param {Array<File|Directory>=} removed If the entry is a directory, this\r\n     *      is a set of removed entries from the directory.\r\n     */\r\n    FileSystem.prototype._fireChangeEvent = function (entry, added, removed) {\r\n        $(this).trigger("change", [entry, added, removed]);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Notify the system when an entry name has changed.\r\n     *\r\n     * @param {string} oldFullPath\r\n     * @param {string} newFullPath\r\n     * @param {boolean} isDirectory\r\n     */\r\n    FileSystem.prototype._handleRename = function (oldFullPath, newFullPath, isDirectory) {\r\n        // Update all affected entries in the index\r\n        this._index.entryRenamed(oldFullPath, newFullPath, isDirectory);\r\n    };\r\n    \r\n    /**\r\n     * Notify the filesystem that the given directory has changed. Updates the filesystem\'s\r\n     * internal state as a result of the change, and calls back with the set of added and\r\n     * removed entries. Mutating FileSystemEntry operations should call this method before\r\n     * applying the operation\'s callback, and pass along the resulting change sets in the\r\n     * internal change event.\r\n     * \r\n     * @param {Directory} directory The directory that has changed.\r\n     * @param {function(Array<File|Directory>=, Array<File|Directory>=)} callback\r\n     *      The callback that will be applied to a set of added and a set of removed\r\n     *      FileSystemEntry objects.\r\n     */\r\n    FileSystem.prototype._handleDirectoryChange = function (directory, callback) {\r\n        var oldContents = directory._contents;\r\n        \r\n        directory._clearCachedData();\r\n        directory.getContents(function (err, contents) {\r\n            var addedEntries = oldContents && contents.filter(function (entry) {\r\n                return oldContents.indexOf(entry) === -1;\r\n            });\r\n            \r\n            var removedEntries = oldContents && oldContents.filter(function (entry) {\r\n                return contents.indexOf(entry) === -1;\r\n            });\r\n\r\n            // If directory is not watched, clear children\'s caches manually.\r\n            var watchedRoot = this._findWatchedRootForPath(directory.fullPath);\r\n            if (!watchedRoot || !watchedRoot.filter(directory.name, directory.parentPath)) {\r\n                this._index.visitAll(function (entry) {\r\n                    if (entry.fullPath.indexOf(directory.fullPath) === 0) {\r\n                        // Passing \'true\' for a similar reason as in _unwatchEntry() - see #7150\r\n                        entry._clearCachedData(true);\r\n                    }\r\n                }.bind(this));\r\n                \r\n                callback(addedEntries, removedEntries);\r\n                return;\r\n            }\r\n\r\n            var addedCounter = addedEntries ? addedEntries.length : 0,\r\n                removedCounter = removedEntries ? removedEntries.length : 0,\r\n                counter = addedCounter + removedCounter;\r\n            \r\n            if (counter === 0) {\r\n                callback(addedEntries, removedEntries);\r\n                return;\r\n            }\r\n            \r\n            var watchOrUnwatchCallback = function (err) {\r\n                if (err) {\r\n                    console.error("FileSystem error in _handleDirectoryChange after watch/unwatch entries: " + err);\r\n                }\r\n                \r\n                if (--counter === 0) {\r\n                    callback(addedEntries, removedEntries);\r\n                }\r\n            };\r\n            \r\n            if (addedEntries) {\r\n                addedEntries.forEach(function (entry) {\r\n                    this._watchEntry(entry, watchedRoot, watchOrUnwatchCallback);\r\n                }, this);\r\n            }\r\n\r\n            if (removedEntries) {\r\n                removedEntries.forEach(function (entry) {\r\n                    this._unwatchEntry(entry, watchedRoot, watchOrUnwatchCallback);\r\n                }, this);\r\n            }\r\n        }.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Processes a result from the file/directory watchers. Watch results are sent from the low-level implementation\r\n     * whenever a directory or file is changed. \r\n     *\r\n     * @param {string} path The path that changed. This could be a file or a directory.\r\n     * @param {FileSystemStats=} stat Optional stat for the item that changed. This param is not always\r\n     *         passed. \r\n     */\r\n    FileSystem.prototype._handleExternalChange = function (path, stat) {\r\n\r\n        if (!path) {\r\n            // This is a "wholesale" change event; clear all caches\r\n            this._index.visitAll(function (entry) {\r\n                // Passing \'true\' for a similar reason as in _unwatchEntry() - see #7150\r\n                entry._clearCachedData(true);\r\n            });\r\n            \r\n            this._fireChangeEvent(null);\r\n            return;\r\n        }\r\n        \r\n        path = this._normalizePath(path, false);\r\n        \r\n        var entry = this._index.getEntry(path);\r\n        if (entry) {\r\n            var oldStat = entry._stat;\r\n            if (entry.isFile) {\r\n                // Update stat and clear contents, but only if out of date\r\n                if (!(stat && oldStat && stat.mtime.getTime() === oldStat.mtime.getTime())) {\r\n                    entry._clearCachedData();\r\n                    entry._stat = stat;\r\n                    this._fireChangeEvent(entry);\r\n                }\r\n            } else {\r\n                this._handleDirectoryChange(entry, function (added, removed) {\r\n                    entry._stat = stat;\r\n                    \r\n                    // We send a change even if added & removed are both zero-length. Something may still have changed,\r\n                    // e.g. a file may have been quickly removed & re-added before we got a chance to reread the directory\r\n                    // listing.\r\n                    this._fireChangeEvent(entry, added, removed);\r\n                }.bind(this));\r\n            }\r\n        }\r\n    };\r\n        \r\n    /**\r\n     * Start watching a filesystem root entry.\r\n     * \r\n     * @param {FileSystemEntry} entry - The root entry to watch. If entry is a directory,\r\n     *      all subdirectories that aren\'t explicitly filtered will also be watched.\r\n     * @param {function(string): boolean} filter - Returns true if a particular item should\r\n     *      be watched, given its name (not full path). Items that are ignored are also\r\n     *      filtered from Directory.getContents() results within this subtree.\r\n     * @param {function(?string)=} callback - A function that is called when the watch has\r\n     *      completed. If the watch fails, the function will have a non-null FileSystemError\r\n     *      string parametr.\r\n     */\r\n    FileSystem.prototype.watch = function (entry, filter, callback) {\r\n        var fullPath = entry.fullPath;\r\n        \r\n        callback = callback || function () {};\r\n        \r\n        var watchingParentRoot = this._findWatchedRootForPath(fullPath);\r\n        if (watchingParentRoot &&\r\n                (watchingParentRoot.status === WatchedRoot.STARTING ||\r\n                 watchingParentRoot.status === WatchedRoot.ACTIVE)) {\r\n            callback("A parent of this root is already watched");\r\n            return;\r\n        }\r\n\r\n        var watchingChildRoot = Object.keys(this._watchedRoots).some(function (path) {\r\n            var watchedRoot = this._watchedRoots[path],\r\n                watchedPath = watchedRoot.entry.fullPath;\r\n            \r\n            return watchedPath.indexOf(fullPath) === 0;\r\n        }, this);\r\n        \r\n        if (watchingChildRoot &&\r\n                (watchingChildRoot.status === WatchedRoot.STARTING ||\r\n                 watchingChildRoot.status === WatchedRoot.ACTIVE)) {\r\n            callback("A child of this root is already watched");\r\n            return;\r\n        }\r\n        \r\n        var watchedRoot = new WatchedRoot(entry, filter);\r\n        \r\n        this._watchedRoots[fullPath] = watchedRoot;\r\n\r\n        // Enter the STARTING state early to indiate that watched Directory\r\n        // objects may cache their contents. See FileSystemEntry._isWatched.\r\n        watchedRoot.status = WatchedRoot.STARTING;\r\n        \r\n        this._watchEntry(entry, watchedRoot, function (err) {\r\n            if (err) {\r\n                console.warn("Failed to watch root: ", entry.fullPath, err);\r\n                delete this._watchedRoots[fullPath];\r\n                callback(err);\r\n                return;\r\n            }\r\n\r\n            watchedRoot.status = WatchedRoot.ACTIVE;\r\n            \r\n            callback(null);\r\n        }.bind(this));\r\n    };\r\n\r\n    /**\r\n     * Stop watching a filesystem root entry.\r\n     * \r\n     * @param {FileSystemEntry} entry - The root entry to stop watching. The unwatch will\r\n     *      if the entry is not currently being watched.\r\n     * @param {function(?string)=} callback - A function that is called when the unwatch has\r\n     *      completed. If the unwatch fails, the function will have a non-null FileSystemError\r\n     *      string parameter.\r\n     */\r\n    FileSystem.prototype.unwatch = function (entry, callback) {\r\n        var fullPath = entry.fullPath,\r\n            watchedRoot = this._watchedRoots[fullPath];\r\n        \r\n        callback = callback || function () {};\r\n        \r\n        if (!watchedRoot) {\r\n            callback(FileSystemError.ROOT_NOT_WATCHED);\r\n            return;\r\n        }\r\n\r\n        // Mark this as inactive, but don\'t delete the entry until the unwatch is complete.\r\n        // This is useful for making sure we don\'t try to concurrently watch overlapping roots.\r\n        watchedRoot.status = WatchedRoot.INACTIVE;\r\n        \r\n        this._unwatchEntry(entry, watchedRoot, function (err) {\r\n            delete this._watchedRoots[fullPath];\r\n            \r\n            this._index.visitAll(function (child) {\r\n                if (child.fullPath.indexOf(entry.fullPath) === 0) {\r\n                    this._index.removeEntry(child);\r\n                }\r\n            }.bind(this));\r\n            \r\n            if (err) {\r\n                console.warn("Failed to unwatch root: ", entry.fullPath, err);\r\n                callback(err);\r\n                return;\r\n            }\r\n\r\n            callback(null);\r\n        }.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * Unwatch all watched roots. Calls unwatch on the underlying impl for each\r\n     * watched root and ignores errors.\r\n     * @private\r\n     */\r\n    FileSystem.prototype._unwatchAll = function () {\r\n        console.warn("File watchers went offline!");\r\n        \r\n        Object.keys(this._watchedRoots).forEach(function (path) {\r\n            var watchedRoot = this._watchedRoots[path];\r\n\r\n            watchedRoot.status = WatchedRoot.INACTIVE;\r\n            delete this._watchedRoots[path];\r\n            this._unwatchEntry(watchedRoot.entry, watchedRoot, function () {\r\n                console.warn("Watching disabled for", watchedRoot.entry.fullPath);\r\n            });\r\n        }, this);\r\n        \r\n        // Fire a wholesale change event, clearing all caches and request that\r\n        // clients manually update their state.\r\n        this._handleExternalChange(null);\r\n    };\r\n\r\n    \r\n    // The singleton instance\r\n    var _instance;\r\n\r\n    function _wrap(func) {\r\n        return function () {\r\n            return func.apply(_instance, arguments);\r\n        };\r\n    }\r\n    \r\n    // Export public methods as proxies to the singleton instance\r\n    exports.init = _wrap(FileSystem.prototype.init);\r\n    exports.close = _wrap(FileSystem.prototype.close);\r\n    exports.shouldShow = _wrap(FileSystem.prototype.shouldShow);\r\n    exports.getFileForPath = _wrap(FileSystem.prototype.getFileForPath);\r\n    exports.getDirectoryForPath = _wrap(FileSystem.prototype.getDirectoryForPath);\r\n    exports.resolve = _wrap(FileSystem.prototype.resolve);\r\n    exports.showOpenDialog = _wrap(FileSystem.prototype.showOpenDialog);\r\n    exports.showSaveDialog = _wrap(FileSystem.prototype.showSaveDialog);\r\n    exports.watch = _wrap(FileSystem.prototype.watch);\r\n    exports.unwatch = _wrap(FileSystem.prototype.unwatch);\r\n    \r\n    // Static public utility methods\r\n    exports.isAbsolutePath = FileSystem.isAbsolutePath;\r\n    \r\n    // For testing only\r\n    exports._getActiveChangeCount = _wrap(FileSystem.prototype._getActiveChangeCount);\r\n    \r\n    /**\r\n     * Add an event listener for a FileSystem event.\r\n     *\r\n     * @param {string} event The name of the event\r\n     * @param {function} handler The handler for the event\r\n     */\r\n    exports.on = function (event, handler) {\r\n        $(_instance).on(event, handler);\r\n    };\r\n    \r\n    /**\r\n     * Remove an event listener for a FileSystem event.\r\n     *\r\n     * @param {string} event The name of the event\r\n     * @param {function} handler The handler for the event\r\n     */\r\n    exports.off = function (event, handler) {\r\n        $(_instance).off(event, handler);\r\n    };\r\n    \r\n    // Export the FileSystem class as "private" for unit testing only.\r\n    exports._FileSystem = FileSystem;\r\n    \r\n    // Create the singleton instance\r\n    _instance = new FileSystem();\r\n    \r\n    // Initialize the singleton instance\r\n    _instance.init(require("fileSystemImpl"));\r\n});\r\n\n//# sourceURL=/filesystem/FileSystem.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets, less, PathUtils */\r\n\r\n/**\r\n * ExtensionUtils defines utility methods for implementing extensions.\r\n */\r\ndefine(\'utils/ExtensionUtils\',[\'require\',\'exports\',\'module\',\'filesystem/FileSystem\',\'file/FileUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var FileSystem = require("filesystem/FileSystem"),\r\n        FileUtils  = require("file/FileUtils");\r\n\r\n    /**\r\n     * Appends a <style> tag to the document\'s head.\r\n     *\r\n     * @param {!string} css CSS code to use as the tag\'s content\r\n     * @return {!HTMLStyleElement} The generated HTML node\r\n     **/\r\n    function addEmbeddedStyleSheet(css) {\r\n        return $("<style>").text(css).appendTo("head")[0];\r\n    }\r\n    \r\n    /**\r\n     * Appends a <link> tag to the document\'s head.\r\n     *\r\n     * @param {!string} url URL to a style sheet\r\n     * @param {$.Deferred=} deferred Optionally check for load and error events\r\n     * @return {!HTMLLinkElement} The generated HTML node\r\n     **/\r\n    function addLinkedStyleSheet(url, deferred) {\r\n        var attributes = {\r\n            type: "text/css",\r\n            rel:  "stylesheet",\r\n            href: url\r\n        };\r\n        \r\n        var $link = $("<link/>").attr(attributes);\r\n        \r\n        if (deferred) {\r\n            $link.on(\'load\', deferred.resolve).on(\'error\', deferred.reject);\r\n        }\r\n        \r\n        $link.appendTo("head");\r\n        \r\n        return $link[0];\r\n    }\r\n\r\n    /**\r\n     * getModuleUrl returns different urls for win platform\r\n     * so that\'s why we need a different check here\r\n     * @see getModuleUrl()\r\n     * @param {!string} pathOrUrl that should be checked if it\'s absolute\r\n     * @return {!boolean} returns true if pathOrUrl is absolute url on win platform\r\n     *                    or when it\'s absolute path on other platforms\r\n     */\r\n    function isAbsolutePathOrUrl(pathOrUrl) {\r\n        return brackets.platform === "win" ? PathUtils.isAbsoluteUrl(pathOrUrl) : FileSystem.isAbsolutePath(pathOrUrl);\r\n    }\r\n\r\n    /**\r\n     * Parses LESS code and returns a promise that resolves with plain CSS code.\r\n     *\r\n     * Pass the {@link url} argument to resolve relative URLs contained in the code.\r\n     * Make sure URLs in the code are wrapped in quotes, like so:\r\n     *     background-image: url("image.png");\r\n     *\r\n     * @param {!string} code LESS code to parse\r\n     * @param {?string} url URL to the file containing the code\r\n     * @return {!$.Promise} A promise object that is resolved with CSS code if the LESS code can be parsed\r\n     */\r\n    function parseLessCode(code, url) {\r\n        var result = new $.Deferred(),\r\n            options;\r\n        \r\n        if (url) {\r\n            var dir  = url.slice(0, url.lastIndexOf("/") + 1),\r\n                file = url.slice(dir.length);\r\n            \r\n            options = {\r\n                filename: file,\r\n                paths:    [dir],\r\n                rootpath: dir\r\n            };\r\n\r\n            if (isAbsolutePathOrUrl(url)) {\r\n                options.currentFileInfo = {\r\n                    currentDirectory: dir,\r\n                    entryPath: dir,\r\n                    filename: url,\r\n                    rootFilename: url,\r\n                    rootpath: dir\r\n                };\r\n            }\r\n        }\r\n        \r\n        var parser = new less.Parser(options);\r\n        parser.parse(code, function onParse(err, tree) {\r\n            if (err) {\r\n                result.reject(err);\r\n            } else {\r\n                result.resolve(tree.toCSS());\r\n            }\r\n        });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Returns a path to an extension module.\r\n     *\r\n     * @param {!module} module Module provided by RequireJS\r\n     * @param {?string} path Relative path from the extension folder to a file\r\n     * @return {!string} The path to the module\'s folder\r\n     **/\r\n    function getModulePath(module, path) {\r\n        var modulePath = module.uri.substr(0, module.uri.lastIndexOf("/") + 1);\r\n        if (path) {\r\n            modulePath += path;\r\n        }\r\n        \r\n        return modulePath;\r\n    }\r\n    \r\n    /**\r\n     * Returns a URL to an extension module.\r\n     *\r\n     * @param {!module} module Module provided by RequireJS\r\n     * @param {?string} path Relative path from the extension folder to a file\r\n     * @return {!string} The URL to the module\'s folder\r\n     **/\r\n    function getModuleUrl(module, path) {\r\n        var url = encodeURI(getModulePath(module, path));\r\n        \r\n        // On Windows, $.get() fails if the url is a full pathname. To work around this,\r\n        // prepend "file:///". On the Mac, $.get() works fine if the url is a full pathname,\r\n        // but *doesn\'t* work if it is prepended with "file://". Go figure.\r\n        // However, the prefix "file://localhost" does work.\r\n        if (brackets.platform === "win" && url.indexOf(":") !== -1) {\r\n            url = "file:///" + url;\r\n        }\r\n        \r\n        return url;\r\n    }\r\n    \r\n    /**\r\n     * Performs a GET request using a path relative to an extension module.\r\n     *\r\n     * The resulting URL can be retrieved in the resolve callback by accessing\r\n     * \r\n     * @param {!module} module Module provided by RequireJS\r\n     * @param {!string} path Relative path from the extension folder to a file\r\n     * @return {!$.Promise} A promise object that is resolved with the contents of the requested file\r\n     **/\r\n    function loadFile(module, path) {\r\n        var url     = PathUtils.isAbsoluteUrl(path) ? path : getModuleUrl(module, path),\r\n            promise = $.get(url);\r\n\r\n        return promise;\r\n    }\r\n    \r\n    /**\r\n     * Loads a style sheet (CSS or LESS) relative to the extension module.\r\n     *\r\n     * @param {!module} module Module provided by RequireJS\r\n     * @param {!string} path Relative path from the extension folder to a CSS or LESS file\r\n     * @return {!$.Promise} A promise object that is resolved with an HTML node if the file can be loaded.\r\n     */\r\n    function loadStyleSheet(module, path) {\r\n        var result = new $.Deferred();\r\n\r\n        loadFile(module, path)\r\n            .done(function (content) {\r\n                var url = this.url;\r\n                \r\n                if (url.slice(-5) === ".less") {\r\n                    parseLessCode(content, url)\r\n                        .done(function (css) {\r\n                            result.resolve(addEmbeddedStyleSheet(css));\r\n                        })\r\n                        .fail(result.reject);\r\n                } else {\r\n                    var deferred = new $.Deferred(),\r\n                        link = addLinkedStyleSheet(url, deferred);\r\n                    \r\n                    deferred\r\n                        .done(function () {\r\n                            result.resolve(link);\r\n                        })\r\n                        .fail(result.reject);\r\n                }\r\n            })\r\n            .fail(result.reject);\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Loads the package.json file in the given extension folder.\r\n     *\r\n     * @param {string} folder The extension folder.\r\n     * @return {$.Promise} A promise object that is resolved with the parsed contents of the package.json file,\r\n     *     or rejected if there is no package.json or the contents are not valid JSON.\r\n     */\r\n    function loadPackageJson(folder) {\r\n        var file = FileSystem.getFileForPath(folder + "/package.json"),\r\n            result = new $.Deferred();\r\n        FileUtils.readAsText(file)\r\n            .done(function (text) {\r\n                try {\r\n                    var json = JSON.parse(text);\r\n                    result.resolve(json);\r\n                } catch (e) {\r\n                    result.reject();\r\n                }\r\n            })\r\n            .fail(function () {\r\n                result.reject();\r\n            });\r\n        return result.promise();\r\n    }\r\n    \r\n    exports.addEmbeddedStyleSheet = addEmbeddedStyleSheet;\r\n    exports.addLinkedStyleSheet   = addLinkedStyleSheet;\r\n    exports.parseLessCode         = parseLessCode;\r\n    exports.getModulePath         = getModulePath;\r\n    exports.getModuleUrl          = getModuleUrl;\r\n    exports.loadFile              = loadFile;\r\n    exports.loadStyleSheet        = loadStyleSheet;\r\n    exports.loadPackageJson       = loadPackageJson;\r\n});\r\n\n//# sourceURL=/utils/ExtensionUtils.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets, window */\r\n\r\n/**\r\n * ExtensionLoader searches the filesystem for extensions, then creates a new context for each one and loads it.\r\n * This module dispatches the following events:\r\n *      "load" - when an extension is successfully loaded. The second argument is the file path to the\r\n *          extension root.\r\n *      "loadFailed" - when an extension load is unsuccessful. The second argument is the file path to the\r\n *          extension root.\r\n */\r\n\r\ndefine(\'utils/ExtensionLoader\',[\'require\',\'exports\',\'module\',\'utils/Global\',\'thirdparty/lodash\',\'filesystem/FileSystem\',\'file/FileUtils\',\'utils/Async\',\'utils/ExtensionUtils\',\'utils/UrlParams\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    require("utils/Global");\r\n\r\n    var _              = require("thirdparty/lodash"),\r\n        FileSystem     = require("filesystem/FileSystem"),\r\n        FileUtils      = require("file/FileUtils"),\r\n        Async          = require("utils/Async"),\r\n        ExtensionUtils = require("utils/ExtensionUtils"),\r\n        UrlParams      = require("utils/UrlParams").UrlParams;\r\n\r\n    // default async initExtension timeout\r\n    var INIT_EXTENSION_TIMEOUT = 10000;\r\n    \r\n    var _init       = false,\r\n        _extensions = {},\r\n        _initExtensionTimeout = INIT_EXTENSION_TIMEOUT,\r\n        srcPath     = FileUtils.getNativeBracketsDirectoryPath();\r\n    \r\n    /**\r\n     * Stores require.js contexts of extensions\r\n     * @type {Object.<string, Object>}\r\n     */\r\n    var contexts    = {};\r\n\r\n    // The native directory path ends with either "test" or "src". We need "src" to\r\n    // load the text and i18n modules.\r\n    srcPath = srcPath.replace(/\\/test$/, "/src"); // convert from "test" to "src"\r\n\r\n    var globalConfig = {\r\n            "text" : srcPath + "/thirdparty/text/text",\r\n            "i18n" : srcPath + "/thirdparty/i18n/i18n"\r\n        };\r\n    \r\n    /**\r\n     * Returns the full path of the default user extensions directory. This is in the users\r\n     * application support directory, which is typically\r\n     * /Users/<user>/Application Support/Brackets/extensions/user on the mac, and\r\n     * C:\\Users\\<user>\\AppData\\Roaming\\Brackets\\extensions\\user on windows.\r\n     */\r\n    function getUserExtensionPath() {\r\n        if (brackets.app.getApplicationSupportDirectory) {\r\n            return brackets.app.getApplicationSupportDirectory() + "/extensions/user";\r\n        }\r\n\r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Returns the require.js require context used to load an extension\r\n     *\r\n     * @param {!string} name, used to identify the extension\r\n     * @return {!Object} A require.js require object used to load the extension, or undefined if \r\n     * there is no require object with that name\r\n     */\r\n    function getRequireContextForExtension(name) {\r\n        return contexts[name];\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Get timeout value for rejecting an extension\'s async initExtension promise.\r\n     * @return {number} Timeout in milliseconds\r\n     */\r\n    function _getInitExtensionTimeout() {\r\n        return _initExtensionTimeout;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Set timeout for rejecting an extension\'s async initExtension promise.\r\n     * @param {number} value Timeout in milliseconds\r\n     */\r\n    function _setInitExtensionTimeout(value) {\r\n        _initExtensionTimeout = value;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Loads optional requirejs-config.json file for an extension\r\n     * @param {Object} baseConfig\r\n     * @return {$.Promise}\r\n     */\r\n    function _mergeConfig(baseConfig) {\r\n        var deferred = new $.Deferred(),\r\n            extensionConfigFile = FileSystem.getFileForPath(baseConfig.baseUrl + "/requirejs-config.json");\r\n\r\n        // Optional JSON config for require.js\r\n        FileUtils.readAsText(extensionConfigFile).done(function (text) {\r\n            try {\r\n                var extensionConfig = JSON.parse(text);\r\n                \r\n                // baseConfig.paths properties will override any extension config paths\r\n                _.extend(extensionConfig.paths, baseConfig.paths);\r\n\r\n                // Overwrite baseUrl, context, locale (paths is already merged above)\r\n                _.extend(extensionConfig, _.omit(baseConfig, "paths"));\r\n                \r\n                deferred.resolve(extensionConfig);\r\n            } catch (err) {\r\n                // Failed to parse requirejs-config.json\r\n                deferred.reject("failed to parse requirejs-config.json");\r\n            }\r\n        }).fail(function () {\r\n            // If requirejs-config.json isn\'t specified, resolve with the baseConfig only\r\n            deferred.resolve(baseConfig);\r\n        });\r\n\r\n        return deferred.promise();\r\n    }\r\n    \r\n    /**\r\n     * Loads the extension module that lives at baseUrl into its own Require.js context\r\n     *\r\n     * @param {!string} name, used to identify the extension\r\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension\r\n     * @param {!string} entryPoint, name of the main js file to load\r\n     * @return {!$.Promise} A promise object that is resolved when the extension is loaded, or rejected\r\n     *              if the extension fails to load or throws an exception immediately when loaded.\r\n     *              (Note: if extension contains a JS syntax error, promise is resolved not rejected).\r\n     */\r\n    function loadExtensionModule(name, config, entryPoint) {\r\n        var extensionConfig = {\r\n            context: name,\r\n            baseUrl: config.baseUrl,\r\n            /* FIXME (issue #1087): can we pass this from the global require context instead of hardcoding twice? */\r\n            paths: globalConfig,\r\n            locale: brackets.getLocale()\r\n        };\r\n        \r\n        // Read optional requirejs-config.json\r\n        var promise = _mergeConfig(extensionConfig).then(function (mergedConfig) {\r\n            // Create new RequireJS context and load extension entry point\r\n            var extensionRequire = brackets.libRequire.config(mergedConfig),\r\n                extensionRequireDeferred = new $.Deferred();\r\n\r\n            contexts[name] = extensionRequire;\r\n            extensionRequire([entryPoint], extensionRequireDeferred.resolve, extensionRequireDeferred.reject);\r\n            \r\n            return extensionRequireDeferred.promise();\r\n        }).then(function (module) {\r\n            // Extension loaded normally\r\n            var initPromise;\r\n\r\n            _extensions[name] = module;\r\n\r\n            // Optional sync/async initExtension\r\n            if (module && module.initExtension && (typeof module.initExtension === "function")) {\r\n                // optional async extension init \r\n                try {\r\n                    initPromise = Async.withTimeout(module.initExtension(), _getInitExtensionTimeout());\r\n                } catch (err) {\r\n                    // Synchronous error while initializing extension\r\n                    console.error("[Extension] Error -- error thrown during initExtension for " + name + ": " + err);\r\n                    return new $.Deferred().reject(err).promise();\r\n                }\r\n\r\n                // initExtension may be synchronous and may not return a promise\r\n                if (initPromise) {\r\n                    // WARNING: These calls to initPromise.fail() and initPromise.then(),\r\n                    // could also result in a runtime error if initPromise is not a valid\r\n                    // promise. Currently, the promise is wrapped via Async.withTimeout(),\r\n                    // so the call is safe as-is.\r\n                    initPromise.fail(function (err) {\r\n                        if (err === Async.ERROR_TIMEOUT) {\r\n                            console.error("[Extension] Error -- timeout during initExtension for " + name);\r\n                        } else {\r\n                            console.error("[Extension] Error -- failed initExtension for " + name + (err ? ": " + err : ""));\r\n                        }\r\n                    });\r\n\r\n                    return initPromise;\r\n                }\r\n            }\r\n        }, function errback(err) {\r\n            // Extension failed to load during the initial require() call\r\n            console.error("[Extension] failed to load " + config.baseUrl + " " + err);\r\n            if (err.requireType === "define") {\r\n                // This type has a useful stack (exception thrown by ext code or info on bad getModule() call)\r\n                console.log(err.stack);\r\n            }\r\n        });\r\n\r\n        return promise;\r\n    }\r\n    \r\n    /**\r\n     * Loads the extension that lives at baseUrl into its own Require.js context\r\n     *\r\n     * @param {!string} name, used to identify the extension\r\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension\r\n     * @param {!string} entryPoint, name of the main js file to load\r\n     * @return {!$.Promise} A promise object that is resolved when the extension is loaded, or rejected\r\n     *              if the extension fails to load or throws an exception immediately when loaded.\r\n     *              (Note: if extension contains a JS syntax error, promise is resolved not rejected).\r\n     */\r\n    function loadExtension(name, config, entryPoint) {\r\n        var promise = new $.Deferred();\r\n\r\n        // Try to load the package.json to figure out if we are loading a theme.\r\n        ExtensionUtils.loadPackageJson(config.baseUrl).always(promise.resolve);\r\n\r\n        return promise\r\n            .then(function (metadata) {\r\n                // No special handling for themes... Let the promise propagate into the ExtensionManager\r\n                if (metadata && metadata.hasOwnProperty("theme")) {\r\n                    return;\r\n                }\r\n\r\n                return loadExtensionModule(name, config, entryPoint);\r\n            })\r\n            .then(function () {\r\n                $(exports).triggerHandler("load", config.baseUrl);\r\n            }, function (err) {\r\n                $(exports).triggerHandler("loadFailed", config.baseUrl);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Runs unit tests for the extension that lives at baseUrl into its own Require.js context\r\n     *\r\n     * @param {!string} name, used to identify the extension\r\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension\r\n     * @param {!string} entryPoint, name of the main js file to load\r\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\r\n     */\r\n    function testExtension(name, config, entryPoint) {\r\n        var result = new $.Deferred(),\r\n            extensionPath = config.baseUrl + "/" + entryPoint + ".js";\r\n        \r\n        FileSystem.resolve(extensionPath, function (err, entry) {\r\n            if (!err && entry.isFile) {\r\n                // unit test file exists\r\n                var extensionRequire = brackets.libRequire.config({\r\n                    context: name,\r\n                    baseUrl: config.baseUrl,\r\n                    paths: $.extend({}, config.paths, globalConfig)\r\n                });\r\n    \r\n                extensionRequire([entryPoint], function () {\r\n                    result.resolve();\r\n                });\r\n            } else {\r\n                result.reject();\r\n            }\r\n        });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Loads a file entryPoint from each extension folder within the baseUrl into its own Require.js context\r\n     *\r\n     * @param {!string} directory, an absolute native path that contains a directory of extensions.\r\n     *                  each subdirectory is interpreted as an independent extension\r\n     * @param {!{baseUrl: string}} config object with baseUrl property containing absolute path of extension folder\r\n     * @param {!string} entryPoint Module name to load (without .js suffix)\r\n     * @param {function} processExtension \r\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\r\n     */\r\n    function _loadAll(directory, config, entryPoint, processExtension) {\r\n        var result = new $.Deferred();\r\n        \r\n        FileSystem.getDirectoryForPath(directory).getContents(function (err, contents) {\r\n            if (!err) {\r\n                var i,\r\n                    extensions = [];\r\n                \r\n                for (i = 0; i < contents.length; i++) {\r\n                    if (contents[i].isDirectory) {\r\n                        // FUTURE (JRB): read package.json instead of just using the entrypoint "main".\r\n                        // Also, load sub-extensions defined in package.json.\r\n                        extensions.push(contents[i].name);\r\n                    }\r\n                }\r\n\r\n                if (extensions.length === 0) {\r\n                    result.resolve();\r\n                    return;\r\n                }\r\n                \r\n                Async.doInParallel(extensions, function (item) {\r\n                    var extConfig = {\r\n                        baseUrl: config.baseUrl + "/" + item,\r\n                        paths: config.paths\r\n                    };\r\n                    return processExtension(item, extConfig, entryPoint);\r\n                }).always(function () {\r\n                    // Always resolve the promise even if some extensions had errors\r\n                    result.resolve();\r\n                });\r\n            } else {\r\n                console.error("[Extension] Error -- could not read native directory: " + directory);\r\n                result.reject();\r\n            }\r\n        });\r\n               \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Loads the extension that lives at baseUrl into its own Require.js context\r\n     *\r\n     * @param {!string} directory, an absolute native path that contains a directory of extensions.\r\n     *                  each subdirectory is interpreted as an independent extension\r\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\r\n     */\r\n    function loadAllExtensionsInNativeDirectory(directory) {\r\n        return _loadAll(directory, {baseUrl: directory}, "main", loadExtension);\r\n    }\r\n    \r\n    /**\r\n     * Runs unit test for the extension that lives at baseUrl into its own Require.js context\r\n     *\r\n     * @param {!string} directory, an absolute native path that contains a directory of extensions.\r\n     *                  each subdirectory is interpreted as an independent extension\r\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\r\n     */\r\n    function testAllExtensionsInNativeDirectory(directory) {\r\n        var bracketsPath = FileUtils.getNativeBracketsDirectoryPath(),\r\n            config = {\r\n                baseUrl: directory\r\n            };\r\n        \r\n        config.paths = {\r\n            "perf": bracketsPath + "/perf",\r\n            "spec": bracketsPath + "/spec"\r\n        };\r\n        \r\n        return _loadAll(directory, config, "unittests", testExtension);\r\n    }\r\n    \r\n    /**\r\n     * Load extensions.\r\n     *\r\n     * @param {?Array.<string>} A list containing references to extension source\r\n     *      location. A source location may be either (a) a folder name inside\r\n     *      src/extensions or (b) an absolute path.\r\n     * @return {!$.Promise} A promise object that is resolved when all extensions complete loading.\r\n     */\r\n    function init(paths) {\r\n        var params = new UrlParams();\r\n        \r\n        if (_init) {\r\n            // Only init once. Return a resolved promise.\r\n            return new $.Deferred().resolve().promise();\r\n        }\r\n        \r\n        // Load *subset* of the usual builtin extensions list, and don\'t try to find any user/dev extensions\r\n        if (brackets.inBrowser) {\r\n            var basePath = PathUtils.directory(window.location.href) + "extensions/default/",\r\n                defaultExtensions = [\r\n                    // Core extensions we want to support in the browser\r\n                    "CSSCodeHints",\r\n                    "HTMLCodeHints",\r\n                    "HtmlEntityCodeHints",\r\n                    "InlineColorEditor",\r\n                    "JavaScriptQuickEdit",\r\n                    "JSLint",\r\n                    "LESSSupport",\r\n                    "QuickOpenCSS",\r\n                    "QuickOpenHTML",\r\n                    "QuickOpenJavaScript",\r\n                    "QuickView",\r\n                    "RecentProjects",\r\n                    "UrlCodeHints",\r\n                    "WebPlatformDocs",\r\n\r\n                    // Custom extensions we want loaded by default\r\n                    // NOTE: Maps to a folder inside /src/extensions/default/\r\n                    "makedrive-sync-icon"\r\n\r\n                    // "ExampleExtension",\r\n                ];\r\n\r\n            return Async.doInParallel(defaultExtensions, function (item) {\r\n                var extConfig = {\r\n                    baseUrl: basePath + item\r\n                };\r\n                return loadExtension(item, extConfig, "main");\r\n            });\r\n        }\r\n\r\n        \r\n        if (!paths) {\r\n            params.parse();\r\n            \r\n            if (params.get("reloadWithoutUserExts") === "true") {\r\n                paths = ["default"];\r\n            } else {\r\n                paths = ["default", "dev", getUserExtensionPath()];\r\n            }\r\n        }\r\n        \r\n        // Load extensions before restoring the project\r\n        \r\n        // Get a Directory for the user extension directory and create it if it doesn\'t exist.\r\n        // Note that this is an async call and there are no success or failure functions passed\r\n        // in. If the directory *doesn\'t* exist, it will be created. Extension loading may happen\r\n        // before the directory is finished being created, but that is okay, since the extension\r\n        // loading will work correctly without this directory.\r\n        // If the directory *does* exist, nothing else needs to be done. It will be scanned normally\r\n        // during extension loading.\r\n        var extensionPath = getUserExtensionPath();\r\n        FileSystem.getDirectoryForPath(extensionPath).create();\r\n        \r\n        // Create the extensions/disabled directory, too.\r\n        var disabledExtensionPath = extensionPath.replace(/\\/user$/, "/disabled");\r\n        FileSystem.getDirectoryForPath(disabledExtensionPath).create();\r\n        \r\n        var promise = Async.doSequentially(paths, function (item) {\r\n            var extensionPath = item;\r\n            \r\n            // If the item has "/" in it, assume it is a full path. Otherwise, load\r\n            // from our source path + "/extensions/".\r\n            if (item.indexOf("/") === -1) {\r\n                extensionPath = FileUtils.getNativeBracketsDirectoryPath() + "/extensions/" + item;\r\n            }\r\n            \r\n            return loadAllExtensionsInNativeDirectory(extensionPath);\r\n        }, false);\r\n        \r\n        promise.always(function () {\r\n            _init = true;\r\n        });\r\n        \r\n        return promise;\r\n    }\r\n\r\n    // unit tests\r\n    exports._setInitExtensionTimeout = _setInitExtensionTimeout;\r\n    exports._getInitExtensionTimeout = _getInitExtensionTimeout;\r\n    \r\n    // public API\r\n    exports.init = init;\r\n    exports.getUserExtensionPath = getUserExtensionPath;\r\n    exports.getRequireContextForExtension = getRequireContextForExtension;\r\n    exports.loadExtension = loadExtension;\r\n    exports.testExtension = testExtension;\r\n    exports.loadAllExtensionsInNativeDirectory = loadAllExtensionsInNativeDirectory;\r\n    exports.testAllExtensionsInNativeDirectory = testAllExtensionsInNativeDirectory;\r\n});\r\n\n//# sourceURL=/utils/ExtensionLoader.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n/**\r\n *  Utilities functions related to data collections (arrays & maps)\r\n */\r\ndefine(\'utils/CollectionUtils\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n\r\n    /**\r\n     * Returns the first index in \'array\' for which isMatch() returns true, or -1 if none\r\n     * @param {!Array.<*>|jQueryObject} array\r\n     * @param {!function(*, Number):boolean} isMatch Passed (item, index), same as with forEach()\r\n     * @deprecated\r\n     */\r\n    function indexOf(array, isMatch) {\r\n        console.warn("CollectionUtils.indexOf is deprecated. Use _.findIndex instead.");\r\n        return _.findIndex(array, isMatch);\r\n    }\r\n    \r\n    /**\r\n     * Iterates over all the properties in an object or elements in an array. Differs from\r\n     * $.each in that it always iterates over the properties of an object, even if it has a length\r\n     * property making it look like an array.\r\n     * @param {*} object The object or array to iterate over.\r\n     * @param {function(value, key)} callback The function that will be executed on every object.\r\n     * @deprecated\r\n     */\r\n    function forEach(object, callback) {\r\n        console.warn("CollectionUtils.forEach is deprecated. Use _.forEach instead.");\r\n        _.forEach(object, callback);\r\n    }\r\n    \r\n    /**\r\n     * Iterates over all the properties in an object or elements in an array. If a callback returns a\r\n     * truthly value then it will immediately return true, if not, it will return false. Differs from\r\n     * $.each in that it always iterates over the properties of an object, even if it has a length\r\n     * property making it look like an array.\r\n     * @param {*} object The object or array to iterate over.\r\n     * @param {function(value, key)} callback The function that will be executed on every object.\r\n     * @return {boolean}\r\n     * @deprecated\r\n     */\r\n    function some(object, callback) {\r\n        console.warn("CollectionUtils.some is deprecated. Use _.some instead.");\r\n        return _.some(object, callback);\r\n    }\r\n    \r\n    /**\r\n     * Returns true if the object has the specified property.\r\n     * This calls the Object.prototype.hasOwnProperty function directly, rather than\r\n     * depending on the object having a function named "hasOwnProperty". This way the\r\n     * object *can* have a property named "hasOwnProperty" that is not a function.\r\n     * @param {*} object The object to test\r\n     * @param {string} property The name of the property to query\r\n     * @return {boolean} True if the object contains the property\r\n     * @deprecated\r\n     */\r\n    function hasProperty(object, property) {\r\n        console.warn("CollectionUtils.hasProperty is deprecated. Use _.has instead.");\r\n        return _.has(object, property);\r\n    }\r\n    \r\n    // Define public API\r\n    exports.indexOf     = indexOf;\r\n    exports.forEach     = forEach;\r\n    exports.some        = some;\r\n    exports.hasProperty = hasProperty;\r\n});\r\n\n//# sourceURL=/utils/CollectionUtils.js'),eval('// This is a slightly modified version of the minimatch library\r\n// https://github.com/isaacs/minimatch\r\n// (MIT-licensed, Copyright 2009-2011 Isaac Z. Schlueter)\r\n//\r\n// It has been modified to work properly with RequireJS and\r\n// to export an fnmatch function adapted from the EditorConfig project:\r\n// https://github.com/editorconfig/editorconfig-core-js/\r\n// (MIT-licensed, Copyright 2012 EditorConfig Team)\r\n\r\n\r\ndefine(\'thirdparty/globmatch\',[\'require\',\'exports\',\'module\'],function (r, exports, module, platform) {\r\n\r\nmodule.exports = fnmatch;\r\nminimatch.Minimatch = Minimatch;\r\n    \r\nfunction fnmatch(filepath, glob) {\r\n  var matchOptions = {dot: true, noext: true};\r\n  \r\n  // brackets #7374: don\'t try to match base if a directory name is passed in\r\n  if (filepath[filepath.length - 1] !== "/") {\r\n    matchOptions.matchBase = true;\r\n  }\r\n  \r\n  glob = glob.replace(/\\*\\*/g, \'{*,**/**/**}\');\r\n  return minimatch(filepath, glob, matchOptions);\r\n};\r\n\r\nvar LRU = function LRUCache () {\r\n        // not quite an LRU, but still space-limited.\r\n        var cache = {}\r\n        var cnt = 0\r\n        this.set = function (k, v) {\r\n          cnt ++\r\n          if (cnt >= 100) cache = {}\r\n          cache[k] = v\r\n        }\r\n        this.get = function (k) { return cache[k] }\r\n      }\r\n  , cache = minimatch.cache = new LRU({max: 100})\r\n  , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}\r\n  , sigmund = function sigmund (obj) {\r\n        return JSON.stringify(obj)\r\n      };\r\n\r\nvar path = { basename: function (f) {\r\n        f = f.split(/[\\/\\\\]/)\r\n        var e = f.pop()\r\n        if (!e) e = f.pop()\r\n        return e\r\n      }}\r\n  // any single thing other than /\r\n  // don\'t need to escape / when using new RegExp()\r\n  , qmark = "[^/]"\r\n\r\n  // * => any number of characters\r\n  , star = qmark + "*?"\r\n\r\n  // ** when dots are allowed.  Anything goes, except .. and .\r\n  // not (^ or / followed by one or two dots followed by $ or /),\r\n  // followed by anything, any number of times.\r\n  , twoStarDot = "(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?"\r\n\r\n  // not a ^ or / followed by a dot,\r\n  // followed by anything, any number of times.\r\n  , twoStarNoDot = "(?:(?!(?:\\\\\\/|^)\\\\.).)*?"\r\n\r\n  // characters that need to be escaped in RegExp.\r\n  , reSpecials = charSet("().*{}+?[]^$\\\\!")\r\n\r\n// "abc" -> { a:true, b:true, c:true }\r\nfunction charSet (s) {\r\n  return s.split("").reduce(function (set, c) {\r\n    set[c] = true\r\n    return set\r\n  }, {})\r\n}\r\n\r\n// normalizes slashes.\r\nvar slashSplit = /\\/+/\r\n\r\nminimatch.monkeyPatch = monkeyPatch\r\nfunction monkeyPatch () {\r\n  var desc = Object.getOwnPropertyDescriptor(String.prototype, "match")\r\n  var orig = desc.value\r\n  desc.value = function (p) {\r\n    if (p instanceof Minimatch) return p.match(this)\r\n    return orig.call(this, p)\r\n  }\r\n  Object.defineProperty(String.prototype, desc)\r\n}\r\n\r\nminimatch.filter = filter\r\nfunction filter (pattern, options) {\r\n  options = options || {}\r\n  return function (p, i, list) {\r\n    return minimatch(p, pattern, options)\r\n  }\r\n}\r\n\r\nfunction ext (a, b) {\r\n  a = a || {}\r\n  b = b || {}\r\n  var t = {}\r\n  Object.keys(b).forEach(function (k) {\r\n    t[k] = b[k]\r\n  })\r\n  Object.keys(a).forEach(function (k) {\r\n    t[k] = a[k]\r\n  })\r\n  return t\r\n}\r\n\r\nminimatch.defaults = function (def) {\r\n  if (!def || !Object.keys(def).length) return minimatch\r\n\r\n  var orig = minimatch\r\n\r\n  var m = function minimatch (p, pattern, options) {\r\n    return orig.minimatch(p, pattern, ext(def, options))\r\n  }\r\n\r\n  m.Minimatch = function Minimatch (pattern, options) {\r\n    return new orig.Minimatch(pattern, ext(def, options))\r\n  }\r\n\r\n  return m\r\n}\r\n\r\nMinimatch.defaults = function (def) {\r\n  if (!def || !Object.keys(def).length) return Minimatch\r\n  return minimatch.defaults(def).Minimatch\r\n}\r\n\r\n\r\nfunction minimatch (p, pattern, options) {\r\n  if (typeof pattern !== "string") {\r\n    throw new TypeError("glob pattern string required")\r\n  }\r\n\r\n  if (!options) options = {}\r\n\r\n  // shortcut: comments match nothing.\r\n  if (!options.nocomment && pattern.charAt(0) === "#") {\r\n    return false\r\n  }\r\n\r\n  // "" only matches ""\r\n  if (pattern.trim() === "") return p === ""\r\n\r\n  return new Minimatch(pattern, options).match(p)\r\n}\r\n\r\nfunction Minimatch (pattern, options) {\r\n  if (!(this instanceof Minimatch)) {\r\n    return new Minimatch(pattern, options, cache)\r\n  }\r\n\r\n  if (typeof pattern !== "string") {\r\n    throw new TypeError("glob pattern string required")\r\n  }\r\n\r\n  if (!options) options = {}\r\n  pattern = pattern.trim()\r\n\r\n  // windows: need to use /, not \\\r\n  // On other platforms, \\ is a valid (albeit bad) filename char.\r\n  if (platform === "win32") {\r\n    pattern = pattern.split("\\\\").join("/")\r\n  }\r\n\r\n  // lru storage.\r\n  // these things aren\'t particularly big, but walking down the string\r\n  // and turning it into a regexp can get pretty costly.\r\n  var cacheKey = pattern + "\\n" + sigmund(options)\r\n  var cached = minimatch.cache.get(cacheKey)\r\n  if (cached) return cached\r\n  minimatch.cache.set(cacheKey, this)\r\n\r\n  this.options = options\r\n  this.set = []\r\n  this.pattern = pattern\r\n  this.regexp = null\r\n  this.negate = false\r\n  this.comment = false\r\n  this.empty = false\r\n\r\n  // make the set of regexps etc.\r\n  this.make()\r\n}\r\n\r\nMinimatch.prototype.make = make\r\nfunction make () {\r\n  // don\'t do it more than once.\r\n  if (this._made) return\r\n\r\n  var pattern = this.pattern\r\n  var options = this.options\r\n\r\n  // empty patterns and comments match nothing.\r\n  if (!options.nocomment && pattern.charAt(0) === "#") {\r\n    this.comment = true\r\n    return\r\n  }\r\n  if (!pattern) {\r\n    this.empty = true\r\n    return\r\n  }\r\n\r\n  // step 1: figure out negation, etc.\r\n  this.parseNegate()\r\n\r\n  // step 2: expand braces\r\n  var set = this.globSet = this.braceExpand()\r\n\r\n  if (options.debug) console.error(this.pattern, set)\r\n\r\n  // step 3: now we have a set, so turn each one into a series of path-portion\r\n  // matching patterns.\r\n  // These will be regexps, except in the case of "**", which is\r\n  // set to the GLOBSTAR object for globstar behavior,\r\n  // and will not contain any / characters\r\n  set = this.globParts = set.map(function (s) {\r\n    return s.split(slashSplit)\r\n  })\r\n\r\n  if (options.debug) console.error(this.pattern, set)\r\n\r\n  // glob --> regexps\r\n  set = set.map(function (s, si, set) {\r\n    return s.map(this.parse, this)\r\n  }, this)\r\n\r\n  if (options.debug) console.error(this.pattern, set)\r\n\r\n  // filter out everything that didn\'t compile properly.\r\n  set = set.filter(function (s) {\r\n    return -1 === s.indexOf(false)\r\n  })\r\n\r\n  if (options.debug) console.error(this.pattern, set)\r\n\r\n  this.set = set\r\n}\r\n\r\nMinimatch.prototype.parseNegate = parseNegate\r\nfunction parseNegate () {\r\n  var pattern = this.pattern\r\n    , negate = false\r\n    , options = this.options\r\n    , negateOffset = 0\r\n\r\n  if (options.nonegate) return\r\n\r\n  for ( var i = 0, l = pattern.length\r\n      ; i < l && pattern.charAt(i) === "!"\r\n      ; i ++) {\r\n    negate = !negate\r\n    negateOffset ++\r\n  }\r\n\r\n  if (negateOffset) this.pattern = pattern.substr(negateOffset)\r\n  this.negate = negate\r\n}\r\n\r\n// Brace expansion:\r\n// a{b,c}d -> abd acd\r\n// a{b,}c -> abc ac\r\n// a{0..3}d -> a0d a1d a2d a3d\r\n// a{b,c{d,e}f}g -> abg acdfg acefg\r\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\r\n//\r\n// Invalid sets are not expanded.\r\n// a{2..}b -> a{2..}b\r\n// a{b}c -> a{b}c\r\nminimatch.braceExpand = function (pattern, options) {\r\n  return new Minimatch(pattern, options).braceExpand()\r\n}\r\n\r\nMinimatch.prototype.braceExpand = braceExpand\r\nfunction braceExpand (pattern, options) {\r\n  options = options || this.options\r\n  pattern = typeof pattern === "undefined"\r\n    ? this.pattern : pattern\r\n\r\n  if (typeof pattern === "undefined") {\r\n    throw new Error("undefined pattern")\r\n  }\r\n\r\n  if (options.nobrace ||\r\n      !pattern.match(/\\{.*\\}/)) {\r\n    // shortcut. no need to expand.\r\n    return [pattern]\r\n  }\r\n\r\n  var escaping = false\r\n\r\n  // examples and comments refer to this crazy pattern:\r\n  // a{b,c{d,e},{f,g}h}x{y,z}\r\n  // expected:\r\n  // abxy\r\n  // abxz\r\n  // acdxy\r\n  // acdxz\r\n  // acexy\r\n  // acexz\r\n  // afhxy\r\n  // afhxz\r\n  // aghxy\r\n  // aghxz\r\n\r\n  // everything before the first \\{ is just a prefix.\r\n  // So, we pluck that off, and work with the rest,\r\n  // and then prepend it to everything we find.\r\n  if (pattern.charAt(0) !== "{") {\r\n    // console.error(pattern)\r\n    var prefix = null\r\n    for (var i = 0, l = pattern.length; i < l; i ++) {\r\n      var c = pattern.charAt(i)\r\n      // console.error(i, c)\r\n      if (c === "\\\\") {\r\n        escaping = !escaping\r\n      } else if (c === "{" && !escaping) {\r\n        prefix = pattern.substr(0, i)\r\n        break\r\n      }\r\n    }\r\n\r\n    // actually no sets, all { were escaped.\r\n    if (prefix === null) {\r\n      // console.error("no sets")\r\n      return [pattern]\r\n    }\r\n\r\n    var tail = braceExpand(pattern.substr(i), options)\r\n    return tail.map(function (t) {\r\n      return prefix + t\r\n    })\r\n  }\r\n\r\n  // now we have something like:\r\n  // {b,c{d,e},{f,g}h}x{y,z}\r\n  // walk through the set, expanding each part, until\r\n  // the set ends.  then, we\'ll expand the suffix.\r\n  // If the set only has a single member, then\'ll put the {} back\r\n\r\n  // first, handle numeric sets, since they\'re easier\r\n  var numset = pattern.match(/^\\{(-?[0-9]+)\\.\\.(-?[0-9]+)\\}/)\r\n  if (numset) {\r\n    // console.error("numset", numset[1], numset[2])\r\n    var suf = braceExpand(pattern.substr(numset[0].length), options)\r\n      , start = +numset[1]\r\n      , end = +numset[2]\r\n      , inc = start > end ? -1 : 1\r\n      , set = []\r\n    for (var i = start; i != (end + inc); i += inc) {\r\n      // append all the suffixes\r\n      for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\r\n        set.push(i + suf[ii])\r\n      }\r\n    }\r\n    return set\r\n  }\r\n\r\n  // ok, walk through the set\r\n  // We hope, somewhat optimistically, that there\r\n  // will be a } at the end.\r\n  // If the closing brace isn\'t found, then the pattern is\r\n  // interpreted as braceExpand("\\\\" + pattern) so that\r\n  // the leading \\{ will be interpreted literally.\r\n  var i = 1 // skip the \\{\r\n    , depth = 1\r\n    , set = []\r\n    , member = ""\r\n    , sawEnd = false\r\n    , escaping = false\r\n\r\n  function addMember () {\r\n    set.push(member)\r\n    member = ""\r\n  }\r\n\r\n  // console.error("Entering for")\r\n  FOR: for (i = 1, l = pattern.length; i < l; i ++) {\r\n    var c = pattern.charAt(i)\r\n    // console.error("", i, c)\r\n\r\n    if (escaping) {\r\n      escaping = false\r\n      member += "\\\\" + c\r\n    } else {\r\n      switch (c) {\r\n        case "\\\\":\r\n          escaping = true\r\n          continue\r\n\r\n        case "{":\r\n          depth ++\r\n          member += "{"\r\n          continue\r\n\r\n        case "}":\r\n          depth --\r\n          // if this closes the actual set, then we\'re done\r\n          if (depth === 0) {\r\n            addMember()\r\n            // pluck off the close-brace\r\n            i ++\r\n            break FOR\r\n          } else {\r\n            member += c\r\n            continue\r\n          }\r\n\r\n        case ",":\r\n          if (depth === 1) {\r\n            addMember()\r\n          } else {\r\n            member += c\r\n          }\r\n          continue\r\n\r\n        default:\r\n          member += c\r\n          continue\r\n      } // switch\r\n    } // else\r\n  } // for\r\n\r\n  // now we\'ve either finished the set, and the suffix is\r\n  // pattern.substr(i), or we have *not* closed the set,\r\n  // and need to escape the leading brace\r\n  if (depth !== 0) {\r\n    // console.error("didn\'t close", pattern)\r\n    return braceExpand("\\\\" + pattern, options)\r\n  }\r\n\r\n  // x{y,z} -> ["xy", "xz"]\r\n  // console.error("set", set)\r\n  // console.error("suffix", pattern.substr(i))\r\n  var suf = braceExpand(pattern.substr(i), options)\r\n  // ["b", "c{d,e}","{f,g}h"] ->\r\n  //   [["b"], ["cd", "ce"], ["fh", "gh"]]\r\n  var addBraces = set.length === 1\r\n  // console.error("set pre-expanded", set)\r\n  set = set.map(function (p) {\r\n    return braceExpand(p, options)\r\n  })\r\n  // console.error("set expanded", set)\r\n\r\n\r\n  // [["b"], ["cd", "ce"], ["fh", "gh"]] ->\r\n  //   ["b", "cd", "ce", "fh", "gh"]\r\n  set = set.reduce(function (l, r) {\r\n    return l.concat(r)\r\n  })\r\n\r\n  if (addBraces) {\r\n    set = set.map(function (s) {\r\n      return "{" + s + "}"\r\n    })\r\n  }\r\n\r\n  // now attach the suffixes.\r\n  var ret = []\r\n  for (var i = 0, l = set.length; i < l; i ++) {\r\n    for (var ii = 0, ll = suf.length; ii < ll; ii ++) {\r\n      ret.push(set[i] + suf[ii])\r\n    }\r\n  }\r\n  return ret\r\n}\r\n\r\n// parse a component of the expanded set.\r\n// At this point, no pattern may contain "/" in it\r\n// so we\'re going to return a 2d array, where each entry is the full\r\n// pattern, split on \'/\', and then turned into a regular expression.\r\n// A regexp is made at the end which joins each array with an\r\n// escaped /, and another full one which joins each regexp with |.\r\n//\r\n// Following the lead of Bash 4.1, note that "**" only has special meaning\r\n// when it is the *only* thing in a path portion.  Otherwise, any series\r\n// of * is equivalent to a single *.  Globstar behavior is enabled by\r\n// default, and can be disabled by setting options.noglobstar.\r\nMinimatch.prototype.parse = parse\r\nvar SUBPARSE = {}\r\nfunction parse (pattern, isSub) {\r\n  var options = this.options\r\n\r\n  // shortcuts\r\n  if (!options.noglobstar && pattern === "**") return GLOBSTAR\r\n  if (pattern === "") return ""\r\n\r\n  var re = ""\r\n    , hasMagic = !!options.nocase\r\n    , escaping = false\r\n    // ? => one single character\r\n    , patternListStack = []\r\n    , plType\r\n    , stateChar\r\n    , inClass = false\r\n    , reClassStart = -1\r\n    , classStart = -1\r\n    // . and .. never match anything that doesn\'t start with .,\r\n    // even when options.dot is set.\r\n    , patternStart = pattern.charAt(0) === "." ? "" // anything\r\n      // not (start or / followed by . or .. followed by / or end)\r\n      : options.dot ? "(?!(?:^|\\\\\\/)\\\\.{1,2}(?:$|\\\\\\/))"\r\n      : "(?!\\\\.)"\r\n\r\n  function clearStateChar () {\r\n    if (stateChar) {\r\n      // we had some state-tracking character\r\n      // that wasn\'t consumed by this pass.\r\n      switch (stateChar) {\r\n        case "*":\r\n          re += star\r\n          hasMagic = true\r\n          break\r\n        case "?":\r\n          re += qmark\r\n          hasMagic = true\r\n          break\r\n        default:\r\n          re += "\\\\"+stateChar\r\n          break\r\n      }\r\n      stateChar = false\r\n    }\r\n  }\r\n\r\n  for ( var i = 0, len = pattern.length, c\r\n      ; (i < len) && (c = pattern.charAt(i))\r\n      ; i ++ ) {\r\n\r\n    if (options.debug) {\r\n      console.error("%s\\t%s %s %j", pattern, i, re, c)\r\n    }\r\n\r\n    // skip over any that are escaped.\r\n    if (escaping && reSpecials[c]) {\r\n      re += "\\\\" + c\r\n      escaping = false\r\n      continue\r\n    }\r\n\r\n    SWITCH: switch (c) {\r\n      case "/":\r\n        // completely not allowed, even escaped.\r\n        // Should already be path-split by now.\r\n        return false\r\n\r\n      case "\\\\":\r\n        clearStateChar()\r\n        escaping = true\r\n        continue\r\n\r\n      // the various stateChar values\r\n      // for the "extglob" stuff.\r\n      case "?":\r\n      case "*":\r\n      case "+":\r\n      case "@":\r\n      case "!":\r\n        if (options.debug) {\r\n          console.error("%s\\t%s %s %j <-- stateChar", pattern, i, re, c)\r\n        }\r\n\r\n        // all of those are literals inside a class, except that\r\n        // the glob [!a] means [^a] in regexp\r\n        if (inClass) {\r\n          if (c === "!" && i === classStart + 1) c = "^"\r\n          re += c\r\n          continue\r\n        }\r\n\r\n        // if we already have a stateChar, then it means\r\n        // that there was something like ** or +? in there.\r\n        // Handle the stateChar, then proceed with this one.\r\n        clearStateChar()\r\n        stateChar = c\r\n        // if extglob is disabled, then +(asdf|foo) isn\'t a thing.\r\n        // just clear the statechar *now*, rather than even diving into\r\n        // the patternList stuff.\r\n        if (options.noext) clearStateChar()\r\n        continue\r\n\r\n      case "(":\r\n        if (inClass) {\r\n          re += "("\r\n          continue\r\n        }\r\n\r\n        if (!stateChar) {\r\n          re += "\\\\("\r\n          continue\r\n        }\r\n\r\n        plType = stateChar\r\n        patternListStack.push({ type: plType\r\n                              , start: i - 1\r\n                              , reStart: re.length })\r\n        // negation is (?:(?!js)[^/]*)\r\n        re += stateChar === "!" ? "(?:(?!" : "(?:"\r\n        stateChar = false\r\n        continue\r\n\r\n      case ")":\r\n        if (inClass || !patternListStack.length) {\r\n          re += "\\\\)"\r\n          continue\r\n        }\r\n\r\n        hasMagic = true\r\n        re += ")"\r\n        plType = patternListStack.pop().type\r\n        // negation is (?:(?!js)[^/]*)\r\n        // The others are (?:<pattern>)<type>\r\n        switch (plType) {\r\n          case "!":\r\n            re += "[^/]*?)"\r\n            break\r\n          case "?":\r\n          case "+":\r\n          case "*": re += plType\r\n          case "@": break // the default anyway\r\n        }\r\n        continue\r\n\r\n      case "|":\r\n        if (inClass || !patternListStack.length || escaping) {\r\n          re += "\\\\|"\r\n          escaping = false\r\n          continue\r\n        }\r\n\r\n        re += "|"\r\n        continue\r\n\r\n      // these are mostly the same in regexp and glob\r\n      case "[":\r\n        // swallow any state-tracking char before the [\r\n        clearStateChar()\r\n\r\n        if (inClass) {\r\n          re += "\\\\" + c\r\n          continue\r\n        }\r\n\r\n        inClass = true\r\n        classStart = i\r\n        reClassStart = re.length\r\n        re += c\r\n        continue\r\n\r\n      case "]":\r\n        //  a right bracket shall lose its special\r\n        //  meaning and represent itself in\r\n        //  a bracket expression if it occurs\r\n        //  first in the list.  -- POSIX.2 2.8.3.2\r\n        if (i === classStart + 1 || !inClass) {\r\n          re += "\\\\" + c\r\n          escaping = false\r\n          continue\r\n        }\r\n\r\n        // finish up the class.\r\n        hasMagic = true\r\n        inClass = false\r\n        re += c\r\n        continue\r\n\r\n      default:\r\n        // swallow any state char that wasn\'t consumed\r\n        clearStateChar()\r\n\r\n        if (escaping) {\r\n          // no need\r\n          escaping = false\r\n        } else if (reSpecials[c]\r\n                   && !(c === "^" && inClass)) {\r\n          re += "\\\\"\r\n        }\r\n\r\n        re += c\r\n\r\n    } // switch\r\n  } // for\r\n\r\n\r\n  // handle the case where we left a class open.\r\n  // "[abc" is valid, equivalent to "\\[abc"\r\n  if (inClass) {\r\n    // split where the last [ was, and escape it\r\n    // this is a huge pita.  We now have to re-walk\r\n    // the contents of the would-be class to re-translate\r\n    // any characters that were passed through as-is\r\n    var cs = pattern.substr(classStart + 1)\r\n      , sp = this.parse(cs, SUBPARSE)\r\n    re = re.substr(0, reClassStart) + "\\\\[" + sp[0]\r\n    hasMagic = hasMagic || sp[1]\r\n  }\r\n\r\n  // handle the case where we had a +( thing at the *end*\r\n  // of the pattern.\r\n  // each pattern list stack adds 3 chars, and we need to go through\r\n  // and escape any | chars that were passed through as-is for the regexp.\r\n  // Go through and escape them, taking care not to double-escape any\r\n  // | chars that were already escaped.\r\n  var pl\r\n  while (pl = patternListStack.pop()) {\r\n    var tail = re.slice(pl.reStart + 3)\r\n    // maybe some even number of \\, then maybe 1 \\, followed by a |\r\n    tail = tail.replace(/((?:\\\\{2})*)(\\\\?)\\|/g, function (_, $1, $2) {\r\n      if (!$2) {\r\n        // the | isn\'t already escaped, so escape it.\r\n        $2 = "\\\\"\r\n      }\r\n\r\n      // need to escape all those slashes *again*, without escaping the\r\n      // one that we need for escaping the | character.  As it works out,\r\n      // escaping an even number of slashes can be done by simply repeating\r\n      // it exactly after itself.  That\'s why this trick works.\r\n      //\r\n      // I am sorry that you have to see this.\r\n      return $1 + $1 + $2 + "|"\r\n    })\r\n\r\n    // console.error("tail=%j\\n   %s", tail, tail)\r\n    var t = pl.type === "*" ? star\r\n          : pl.type === "?" ? qmark\r\n          : "\\\\" + pl.type\r\n\r\n    hasMagic = true\r\n    re = re.slice(0, pl.reStart)\r\n       + t + "\\\\("\r\n       + tail\r\n  }\r\n\r\n  // handle trailing things that only matter at the very end.\r\n  clearStateChar()\r\n  if (escaping) {\r\n    // trailing \\\\\r\n    re += "\\\\\\\\"\r\n  }\r\n\r\n  // only need to apply the nodot start if the re starts with\r\n  // something that could conceivably capture a dot\r\n  var addPatternStart = false\r\n  switch (re.charAt(0)) {\r\n    case ".":\r\n    case "[":\r\n    case "(": addPatternStart = true\r\n  }\r\n\r\n  // if the re is not "" at this point, then we need to make sure\r\n  // it doesn\'t match against an empty path part.\r\n  // Otherwise a/* will match a/, which it should not.\r\n  if (re !== "" && hasMagic) re = "(?=.)" + re\r\n\r\n  if (addPatternStart) re = patternStart + re\r\n\r\n  // parsing just a piece of a larger pattern.\r\n  if (isSub === SUBPARSE) {\r\n    return [ re, hasMagic ]\r\n  }\r\n\r\n  // skip the regexp for non-magical patterns\r\n  // unescape anything in it, though, so that it\'ll be\r\n  // an exact match against a file etc.\r\n  if (!hasMagic) {\r\n    return globUnescape(pattern)\r\n  }\r\n\r\n  var flags = options.nocase ? "i" : ""\r\n    , regExp = new RegExp("^" + re + "$", flags)\r\n\r\n  regExp._glob = pattern\r\n  regExp._src = re\r\n\r\n  return regExp\r\n}\r\n\r\nminimatch.makeRe = function (pattern, options) {\r\n  return new Minimatch(pattern, options || {}).makeRe()\r\n}\r\n\r\nMinimatch.prototype.makeRe = makeRe\r\nfunction makeRe () {\r\n  if (this.regexp || this.regexp === false) return this.regexp\r\n\r\n  // at this point, this.set is a 2d array of partial\r\n  // pattern strings, or "**".\r\n  //\r\n  // It\'s better to use .match().  This function shouldn\'t\r\n  // be used, really, but it\'s pretty convenient sometimes,\r\n  // when you just want to work with a regex.\r\n  var set = this.set\r\n\r\n  if (!set.length) return this.regexp = false\r\n  var options = this.options\r\n\r\n  var twoStar = options.noglobstar ? star\r\n      : options.dot ? twoStarDot\r\n      : twoStarNoDot\r\n    , flags = options.nocase ? "i" : ""\r\n\r\n  var re = set.map(function (pattern) {\r\n    return pattern.map(function (p) {\r\n      return (p === GLOBSTAR) ? twoStar\r\n           : (typeof p === "string") ? regExpEscape(p)\r\n           : p._src\r\n    }).join("\\\\\\/")\r\n  }).join("|")\r\n\r\n  // must match entire pattern\r\n  // ending in a * or ** will make it less strict.\r\n  re = "^(?:" + re + ")$"\r\n\r\n  // can match anything, as long as it\'s not this.\r\n  if (this.negate) re = "^(?!" + re + ").*$"\r\n\r\n  try {\r\n    return this.regexp = new RegExp(re, flags)\r\n  } catch (ex) {\r\n    return this.regexp = false\r\n  }\r\n}\r\n\r\nminimatch.match = function (list, pattern, options) {\r\n  var mm = new Minimatch(pattern, options)\r\n  list = list.filter(function (f) {\r\n    return mm.match(f)\r\n  })\r\n  if (options.nonull && !list.length) {\r\n    list.push(pattern)\r\n  }\r\n  return list\r\n}\r\n\r\nMinimatch.prototype.match = match\r\nfunction match (f, partial) {\r\n  // console.error("match", f, this.pattern)\r\n  // short-circuit in the case of busted things.\r\n  // comments, etc.\r\n  if (this.comment) return false\r\n  if (this.empty) return f === ""\r\n\r\n  if (f === "/" && partial) return true\r\n\r\n  var options = this.options\r\n\r\n  // windows: need to use /, not \\\r\n  // On other platforms, \\ is a valid (albeit bad) filename char.\r\n  if (platform === "win32") {\r\n    f = f.split("\\\\").join("/")\r\n  }\r\n\r\n  // treat the test path as a set of pathparts.\r\n  f = f.split(slashSplit)\r\n  if (options.debug) {\r\n    console.error(this.pattern, "split", f)\r\n  }\r\n\r\n  // just ONE of the pattern sets in this.set needs to match\r\n  // in order for it to be valid.  If negating, then just one\r\n  // match means that we have failed.\r\n  // Either way, return on the first hit.\r\n\r\n  var set = this.set\r\n  // console.error(this.pattern, "set", set)\r\n\r\n  for (var i = 0, l = set.length; i < l; i ++) {\r\n    var pattern = set[i]\r\n    var hit = this.matchOne(f, pattern, partial)\r\n    if (hit) {\r\n      if (options.flipNegate) return true\r\n      return !this.negate\r\n    }\r\n  }\r\n\r\n  // didn\'t get any hits.  this is success if it\'s a negative\r\n  // pattern, failure otherwise.\r\n  if (options.flipNegate) return false\r\n  return this.negate\r\n}\r\n\r\n// set partial to true to test if, for example,\r\n// "/a/b" matches the start of "/*/b/*/d"\r\n// Partial means, if you run out of file before you run\r\n// out of pattern, then that\'s fine, as long as all\r\n// the parts match.\r\nMinimatch.prototype.matchOne = function (file, pattern, partial) {\r\n  var options = this.options\r\n\r\n  if (options.debug) {\r\n    console.error("matchOne",\r\n                  { "this": this\r\n                  , file: file\r\n                  , pattern: pattern })\r\n  }\r\n\r\n  if (options.matchBase && pattern.length === 1) {\r\n    file = path.basename(file.join("/")).split("/")\r\n  }\r\n\r\n  if (options.debug) {\r\n    console.error("matchOne", file.length, pattern.length)\r\n  }\r\n\r\n  for ( var fi = 0\r\n          , pi = 0\r\n          , fl = file.length\r\n          , pl = pattern.length\r\n      ; (fi < fl) && (pi < pl)\r\n      ; fi ++, pi ++ ) {\r\n\r\n    if (options.debug) {\r\n      console.error("matchOne loop")\r\n    }\r\n    var p = pattern[pi]\r\n      , f = file[fi]\r\n\r\n    if (options.debug) {\r\n      console.error(pattern, p, f)\r\n    }\r\n\r\n    // should be impossible.\r\n    // some invalid regexp stuff in the set.\r\n    if (p === false) return false\r\n\r\n    if (p === GLOBSTAR) {\r\n      if (options.debug)\r\n        console.error(\'GLOBSTAR\', [pattern, p, f])\r\n\r\n      // "**"\r\n      // a/**/b/**/c would match the following:\r\n      // a/b/x/y/z/c\r\n      // a/x/y/z/b/c\r\n      // a/b/x/b/x/c\r\n      // a/b/c\r\n      // To do this, take the rest of the pattern after\r\n      // the **, and see if it would match the file remainder.\r\n      // If so, return success.\r\n      // If not, the ** "swallows" a segment, and try again.\r\n      // This is recursively awful.\r\n      //\r\n      // a/**/b/**/c matching a/b/x/y/z/c\r\n      // - a matches a\r\n      // - doublestar\r\n      //   - matchOne(b/x/y/z/c, b/**/c)\r\n      //     - b matches b\r\n      //     - doublestar\r\n      //       - matchOne(x/y/z/c, c) -> no\r\n      //       - matchOne(y/z/c, c) -> no\r\n      //       - matchOne(z/c, c) -> no\r\n      //       - matchOne(c, c) yes, hit\r\n      var fr = fi\r\n        , pr = pi + 1\r\n      if (pr === pl) {\r\n        if (options.debug)\r\n          console.error(\'** at the end\')\r\n        // a ** at the end will just swallow the rest.\r\n        // We have found a match.\r\n        // however, it will not swallow /.x, unless\r\n        // options.dot is set.\r\n        // . and .. are *never* matched by **, for explosively\r\n        // exponential reasons.\r\n        for ( ; fi < fl; fi ++) {\r\n          if (file[fi] === "." || file[fi] === ".." ||\r\n              (!options.dot && file[fi].charAt(0) === ".")) return false\r\n        }\r\n        return true\r\n      }\r\n\r\n      // ok, let\'s see if we can swallow whatever we can.\r\n      WHILE: while (fr < fl) {\r\n        var swallowee = file[fr]\r\n\r\n        if (options.debug) {\r\n          console.error(\'\\nglobstar while\',\r\n                        file, fr, pattern, pr, swallowee)\r\n        }\r\n\r\n        // XXX remove this slice.  Just pass the start index.\r\n        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\r\n          if (options.debug)\r\n            console.error(\'globstar found match!\', fr, fl, swallowee)\r\n          // found a match.\r\n          return true\r\n        } else {\r\n          // can\'t swallow "." or ".." ever.\r\n          // can only swallow ".foo" when explicitly asked.\r\n          if (swallowee === "." || swallowee === ".." ||\r\n              (!options.dot && swallowee.charAt(0) === ".")) {\r\n            if (options.debug)\r\n              console.error("dot detected!", file, fr, pattern, pr)\r\n            break WHILE\r\n          }\r\n\r\n          // ** swallows a segment, and continue.\r\n          if (options.debug)\r\n            console.error(\'globstar swallow a segment, and continue\')\r\n          fr ++\r\n        }\r\n      }\r\n      // no match was found.\r\n      // However, in partial mode, we can\'t say this is necessarily over.\r\n      // If there\'s more *pattern* left, then \r\n      if (partial) {\r\n        // ran out of file\r\n        // console.error("\\n>>> no match, partial?", file, fr, pattern, pr)\r\n        if (fr === fl) return true\r\n      }\r\n      return false\r\n    }\r\n\r\n    // something other than **\r\n    // non-magic patterns just have to match exactly\r\n    // patterns with magic have been turned into regexps.\r\n    var hit\r\n    if (typeof p === "string") {\r\n      if (options.nocase) {\r\n        hit = f.toLowerCase() === p.toLowerCase()\r\n      } else {\r\n        hit = f === p\r\n      }\r\n      if (options.debug) {\r\n        console.error("string match", p, f, hit)\r\n      }\r\n    } else {\r\n      hit = f.match(p)\r\n      if (options.debug) {\r\n        console.error("pattern match", p, f, hit)\r\n      }\r\n    }\r\n\r\n    if (!hit) return false\r\n  }\r\n\r\n  // Note: ending in / means that we\'ll get a final ""\r\n  // at the end of the pattern.  This can only match a\r\n  // corresponding "" at the end of the file.\r\n  // If the file ends in /, then it can only match a\r\n  // a pattern that ends in /, unless the pattern just\r\n  // doesn\'t have any more for it. But, a/b/ should *not*\r\n  // match "a/b/*", even though "" matches against the\r\n  // [^/]*? pattern, except in partial mode, where it might\r\n  // simply not be reached yet.\r\n  // However, a/b/ should still satisfy a/*\r\n\r\n  // now either we fell off the end of the pattern, or we\'re done.\r\n  if (fi === fl && pi === pl) {\r\n    // ran out of pattern and filename at the same time.\r\n    // an exact hit!\r\n    return true\r\n  } else if (fi === fl) {\r\n    // ran out of file, but still had pattern left.\r\n    // this is ok if we\'re doing the match as part of\r\n    // a glob fs traversal.\r\n    return partial\r\n  } else if (pi === pl) {\r\n    // ran out of pattern, still have file left.\r\n    // this is only acceptable if we\'re on the very last\r\n    // empty segment of a file with a trailing slash.\r\n    // a/* should match a/b/\r\n    var emptyFileEnd = (fi === fl - 1) && (file[fi] === "")\r\n    return emptyFileEnd\r\n  }\r\n\r\n  // should be unreachable.\r\n  throw new Error("wtf?")\r\n}\r\n\r\n\r\n// replace stuff like \\* with *\r\nfunction globUnescape (s) {\r\n  return s.replace(/\\\\(.)/g, "$1")\r\n}\r\n\r\n\r\nfunction regExpEscape (s) {\r\n  return s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, "\\\\$&")\r\n}\r\n\r\n});\n//# sourceURL=/thirdparty/globmatch.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*global define, $, localStorage, brackets, console */\r\n/*unittests: Preferences Base */\r\n\r\n/**\r\n * Infrastructure for the preferences system.\r\n *\r\n * At the top, the level at which most people will interact, is the `PreferencesSystem` object.\r\n * The most common operation is `get(id)`, which simply retrieves the value of a given preference.\r\n * \r\n * The PreferencesSystem has a collection of Scopes, which it traverses in a specified order. \r\n * Each Scope holds one level of settings. \r\n * \r\n * PreferencesManager.js sets up a singleton PreferencesSystem that has the following Scopes:\r\n *\r\n * * default (the default values for any settings that are explicitly registered)\r\n * * user (the user\'s customized settings – the equivalent of Brackets\' old \r\n *   localStorage-based system. This is the settings file that lives in AppData)\r\n * * Additional scopes for each .brackets.json file going upward in the file tree from the\r\n *   current file\r\n * \r\n * For example, if spaceUnits has a value set in a .brackets.json file near the open file, \r\n * then a call to get("spaceUnits") would return the value from that file. File values come \r\n * first, user values next, default values last. If the setting is not known \r\n * at all, undefined is returned.\r\n * \r\n * Each Scope has an associated Storage object that knows how to load and \r\n * save the preferences value for that Scope. There are two implementations: \r\n * MemoryStorage and FileStorage.\r\n * \r\n * The final concept used is that of Layers, which can be added to Scopes. Generally, a Layer looks \r\n * for a collection of preferences that are nested in some fashion in the Scope\'s \r\n * data. Under certain circumstances (decided upon by the Layer object), \r\n * those nested preferences will take precedence over the main preferences in the Scope.\r\n */\r\ndefine(\'preferences/PreferencesBase\',[\'require\',\'exports\',\'module\',\'file/FileUtils\',\'filesystem/FileSystem\',\'utils/ExtensionLoader\',\'utils/CollectionUtils\',\'thirdparty/lodash\',\'utils/Async\',\'thirdparty/globmatch\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var FileUtils         = require("file/FileUtils"),\r\n        FileSystem        = require("filesystem/FileSystem"),\r\n        ExtensionLoader   = require("utils/ExtensionLoader"),\r\n        CollectionUtils   = require("utils/CollectionUtils"),\r\n        _                 = require("thirdparty/lodash"),\r\n        Async             = require("utils/Async"),\r\n        globmatch         = require("thirdparty/globmatch");\r\n    \r\n    // CONSTANTS\r\n    var PREFERENCE_CHANGE = "change",\r\n        SCOPEORDER_CHANGE = "scopeOrderChange";\r\n    \r\n    /*\r\n     * Storages manage the loading and saving of preference data. \r\n     */\r\n    \r\n    /**\r\n     * MemoryStorage, as the name implies, stores the preferences in memory.\r\n     * This is suitable for single session data or testing.\r\n     * \r\n     * @constructor\r\n     * @param {?Object} data Initial data for the storage.\r\n     */\r\n    function MemoryStorage(data) {\r\n        this.data = data || {};\r\n    }\r\n    \r\n    MemoryStorage.prototype = {\r\n        \r\n        /**\r\n         * *Synchronously* returns the data stored in this storage.\r\n         * The original object (not a clone) is returned.\r\n         * \r\n         * @return {Promise} promise that is already resolved\r\n         */\r\n        load: function () {\r\n            var result = new $.Deferred();\r\n            result.resolve(this.data);\r\n            return result.promise();\r\n        },\r\n        \r\n        /**\r\n         * *Synchronously* saves the data to this storage. This saves\r\n         * the `newData` object reference without cloning it.\r\n         * \r\n         * @param {Object} newData The data to store.\r\n         * @return {Promise} promise that is already resolved\r\n         */\r\n        save: function (newData) {\r\n            var result = new $.Deferred();\r\n            this.data = newData;\r\n            result.resolve();\r\n            return result.promise();\r\n        },\r\n        \r\n        /**\r\n         * MemoryStorage is not stored in a file, so fileChanged is ignored.\r\n         * \r\n         * @param {string} filePath File that has changed\r\n         */\r\n        fileChanged: function (filePath) {\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Error type for problems parsing preference files.\r\n     * \r\n     * @constructor\r\n     * @param {string} message Error message\r\n     */\r\n    function ParsingError(message) {\r\n        this.name = "ParsingError";\r\n        this.message = message || "";\r\n    }\r\n    \r\n    ParsingError.prototype = new Error();\r\n    \r\n    /**\r\n     * Loads/saves preferences from a JSON file on disk.\r\n     * \r\n     * @constructor\r\n     * @param {string} path Path to the preferences file\r\n     * @param {boolean} createIfNew True if the file should be created if it doesn\'t exist.\r\n     *                              If this is not true, an exception will be thrown if the\r\n     *                              file does not exist.\r\n     */\r\n    function FileStorage(path, createIfNew) {\r\n        this.path = path;\r\n        this.createIfNew = createIfNew;\r\n        this._lineEndings = FileUtils.getPlatformLineEndings();\r\n    }\r\n    \r\n    FileStorage.prototype = {\r\n        \r\n        /**\r\n         * Loads the preferences from disk. Can throw an exception if the file is not\r\n         * readable or parseable.\r\n         * \r\n         * @return {Promise} Resolved with the data once it has been parsed.\r\n         */\r\n        load: function () {\r\n            var result = new $.Deferred();\r\n            var path = this.path;\r\n            var createIfNew = this.createIfNew;\r\n            var self = this;\r\n            \r\n            if (path) {\r\n                var prefFile = FileSystem.getFileForPath(path);\r\n                prefFile.read({}, function (err, text) {\r\n                    if (err) {\r\n                        if (createIfNew) {\r\n                            result.resolve({});\r\n                        } else {\r\n                            result.reject(new Error("Unable to load prefs at " + path + " " + err));\r\n                        }\r\n                        return;\r\n                    }\r\n                    \r\n                    self._lineEndings = FileUtils.sniffLineEndings(text);\r\n                    \r\n                    // If the file is empty, turn it into an empty object\r\n                    if (/^\\s*$/.test(text)) {\r\n                        result.resolve({});\r\n                    } else {\r\n                        try {\r\n                            result.resolve(JSON.parse(text));\r\n                        } catch (e) {\r\n                            result.reject(new ParsingError("Invalid JSON settings at " + path + "(" + e.toString() + ")"));\r\n                        }\r\n                    }\r\n                });\r\n            } else {\r\n                result.resolve({});\r\n            }\r\n            \r\n            return result.promise();\r\n        },\r\n        \r\n        /**\r\n         * Saves the new data to disk.\r\n         * \r\n         * @param {Object} newData data to save\r\n         * @return {Promise} Promise resolved (with no arguments) once the data has been saved\r\n         */\r\n        save: function (newData) {\r\n            var result = new $.Deferred();\r\n            var path = this.path;\r\n            var prefFile = FileSystem.getFileForPath(path);\r\n            \r\n            if (path) {\r\n                try {\r\n                    var text = JSON.stringify(newData, null, 4);\r\n                    \r\n                    // maintain the original line endings\r\n                    text = FileUtils.translateLineEndings(text, this._lineEndings);\r\n                    prefFile.write(text, {}, function (err) {\r\n                        if (err) {\r\n                            result.reject("Unable to save prefs at " + path + " " + err);\r\n                        } else {\r\n                            result.resolve();\r\n                        }\r\n                    });\r\n                } catch (e) {\r\n                    result.reject("Unable to convert prefs to JSON" + e.toString());\r\n                }\r\n            } else {\r\n                result.resolve();\r\n            }\r\n            return result.promise();\r\n        },\r\n        \r\n        /**\r\n         * Changes the path to the preferences file.\r\n         * This sends a "changed" event to listeners, regardless of whether\r\n         * the path has changed.\r\n         * \r\n         * @param {string} newPath location of this settings file\r\n         */\r\n        setPath: function (newPath) {\r\n            this.path = newPath;\r\n            $(this).trigger("changed");\r\n        },\r\n        \r\n        /**\r\n         * If the filename matches this Storage\'s path, a changed message is triggered.\r\n         * \r\n         * @param {string} filePath File that has changed\r\n         */\r\n        fileChanged: function (filePath) {\r\n            if (filePath === this.path) {\r\n                $(this).trigger("changed");\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * A `Scope` is a data container that is tied to a `Storage`.\r\n     * \r\n     * Additionally, `Scope`s support "layers" which are additional levels of preferences\r\n     * that are stored within a single preferences file.\r\n     * \r\n     * @constructor\r\n     * @param {Storage} storage Storage object from which prefs are loaded/saved\r\n     */\r\n    function Scope(storage) {\r\n        this.storage = storage;\r\n        $(storage).on("changed", this.load.bind(this));\r\n        this.data = {};\r\n        this._dirty = false;\r\n        this._layers = [];\r\n        this._layerMap = {};\r\n        this._exclusions = [];\r\n    }\r\n    \r\n    _.extend(Scope.prototype, {\r\n        /**\r\n         * Loads the prefs for this `Scope` from the `Storage`.\r\n         * \r\n         * @return {Promise} Promise that is resolved once loading is complete\r\n         */\r\n        load: function () {\r\n            var result = new $.Deferred();\r\n            this.storage.load()\r\n                .then(function (data) {\r\n                    var oldKeys = this.getKeys();\r\n                    this.data = data;\r\n                    result.resolve();\r\n                    $(this).trigger(PREFERENCE_CHANGE, {\r\n                        ids: _.union(this.getKeys(), oldKeys)\r\n                    });\r\n                }.bind(this))\r\n                .fail(function (error) {\r\n                    result.reject(error);\r\n                });\r\n            return result.promise();\r\n        },\r\n            \r\n        /**\r\n         * Saves the prefs for this `Scope`.\r\n         * \r\n         * @return {Promise} promise resolved once the data is saved.\r\n         */\r\n        save: function () {\r\n            var self = this;\r\n            if (this._dirty) {\r\n                self._dirty = false;\r\n                return this.storage.save(this.data);\r\n            } else {\r\n                return (new $.Deferred()).resolve().promise();\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Sets the value for `id`. The value is set at the location given, or at the current\r\n         * location for the preference if no location is specified. If an invalid location is\r\n         * given, nothing will be set and no exception is thrown.\r\n         * \r\n         * @param {string} id Key to set\r\n         * @param {*} value Value for this key\r\n         * @param {Object=} context Optional additional information about the request (typically used for layers)\r\n         * @param {{layer: ?string, layerID: ?Object}=} location Optional location in which to set the value.\r\n         *                                                      If the object is empty, the value will be\r\n         *                                                      set at the Scope\'s base level.\r\n         * @return {boolean} true if the value was set\r\n         */\r\n        set: function (id, value, context, location) {\r\n            if (!location) {\r\n                location = this.getPreferenceLocation(id, context);\r\n            }\r\n            if (location && location.layer) {\r\n                var layer = this._layerMap[location.layer];\r\n                if (layer) {\r\n                    if (this.data[layer.key] === undefined) {\r\n                        this.data[layer.key] = {};\r\n                    }\r\n                    \r\n                    var wasSet = layer.set(this.data[layer.key], id, value, context, location.layerID);\r\n                    this._dirty = this._dirty || wasSet;\r\n                    return wasSet;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                return this._performSet(id, value);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * @private\r\n         * \r\n         * Performs the set operation on this Scope\'s data, deleting the given ID if\r\n         * the new value is undefined. The dirty flag will be set as well.\r\n         * \r\n         * @param {string} id key to set or delete\r\n         * @param {*} value value for this key (undefined to delete)\r\n         * @return {boolean} true if the value was set.\r\n         */\r\n        _performSet: function (id, value) {\r\n            if (!_.isEqual(this.data[id], value)) {\r\n                this._dirty = true;\r\n                if (value === undefined) {\r\n                    delete this.data[id];\r\n                } else {\r\n                    this.data[id] = _.cloneDeep(value);\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        \r\n        /**\r\n         * Get the value for id, given the context. The context is provided to layers\r\n         * which may override the value from the main data of the Scope. Note that\r\n         * layers will often exclude values from consideration.\r\n         * \r\n         * @param {string} id Preference to retrieve\r\n         * @param {?Object} context Optional additional information about the request\r\n         * @return {*} Current value of the Preference\r\n         */\r\n        get: function (id, context) {\r\n            var layerCounter,\r\n                layers = this._layers,\r\n                layer,\r\n                data = this.data,\r\n                result;\r\n            \r\n            context = context || {};\r\n            \r\n            for (layerCounter = 0; layerCounter < layers.length; layerCounter++) {\r\n                layer = layers[layerCounter];\r\n                result = layer.get(data[layer.key], id, context);\r\n                if (result !== undefined) {\r\n                    return result;\r\n                }\r\n            }\r\n            \r\n            if (this._exclusions.indexOf(id) === -1) {\r\n                return data[id];\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Get the location in this Scope (if any) where the given preference is set.\r\n         * \r\n         * @param {string} id Name of the preference for which the value should be retrieved\r\n         * @param {Object=} context Optional context object to change the preference lookup\r\n         * @return {{layer: ?string, layerID: ?object}|undefined} Object describing where the preferences came from. \r\n         *                                              An empty object means that it was defined in the Scope\'s\r\n         *                                              base data. Undefined means the pref is not\r\n         *                                              defined in this Scope.\r\n         */\r\n        getPreferenceLocation: function (id, context) {\r\n            var layerCounter,\r\n                layers = this._layers,\r\n                layer,\r\n                data = this.data,\r\n                result;\r\n            \r\n            context = context || {};\r\n            \r\n            for (layerCounter = 0; layerCounter < layers.length; layerCounter++) {\r\n                layer = layers[layerCounter];\r\n                result = layer.getPreferenceLocation(data[layer.key], id, context);\r\n                if (result !== undefined) {\r\n                    return {\r\n                        layer: layer.key,\r\n                        layerID: result\r\n                    };\r\n                }\r\n            }\r\n            \r\n            if (this._exclusions.indexOf(id) === -1 && data[id] !== undefined) {\r\n                // The value is defined in this Scope, which means we need to return an\r\n                // empty object as a signal to the PreferencesSystem that this pref\r\n                // is defined in this Scope (in the base data)\r\n                return {};\r\n            }\r\n            \r\n            // return undefined when this Scope does not have the requested pref\r\n            return undefined;\r\n        },\r\n        \r\n        /**\r\n         * Get the preference IDs that are set in this Scope. All layers are added\r\n         * in. If context is not provided, the set of all keys in the Scope including\r\n         * all keys in each layer will be returned.\r\n         * \r\n         * @param {?Object} context Optional additional information for looking up the keys\r\n         * @return {Array.<string>} Set of preferences set by this Scope\r\n         */\r\n        getKeys: function (context) {\r\n            context = context || {};\r\n            \r\n            var layerCounter,\r\n                layers = this._layers,\r\n                layer,\r\n                data = this.data;\r\n            \r\n            var keySets = [_.difference(_.keys(data), this._exclusions)];\r\n            for (layerCounter = 0; layerCounter < layers.length; layerCounter++) {\r\n                layer = layers[layerCounter];\r\n                keySets.push(layer.getKeys(data[layer.key], context));\r\n            }\r\n            \r\n            return _.union.apply(null, keySets);\r\n        },\r\n        \r\n        /**\r\n         * Adds a Layer to this Scope. The Layer object should define a `key`, which\r\n         * represents the subset of the preference data that the Layer works with.\r\n         * Layers should also define `get` and `getKeys` operations that are like their\r\n         * counterparts in Scope but take "data" as the first argument.\r\n         * \r\n         * Listeners are notified of potential changes in preferences with the addition of\r\n         * this layer.\r\n         * \r\n         * @param {Layer} layer Layer object to add to this Scope\r\n         */\r\n        addLayer: function (layer) {\r\n            this._layers.push(layer);\r\n            this._layerMap[layer.key] = layer;\r\n            this._exclusions.push(layer.key);\r\n            $(this).trigger(PREFERENCE_CHANGE, {\r\n                ids: layer.getKeys(this.data[layer.key], {})\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Tells the Scope that the given file has been changed so that the\r\n         * Storage can be reloaded if needed.\r\n         * \r\n         * @param {string} filePath File that has changed\r\n         */\r\n        fileChanged: function (filePath) {\r\n            this.storage.fileChanged(filePath);\r\n        },\r\n        \r\n        /**\r\n         * Determines if there are likely to be any changes based on a change\r\n         * to the default filename used in lookups.\r\n         * \r\n         * @param {string} filename New filename\r\n         * @param {string} oldFilename Old filename\r\n         * @return {Array.<string>} List of changed IDs\r\n         */\r\n        defaultFilenameChanged: function (filename, oldFilename) {\r\n            var changes = [],\r\n                data    = this.data;\r\n            \r\n            _.each(this._layers, function (layer) {\r\n                if (layer.defaultFilenameChanged && data[layer.key]) {\r\n                    var changesInLayer = layer.defaultFilenameChanged(data[layer.key],\r\n                                                                      filename,\r\n                                                                      oldFilename);\r\n                    if (changesInLayer) {\r\n                        changes.push(changesInLayer);\r\n                    }\r\n                }\r\n            });\r\n            return _.union.apply(null, changes);\r\n        }\r\n    });\r\n    \r\n    // Utility functions for the PathLayer\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Look for a matching file glob among the collection of paths.\r\n     * \r\n     * @param {Object} pathData The keys are globs and the values are the preferences for that glob\r\n     * @param {string} filename relative filename to match against the globs\r\n     * @return {?string} glob pattern that matched, if any\r\n     */\r\n    function _findMatchingGlob(pathData, filename) {\r\n        var globs = Object.keys(pathData),\r\n            globCounter;\r\n\r\n        if (!filename) {\r\n            return;\r\n        }\r\n\r\n        for (globCounter = 0; globCounter < globs.length; globCounter++) {\r\n            var glob = globs[globCounter];\r\n\r\n            if (globmatch(filename, glob)) {\r\n                return glob;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a default project layer object that has a single property "key"\r\n     * with "project" as its value. \r\n     *\r\n     * @constructor\r\n     */\r\n    function ProjectLayer() {\r\n        this.projectPath = null;\r\n    }\r\n\r\n    ProjectLayer.prototype = {\r\n        key: "project",\r\n\r\n        /**\r\n         * Retrieve the current value based on the current project path\r\n         * in the layer.\r\n         * \r\n         * @param {Object} data the preference data from the Scope\r\n         * @param {string} id preference ID to look up\r\n         */\r\n        get: function (data, id) {\r\n            if (!data || !this.projectPath) {\r\n                return;\r\n            }\r\n\r\n            if (data[this.projectPath] && data[this.projectPath][id]) {\r\n                return data[this.projectPath][id];\r\n            }\r\n            return;\r\n        },\r\n\r\n        /**\r\n         * Gets the location in which the given pref was set, if it was set within\r\n         * this project layer for the current project path.\r\n         * \r\n         * @param {Object} data the preference data from the Scope\r\n         * @param {string} id preference ID to look up\r\n         * @return {string} the Layer ID, in this case the current project path.\r\n         */\r\n        getPreferenceLocation: function (data, id) {\r\n            if (!data || !this.projectPath) {\r\n                return;\r\n            }\r\n\r\n            if (data[this.projectPath] && data[this.projectPath][id]) {\r\n                return this.projectPath;\r\n            }\r\n\r\n            return;\r\n        },\r\n\r\n        /**\r\n         * Sets the preference value in the given data structure for the layerID provided. If no\r\n         * layerID is provided, then the current project path is used. If a layerID is provided \r\n         * and it does not exist, it will be created.\r\n         * \r\n         * This function returns whether or not a value was set.\r\n         * \r\n         * @param {Object} data the preference data from the Scope\r\n         * @param {string} id preference ID to look up\r\n         * @param {Object} value new value to assign to the preference\r\n         * @param {Object} context Object with scope and layer key-value pairs (not yet used in project layer)\r\n         * @param {string=} layerID Optional: project path to be used for setting value\r\n         * @return {boolean} true if the value was set\r\n         */\r\n        set: function (data, id, value, context, layerID) {\r\n            if (!layerID) {\r\n                layerID = this.getPreferenceLocation(data, id);\r\n            }\r\n\r\n            if (!layerID) {\r\n                return false;\r\n            }\r\n\r\n            var section = data[layerID];\r\n            if (!section) {\r\n                data[layerID] = section = {};\r\n            }\r\n            if (!_.isEqual(section[id], value)) {\r\n                if (value === undefined) {\r\n                    delete section[id];\r\n                } else {\r\n                    section[id] = _.cloneDeep(value);\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n\r\n        /**\r\n         * Retrieves the keys provided by this layer object.\r\n         * \r\n         * @param {Object} data the preference data from the Scope\r\n         */\r\n        getKeys: function (data) {\r\n            if (!data) {\r\n                return;\r\n            }\r\n\r\n            return _.union.apply(null, _.map(_.values(data), _.keys));\r\n        },\r\n\r\n        /**\r\n         * Set the project path to be used as the layer ID of this layer object.\r\n         * \r\n         * @param {string} projectPath Path of the project root\r\n         */\r\n        setProjectPath: function (projectPath) {\r\n            this.projectPath = projectPath;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Provides layered preferences based on file globs, generally following the model provided\r\n     * by [EditorConfig](http://editorconfig.org/). In usage, it looks something like this\r\n     * (switching to single line comments because the glob interferes with the multiline comment):\r\n     */\r\n    \r\n//    "path": {\r\n//        "src/thirdparty/CodeMirror2/**/*.js": {\r\n//            "spaceUnits": 2,\r\n//            "linting.enabled": false\r\n//        }\r\n//    }\r\n    \r\n    /**\r\n     * There can be multiple paths and they are each checked in turn. The first that matches the\r\n     * currently edited file wins.\r\n     * \r\n     * @constructor\r\n     * @param {string} prefFilePath path to the preference file\r\n     */\r\n    function PathLayer(prefFilePath) {\r\n        this.setPrefFilePath(prefFilePath);\r\n    }\r\n    \r\n    PathLayer.prototype = {\r\n        key: "path",\r\n        \r\n        /**\r\n         * Retrieve the current value based on the filename in the context\r\n         * object, comparing globs relative to the prefFilePath that this\r\n         * PathLayer was set up with.\r\n         * \r\n         * @param {Object} data the preference data from the Scope\r\n         * @param {string} id preference ID to look up\r\n         * @param {Object} context Object with filename that will be compared to the globs\r\n         */\r\n        get: function (data, id, context) {\r\n            var glob = this.getPreferenceLocation(data, id, context);\r\n            \r\n            if (!glob) {\r\n                return;\r\n            }\r\n            \r\n            return data[glob][id];\r\n        },\r\n        \r\n        /**\r\n         * Gets the location in which the given pref was set, if it was set within\r\n         * this path layer for the current path.\r\n         * \r\n         * @param {Object} data the preference data from the Scope\r\n         * @param {string} id preference ID to look up\r\n         * @param {Object} context Object with filename that will be compared to the globs\r\n         * @return {string} the Layer ID, in this case the glob that matched\r\n         */\r\n        getPreferenceLocation: function (data, id, context) {\r\n            if (!data) {\r\n                return;\r\n            }\r\n            \r\n            var relativeFilename = FileUtils.getRelativeFilename(this.prefFilePath, context.filename);\r\n            if (!relativeFilename) {\r\n                return;\r\n            }\r\n            \r\n            return _findMatchingGlob(data, relativeFilename);\r\n        },\r\n        \r\n        /**\r\n         * Sets the preference value in the given data structure for the layerID provided. If no\r\n         * layerID is provided, then the current layer is used. If a layerID is provided and it\r\n         * does not exist, it will be created.\r\n         * \r\n         * This function returns whether or not a value was set.\r\n         * \r\n         * @param {Object} data the preference data from the Scope\r\n         * @param {string} id preference ID to look up\r\n         * @param {Object} value new value to assign to the preference\r\n         * @param {Object} context Object with filename that will be compared to the globs\r\n         * @param {string=} layerID Optional: glob pattern for a specific section to set the value in\r\n         * @return {boolean} true if the value was set\r\n         */\r\n        set: function (data, id, value, context, layerID) {\r\n            if (!layerID) {\r\n                layerID = this.getPreferenceLocation(data, id, context);\r\n            }\r\n            \r\n            if (!layerID) {\r\n                return false;\r\n            }\r\n            \r\n            var section = data[layerID];\r\n            if (!section) {\r\n                data[layerID] = section = {};\r\n            }\r\n            if (!_.isEqual(section[id], value)) {\r\n                if (value === undefined) {\r\n                    delete section[id];\r\n                } else {\r\n                    section[id] = _.cloneDeep(value);\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        },\r\n        \r\n        /**\r\n         * Retrieves the keys provided by this layer object. If context with a filename is provided,\r\n         * only the keys for the matching file glob are given. Otherwise, all keys for all globs\r\n         * are provided.\r\n         * \r\n         * @param {Object} data the preference data from the Scope\r\n         * @param {?Object} context Additional context data (filename in particular is important)\r\n         */\r\n        getKeys: function (data, context) {\r\n            if (!data) {\r\n                return;\r\n            }\r\n            \r\n            var relativeFilename = FileUtils.getRelativeFilename(this.prefFilePath, context.filename);\r\n            \r\n            if (relativeFilename) {\r\n                var glob = _findMatchingGlob(data, relativeFilename);\r\n                if (glob) {\r\n                    return _.keys(data[glob]);\r\n                } else {\r\n                    return [];\r\n                }\r\n            }\r\n            return _.union.apply(null, _.map(_.values(data), _.keys));\r\n        },\r\n        \r\n        /**\r\n         * Changes the preference file path.\r\n         * \r\n         * @param {string} prefFilePath New path to the preferences file\r\n         */\r\n        setPrefFilePath: function (prefFilePath) {\r\n            if (!prefFilePath) {\r\n                this.prefFilePath = "/";\r\n            } else {\r\n                this.prefFilePath = FileUtils.getDirectoryPath(prefFilePath);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Determines if there are preference IDs that could change as a result of\r\n         * a change to the default filename.\r\n         * \r\n         * @param {Object} data Data in the Scope\r\n         * @param {string} filename New filename\r\n         * @param {string} oldFilename Old filename\r\n         * @return {Array.<string>} list of preference IDs that could have changed\r\n         */\r\n        defaultFilenameChanged: function (data, filename, oldFilename) {\r\n            var newGlob = _findMatchingGlob(data,\r\n                              FileUtils.getRelativeFilename(this.prefFilePath, filename)),\r\n                oldGlob = _findMatchingGlob(data,\r\n                              FileUtils.getRelativeFilename(this.prefFilePath, oldFilename));\r\n            \r\n            \r\n            if (newGlob === oldGlob) {\r\n                return;\r\n            }\r\n            if (newGlob === undefined) {\r\n                return _.keys(data[oldGlob]);\r\n            }\r\n            if (oldGlob === undefined) {\r\n                return _.keys(data[newGlob]);\r\n            }\r\n            \r\n            return _.union(_.keys(data[oldGlob]), _.keys(data[newGlob]));\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Represents a single, known Preference.\r\n     * \r\n     * @constructor\r\n     * @param {Object} properties Information about the Preference that is stored on this object\r\n     */\r\n    function Preference(properties) {\r\n        _.extend(this, properties);\r\n    }\r\n    \r\n    _.extend(Preference.prototype, {\r\n        /**\r\n         * Sets an event handler on this Preference.\r\n         * \r\n         * @param {string} event Event name\r\n         * @param {Function} handler Function to handle the event\r\n         */\r\n        on: function (event, handler) {\r\n            $(this).on(event, handler);\r\n        },\r\n        \r\n        /**\r\n         * Removes an event handler from this Preference\r\n         * \r\n         * @param {string} event Event name\r\n         * @param {?Function} handler Optional specific function to stop receiving events \r\n         */\r\n        off: function (event, handler) {\r\n            $(this).off(event, handler);\r\n        }\r\n    });\r\n    \r\n    /**\r\n     * Provides a subset of the PreferencesSystem functionality with preference\r\n     * access always occurring with the given prefix.\r\n     * \r\n     * @constructor\r\n     * @param {PreferencesSystem} base The real PreferencesSystem that is backing this one\r\n     * @param {string} prefix Prefix that is used for preferences lookup. Any separator characters should already be added.\r\n     */\r\n    function PrefixedPreferencesSystem(base, prefix) {\r\n        this.base = base;\r\n        this.prefix = prefix;\r\n        this._listenerInstalled = false;\r\n    }\r\n    \r\n    PrefixedPreferencesSystem.prototype = {\r\n        /**\r\n         * Defines a new (prefixed) preference.\r\n         * \r\n         * @param {string} id unprefixed identifier of the preference. Generally a dotted name.\r\n         * @param {string} type Data type for the preference (generally, string, boolean, number)\r\n         * @param {Object} initial Default value for the preference\r\n         * @param {?Object} options Additional options for the pref. Can include name and description\r\n         *                          that will ultimately be used in UI.\r\n         * @return {Object} The preference object.\r\n         */\r\n        definePreference: function (id, type, initial, options) {\r\n            return this.base.definePreference(this.prefix + id, type, initial, options);\r\n        },\r\n        \r\n        /**\r\n         * Get the prefixed preference object\r\n         * \r\n         * @param {string} id ID of the pref to retrieve.\r\n         */\r\n        getPreference: function (id) {\r\n            return this.base.getPreference(this.prefix + id);\r\n        },\r\n        \r\n        /**\r\n         * Gets the prefixed preference\r\n         * \r\n         * @param {string} id Name of the preference for which the value should be retrieved\r\n         * @param {Object=} context Optional context object to change the preference lookup\r\n         */\r\n        get: function (id, context) {\r\n            return this.base.get(this.prefix + id, context);\r\n        },\r\n        \r\n        /**\r\n         * Gets the location in which the value of a prefixed preference has been set.\r\n         * \r\n         * @param {string} id Name of the preference for which the value should be retrieved\r\n         * @param {Object=} context Optional context object to change the preference lookup\r\n         * @return {{scope: string, layer: ?string, layerID: ?object}} Object describing where the preferences came from\r\n         */\r\n        getPreferenceLocation: function (id, context) {\r\n            return this.base.getPreferenceLocation(this.prefix + id, context);\r\n        },\r\n        \r\n        /**\r\n         * Sets the prefixed preference\r\n         * \r\n         * @param {string} id Identifier of the preference to set\r\n         * @param {Object} value New value for the preference\r\n         * @param {{location: ?Object, context: ?Object}=} options Specific location in which to set the value or the context to use when setting the value\r\n         * @param {boolean=} doNotSave True if the preference change should not be saved automatically.\r\n         * @return {valid:  {boolean}, true if no validator specified or if value is valid\r\n         *          stored: {boolean}} true if a value was stored\r\n         */\r\n        set: function (id, value, options, doNotSave) {\r\n            return this.base.set(this.prefix + id, value, options, doNotSave);\r\n        },\r\n        \r\n        /**\r\n         * @private\r\n         * \r\n         * Listens for events on the base PreferencesSystem to filter down to the\r\n         * events that consumers of this PreferencesSystem would be interested in.\r\n         */\r\n        _installListener: function () {\r\n            if (this._listenerInstalled) {\r\n                return;\r\n            }\r\n            var $this = $(this),\r\n                prefix = this.prefix;\r\n            \r\n            var onlyWithPrefix = function (id) {\r\n                if (id.substr(0, prefix.length) === prefix) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            };\r\n            \r\n            var withoutPrefix = function (id) {\r\n                return id.substr(prefix.length);\r\n            };\r\n            \r\n            $(this.base).on(PREFERENCE_CHANGE, function (e, data) {\r\n                var prefixedIds = data.ids.filter(onlyWithPrefix);\r\n                \r\n                if (prefixedIds.length > 0) {\r\n                    $this.trigger(PREFERENCE_CHANGE, {\r\n                        ids: prefixedIds.map(withoutPrefix)\r\n                    });\r\n                }\r\n            });\r\n            \r\n            this._listenerInstalled = true;\r\n        },\r\n        \r\n        /**\r\n         * Sets up a listener for events for this PrefixedPreferencesSystem. Only prefixed events\r\n         * will notify. Optionally, you can set up a listener for a\r\n         * specific preference.\r\n         * \r\n         * @param {string} event Name of the event to listen for\r\n         * @param {string|Function} preferenceID Name of a specific preference or the handler function\r\n         * @param {?Function} handler Handler for the event\r\n         */\r\n        on: function (event, preferenceID, handler) {\r\n            if (typeof preferenceID === "function") {\r\n                handler = preferenceID;\r\n                preferenceID = null;\r\n            }\r\n            \r\n            if (preferenceID) {\r\n                var pref = this.getPreference(preferenceID);\r\n                pref.on(event, handler);\r\n            } else {\r\n                this._installListener();\r\n                $(this).on(event, handler);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Turns off the event handlers for a given event, optionally for a specific preference\r\n         * or a specific handler function.\r\n         * \r\n         * @param {string} event Name of the event for which to turn off listening\r\n         * @param {string|Function} preferenceID Name of a specific preference or the handler function\r\n         * @param {?Function} handler Specific handler which should stop being notified\r\n         */\r\n        off: function (event, preferenceID, handler) {\r\n            if (typeof preferenceID === "function") {\r\n                handler = preferenceID;\r\n                preferenceID = null;\r\n            }\r\n            \r\n            if (preferenceID) {\r\n                var pref = this.getPreference(preferenceID);\r\n                pref.off(event, handler);\r\n            } else {\r\n                $(this).off(event, handler);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Saves the preferences. If a save is already in progress, a Promise is returned for\r\n         * that save operation.\r\n         * \r\n         * @return {Promise} Resolved when the preferences are done saving.\r\n         */\r\n        save: function () {\r\n            return this.base.save();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * PreferencesSystem ties everything together to provide a simple interface for\r\n     * managing the whole prefs system.\r\n     * \r\n     * It keeps track of multiple Scope levels and also manages path-based Scopes.\r\n     * \r\n     * It also provides the ability to register preferences, which gives a fine-grained\r\n     * means for listening for changes and will ultimately allow for automatic UI generation.\r\n     * \r\n     * The contextNormalizer is used to customize get/set contexts based on the needs of individual\r\n     * context systems. It can be passed in at construction time or set later.\r\n     * \r\n     * @constructor\r\n     * @param {function=} contextNormalizer function that is passed the context used for get or set to adjust for specific PreferencesSystem behavior\r\n     */\r\n    function PreferencesSystem(contextNormalizer) {\r\n        this.contextNormalizer = contextNormalizer;\r\n        \r\n        this._knownPrefs = {};\r\n        this._scopes = {\r\n            "default": new Scope(new MemoryStorage())\r\n        };\r\n        \r\n        this._scopes["default"].load();\r\n        \r\n        this._defaultContext = {\r\n            scopeOrder: ["default"],\r\n            _shadowScopeOrder: [{\r\n                id: "default",\r\n                scope: this._scopes["default"],\r\n                promise: (new $.Deferred()).resolve().promise()\r\n            }]\r\n        };\r\n        \r\n        this._pendingScopes = {};\r\n        \r\n        this._saveInProgress = null;\r\n        this._nextSaveDeferred = null;\r\n        this.finalized = false;\r\n        \r\n        // The objects that define the different kinds of path-based Scope handlers.\r\n        // Examples could include the handler for .brackets.json files or an .editorconfig\r\n        // handler.\r\n        this._pathScopeDefinitions = {};\r\n        \r\n        // Names of the files that contain path scopes\r\n        this._pathScopeFilenames = [];\r\n        \r\n        // Keeps track of cached path scope objects.\r\n        this._pathScopes = {};\r\n        \r\n        // Keeps track of change events that need to be sent when change events are resumed\r\n        this._changeEventQueue = null;\r\n        \r\n        var notifyPrefChange = function (id) {\r\n            var pref = this._knownPrefs[id];\r\n            if (pref) {\r\n                $(pref).trigger(PREFERENCE_CHANGE);\r\n            }\r\n        }.bind(this);\r\n        \r\n        // When we signal a general change message on this manager, we also signal a change\r\n        // on the individual preference object.\r\n        $(this).on(PREFERENCE_CHANGE, function (e, data) {\r\n            data.ids.forEach(notifyPrefChange);\r\n        }.bind(this));\r\n    }\r\n    \r\n    _.extend(PreferencesSystem.prototype, {\r\n        \r\n        /**\r\n         * Defines a new preference.\r\n         * \r\n         * @param {string} id identifier of the preference. Generally a dotted name.\r\n         * @param {string} type Data type for the preference (generally, string, boolean, number)\r\n         * @param {Object} initial Default value for the preference\r\n         * @param {?Object} options Additional options for the pref. Can include name and description\r\n         *                          that will ultimately be used in UI.\r\n         * @return {Object} The preference object.\r\n         */\r\n        definePreference: function (id, type, initial, options) {\r\n            options = options || {};\r\n            if (this._knownPrefs.hasOwnProperty(id)) {\r\n                throw new Error("Preference " + id + " was redefined");\r\n            }\r\n            var pref = this._knownPrefs[id] = new Preference({\r\n                type: type,\r\n                initial: initial,\r\n                name: options.name,\r\n                description: options.description,\r\n                validator: options.validator\r\n            });\r\n            this.set(id, initial, {\r\n                location: {\r\n                    scope: "default"\r\n                }\r\n            });\r\n            return pref;\r\n        },\r\n        \r\n        /**\r\n         * Get the preference object for the given ID.\r\n         * \r\n         * @param {string} id ID of the pref to retrieve.\r\n         */\r\n        getPreference: function (id) {\r\n            return this._knownPrefs[id];\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         *\r\n         * Adds the scope before the scope specified by before argument.  This\r\n         * function must never be called directly. Use addScope to add scopes to\r\n         * PreferencesSystem, including from within its implementation.\r\n         * \r\n         * @param {string} id Id of the scope to add\r\n         * @param {string} before Id of the scope to add it before\r\n         */\r\n        _pushToScopeOrder: function (id, before) {\r\n            var defaultScopeOrder = this._defaultContext.scopeOrder,\r\n                index = _.findIndex(defaultScopeOrder, function (id) {\r\n                    return id === before;\r\n                });\r\n            if (index > -1) {\r\n                defaultScopeOrder.splice(index, 0, id);\r\n            } else {\r\n                // error\r\n                throw new Error("Internal error: scope " + before + " should be in the scope order");\r\n            }\r\n\r\n        },\r\n\r\n        /**\r\n         * @private\r\n         *\r\n         * Tries to add scope to the scopeOrder once it\'s resolved. It looks up\r\n         * context\'s _shadowScopeOrder to find an appropriate context to add it\r\n         * before.\r\n         *\r\n         * @param {Object} shadowEntry Shadow entry of the resolved scope\r\n         */\r\n        _tryAddToScopeOrder: function (shadowEntry) {\r\n            var defaultScopeOrder = this._defaultContext.scopeOrder,\r\n                shadowScopeOrder = this._defaultContext._shadowScopeOrder,\r\n                index = _.findIndex(shadowScopeOrder, function (entry) {\r\n                    return entry === shadowEntry;\r\n                }),\r\n                $this = $(this),\r\n                done = false,\r\n                i = index + 1;\r\n            \r\n            // Find an appropriate scope of lower priority to add it before\r\n            while (i < shadowScopeOrder.length) {\r\n                if (shadowScopeOrder[i].promise.state() === "pending" ||\r\n                        shadowScopeOrder[i].promise.state() === "resolved") {\r\n                    break;\r\n                }\r\n                i++;\r\n            }\r\n            switch (shadowScopeOrder[i].promise.state()) {\r\n            case "pending":\r\n                // cannot decide now, lookup once pending promise is settled\r\n                shadowScopeOrder[i].promise.always(function () {\r\n                    this._tryAddToScopeOrder(shadowEntry);\r\n                }.bind(this));\r\n                break;\r\n            case "resolved":\r\n                this._pushToScopeOrder(shadowEntry.id, shadowScopeOrder[i].id);\r\n                $this.trigger(SCOPEORDER_CHANGE, {\r\n                    id: shadowEntry.id,\r\n                    action: "added"\r\n                });\r\n                this._triggerChange({\r\n                    ids: shadowEntry.scope.getKeys()\r\n                });\r\n                break;\r\n            default:\r\n                throw new Error("Internal error: no scope found to add before. \\"default\\" is missing?..");\r\n            }\r\n\r\n        },\r\n        \r\n        /**\r\n         * @private\r\n         * \r\n         * Schedules the new Scope to be added the scope order in the specified\r\n         * location once the promise is resolved. Context\'s _shadowScopeOrder is\r\n         * used to keep track of the order in which the scope should appear. If\r\n         * the scope which should precede this scope fails to load, then\r\n         * _shadowScopeOrder will be searched for the next appropriate context\r\n         * (the first one which is pending or loaded that is before the failed\r\n         * scope). There\'s always the lowest-priority "default" scope which is\r\n         * loaded and added, it guarantees that a successfully loaded scope will\r\n         * always be added.\r\n         * \r\n         * Adding a Scope "before" another Scope means that the new Scope\'s\r\n         * preferences will take priority over the "before" Scope\'s preferences.\r\n         * \r\n         * @param {string} id Name of the new Scope\r\n         * @param {Scope} scope The scope object to add\r\n         * @param {$.Promise} promise Scope\'s load promise\r\n         * @param {?string} addBefore Name of the Scope before which this new one is added\r\n         */\r\n        _addToScopeOrder: function (id, scope, promise, addBefore) {\r\n            var defaultScopeOrder = this._defaultContext.scopeOrder,\r\n                shadowScopeOrder = this._defaultContext._shadowScopeOrder,\r\n                shadowEntry,\r\n                index,\r\n                isPending = false,\r\n                self = this;\r\n\r\n            $(scope).on(PREFERENCE_CHANGE + ".prefsys", function (e, data) {\r\n                self._triggerChange(data);\r\n            }.bind(this));\r\n\r\n            index = _.findIndex(shadowScopeOrder, function (entry) {\r\n                return entry.id === id;\r\n            });\r\n\r\n            if (index > -1) {\r\n                shadowEntry = shadowScopeOrder[index];\r\n            } else {\r\n                /* new scope is being added. */\r\n                shadowEntry = {\r\n                    id: id,\r\n                    promise: promise,\r\n                    scope: scope\r\n                };\r\n                if (!addBefore) {\r\n                    shadowScopeOrder.unshift(shadowEntry);\r\n                } else {\r\n                    index = _.findIndex(shadowScopeOrder, function (entry) {\r\n                        return entry.id === addBefore;\r\n                    });\r\n                    if (index > -1) {\r\n                        shadowScopeOrder.splice(index, 0, shadowEntry);\r\n                    } else {\r\n                        var queue = this._pendingScopes[addBefore];\r\n                        if (!queue) {\r\n                            queue = [];\r\n                            this._pendingScopes[addBefore] = queue;\r\n                        }\r\n                        queue.unshift(shadowEntry);\r\n                        isPending = true;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            if (!isPending) {\r\n                promise\r\n                    .then(function () {\r\n                        this._scopes[id] = scope;\r\n                        this._tryAddToScopeOrder(shadowEntry);\r\n                    }.bind(this))\r\n                    .fail(function (err) {\r\n                        // clean up all what\'s been done up to this point\r\n                        _.pull(shadowScopeOrder, shadowEntry);\r\n                    }.bind(this));\r\n                if (this._pendingScopes[id]) {\r\n                    var pending = this._pendingScopes[id];\r\n                    delete this._pendingScopes[id];\r\n                    pending.forEach(function (entry) {\r\n                        this._addToScopeOrder(entry.id, entry.scope, entry.promise, id);\r\n                    }.bind(this));\r\n                }\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Adds scope to the scope order by its id. The scope should be previously added to the preference system.\r\n         * \r\n         * @param {string} id the scope id\r\n         * @param {string} before the id of the scope to add before\r\n         *\r\n         */\r\n        addToScopeOrder: function (id, addBefore) {\r\n            var shadowScopeOrder = this._defaultContext._shadowScopeOrder,\r\n                index = _.findIndex(shadowScopeOrder, function (entry) {\r\n                    return entry.id === id;\r\n                }),\r\n                entry;\r\n            if (index > -1) {\r\n                entry = shadowScopeOrder[index];\r\n                this._addToScopeOrder(entry.id, entry.scope, entry.promise, addBefore);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Removes a scope from the default scope order.\r\n         * \r\n         * @param {string} id Name of the Scope to remove from the default scope order.\r\n         */\r\n        removeFromScopeOrder: function (id) {\r\n            var scope = this._scopes[id];\r\n            if (scope) {\r\n                _.pull(this._defaultContext.scopeOrder, id);\r\n                var $this = $(this);\r\n                $(scope).off(".prefsys");\r\n                $this.trigger(SCOPEORDER_CHANGE, {\r\n                    id: id,\r\n                    action: "removed"\r\n                });\r\n                this._triggerChange({\r\n                    ids: scope.getKeys()\r\n                });\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * @private\r\n         * \r\n         * Normalizes the context to be one of:\r\n         * \r\n         * 1. a context object that was passed in\r\n         * 2. the default context\r\n         * \r\n         * @param {Object} context Context that was passed in\r\n         * @return {{scopeOrder: string, filename: ?string}} context object\r\n         */\r\n        _getContext: function (context) {\r\n            if (context) {\r\n                if (this.contextNormalizer) {\r\n                    context = this.contextNormalizer(context);\r\n                }\r\n                return context;\r\n            }\r\n            return this._defaultContext;\r\n        },\r\n        \r\n        /**\r\n         * Adds a new Scope. New Scopes are added at the highest precedence, unless the "before" option\r\n         * is given. The new Scope is automatically loaded.\r\n         * \r\n         * @param {string} id Name of the Scope\r\n         * @param {Scope|Storage} scope the Scope object itself. Optionally, can be given a Storage directly for convenience.\r\n         * @param {{before: string}} options optional behavior when adding (e.g. setting which scope this comes before)\r\n         * @return {Promise} Promise that is resolved when the Scope is loaded. It is resolved\r\n         *                   with id and scope.\r\n         */\r\n        addScope: function (id, scope, options) {\r\n            var promise;\r\n            options = options || {};\r\n            \r\n            if (this._scopes[id]) {\r\n                throw new Error("Attempt to redefine preferences scope: " + id);\r\n            }\r\n            \r\n            // Check to see if scope is a Storage that needs to be wrapped\r\n            if (!scope.get) {\r\n                scope = new Scope(scope);\r\n            }\r\n            \r\n            promise = scope.load();\r\n\r\n            this._addToScopeOrder(id, scope, promise, options.before);\r\n            \r\n            promise\r\n                .fail(function (err) {\r\n                    // With preferences, it is valid for there to be no file.\r\n                    // It is not valid to have an unparseable file.\r\n                    if (err instanceof ParsingError) {\r\n                        console.error(err);\r\n                    }\r\n                });\r\n            \r\n            return promise;\r\n        },\r\n        \r\n        /**\r\n         * Removes a Scope from this PreferencesSystem. Returns without doing anything\r\n         * if the Scope does not exist. Notifies listeners of preferences that may have\r\n         * changed.\r\n         * \r\n         * @param {string} id Name of the Scope to remove\r\n         */\r\n        removeScope: function (id) {\r\n            var scope = this._scopes[id],\r\n                shadowIndex;\r\n            if (!scope) {\r\n                return;\r\n            }\r\n\r\n            this.removeFromScopeOrder(id);\r\n            shadowIndex = _.findIndex(this._defaultContext._shadowScopeOrder, function (entry) {\r\n                return entry.id === id;\r\n            });\r\n            this._defaultContext._shadowScopeOrder.splice(shadowIndex, 1);\r\n            delete this._scopes[id];\r\n        },\r\n        \r\n        /**\r\n         * @private\r\n         * \r\n         * Retrieves the appropriate scopeOrder based on the given context.\r\n         * If the context contains a scopeOrder, that will be used. If not,\r\n         * the default scopeOrder is used.\r\n         * \r\n         * @param {{scopeOrder: ?Array.<string>, filename: ?string} context \r\n         * @return {Array.<string>} list of scopes in the correct order for traversal\r\n         */\r\n        _getScopeOrder: function (context) {\r\n            return context.scopeOrder || this._defaultContext.scopeOrder;\r\n        },\r\n        \r\n        /**\r\n         * Get the current value of a preference. The optional context provides a way to\r\n         * change scope ordering or the reference filename for path-based scopes.\r\n         * \r\n         * @param {string} id Name of the preference for which the value should be retrieved\r\n         * @param {Object|string=} context Optional context object or name of context to change the preference lookup\r\n         */\r\n        get: function (id, context) {\r\n            var scopeCounter;\r\n            \r\n            context = this._getContext(context);\r\n            \r\n            var scopeOrder = this._getScopeOrder(context);\r\n            \r\n            for (scopeCounter = 0; scopeCounter < scopeOrder.length; scopeCounter++) {\r\n                var scope = this._scopes[scopeOrder[scopeCounter]];\r\n                if (scope) {\r\n                    var result = scope.get(id, context);\r\n                    if (result !== undefined) {\r\n                        var pref      = this.getPreference(id),\r\n                            validator = pref && pref.validator;\r\n                        if (!validator || validator(result)) {\r\n                            return _.cloneDeep(result);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Gets the location in which the value of a preference has been set.\r\n         * \r\n         * @param {string} id Name of the preference for which the value should be retrieved\r\n         * @param {Object=} context Optional context object to change the preference lookup\r\n         * @return {{scope: string, layer: ?string, layerID: ?object}} Object describing where the preferences came from\r\n         */\r\n        getPreferenceLocation: function (id, context) {\r\n            var scopeCounter,\r\n                scopeName;\r\n            \r\n            context = this._getContext(context);\r\n            \r\n            var scopeOrder = this._getScopeOrder(context);\r\n            \r\n            for (scopeCounter = 0; scopeCounter < scopeOrder.length; scopeCounter++) {\r\n                scopeName = scopeOrder[scopeCounter];\r\n                var scope = this._scopes[scopeName];\r\n                if (scope) {\r\n                    var result = scope.getPreferenceLocation(id, context);\r\n                    if (result !== undefined) {\r\n                        result.scope = scopeName;\r\n                        return result;\r\n                    }\r\n                }\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Sets a preference and notifies listeners that there may\r\n         * have been a change. By default, the preference is set in the same location in which\r\n         * it was defined except for the "default" scope. If the current value of the preference\r\n         * comes from the "default" scope, the new value will be set at the level just above\r\n         * default.\r\n         * \r\n         * @param {string} id Identifier of the preference to set\r\n         * @param {Object} value New value for the preference\r\n         * @param {{location: ?Object, context: ?Object}=} options Specific location in which to set the value or the context to use when setting the value\r\n         * @param {boolean=} doNotSave True if the preference change should not be saved automatically.\r\n         * @return {valid:  {boolean}, true if no validator specified or if value is valid\r\n         *          stored: {boolean}} true if a value was stored\r\n         */\r\n        set: function (id, value, options, doNotSave) {\r\n            options = options || {};\r\n            var context = this._getContext(options.context),\r\n                \r\n                // The case where the "default" scope was chosen specifically is special.\r\n                // Usually "default" would come up only when a preference did not have any\r\n                // user-set value, in which case we\'d want to set the value in a different scope.\r\n                forceDefault = options.location && options.location.scope === "default" ? true : false,\r\n                location = options.location || this.getPreferenceLocation(id, context);\r\n            \r\n            if (!location || (location.scope === "default" && !forceDefault)) {\r\n                var scopeOrder = this._getScopeOrder(context);\r\n                \r\n                // The default scope for setting a preference is the lowest priority\r\n                // scope after "default".\r\n                if (scopeOrder.length > 1) {\r\n                    location = {\r\n                        scope: scopeOrder[scopeOrder.length - 2]\r\n                    };\r\n                } else {\r\n                    return { valid: true, stored: false };\r\n                }\r\n            }\r\n            \r\n            var scope = this._scopes[location.scope];\r\n            if (!scope) {\r\n                return { valid: true, stored: false };\r\n            }\r\n            \r\n            var pref      = this.getPreference(id),\r\n                validator = pref && pref.validator;\r\n            if (validator && !validator(value)) {\r\n                return { valid: false, stored: false };\r\n            }\r\n            \r\n            var wasSet = scope.set(id, value, context, location);\r\n            if (wasSet) {\r\n                if (!doNotSave) {\r\n                    this.save();\r\n                }\r\n                this._triggerChange({\r\n                    ids: [id]\r\n                });\r\n            }\r\n            return { valid: true, stored: wasSet };\r\n        },\r\n        \r\n        /**\r\n         * Saves the preferences. If a save is already in progress, a Promise is returned for\r\n         * that save operation. If preferences have already been finalized then return a\r\n         * rejected promise.\r\n         * \r\n         * @return {Promise} Resolved when the preferences are done saving.\r\n         */\r\n        save: function () {\r\n            if (this.finalized) {\r\n                console.log("PreferencesSystem.save() called after finalized!");\r\n                return (new $.Deferred()).reject().promise();\r\n            }\r\n            \r\n            if (this._saveInProgress) {\r\n                if (!this._nextSaveDeferred) {\r\n                    this._nextSaveDeferred = new $.Deferred();\r\n                }\r\n                return this._nextSaveDeferred.promise();\r\n            }\r\n            \r\n            var deferred = this._nextSaveDeferred || (new $.Deferred());\r\n            this._saveInProgress = deferred;\r\n            this._nextSaveDeferred = null;\r\n            \r\n            Async.doInParallel(_.values(this._scopes), function (scope) {\r\n                if (scope) {\r\n                    return scope.save();\r\n                } else {\r\n                    return (new $.Deferred()).resolve().promise();\r\n                }\r\n            }.bind(this))\r\n                .then(function () {\r\n                    this._saveInProgress = null;\r\n                    if (this._nextSaveDeferred) {\r\n                        this.save();\r\n                    }\r\n                    deferred.resolve();\r\n                }.bind(this))\r\n                .fail(function (err) {\r\n                    deferred.reject(err);\r\n                });\r\n            \r\n            return deferred.promise();\r\n        },\r\n        \r\n        /**\r\n         * Sets the default filename used for computing preferences when there are PathLayers.\r\n         * This should be the filename of the file being edited.\r\n         * \r\n         * @param {string} filename New filename used to resolve preferences\r\n         */\r\n        setDefaultFilename: function (filename) {\r\n            var oldFilename = this._defaultContext.filename;\r\n            if (oldFilename === filename) {\r\n                return;\r\n            }\r\n            \r\n            var changes = [];\r\n            \r\n            _.each(this._scopes, function (scope) {\r\n                var changedInScope = scope.defaultFilenameChanged(filename, oldFilename);\r\n                if (changedInScope) {\r\n                    changes.push(changedInScope);\r\n                }\r\n            });\r\n            \r\n            this._defaultContext.filename = filename;\r\n            \r\n            changes = _.union.apply(null, changes);\r\n            if (changes.length > 0) {\r\n                this._triggerChange({\r\n                    ids: changes\r\n                });\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Augments the context object passed in with information from the default context.\r\n         * For example, if you want to create a context for a specific file while maintaining\r\n         * the default scopeOrder, you can pass in an object with just the filename and the\r\n         * scopeOrder will be added.\r\n         * \r\n         * *This method changes the object passed in.*\r\n         * \r\n         * @param {Object} context context object to augment\r\n         * @return {Object} the same context object that was passed in.\r\n         */\r\n        buildContext: function (context) {\r\n            return _.defaults(context, this._defaultContext);\r\n        },\r\n        \r\n        /**\r\n         * Sets up a listener for events. Optionally, you can set up a listener for a\r\n         * specific preference.\r\n         * \r\n         * @param {string} event Name of the event to listen for\r\n         * @param {string|Function} preferenceID Name of a specific preference or the handler function\r\n         * @param {?Function} handler Handler for the event\r\n         */\r\n        on: function (event, preferenceID, handler) {\r\n            if (typeof preferenceID === "function") {\r\n                handler = preferenceID;\r\n                preferenceID = null;\r\n            }\r\n            \r\n            if (preferenceID) {\r\n                var pref = this.getPreference(preferenceID);\r\n                pref.on(event, handler);\r\n            } else {\r\n                $(this).on(event, handler);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Turns off the event handlers for a given event, optionally for a specific preference\r\n         * or a specific handler function.\r\n         * \r\n         * @param {string} event Name of the event for which to turn off listening\r\n         * @param {string|Function} preferenceID Name of a specific preference or the handler function\r\n         * @param {?Function} handler Specific handler which should stop being notified\r\n         */\r\n        off: function (event, preferenceID, handler) {\r\n            if (typeof preferenceID === "function") {\r\n                handler = preferenceID;\r\n                preferenceID = null;\r\n            }\r\n            \r\n            if (preferenceID) {\r\n                var pref = this.getPreference(preferenceID);\r\n                pref.off(event, handler);\r\n            } else {\r\n                $(this).off(event, handler);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * @private\r\n         * \r\n         * Sends a change event to listeners. If change events have been paused (see\r\n         * pauseChangeEvents) then the IDs are queued up.\r\n         * \r\n         * @param {{ids: Array.<string>}} data Message to send\r\n         */\r\n        _triggerChange: function (data) {\r\n            if (this._changeEventQueue) {\r\n                this._changeEventQueue = _.union(this._changeEventQueue, data.ids);\r\n            } else {\r\n                $(this).trigger(PREFERENCE_CHANGE, data);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Turns off sending of change events, queueing them up for sending once sending is resumed.\r\n         * The events are compacted so that each preference that will be notified is only\r\n         * notified once. (For example, if `spaceUnits` is changed 5 times, only one change\r\n         * event will be sent upon resuming events.)\r\n         */\r\n        pauseChangeEvents: function () {\r\n            if (!this._changeEventQueue) {\r\n                this._changeEventQueue = [];\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Turns sending of events back on, sending any events that were queued while the\r\n         * events were paused.\r\n         */\r\n        resumeChangeEvents: function () {\r\n            if (this._changeEventQueue) {\r\n                $(this).trigger(PREFERENCE_CHANGE, {\r\n                    ids: this._changeEventQueue\r\n                });\r\n                this._changeEventQueue = null;\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Tells the PreferencesSystem that the given file has been changed so that any\r\n         * related Scopes can be reloaded.\r\n         * \r\n         * @param {string} filePath File that has changed\r\n         */\r\n        fileChanged: function (filePath) {\r\n            _.forEach(this._scopes, function (scope) {\r\n                scope.fileChanged(filePath);\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * Retrieves a PreferencesSystem in which all preference access is prefixed.\r\n         * This helps provide namespacing so that different preferences consumers do\r\n         * not interfere with one another.\r\n         * \r\n         * The prefix provided has a `.` character appended when preference lookups are\r\n         * done.\r\n         */\r\n        getPrefixedSystem: function (prefix) {\r\n            return new PrefixedPreferencesSystem(this, prefix + ".");\r\n        },\r\n        \r\n        /**\r\n         * Return a promise that is resolved when all preferences have been saved.\r\n         * Disallow any other preferences from getting saved after promise is resolved.\r\n         * \r\n         * @return {Promise} Resolved when the preferences are done saving.\r\n         */\r\n        _finalize: function () {\r\n            var deferred = new $.Deferred(),\r\n                self = this;\r\n\r\n            // Don\'t resolve promise until last `_saveInProgress` promise completes.\r\n            // There will only ever be a `_nextSaveDeferred`, if there is already a\r\n            // `_saveInProgress` and it will become the new `_saveInProgress` as soon as\r\n            // previous `_saveInProgress` resolves, so only need to wait for `_saveInProgress`.\r\n            function checkForSaveAndFinalize() {\r\n                if (self._saveInProgress) {\r\n                    self._saveInProgress.done(checkForSaveAndFinalize);\r\n                } else {\r\n                    self.finalized = true;\r\n                    deferred.resolve();\r\n                }\r\n            }\r\n\r\n            checkForSaveAndFinalize();\r\n\r\n            return deferred.promise();\r\n        }\r\n    });\r\n    \r\n    // Public interface\r\n    exports.PreferencesSystem  = PreferencesSystem;\r\n    exports.Scope              = Scope;\r\n    exports.MemoryStorage      = MemoryStorage;\r\n    exports.PathLayer          = PathLayer;\r\n    exports.ProjectLayer       = ProjectLayer;\r\n    exports.FileStorage        = FileStorage;\r\n});\r\n\n//# sourceURL=/preferences/PreferencesBase.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*global define, $, localStorage, brackets, console */\r\n\r\n/**\r\n * Generates the fully configured preferences systems used throughout Brackets. This is intended\r\n * to be essentially private implementation that can be overridden for tests.\r\n */\r\ndefine(\'preferences/PreferencesImpl\',[\'require\',\'exports\',\'module\',\'./PreferencesBase\',\'utils/Async\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var PreferencesBase = require("./PreferencesBase"),\r\n        Async           = require("utils/Async"),\r\n    \r\n        // The SETTINGS_FILENAME is used with a preceding "." within user projects\r\n        SETTINGS_FILENAME = "brackets.json",\r\n        STATE_FILENAME    = "state.json",\r\n    \r\n        // User-level preferences\r\n        userPrefFile = brackets.app.getApplicationSupportDirectory() + "/" + SETTINGS_FILENAME;\r\n    \r\n    /**\r\n     * A deferred object which is used to indicate PreferenceManager readiness during the start-up.\r\n     * @private\r\n     * @type {$.Deferred}\r\n     */\r\n    var _prefManagerReadyDeferred = new $.Deferred();\r\n\r\n    /** \r\n     * A boolean property indicating if the user scope configuration file is malformed.\r\n     */\r\n    var userScopeCorrupt = false;\r\n\r\n    function isUserScopeCorrupt() {\r\n        return userScopeCorrupt;\r\n    }\r\n\r\n    /**\r\n     * Promises to add scopes. Used at init time only. \r\n     * @private\r\n     * @type {Array.<$.Promise>}\r\n     */\r\n    var _addScopePromises = [];\r\n\r\n    var manager = new PreferencesBase.PreferencesSystem();\r\n    manager.pauseChangeEvents();\r\n\r\n    // Create a Project scope\r\n    var projectStorage          = new PreferencesBase.FileStorage(undefined, true),\r\n        projectScope            = new PreferencesBase.Scope(projectStorage),\r\n        projectPathLayer        = new PreferencesBase.PathLayer();\r\n\r\n    projectScope.addLayer(projectPathLayer);\r\n\r\n    var userScopeLoading = manager.addScope("user", new PreferencesBase.FileStorage(userPrefFile, true));\r\n\r\n    _addScopePromises.push(userScopeLoading);\r\n\r\n    // Set up the .brackets.json file handling\r\n    userScopeLoading\r\n        .fail(function (err) {\r\n            _addScopePromises.push(manager.addScope("user", new PreferencesBase.MemoryStorage(), {\r\n                before: "default"\r\n            }));\r\n\r\n            if (err.name && err.name === "ParsingError") {\r\n                userScopeCorrupt = true;\r\n            }\r\n        })\r\n        .always(function () {\r\n            _addScopePromises.push(manager.addScope("project", projectScope, {\r\n                before: "user"\r\n            }));\r\n\r\n            // Session Scope is for storing prefs in memory only but with the highest precedence.\r\n            _addScopePromises.push(manager.addScope("session", new PreferencesBase.MemoryStorage()));\r\n\r\n            Async.waitForAll(_addScopePromises)\r\n                .always(function () {\r\n                    _prefManagerReadyDeferred.resolve();\r\n                });\r\n        });\r\n\r\n    \r\n    // "State" is stored like preferences but it is not generally intended to be user-editable.\r\n    // It\'s for more internal, implicit things like window size, working set, etc.\r\n    var stateManager = new PreferencesBase.PreferencesSystem();\r\n    var userStateFile = brackets.app.getApplicationSupportDirectory() + "/" + STATE_FILENAME;\r\n    var smUserScope = new PreferencesBase.Scope(new PreferencesBase.FileStorage(userStateFile, true));\r\n    var stateProjectLayer = new PreferencesBase.ProjectLayer();\r\n    smUserScope.addLayer(stateProjectLayer);\r\n    var smUserScopeLoading = stateManager.addScope("user", smUserScope);\r\n    \r\n    \r\n    // Listen for times where we might be unwatching a root that contains one of the user-level prefs files,\r\n    // and force a re-read of the file in order to ensure we can write to it later (see #7300).\r\n    function _reloadUserPrefs(rootDir) {\r\n        var prefsDir = brackets.app.getApplicationSupportDirectory() + "/";\r\n        if (prefsDir.indexOf(rootDir.fullPath) === 0) {\r\n            manager.fileChanged(userPrefFile);\r\n            stateManager.fileChanged(userStateFile);\r\n        }\r\n    }\r\n    \r\n    \r\n    // Semi-Public API. Use this at your own risk. The public API is in PreferencesManager.\r\n    exports.manager             = manager;\r\n    exports.projectStorage      = projectStorage;\r\n    exports.projectPathLayer    = projectPathLayer;\r\n    exports.userScopeLoading    = userScopeLoading;\r\n    exports.stateManager        = stateManager;\r\n    exports.stateProjectLayer   = stateProjectLayer;\r\n    exports.smUserScopeLoading  = smUserScopeLoading;\r\n    exports.userPrefFile        = userPrefFile;\r\n    exports.isUserScopeCorrupt  = isUserScopeCorrupt;\r\n    exports.managerReady        = _prefManagerReadyDeferred.promise();\r\n    exports.reloadUserPrefs     = _reloadUserPrefs;\r\n    exports.STATE_FILENAME      = STATE_FILENAME;\r\n    exports.SETTINGS_FILENAME   = SETTINGS_FILENAME;\r\n});\r\n\n//# sourceURL=/preferences/PreferencesImpl.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*global define, $, localStorage, brackets, console */\r\n/*unittests: Preferences Manager */\r\n\r\n/**\r\n * PreferencesManager\r\n *\r\n */\r\ndefine(\'preferences/PreferencesManager\',[\'require\',\'exports\',\'module\',\'preferences/PreferenceStorage\',\'utils/AppInit\',\'utils/Async\',\'command/Commands\',\'command/CommandManager\',\'utils/DeprecationWarning\',\'file/FileUtils\',\'utils/ExtensionLoader\',\'preferences/PreferencesBase\',\'filesystem/FileSystem\',\'strings\',\'preferences/PreferencesImpl\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var OldPreferenceStorage    = require("preferences/PreferenceStorage").PreferenceStorage,\r\n        AppInit                 = require("utils/AppInit"),\r\n        Async                   = require("utils/Async"),\r\n        Commands                = require("command/Commands"),\r\n        CommandManager          = require("command/CommandManager"),\r\n        DeprecationWarning      = require("utils/DeprecationWarning"),\r\n        FileUtils               = require("file/FileUtils"),\r\n        ExtensionLoader         = require("utils/ExtensionLoader"),\r\n        PreferencesBase         = require("preferences/PreferencesBase"),\r\n        FileSystem              = require("filesystem/FileSystem"),\r\n        Strings                 = require("strings"),\r\n        PreferencesImpl         = require("preferences/PreferencesImpl"),\r\n        _                       = require("thirdparty/lodash");\r\n    \r\n    /**\r\n     * The local storage ID\r\n     * @const\r\n     * @type {string}\r\n     */\r\n    var PREFERENCES_CLIENT_ID = "com.adobe.brackets.preferences";\r\n    \r\n    /**\r\n     * The prefix used in the generated client ID\r\n     * @const\r\n     * @type {string}\r\n     */\r\n    var CLIENT_ID_PREFIX = "com.adobe.brackets.";\r\n    \r\n    // Private Properties\r\n    var preferencesKey,\r\n        prefStorage,\r\n        persistentStorage,\r\n        extensionPaths,\r\n        doLoadPreferences   = false;\r\n    \r\n    \r\n    /**\r\n     * @private\r\n     * Returns an array with the extension paths used in Brackets. The result is stored on a\r\n     * private variable on the first call and used to return the value on the next calls.\r\n     * @return {Array.<string>}\r\n     */\r\n    function _getExtensionPaths() {\r\n        if (!extensionPaths) {\r\n            var dirPath = FileUtils.getNativeBracketsDirectoryPath();\r\n            \r\n            extensionPaths = [\r\n                dirPath + "/extensions/default/",\r\n                dirPath + "/extensions/dev/",\r\n                ExtensionLoader.getUserExtensionPath() + "/"\r\n            ];\r\n        }\r\n        return extensionPaths;\r\n    }\r\n\r\n    /**\r\n     * This method returns a standardized ClientID for a given requireJS module object\r\n     * @param {!{id: string, uri: string}} module - A requireJS module object\r\n     * @return {string} The ClientID\r\n     */\r\n    function getClientID(module) {\r\n        var paths = exports._getExtensionPaths();\r\n        var pathExp, pathUrl, clientID;\r\n\r\n        paths.some(function (path) {\r\n            if (module.uri.toLocaleLowerCase().indexOf(path.toLocaleLowerCase()) === 0) {\r\n                pathUrl = path;\r\n                return true;\r\n            }\r\n        });\r\n\r\n        if (pathUrl) {\r\n            clientID = CLIENT_ID_PREFIX + module.uri.replace(pathUrl, "");\r\n        } else {\r\n            clientID = CLIENT_ID_PREFIX + module.id;\r\n        }\r\n        return clientID;\r\n    }\r\n    \r\n    /**\r\n     * Retreive the preferences data for the given clientID.\r\n     * @param {string|{id: string, uri: string}} clientID - A unique identifier or a requireJS module object\r\n     * @param {string=} defaults - Default preferences stored as JSON\r\n     * @param {boolean=} _doNotCreate Do not create the storage if it does not already exist. Used for conversion.\r\n     * @return {PreferenceStorage}\r\n     */\r\n    function getPreferenceStorage(clientID, defaults, _doNotCreate) {\r\n        // No one should be calling this to access the old preference storage except for \r\n        // migrating the old preferences to the new model. So if this is called without \r\n        // having _doNotCreate set to true, then the caller is using the old preferences model.\r\n        if (!_doNotCreate) {\r\n            var clientString = typeof clientID === "object" ? clientID.uri : clientID;\r\n            DeprecationWarning.deprecationWarning("getPreferenceStorage is called with client ID \'" + clientString + ",\' use PreferencesManager.definePreference instead.");\r\n        }\r\n        if (!clientID || (typeof clientID === "object" && (!clientID.id || !clientID.uri))) {\r\n            console.error("Invalid clientID");\r\n            return;\r\n        }\r\n        if (typeof clientID === "object") {\r\n            clientID = getClientID(clientID);\r\n        }\r\n\r\n        var prefs = prefStorage[clientID];\r\n\r\n        if (prefs === undefined) {\r\n            if (_doNotCreate) {\r\n                return;\r\n            }\r\n            // create a new empty preferences object\r\n            prefs = (defaults && JSON.stringify(defaults)) ? defaults : {};\r\n            prefStorage[clientID] = prefs;\r\n        } else if (defaults) {\r\n            // add new defaults\r\n            _.forEach(defaults, function (value, key) {\r\n                if (prefs[key] === undefined) {\r\n                    prefs[key] = value;\r\n                }\r\n            });\r\n        }\r\n\r\n        return new OldPreferenceStorage(clientID, prefs);\r\n    }\r\n\r\n    /**\r\n     * Save all preference clients.\r\n     */\r\n    function savePreferences() {\r\n        // save all preferences\r\n        persistentStorage.setItem(preferencesKey, JSON.stringify(prefStorage));\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Reset preferences and callbacks\r\n     */\r\n    function _reset() {\r\n        prefStorage = {};\r\n\r\n        // Note that storage.clear() is not used. Production and unit test code\r\n        // both rely on the same backing storage but unique item keys.\r\n        persistentStorage.setItem(preferencesKey, JSON.stringify(prefStorage));\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Initialize persistent storage implementation\r\n     */\r\n    function _initStorage(storage) {\r\n        persistentStorage = storage;\r\n\r\n        if (doLoadPreferences) {\r\n            prefStorage = JSON.parse(persistentStorage.getItem(preferencesKey));\r\n        }\r\n\r\n        // initialize empty preferences if none were found in storage\r\n        if (!prefStorage) {\r\n            _reset();\r\n        }\r\n    }\r\n    \r\n    // Check localStorage for a preferencesKey. Production and unit test keys\r\n    // are used to keep preferences separate within the same storage implementation.\r\n    preferencesKey = localStorage.getItem("preferencesKey");\r\n    \r\n    if (!preferencesKey) {\r\n        // use default key if none is found\r\n        preferencesKey = PREFERENCES_CLIENT_ID;\r\n        doLoadPreferences = true;\r\n    } else {\r\n        // using a non-default key, check for additional settings\r\n        doLoadPreferences = !!(localStorage.getItem("doLoadPreferences"));\r\n    }\r\n\r\n    // Use localStorage by default\r\n    _initStorage(localStorage);\r\n    \r\n    \r\n    // Public API\r\n    exports.getPreferenceStorage    = getPreferenceStorage;\r\n    exports.savePreferences         = savePreferences;\r\n    exports.getClientID             = getClientID;\r\n\r\n\r\n    // Unit test use only\r\n    exports._reset                  = _reset;\r\n    exports._getExtensionPaths      = _getExtensionPaths;\r\n    \r\n    // New code follows. The code above (with the exception of the imports) is\r\n    // deprecated.\r\n    \r\n    var currentEditedFile       = null,\r\n        projectDirectory        = null,\r\n        projectScopeIsIncluded  = true;\r\n\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Determines whether the project Scope should be included based on whether\r\n     * the currently edited file is within the project.\r\n     * \r\n     * @param {string=} filename Full path to edited file\r\n     * @return {boolean} true if the project Scope should be included.\r\n     */\r\n    function _includeProjectScope(filename) {\r\n        filename = filename || currentEditedFile;\r\n        if (!filename || !projectDirectory) {\r\n            return false;\r\n        }\r\n        return FileUtils.getRelativeFilename(projectDirectory, filename) !== undefined;\r\n    }\r\n    \r\n    /**\r\n     * Get the full path to the user-level preferences file.\r\n     * \r\n     * @return {string} Path to the preferences file\r\n     */\r\n    function getUserPrefFile() {\r\n        return PreferencesImpl.userPrefFile;\r\n    }\r\n    \r\n\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Adds or removes the project Scope as needed based on whether the currently\r\n     * edited file is within the project.\r\n     */\r\n    function _toggleProjectScope() {\r\n        if (_includeProjectScope() === projectScopeIsIncluded) {\r\n            return;\r\n        }\r\n        if (projectScopeIsIncluded) {\r\n            PreferencesImpl.manager.removeFromScopeOrder("project");\r\n        } else {\r\n            PreferencesImpl.manager.addToScopeOrder("project", "user");\r\n        }\r\n        projectScopeIsIncluded = !projectScopeIsIncluded;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * This is used internally within Brackets for the ProjectManager to signal\r\n     * which file contains the project-level preferences.\r\n     * \r\n     * @param {string} settingsFile Full path to the project\'s settings file\r\n     */\r\n    function _setProjectSettingsFile(settingsFile) {\r\n        projectDirectory = FileUtils.getDirectoryPath(settingsFile);\r\n        _toggleProjectScope();\r\n        PreferencesImpl.projectPathLayer.setPrefFilePath(settingsFile);\r\n        PreferencesImpl.projectStorage.setPath(settingsFile);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * This is used internally within Brackets for the EditorManager to signal\r\n     * to the preferences what the currently edited file is.\r\n     * \r\n     * @param {string} currentFile Full path to currently edited file\r\n     */\r\n    function _setCurrentEditingFile(currentFile) {\r\n        currentEditedFile = currentFile;\r\n        _toggleProjectScope();\r\n        PreferencesImpl.manager.setDefaultFilename(currentFile);\r\n    }\r\n    \r\n    /**\r\n     * Creates an extension-specific preferences manager using the prefix given.\r\n     * A `.` character will be appended to the prefix. So, a preference named `foo`\r\n     * with a prefix of `myExtension` will be stored as `myExtension.foo` in the\r\n     * preferences files.\r\n     * \r\n     * @param {string} prefix Prefix to be applied\r\n     */\r\n    function getExtensionPrefs(prefix) {\r\n        return PreferencesImpl.manager.getPrefixedSystem(prefix);\r\n    }\r\n    \r\n    /**\r\n     * Converts from the old localStorage-based preferences to the new-style\r\n     * preferences according to the "rules" given.\r\n     * \r\n     * `rules` is an object, the keys of which refer to the preference names.\r\n     * The value tells the converter what to do. The following values are available:\r\n     * \r\n     * * `user`: convert to a user-level preference\r\n     * * `user newkey`: convert to a user-level preference, changing the key to newkey\r\n     * \r\n     * Once a key has been converted, it will not be converted again.\r\n     * \r\n     * @param {string|Object} clientID ClientID used in the old preferences\r\n     * @param {Object} rules Rules for conversion (as defined above)\r\n     * @param {boolean=} isViewState If it is undefined or false, then the preferences\r\n     *      listed in \'rules\' are those normal user-editable preferences. Otherwise,\r\n     *      they are view state settings.\r\n     * @param {function(string)=} prefCheckCallback Optional callback function that\r\n     *      examines each preference key for migration.\r\n     */\r\n    function convertPreferences(clientID, rules, isViewState, prefCheckCallback) {\r\n        PreferencesImpl.smUserScopeLoading.done(function () {\r\n            PreferencesImpl.userScopeLoading.done(function () {\r\n                if (!clientID || (typeof clientID === "object" && (!clientID.id || !clientID.uri))) {\r\n                    console.error("Invalid clientID");\r\n                    return;\r\n                }\r\n                var prefs = getPreferenceStorage(clientID, null, true);\r\n\r\n                if (!prefs) {\r\n                    return;\r\n                }\r\n\r\n                var prefsID = typeof clientID === "object" ? getClientID(clientID) : clientID;\r\n                if (prefStorage.convertedKeysMap === undefined) {\r\n                    prefStorage.convertedKeysMap = {};\r\n                }\r\n                var convertedKeysMap = prefStorage.convertedKeysMap;\r\n\r\n                prefs.convert(rules, convertedKeysMap[prefsID], isViewState, prefCheckCallback)\r\n                    .done(function (complete, convertedKeys) {\r\n                        prefStorage.convertedKeysMap[prefsID] = convertedKeys;\r\n                        savePreferences();\r\n                    });\r\n            }).fail(function (error) {\r\n                console.error("Error while converting ", typeof clientID === "object" ? getClientID(clientID) : clientID);\r\n                console.error(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    \r\n    // Constants for preference lookup contexts.\r\n    \r\n    /**\r\n     * Context to look up preferences in the current project.\r\n     * @type {Object}\r\n     */\r\n    var CURRENT_PROJECT = {};\r\n    \r\n    /**\r\n     * Context to look up preferences for the currently edited file.\r\n     * This is undefined because this is the default behavior of PreferencesSystem.get.\r\n     * \r\n     * @type {Object}\r\n     */\r\n    var CURRENT_FILE;\r\n    \r\n    /**\r\n     * Cached copy of the scopeOrder with the project Scope\r\n     */\r\n    var scopeOrderWithProject = null;\r\n    \r\n    /**\r\n     * Cached copy of the scopeOrder without the project Scope\r\n     */\r\n    var scopeOrderWithoutProject = null;\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Adjusts scopeOrder to have the project Scope if necessary.\r\n     * Returns a new array if changes are needed, otherwise returns\r\n     * the original array.\r\n     * \r\n     * @param {Array.<string>} scopeOrder initial scopeOrder\r\n     * @param {boolean} includeProject Whether the project Scope should be included\r\n     * @return {Array.<string>} array with or without project Scope as needed.\r\n     */\r\n    function _adjustScopeOrderForProject(scopeOrder, includeProject) {\r\n        var hasProject = scopeOrder.indexOf("project") > -1;\r\n        \r\n        if (hasProject === includeProject) {\r\n            return scopeOrder;\r\n        }\r\n        \r\n        var newScopeOrder;\r\n        \r\n        if (includeProject) {\r\n            var before = scopeOrder.indexOf("user");\r\n            if (before === -1) {\r\n                before = scopeOrder.length - 2;\r\n            }\r\n            newScopeOrder = _.first(scopeOrder, before);\r\n            newScopeOrder.push("project");\r\n            newScopeOrder.push.apply(newScopeOrder, _.rest(scopeOrder, before));\r\n        } else {\r\n            newScopeOrder = _.without(scopeOrder, "project");\r\n        }\r\n        return newScopeOrder;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Normalizes the context object to be something that the PreferencesSystem\r\n     * understands. This is how we support CURRENT_FILE and CURRENT_PROJECT\r\n     * preferences.\r\n     * \r\n     * @param {Object|string} context CURRENT_FILE, CURRENT_PROJECT or a filename\r\n     */\r\n    function _normalizeContext(context) {\r\n        if (typeof context === "string") {\r\n            context = {\r\n                filename: context\r\n            };\r\n            context.scopeOrder = _includeProjectScope(context.filename) ?\r\n                                    scopeOrderWithProject :\r\n                                    scopeOrderWithoutProject;\r\n        }\r\n        return context;\r\n    }\r\n    \r\n    PreferencesImpl.manager.contextNormalizer = _normalizeContext;\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Updates the CURRENT_PROJECT context to have the correct scopes.\r\n     */\r\n    function _updateCurrentProjectContext() {\r\n        var context = PreferencesImpl.manager.buildContext({});\r\n        delete context.filename;\r\n        scopeOrderWithProject = _adjustScopeOrderForProject(context.scopeOrder, true);\r\n        scopeOrderWithoutProject = _adjustScopeOrderForProject(context.scopeOrder, false);\r\n        CURRENT_PROJECT.scopeOrder = scopeOrderWithProject;\r\n    }\r\n    \r\n    _updateCurrentProjectContext();\r\n    \r\n    PreferencesImpl.manager.on("scopeOrderChange", _updateCurrentProjectContext);\r\n    \r\n    /**\r\n     * @private\r\n     */\r\n    function _handleOpenPreferences() {\r\n        var fullPath = getUserPrefFile(),\r\n            file = FileSystem.getFileForPath(fullPath);\r\n        file.exists(function (err, doesExist) {\r\n            if (doesExist) {\r\n                CommandManager.execute(Commands.FILE_OPEN, { fullPath: fullPath });\r\n            } else {\r\n                FileUtils.writeText(file, "", true)\r\n                    .done(function () {\r\n                        CommandManager.execute(Commands.FILE_OPEN, { fullPath: fullPath });\r\n                    });\r\n            }\r\n        });\r\n        \r\n    }\r\n    \r\n    CommandManager.register(Strings.CMD_OPEN_PREFERENCES, Commands.FILE_OPEN_PREFERENCES, _handleOpenPreferences);\r\n    \r\n    /**\r\n     * Convenience function that sets a preference and then saves the file, mimicking the\r\n     * old behavior a bit more closely.\r\n     * @deprecated Use set instead.\r\n     * \r\n     * @param {string} id preference to set\r\n     * @param {*} value new value for the preference\r\n     * @param {{location: ?Object, context: ?Object|string}=} options Specific location in which to set the value or the context to use when setting the value\r\n     * @return {boolean} true if a value was set\r\n     */\r\n    function setValueAndSave(id, value, options) {\r\n        DeprecationWarning.deprecationWarning("setValueAndSave called for " + id + ". Use set instead.");\r\n        var changed = exports.set(id, value, options).stored;\r\n        PreferencesImpl.manager.save();\r\n        return changed;\r\n    }\r\n    \r\n    /**\r\n     * Convenience function that gets a view state\r\n     * \r\n     * @param {string} id preference to get\r\n     * @param {?Object} context Optional additional information about the request\r\n     */\r\n    function getViewState(id, context) {\r\n        return PreferencesImpl.stateManager.get(id, context);\r\n    }\r\n    \r\n    /**\r\n     * Convenience function that sets a view state and then saves the file\r\n     * \r\n     * @param {string} id preference to set\r\n     * @param {*} value new value for the preference\r\n     * @param {?Object} context Optional additional information about the request\r\n     * @param {boolean=} doNotSave If it is undefined or false, then save the \r\n     *      view state immediately.\r\n     */\r\n    function setViewState(id, value, context, doNotSave) {\r\n        \r\n        PreferencesImpl.stateManager.set(id, value, context);\r\n        \r\n        if (!doNotSave) {\r\n            PreferencesImpl.stateManager.save();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Return a promise that is resolved when all preferences have been resolved,\r\n     * or rejected if any have been rejected.\r\n     * \r\n     * @return {Promise} Resolved when the preferences are done saving.\r\n     */\r\n    function finalize() {\r\n        var promiseList = [\r\n                PreferencesImpl.managerReady,\r\n                PreferencesImpl.smUserScopeLoading,\r\n                PreferencesImpl.manager._finalize(),\r\n                PreferencesImpl.stateManager._finalize()\r\n            ],\r\n            identityFunc = function (promise) { return promise; };\r\n        \r\n        return Async.doSequentially(promiseList, identityFunc, false);\r\n    }\r\n    \r\n    AppInit.appReady(function () {\r\n        PreferencesImpl.manager.resumeChangeEvents();\r\n    });\r\n    \r\n    // Private API for unit testing and use elsewhere in Brackets core\r\n    exports._isUserScopeCorrupt     = PreferencesImpl.isUserScopeCorrupt;\r\n    exports._manager                = PreferencesImpl.manager;\r\n    exports._setCurrentEditingFile  = _setCurrentEditingFile;\r\n    exports._setProjectSettingsFile = _setProjectSettingsFile;\r\n    exports._smUserScopeLoading     = PreferencesImpl.smUserScopeLoading;\r\n    exports._stateProjectLayer      = PreferencesImpl.stateProjectLayer;\r\n    exports._reloadUserPrefs        = PreferencesImpl.reloadUserPrefs;\r\n    \r\n    // Public API\r\n    \r\n    // Context names for preference lookups\r\n    exports.CURRENT_FILE        = CURRENT_FILE;\r\n    exports.CURRENT_PROJECT     = CURRENT_PROJECT;\r\n    \r\n    exports.ready               = PreferencesImpl.managerReady;\r\n    exports.getUserPrefFile     = getUserPrefFile;\r\n    exports.get                 = PreferencesImpl.manager.get.bind(PreferencesImpl.manager);\r\n    exports.set                 = PreferencesImpl.manager.set.bind(PreferencesImpl.manager);\r\n    exports.save                = PreferencesImpl.manager.save.bind(PreferencesImpl.manager);\r\n    exports.on                  = PreferencesImpl.manager.on.bind(PreferencesImpl.manager);\r\n    exports.off                 = PreferencesImpl.manager.off.bind(PreferencesImpl.manager);\r\n    exports.getPreference       = PreferencesImpl.manager.getPreference.bind(PreferencesImpl.manager);\r\n    exports.getExtensionPrefs   = getExtensionPrefs;\r\n    exports.setValueAndSave     = setValueAndSave;\r\n    exports.getViewState        = getViewState;\r\n    exports.setViewState        = setViewState;\r\n    exports.finalize            = finalize;\r\n    exports.addScope            = PreferencesImpl.manager.addScope.bind(PreferencesImpl.manager);\r\n    exports.stateManager        = PreferencesImpl.stateManager;\r\n    exports.FileStorage         = PreferencesBase.FileStorage;\r\n    exports.SETTINGS_FILENAME   = PreferencesImpl.SETTINGS_FILENAME;\r\n    exports.definePreference    = PreferencesImpl.manager.definePreference.bind(PreferencesImpl.manager);\r\n    exports.fileChanged         = PreferencesImpl.manager.fileChanged.bind(PreferencesImpl.manager);\r\n    exports.convertPreferences  = convertPreferences;\r\n});\r\n\n//# sourceURL=/preferences/PreferencesManager.js'),eval('define(\'text!htmlContent/project-settings-dialog.html\',[],function () { return \'<div class="project-settings-dialog modal">\\r\\n    <div class="modal-header">\\r\\n        <h1 class="dialog-title">{{title}}</h1>\\r\\n    </div>\\r\\n    <div class="modal-body">\\r\\n        <div class="field-container">\\r\\n            <label>\\r\\n                {{Strings.PROJECT_SETTING_BASE_URL}}: <input type="text" placeholder="{{Strings.PROJECT_SETTING_BASE_URL_HINT}}" value="{{baseUrl}}" class="url" />\\r\\n            </label>\\r\\n            {{#errorMessage}}<div class="alert" style="margin-bottom: 0">{{{errorMessage}}}</div>{{/errorMessage}}\\r\\n         </div>\\r\\n    </div>\\r\\n    <div class="modal-footer">\\r\\n        <button class="dialog-button btn" data-button-id="cancel">{{Strings.CANCEL}}</button>\\r\\n        <button class="dialog-button btn primary" data-button-id="ok">{{Strings.DONE}}</button>\\r\\n    </div>\\r\\n</div>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/project-settings-dialog.html'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, PathUtils, Mustache */\r\n\r\n/**\r\n * PreferencesDialogs\r\n *\r\n */\r\ndefine(\'preferences/PreferencesDialogs\',[\'require\',\'exports\',\'module\',\'thirdparty/path-utils/path-utils.min\',\'widgets/Dialogs\',\'preferences/PreferencesManager\',\'project/ProjectManager\',\'utils/StringUtils\',\'strings\',\'text!htmlContent/project-settings-dialog.html\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    require("thirdparty/path-utils/path-utils.min");\r\n\r\n    var Dialogs                = require("widgets/Dialogs"),\r\n        PreferencesManager     = require("preferences/PreferencesManager"),\r\n        ProjectManager         = require("project/ProjectManager"),\r\n        StringUtils            = require("utils/StringUtils"),\r\n        Strings                = require("strings"),\r\n        SettingsDialogTemplate = require("text!htmlContent/project-settings-dialog.html");\r\n\r\n    /**\r\n     * Validate that text string is a valid base url which should map to a server folder\r\n     * @param {string} url\r\n     * @return {string} Empty string if valid, otherwise error string\r\n     */\r\n    function _validateBaseUrl(url) {\r\n        var result = "";\r\n        // Empty url means "no server mapping; use file directly"\r\n        if (url === "") {\r\n            return result;\r\n        }\r\n\r\n        var obj = PathUtils.parseUrl(url);\r\n        if (!obj) {\r\n            result = Strings.BASEURL_ERROR_UNKNOWN_ERROR;\r\n        } else if (obj.href.search(/^(http|https):\\/\\//i) !== 0) {\r\n            result = StringUtils.format(Strings.BASEURL_ERROR_INVALID_PROTOCOL, obj.href.substring(0, obj.href.indexOf("//")));\r\n        } else if (obj.search !== "") {\r\n            result = StringUtils.format(Strings.BASEURL_ERROR_SEARCH_DISALLOWED, obj.search);\r\n        } else if (obj.hash !== "") {\r\n            result = StringUtils.format(Strings.BASEURL_ERROR_HASH_DISALLOWED, obj.hash);\r\n        } else {\r\n            var index = url.search(/[ \\^\\[\\]\\{\\}<>\\\\"\\?]+/);\r\n            if (index !== -1) {\r\n                result = StringUtils.format(Strings.BASEURL_ERROR_INVALID_CHAR, url[index]);\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Show a dialog that shows the project preferences\r\n     * @param {string} baseUrl Initial value\r\n     * @param {string} errorMessage Error to display\r\n     * @return {Dialog} A Dialog object with an internal promise that will be resolved with the ID\r\n     *      of the clicked button when the dialog is dismissed. Never rejected.\r\n     */\r\n    function showProjectPreferencesDialog(baseUrl, errorMessage) {\r\n        var $baseUrlControl,\r\n            dialog;\r\n        \r\n        // Title\r\n        var projectName = "",\r\n            projectRoot = ProjectManager.getProjectRoot(),\r\n            title;\r\n        if (projectRoot) {\r\n            projectName = projectRoot.name;\r\n        }\r\n        title = StringUtils.format(Strings.PROJECT_SETTINGS_TITLE, projectName);\r\n        \r\n        var templateVars = {\r\n            title        : title,\r\n            baseUrl      : baseUrl,\r\n            errorMessage : errorMessage,\r\n            Strings      : Strings\r\n        };\r\n        \r\n        dialog = Dialogs.showModalDialogUsingTemplate(Mustache.render(SettingsDialogTemplate, templateVars));\r\n        \r\n        dialog.done(function (id) {\r\n            if (id === Dialogs.DIALOG_BTN_OK) {\r\n                var baseUrlValue = $baseUrlControl.val();\r\n                var result = _validateBaseUrl(baseUrlValue);\r\n                if (result === "") {\r\n                    ProjectManager.setBaseUrl(baseUrlValue);\r\n                } else {\r\n                    // Re-invoke dialog with result (error message)\r\n                    showProjectPreferencesDialog(baseUrlValue, result);\r\n                }\r\n            }\r\n        });\r\n\r\n        // Give focus to first control\r\n        $baseUrlControl = dialog.getElement().find(".url");\r\n        $baseUrlControl.focus();\r\n\r\n        return dialog;\r\n    }\r\n\r\n    // For unit testing\r\n    exports._validateBaseUrl                = _validateBaseUrl;\r\n\r\n    exports.showProjectPreferencesDialog    = showProjectPreferencesDialog;\r\n});\r\n\n//# sourceURL=/preferences/PreferencesDialogs.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\n/**\r\n * Resizer is a Module utility to inject resizing capabilities to any element\r\n * inside Brackets.\r\n *\r\n * On initialization, Resizer discovers all nodes tagged as "vert-resizable"\r\n * and "horz-resizable" to add the resizer handler. Additionally, "top-resizer",\r\n * "bottom-resizer", "left-resizer" and "right-resizer" classes control the\r\n * position of the resizer on the element.\r\n *\r\n * An element can be made resizable at any time using the `makeResizable()` API.\r\n * Panel sizes are saved via preferences and restored when the DOM node becomes resizable\r\n * again in a subsequent launch.\r\n *\r\n * The resizable elements trigger a panelResizeStart, panelResizeUpdate and panelResizeEnd\r\n * event that can be used to create performance optimizations (such as hiding/showing elements\r\n * while resizing), custom layout logic, etc. See makeResizable() for details on the events.\r\n *\r\n * A resizable element can be collapsed/expanded using the `show`, `hide` and `toggle` APIs or\r\n * via user action. This triggers panelCollapsed/panelExpanded events - see makeResizable().\r\n */\r\ndefine(\'utils/Resizer\',[\'require\',\'exports\',\'module\',\'utils/AppInit\',\'preferences/PreferencesManager\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var DIRECTION_VERTICAL = "vert";\r\n    var DIRECTION_HORIZONTAL = "horz";\r\n    \r\n    var POSITION_TOP = "top";\r\n    var POSITION_BOTTOM = "bottom";\r\n    var POSITION_LEFT = "left";\r\n    var POSITION_RIGHT = "right";\r\n	\r\n    // Minimum size (height or width) for autodiscovered resizable panels\r\n    var DEFAULT_MIN_SIZE = 100;\r\n    \r\n    // Load dependent modules\r\n    var AppInit                 = require("utils/AppInit"),\r\n        PreferencesManager      = require("preferences/PreferencesManager");\r\n    \r\n    var $mainView;\r\n    \r\n    var isResizing = false;\r\n    \r\n    /**\r\n     * Shows a resizable element.\r\n     * @param {DOMNode} element Html element to show if possible\r\n     */\r\n    function show(element) {\r\n        var showFunc = $(element).data("show");\r\n        if (showFunc) {\r\n            showFunc.apply(element);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Hides a resizable element.\r\n     * @param {DOMNode} element Html element to hide if possible\r\n     */\r\n    function hide(element) {\r\n        var hideFunc = $(element).data("hide");\r\n        if (hideFunc) {\r\n            hideFunc.apply(element);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Changes the visibility state of a resizable element. The toggle\r\n     * functionality is added when an element is made resizable.\r\n     * @param {DOMNode} element Html element to toggle\r\n     */\r\n    function toggle(element) {\r\n        if ($(element).is(":visible")) {\r\n            hide(element);\r\n        } else {\r\n            show(element);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Removes the resizability of an element if it\'s resizable\r\n     * @param {DOMNode} element Html element in which to remove sizing \r\n     */\r\n    function removeSizable(element) {\r\n        var removeSizableFunc = $(element).data("removeSizable");\r\n        if (removeSizableFunc) {\r\n            removeSizableFunc.apply(element);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Updates the sizing div by resyncing to the sizing edge of the element\r\n     * Call this method after manually changing the size of the element\r\n     * @param {DOMNode} element Html element whose sizer should be resynchronized\r\n     */\r\n    function resyncSizer(element) {\r\n        var resyncSizerFunc = $(element).data("resyncSizer");\r\n        if (resyncSizerFunc) {\r\n            resyncSizerFunc.apply(element);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Returns the visibility state of a resizable element.\r\n     * @param {DOMNode} element Html element to toggle\r\n     * @return {boolean} true if element is visible, false if it is not visible\r\n     */\r\n    function isVisible(element) {\r\n        return $(element).is(":visible");\r\n    }\r\n    \r\n    /**\r\n     * Adds resizing and (optionally) expand/collapse capabilities to a given html element. The element\'s size\r\n     * & visibility are automatically saved & restored as a view-state preference.\r\n     *\r\n     * Resizing can be configured in two directions:\r\n     *  - Vertical ("vert"): Resizes the height of the element\r\n     *  - Horizontal ("horz"): Resizes the width of the element\r\n     *\r\n     * Resizer handlers can be positioned on the element at:\r\n     *  - Top ("top") or bottom ("bottom") for vertical resizing\r\n     *  - Left ("left") or right ("right") for horizontal resizing\r\n     *\r\n     * A resizable element triggers the following events while resizing:\r\n     *  - panelResizeStart: When the resize starts. Passed the new size.\r\n     *  - panelResizeUpdate: When the resize gets updated. Passed the new size.\r\n     *  - panelResizeEnd: When the resize ends. Passed the final size.\r\n     *  - panelCollapsed: When the panel gets collapsed (or hidden). Passed the last size\r\n     *      before collapse. May occur without any resize events.\r\n     *  - panelExpanded: When the panel gets expanded (or shown). Passed the initial size.\r\n     *      May occur without any resize events.\r\n     *\r\n     * @param {!DOMNode} element DOM element which should be made resizable. Must have an id attribute, for\r\n     *                          use as a preferences key.\r\n     * @param {!string} direction Direction of the resize action: one of the DIRECTION_* constants.\r\n     * @param {!string} position Which side of the element can be dragged: one of the POSITION_* constants\r\n     *                          (TOP/BOTTOM for vertical resizing or LEFT/RIGHT for horizontal).\r\n     * @param {?number} minSize Minimum size (width or height) of the element\'s outer dimensions, including\r\n     *                          border & padding. Defaults to DEFAULT_MIN_SIZE.\r\n     * @param {?boolean} collapsible Indicates the panel is collapsible on double click on the\r\n     *                          resizer. Defaults to false.\r\n     * @param {?string} forceLeft CSS selector indicating element whose \'left\' should be locked to the\r\n     *                          the resizable element\'s size (useful for siblings laid out to the right of\r\n     *                          the element). Must lie in element\'s parent\'s subtree.\r\n     * @param {?boolean} createdByWorkspaceManager For internal use only\r\n     * @param {?boolean} usePercentages Maintain the size of the element as a percentage of its parent\r\n     *                          the default is to maintain the size of the element in pixels\r\n     */\r\n    function makeResizable(element, direction, position, minSize, collapsible, forceLeft, createdByWorkspaceManager, usePercentages) {\r\n        var $resizer            = $(\'<div class="\' + direction + \'-resizer"></div>\'),\r\n            $element            = $(element),\r\n            $parent             = $element.parent(),\r\n            $resizableElement   = $($element.find(".resizable-content:first")[0]),\r\n            $body               = $(window.document.body),\r\n            elementID           = $element.attr("id"),\r\n            elementPrefs        = PreferencesManager.getViewState(elementID) || {},\r\n            animationRequest    = null,\r\n            directionProperty   = direction === DIRECTION_HORIZONTAL ? "clientX" : "clientY",\r\n            directionIncrement  = (position === POSITION_TOP || position === POSITION_LEFT) ? 1 : -1,\r\n            parentSizeFunction  = direction === DIRECTION_HORIZONTAL ? $parent.innerWidth : $parent.innerHeight,\r\n            \r\n            elementSizeFunction = function (newSize) {\r\n                if (!newSize) {\r\n                    // calling the function as a getter\r\n                    if (direction === DIRECTION_HORIZONTAL) {\r\n                        return this.width();\r\n                    } else {\r\n                        return this.height();\r\n                    }\r\n                } else if (!usePercentages) {\r\n                    if (direction === DIRECTION_HORIZONTAL) {\r\n                        return this.width(newSize);\r\n                    } else {\r\n                        return this.height(newSize);\r\n                    }\r\n                } else {\r\n                    // calling the function as a setter\r\n                    var parentSize = parentSizeFunction.apply($parent),\r\n                        percentage,\r\n                        prop;\r\n\r\n                    if (direction === DIRECTION_HORIZONTAL) {\r\n                        prop = "width";\r\n                    } else {\r\n                        prop = "height";\r\n                    }\r\n                    percentage = newSize / parentSize;\r\n                    this.css(prop, (percentage * 100) + "%");\r\n                    \r\n                    return this; // chainable\r\n                }\r\n            },\r\n            \r\n            resizerCSSPosition  = direction === DIRECTION_HORIZONTAL ? "left" : "top",\r\n            contentSizeFunction = direction === DIRECTION_HORIZONTAL ? $resizableElement.width : $resizableElement.height;\r\n\r\n        if (!elementID) {\r\n            console.error("Resizable panels must have a DOM id to use as a preferences key:", element);\r\n            return;\r\n        }\r\n        \r\n        if (minSize === undefined) {\r\n            minSize = DEFAULT_MIN_SIZE;\r\n        }\r\n\r\n        collapsible = collapsible || false;\r\n        \r\n        $element.prepend($resizer);\r\n        \r\n        // Important so min/max sizes behave predictably\r\n        $element.css("box-sizing", "border-box");\r\n        \r\n        // Detect legacy cases where panels in the editor area are created without using WorkspaceManager APIs\r\n        if ($parent[0] && $parent.is(".content") && !createdByWorkspaceManager) {\r\n            console.warn("Deprecated: resizable panels should be created via WorkspaceManager.createBottomPanel(). Using Resizer directly will stop working in the future. \\nElement:", element);\r\n            $(exports).triggerHandler("deprecatedPanelAdded", [$element]);\r\n        }\r\n        \r\n        function adjustSibling(size) {\r\n            if (forceLeft !== undefined) {\r\n                $(forceLeft, $parent).css("left", size);\r\n            }\r\n        }\r\n        \r\n        function resizeElement(elementSize, contentSize) {\r\n            elementSizeFunction.apply($element, [elementSize]);\r\n            \r\n            if ($resizableElement.length) {\r\n                contentSizeFunction.apply($resizableElement, [contentSize]);\r\n            }\r\n        }\r\n        \r\n        // If the resizer is positioned right or bottom of the panel, we need to listen to\r\n        // reposition it if the element size changes externally\r\n        function repositionResizer(elementSize) {\r\n            var resizerPosition = elementSize || 1;\r\n            if (position === POSITION_RIGHT || position === POSITION_BOTTOM) {\r\n                $resizer.css(resizerCSSPosition, resizerPosition);\r\n            }\r\n        }\r\n            \r\n        $element.data("removeSizable", function () {\r\n            $resizer.off(".resizer");\r\n            \r\n            $element.removeData("show");\r\n            $element.removeData("hide");\r\n            $element.removeData("resyncSizer");\r\n            $element.removeData("removeSizable");\r\n            \r\n            $resizer.remove();\r\n        });\r\n        \r\n        $element.data("resyncSizer", function () {\r\n            repositionResizer(elementSizeFunction.apply($element));\r\n        });\r\n        \r\n        $element.data("show", function () {\r\n            var elementOffset   = $element.offset(),\r\n                elementSize     = elementSizeFunction.apply($element) || elementPrefs.size,\r\n                contentSize     = contentSizeFunction.apply($resizableElement) || elementPrefs.contentSize,\r\n                resizerSize     = elementSizeFunction.apply($resizer);\r\n            \r\n            // Resize the element before showing it again. If the panel was collapsed by dragging\r\n            // the resizer, the size of the element should be 0, so we restore size in preferences\r\n            resizeElement(elementSize, contentSize);\r\n            \r\n            $element.show();\r\n            elementPrefs.visible = true;\r\n            \r\n            if (collapsible) {\r\n                $element.prepend($resizer);\r\n                \r\n                if (position === POSITION_TOP) {\r\n                    $resizer.css(resizerCSSPosition, "");\r\n                } else if (position === POSITION_RIGHT) {\r\n                    $resizer.css(resizerCSSPosition, elementOffset[resizerCSSPosition] + elementSize);\r\n                }\r\n            }\r\n            \r\n            adjustSibling(elementSize);\r\n            \r\n            $element.trigger("panelExpanded", [elementSize]);\r\n            PreferencesManager.setViewState(elementID, elementPrefs, null, isResizing);\r\n        });\r\n                      \r\n        $element.data("hide", function () {\r\n            var elementOffset   = $element.offset(),\r\n                elementSize     = elementSizeFunction.apply($element),\r\n                resizerSize     = elementSizeFunction.apply($resizer);\r\n            \r\n            $element.hide();\r\n            elementPrefs.visible = false;\r\n            if (collapsible) {\r\n                $resizer.insertBefore($element);\r\n                if (position === POSITION_RIGHT) {\r\n                    $resizer.css(resizerCSSPosition, "");\r\n                } else if (position === POSITION_TOP) {\r\n                    $resizer.css(resizerCSSPosition, elementOffset[resizerCSSPosition] + elementSize - resizerSize);\r\n                }\r\n            }\r\n            \r\n            adjustSibling(0);\r\n            \r\n            $element.trigger("panelCollapsed", [elementSize]);\r\n            PreferencesManager.setViewState(elementID, elementPrefs, null, isResizing);\r\n        });\r\n        \r\n\r\n        $resizer.on("mousedown.resizer", function (e) {\r\n            var $resizeShield   = $("<div class=\'resizing-container " + direction + "-resizing\' />"),\r\n                startPosition   = e[directionProperty],\r\n                startSize       = $element.is(":visible") ? elementSizeFunction.apply($element) : 0,\r\n                newSize         = startSize,\r\n                previousSize    = startSize,\r\n                baseSize        = 0,\r\n                resizeStarted   = false;\r\n            \r\n            isResizing = true;\r\n            $body.append($resizeShield);\r\n                        \r\n            if ($resizableElement.length) {\r\n                $element.children().not(".horz-resizer, .vert-resizer, .resizable-content").each(function (index, child) {\r\n                    if (direction === DIRECTION_HORIZONTAL) {\r\n                        baseSize += $(child).outerWidth();\r\n                    } else {\r\n                        baseSize += $(child).outerHeight();\r\n                    }\r\n                });\r\n            }\r\n                        \r\n            function doRedraw() {\r\n                // only run this if the mouse is down so we don\'t constantly loop even\r\n                // after we\'re done resizing.\r\n                if (!isResizing) {\r\n                    return;\r\n                }\r\n                \r\n                // Check for real size changes to avoid unnecessary resizing and events\r\n                if (newSize !== previousSize) {\r\n                    previousSize = newSize;\r\n                    \r\n                    if ($element.is(":visible")) {\r\n                        if (newSize < 10) {\r\n                            toggle($element);\r\n                            elementSizeFunction.apply($element, [0]);\r\n                        } else {\r\n                            // Trigger resizeStarted just before the first successful resize update\r\n                            if (!resizeStarted) {\r\n                                resizeStarted = true;\r\n                                $element.trigger("panelResizeStart", newSize);\r\n                            }\r\n                            \r\n                            // Resize the main element to the new size. If there is a content element,\r\n                            // its size is the new size minus the size of the non-resizable elements\r\n                            resizeElement(newSize, (newSize - baseSize));\r\n                            adjustSibling(newSize);\r\n                            \r\n                            $element.trigger("panelResizeUpdate", [newSize]);\r\n                        }\r\n                    } else if (newSize > 10) {\r\n                        elementSizeFunction.apply($element, [newSize]);\r\n                        toggle($element);\r\n                        \r\n                        // Trigger resizeStarted after expanding the element if it was previously collapsed\r\n                        if (!resizeStarted) {\r\n                            resizeStarted = true;\r\n                            $element.trigger("panelResizeStart", newSize);\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                animationRequest = window.requestAnimationFrame(doRedraw);\r\n            }\r\n            \r\n            function onMouseMove(e) {\r\n                // calculate newSize adding to startSize the difference\r\n                // between starting and current position, capped at minSize\r\n                newSize = Math.max(startSize + directionIncrement * (startPosition - e[directionProperty]), minSize);\r\n                \r\n                // respect max size if one provided (e.g. by WorkspaceManager)\r\n                var maxSize = $element.data("maxsize");\r\n                if (maxSize !== undefined) {\r\n                    newSize = Math.min(newSize, maxSize);\r\n                }\r\n                                   \r\n                e.preventDefault();\r\n                \r\n                if (animationRequest === null) {\r\n                    animationRequest = window.requestAnimationFrame(doRedraw);\r\n                }\r\n            }\r\n            \r\n            $(window.document).on("mousemove", onMouseMove);\r\n            \r\n            // If the element is marked as collapsible, check for double click\r\n            // to toggle the element visibility\r\n            if (collapsible) {\r\n                $resizeShield.on("mousedown", function (e) {\r\n                    $(window.document).off("mousemove", onMouseMove);\r\n                    $resizeShield.off("mousedown");\r\n                    $resizeShield.remove();\r\n                    animationRequest = null;\r\n                    toggle($element);\r\n                });\r\n            }\r\n            \r\n            function endResize(e) {\r\n                if (isResizing) {\r\n                    \r\n                    var elementSize	= elementSizeFunction.apply($element);\r\n                    if ($element.is(":visible")) {\r\n                        elementPrefs.size = elementSize;\r\n                        if ($resizableElement.length) {\r\n                            elementPrefs.contentSize = contentSizeFunction.apply($resizableElement);\r\n                        }\r\n                        PreferencesManager.setViewState(elementID, elementPrefs);\r\n                        repositionResizer(elementSize);\r\n                    }\r\n\r\n                    isResizing = false;\r\n                    \r\n                    if (resizeStarted) {\r\n                        $element.trigger("panelResizeEnd", [elementSize]);\r\n                    }\r\n                    \r\n                    // We wait 300ms to remove the resizer container to capture a mousedown\r\n                    // on the container that would account for double click\r\n                    window.setTimeout(function () {\r\n                        $(window.document).off("mousemove", onMouseMove);\r\n                        $resizeShield.off("mousedown");\r\n                        $resizeShield.remove();\r\n                        animationRequest = null;\r\n                    }, 300);\r\n                }\r\n            }\r\n            \r\n            $(window.document).one("mouseup", endResize);\r\n            \r\n            e.preventDefault();\r\n        });\r\n		\r\n        // Panel preferences initialization\r\n        if (elementPrefs) {\r\n            \r\n            if (elementPrefs.size !== undefined) {\r\n                elementSizeFunction.apply($element, [elementPrefs.size]);\r\n            }\r\n            \r\n            if (elementPrefs.contentSize !== undefined) {\r\n                contentSizeFunction.apply($resizableElement, [elementPrefs.contentSize]);\r\n            }\r\n            \r\n            if (elementPrefs.visible !== undefined && !elementPrefs.visible) {\r\n                hide($element);\r\n            } else {\r\n                adjustSibling(elementSizeFunction.apply($element));\r\n                repositionResizer(elementSizeFunction.apply($element));\r\n            }\r\n        }\r\n    }\r\n\r\n    // Scan DOM for horz-resizable and vert-resizable classes and make them resizable\r\n    AppInit.htmlReady(function () {\r\n        var minSize = DEFAULT_MIN_SIZE;\r\n		\r\n        $mainView = $(".main-view");\r\n        \r\n        $(".vert-resizable").each(function (index, element) {\r\n            \r\n            if ($(element).data().minsize !== undefined) {\r\n                minSize = $(element).data().minsize;\r\n            }\r\n			\r\n            if ($(element).hasClass("top-resizer")) {\r\n                makeResizable(element, DIRECTION_VERTICAL, POSITION_TOP, minSize, $(element).hasClass("collapsible"));\r\n            }\r\n            \r\n            //if ($(element).hasClass("bottom-resizer")) {\r\n            //    makeResizable(element, DIRECTION_VERTICAL, POSITION_BOTTOM, DEFAULT_MIN_SIZE);\r\n            //}\r\n        });\r\n        \r\n        $(".horz-resizable").each(function (index, element) {\r\n            \r\n            if ($(element).data().minsize !== undefined) {\r\n                minSize = $(element).data().minsize;\r\n            }\r\n            \r\n            //if ($(element).hasClass("left-resizer")) {\r\n            //    makeResizable(element, DIRECTION_HORIZONTAL, POSITION_LEFT, DEFAULT_MIN_SIZE);\r\n            //}\r\n\r\n            if ($(element).hasClass("right-resizer")) {\r\n                makeResizable(element, DIRECTION_HORIZONTAL, POSITION_RIGHT, minSize, $(element).hasClass("collapsible"), $(element).data().forceleft);\r\n            }\r\n        });\r\n    });\r\n    \r\n    /**\r\n     * @private\r\n     * Examine each preference key for migration of any panel state.\r\n     *\r\n     * @param {string} key The key of the preference to be examined\r\n     *      for migration of panel states.\r\n     * @return {?string} - the scope to which the preference is to be migrated\r\n     */\r\n    function _isPanelPreferences(key) {\r\n        if (key) {\r\n            return "user";\r\n        }\r\n        \r\n        return null;\r\n    }\r\n    \r\n    PreferencesManager.convertPreferences(module, {"panelState": "user"}, true, _isPanelPreferences);\r\n    \r\n    exports.makeResizable   = makeResizable;\r\n    exports.removeSizable   = removeSizable;\r\n    exports.resyncSizer     = resyncSizer;\r\n    exports.toggle          = toggle;\r\n    exports.show            = show;\r\n    exports.hide            = hide;\r\n    exports.isVisible       = isVisible;\r\n    \r\n    //Resizer Constants\r\n    exports.DIRECTION_VERTICAL   = DIRECTION_VERTICAL;\r\n    exports.DIRECTION_HORIZONTAL = DIRECTION_HORIZONTAL;\r\n    exports.POSITION_TOP         = POSITION_TOP;\r\n    exports.POSITION_RIGHT       = POSITION_RIGHT;\r\n    exports.POSITION_BOTTOM      = POSITION_BOTTOM;\r\n    exports.POSITION_LEFT        = POSITION_LEFT;\r\n});\r\n\n//# sourceURL=/utils/Resizer.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, window, $, brackets */\r\n\r\n/**\r\n* Manages layout of panels surrounding the editor area, and size of the editor area (but not its contents).\r\n * \r\n * Updates panel sizes when the window is resized. Maintains the max resizing limits for panels, based on\r\n * currently available window size.\r\n * \r\n * Events:\r\n * `workspaceUpdateLayout` When workspace size changes for any reason (including panel show/hide panel resize, or the window resize).\r\n *              The 2nd arg is the available workspace height.\r\n *              The 3rd arg is a refreshHint flag for internal use (passed in to recomputeLayout)\r\n */\r\ndefine(\'view/WorkspaceManager\',[\'require\',\'exports\',\'module\',\'utils/AppInit\',\'utils/Resizer\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var AppInit                 = require("utils/AppInit"),\r\n        Resizer                 = require("utils/Resizer");\r\n    \r\n    \r\n    /** \r\n     * The ".content" vertical stack (editor + all header/footer panels) \r\n     * @type {jQueryObject} \r\n     */\r\n    var $windowContent;\r\n\r\n    /** \r\n     * The "#editor-holder": has only one visible child, the current CodeMirror instance (or the no-editor placeholder) \r\n     * @type {jQueryObject} \r\n     */\r\n    var $editorHolder;\r\n    \r\n    /** \r\n     * Have we already started listening for the end of the ongoing window resize? \r\n     * @type {boolean} \r\n     */\r\n    var windowResizing = false;\r\n    \r\n\r\n    /**\r\n     * Calculates the available height for the full-size Editor (or the no-editor placeholder),\r\n     * accounting for the current size of all visible panels, toolbar, & status bar.\r\n     * @return {number}\r\n     */\r\n    function calcAvailableHeight() {\r\n        var availableHt = $windowContent.height();\r\n        \r\n        $editorHolder.siblings().each(function (i, elem) {\r\n            var $elem = $(elem);\r\n            if ($elem.css("display") !== "none" && $elem.css("position") !== "absolute") {\r\n                availableHt -= $elem.outerHeight();\r\n            }\r\n        });\r\n        \r\n        // Clip value to 0 (it could be negative if a panel wants more space than we have)\r\n        return Math.max(availableHt, 0);\r\n    }\r\n    \r\n    /** Updates panel resize limits to disallow making panels big enough to shrink editor area below 0 */\r\n    function updateResizeLimits() {\r\n        var editorAreaHeight = $editorHolder.height();\r\n        \r\n        $editorHolder.siblings().each(function (i, elem) {\r\n            var $elem = $(elem);\r\n            if ($elem.css("display") === "none") {\r\n                $elem.data("maxsize", editorAreaHeight);\r\n            } else {\r\n                $elem.data("maxsize", editorAreaHeight + $elem.outerHeight());\r\n            }\r\n        });\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Calculates a new size for editor-holder and resizes it accordingly, then and dispatches the "workspaceUpdateLayout"\r\n     * event. (The editors within are resized by EditorManager, in response to that event).\r\n     * \r\n     * @param {string=} refreshHint  One of "skip", "force", or undefined. See EditorManager docs.\r\n     */\r\n    function triggerUpdateLayout(refreshHint) {\r\n        // Find how much space is left for the editor\r\n        var editorAreaHeight = calcAvailableHeight();\r\n        \r\n        $editorHolder.height(editorAreaHeight);  // affects size of "not-editor" placeholder as well\r\n        \r\n        // Resize editor to fill the space\r\n        $(exports).trigger("workspaceUpdateLayout", [editorAreaHeight, refreshHint]);\r\n    }\r\n    \r\n    \r\n    /** Trigger editor area resize whenever the window is resized */\r\n    function handleWindowResize() {\r\n        // These are not initialized in Jasmine Spec Runner window until a test\r\n        // is run that creates a mock document.\r\n        if (!$windowContent || !$editorHolder) {\r\n            return;\r\n        }\r\n        \r\n        // Immediately adjust editor\'s height, but skip the refresh since CodeMirror will call refresh()\r\n        // itself when it sees the window resize event\r\n        // triggerUpdateLayout("skip");\r\n\r\n        // FIXME (issue #4564) Workaround https://github.com/marijnh/CodeMirror/issues/1787\r\n        triggerUpdateLayout();\r\n        \r\n        if (!windowResizing) {\r\n            windowResizing = true;\r\n            \r\n            // We don\'t need any fancy debouncing here - we just need to react before the user can start\r\n            // resizing any panels at the new window size. So just listen for first mousemove once the\r\n            // window resize releases mouse capture.\r\n            $(window.document).one("mousemove", function () {\r\n                windowResizing = false;\r\n                updateResizeLimits();\r\n            });\r\n        }\r\n    }\r\n    \r\n    /** Trigger editor area resize whenever the given panel is shown/hidden/resized \r\n     *  @param {!jQueryObject} $panel the jquery object in which to attach event handlers \r\n     */\r\n    function listenToResize($panel) {\r\n        // Update editor height when shown/hidden, & continuously as panel is resized\r\n        $panel.on("panelCollapsed panelExpanded panelResizeUpdate", function () {\r\n            triggerUpdateLayout();\r\n        });\r\n        // Update max size of sibling panels when shown/hidden, & at *end* of resize gesture\r\n        $panel.on("panelCollapsed panelExpanded panelResizeEnd", function () {\r\n            updateResizeLimits();\r\n        });\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Represents a panel below the editor area (a child of ".content").\r\n     * @constructor\r\n     * @param {!jQueryObject} $panel  The entire panel, including any chrome, already in the DOM.\r\n     * @param {number=} minSize  Minimum height of panel in px.\r\n     */\r\n    function Panel($panel, minSize) {\r\n        this.$panel = $panel;\r\n        \r\n        Resizer.makeResizable($panel[0], Resizer.DIRECTION_VERTICAL, Resizer.POSITION_TOP, minSize, false, undefined, true);\r\n        listenToResize($panel);\r\n    }\r\n    \r\n    /** \r\n     * Dom node holding the rendered panel \r\n     * @type {jQueryObject} \r\n     */\r\n    Panel.prototype.$panel = null;\r\n    \r\n    /** \r\n     * Determines if the panel is visible\r\n     * @return {boolean} true if visible, false if not\r\n     */\r\n    Panel.prototype.isVisible = function () {\r\n        return this.$panel.is(":visible");\r\n    };\r\n    \r\n    /** \r\n     * Shows the panel\r\n     */\r\n    Panel.prototype.show = function () {\r\n        Resizer.show(this.$panel[0]);\r\n    };\r\n\r\n    /** \r\n     * Hides the panel\r\n     */\r\n    Panel.prototype.hide = function () {\r\n        Resizer.hide(this.$panel[0]);\r\n    };\r\n    \r\n    /** \r\n     * Sets the panel\'s visibility state\r\n     * @param {boolean} visible true to show, false to hide\r\n     */\r\n    Panel.prototype.setVisible = function (visible) {\r\n        if (visible) {\r\n            Resizer.show(this.$panel[0]);\r\n        } else {\r\n            Resizer.hide(this.$panel[0]);\r\n        }\r\n    };\r\n    \r\n    \r\n    /**\r\n     * Creates a new resizable panel beneath the editor area and above the status bar footer. Panel is initially invisible.\r\n     * The panel\'s size & visibility are automatically saved & restored as a view-state preference.\r\n     * \r\n     * @param {!string} id  Unique id for this panel. Use package-style naming, e.g. "myextension.feature.panelname"\r\n     * @param {!jQueryObject} $panel  DOM content to use as the panel. Need not be in the document yet. Must have an id\r\n     *      attribute, for use as a preferences key.\r\n     * @param {number=} minSize  Minimum height of panel in px.\r\n     * @return {!Panel}\r\n     */\r\n    function createBottomPanel(id, $panel, minSize) {\r\n        $panel.insertBefore("#status-bar");\r\n        $panel.hide();\r\n        updateResizeLimits();  // initialize panel\'s max size\r\n        \r\n        return new Panel($panel, minSize);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Called when an external widget has appeared and needs some of the space occupied \r\n     *  by the mainview manager\r\n     * @param {boolean} refreshHint true to refresh the editor, false if not\r\n     */\r\n    function recomputeLayout(refreshHint) {\r\n        triggerUpdateLayout(refreshHint);\r\n        updateResizeLimits();\r\n    }\r\n    \r\n    \r\n    /* Attach to key parts of the overall UI, once created */\r\n    AppInit.htmlReady(function () {\r\n        $windowContent = $(".content");\r\n        $editorHolder = $("#editor-holder");\r\n        \r\n        // Sidebar is a special case: it isn\'t a Panel, and is not created dynamically. Need to explicitly\r\n        // listen for resize here.\r\n        listenToResize($("#sidebar"));\r\n    });\r\n    \r\n    /* Unit test only: allow passing in mock DOM notes, e.g. for use with SpecRunnerUtils.createMockEditor() */\r\n    function _setMockDOM($mockWindowContent, $mockEditorHolder) {\r\n        $windowContent = $mockWindowContent;\r\n        $editorHolder = $mockEditorHolder;\r\n    }\r\n    \r\n    /* If someone adds a panel in the .content stack the old way, make sure we still listen for resize/show/hide\r\n     * (Resizer emits a deprecation warning for us - no need to log anything here) \r\n     */\r\n    $(Resizer).on("deprecatedPanelAdded", function (event, $panel) {\r\n        listenToResize($panel);\r\n    });\r\n    \r\n    /* Add this as a capture handler so we\'re guaranteed to run it before the editor does its own\r\n     * refresh on resize.\r\n     */\r\n    window.addEventListener("resize", handleWindowResize, true);\r\n    \r\n    \r\n    // Define public API\r\n    exports.createBottomPanel    = createBottomPanel;\r\n    exports.recomputeLayout      = recomputeLayout;\r\n    exports._setMockDOM          = _setMockDOM;\r\n});\r\n\n//# sourceURL=/view/WorkspaceManager.js'),eval("/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, window, $, brackets */\r\n\r\n/**\r\n * MainViewFactory is a singleton for managing view factories.\r\n *\r\n * Registering a view factory:\r\n *\r\n *      registerViewFactory({\r\n *           canOpen: function (fullPath) {\r\n *               return (fullPath.slice(-4) === \".ico\");\r\n *           },\r\n *           open: function(file, pane) {\r\n *               return createIconView(file, pane);\r\n *           }\r\n *      });\r\n *\r\n *  The open method is used to open the file and construct\r\n *  a view of it.  Implementation should add the view to the pane\r\n *\r\n *      function createIconView(file, pane) {\r\n *          // IconView will construct its DOM and append \r\n *          //  it to pane.$el\r\n *          var view = new IconView(file, pane.$el);\r\n *          // Then tell the pane to add it to\r\n *          //  its view map and show it\r\n *          pane.addView(view, true); \r\n *          return new $.Deferred().resolve().promise();\r\n *      }\r\n *\r\n *  Factories should only create 1 view of a file per pane.  Brackets currently only supports 1 view of \r\n *  a file open at a given time but that may change to allow the same file open in more than 1 pane. Therefore\r\n *  Factories can do a simple check to see if a view already exists and show it before creating a new one:\r\n *\r\n *      var view = pane.getViewForPath(file.fullPath);\r\n *      if (view) {\r\n *          pane.showView(view);\r\n *      } else {\r\n *          return createIconView(file, pane);\r\n *      }\r\n *  \r\n */\r\ndefine('view/MainViewFactory',['require','exports','module','thirdparty/lodash'],function (require, exports, module) {\r\n    \"use strict\";\r\n    \r\n    var _ = require(\"thirdparty/lodash\");\r\n\r\n    \r\n    /**\r\n     * @typedef {canOpenFile:function(path:string):boolean, openFile:function(path:string, pane:Pane)} Factory\r\n     */\r\n    \r\n    /**\r\n     * The view registration Database\r\n     * @private\r\n     * @type {Array.<Factory>}\r\n     */\r\n    var _factories = [];\r\n    \r\n    /**\r\n     * Registers a view factory\r\n     * @param {!Factory} factory - the view factory to register\r\n     */\r\n    function registerViewFactory(factory) {\r\n        _factories.push(factory);\r\n    }\r\n    \r\n    /**\r\n     * Finds a factory that can open the specified file\r\n     * @param {!string} fullPath - the file to open\r\n     * @return {?Factory} A factory that can create a view for the path or undefined if there isn't one.\r\n     */\r\n    function findSuitableFactoryForPath(fullPath) {\r\n        return _.find(_factories, function (factory) {\r\n            // This could get more complex in the future by searching in this order\r\n            //  1) a factory that can open the file by fullPath\r\n            //  2) a factory that can open the file by name\r\n            //  3) a factory that can open the file by filetype\r\n            return factory.canOpenFile(fullPath);\r\n        });\r\n    }\r\n    \r\n    /* \r\n     * Public API\r\n     */\r\n    exports.registerViewFactory         = registerViewFactory;\r\n    exports.findSuitableFactoryForPath  = findSuitableFactoryForPath;\r\n});\n//# sourceURL=/view/MainViewFactory.js"),eval("/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\n/**\r\n * ViewStateManager is a singleton for views to park their global viwe state. The state is saved\r\n * with project data but the View or View Factory is responsible for restoring the view state\r\n * when the view is created.\r\n *\r\n * Views should implement `getViewState()` so that the view state can be saved and that data is cached\r\n * for later use.\r\n *\r\n * Views or View Factories are responsible for restoring the view state when the view of that file is created\r\n * by recalling the cached state.  Views determine what data is store in the view state and how to restore it.\r\n */\r\ndefine('view/ViewStateManager',['require','exports','module','thirdparty/lodash'],function (require, exports, module) {\r\n    \"use strict\";\r\n    \r\n    var _ = require(\"thirdparty/lodash\");\r\n        \r\n    /**\r\n     * The view state cache.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    var _viewStateCache = {};\r\n    \r\n    /**\r\n     * resets the view state cache\r\n     */\r\n    function reset() {\r\n        _viewStateCache = {};\r\n    }\r\n    \r\n    /**\r\n     * Sets the view state for the specfied file\r\n     * @param {!File} file - the file to record the view state for\r\n     * @param {?*} viewState - any data that the view needs to restore the view state.  \r\n     */\r\n    function _setViewState(file, viewState) {\r\n        _viewStateCache[file.fullPath] = viewState;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Updates the view state for the specified view\r\n     * @param {!{!getFile:function():File, getViewState:function():*}} view - the to save state\r\n     * @param {?*} viewState - any data that the view needs to restore the view state.  \r\n     */\r\n    function updateViewState(view) {\r\n        if (view.getViewState) {\r\n            _setViewState(view.getFile(), view.getViewState());\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * gets the view state for the specified file\r\n     * @param {!File} file - the file to record the view state for\r\n     * @return {?*} whatever data that was saved earlier with a call setViewState\r\n     */\r\n    function getViewState(file) {\r\n        return _viewStateCache[file.fullPath];\r\n    }\r\n    \r\n    /**\r\n     * adds an array of view states\r\n     * @param {!object.<string, *>} viewStates - View State object to append to the current set of view states\r\n     */\r\n    function addViewStates(viewStates) {\r\n        _viewStateCache = _.extend(_viewStateCache, viewStates);\r\n    }\r\n\r\n    /*\r\n     * Public API\r\n     */\r\n    exports.reset           = reset;\r\n    exports.updateViewState = updateViewState;\r\n    exports.getViewState    = getViewState;\r\n    exports.addViewStates   = addViewStates;\r\n});\r\n\n//# sourceURL=/view/ViewStateManager.js"),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, window, $, brackets */\r\n\r\n/**\r\n * Utilities for managing pop-ups.\r\n */\r\ndefine(\'widgets/PopUpManager\',[\'require\',\'exports\',\'module\',\'utils/AppInit\',\'command/CommandManager\',\'editor/EditorManager\',\'utils/KeyEvent\',\'command/Menus\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var AppInit         = require("utils/AppInit"),\r\n        CommandManager  = require("command/CommandManager"),\r\n        EditorManager   = require("editor/EditorManager"),\r\n        KeyEvent        = require("utils/KeyEvent"),\r\n        Menus           = require("command/Menus");\r\n    \r\n    var _popUps = [];\r\n        \r\n    /**\r\n     * Add Esc key handling for a popup DOM element.\r\n     *\r\n     * @param {!jQuery} $popUp jQuery object for the DOM element pop-up\r\n     * @param {function} removeHandler Pop-up specific remove (e.g. display:none or DOM removal)\r\n     * @param {?Boolean} autoRemove - Specify true to indicate the PopUpManager should \r\n     *      remove the popup from the _popUps array when the popup is closed. Specify false\r\n     *      when the popup is always persistant in the _popUps array.\r\n     *      \r\n     */\r\n    function addPopUp($popUp, removeHandler, autoRemove) {\r\n        autoRemove = autoRemove || false;\r\n\r\n        _popUps.push($popUp[0]);\r\n        $popUp.data("PopUpManager-autoRemove", autoRemove);\r\n        $popUp.data("PopUpManager-removeHandler", removeHandler);\r\n    }\r\n    \r\n    /**\r\n     * Remove Esc key handling for a pop-up. Removes the pop-up from the DOM\r\n     * if the pop-up is currently visible and was not originally attached.\r\n     *\r\n     * @param {!jQuery} $popUp\r\n     */\r\n    function removePopUp($popUp) {\r\n        // check visible first to help protect against recursive calls\r\n        // via removeHandler\r\n        if ($popUp.find(":visible").length > 0) {\r\n            var removeHandler = $popUp.data("PopUpManager-removeHandler");\r\n            if (removeHandler) {\r\n                removeHandler();\r\n            }\r\n        }\r\n\r\n        // check index after removeHandler is done processing to protect\r\n        // against recursive calls\r\n        var index = _popUps.indexOf($popUp[0]);\r\n        if (index >= 0) {\r\n            var autoRemove = $popUp.data("PopUpManager-autoRemove");\r\n            if (autoRemove) {\r\n                $popUp.remove();\r\n                _popUps.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Remove Esc key handling for a pop-up. Removes the pop-up from the DOM\r\n     * if the pop-up is currently visible and was not originally attached.\r\n     *\r\n     * @param {KeyboardEvent=} keyEvent (optional)\r\n     */\r\n    function removeCurrentPopUp(keyEvent) {\r\n        // allow the popUp to prevent closing\r\n        var $popUp,\r\n            i,\r\n            event = new $.Event("popUpClose");\r\n        \r\n        for (i = _popUps.length - 1; i >= 0; i--) {\r\n            $popUp = $(_popUps[i]);\r\n            \r\n            if ($popUp.find(":visible").length > 0) {\r\n                $popUp.trigger(event);\r\n                \r\n                if (!event.isDefaultPrevented()) {\r\n                    // Stop the DOM event from propagating\r\n                    if (keyEvent) {\r\n                        keyEvent.stopImmediatePropagation();\r\n                    }\r\n                    \r\n                    removePopUp($popUp);\r\n\r\n                    // TODO: right now Menus and Context Menus do not take focus away from\r\n                    // the editor. We need to have a focus manager to correctly manage focus\r\n                    // between editors and other UI elements.\r\n                    // For now we don\'t set focus here and assume individual popups\r\n                    // adjust focus if necessary\r\n                    // See story in Trello card #404\r\n                    //EditorManager.focusEditor();\r\n                }\r\n                \r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    function _keydownCaptureListener(keyEvent) {\r\n         // Escape key or Alt key (Windows-only)\r\n        if (keyEvent.keyCode !== KeyEvent.DOM_VK_ESCAPE &&\r\n                !(keyEvent.keyCode === KeyEvent.DOM_VK_ALT && brackets.platform === "win")) {\r\n            return;\r\n        }\r\n\r\n        // Don\'t dismiss the popup if both Ctrl and Alt keys are pressed.\r\n        if (keyEvent.keyCode === KeyEvent.DOM_VK_ALT && keyEvent.ctrlKey) {\r\n            return;\r\n        }\r\n        \r\n        removeCurrentPopUp(keyEvent);\r\n    }\r\n    \r\n    /**\r\n     * A menu is being popped up, so remove any menu that is currently popped up\r\n     */\r\n    function _beforeMenuPopup() {\r\n        removeCurrentPopUp();\r\n    }\r\n    \r\n    /**\r\n     * Context menus are also created in AppInit.htmlReady(), so they may not\r\n     * yet have been created when we get our AppInit.htmlReady() callback, so\r\n     * we provide this method to tell us when to start listening for their events\r\n     *\r\n     * @param {ContextMenu} contextMenu\r\n     */\r\n    function listenToContextMenu(contextMenu) {\r\n        $(contextMenu).on("beforeContextMenuOpen", _beforeMenuPopup);\r\n    }\r\n\r\n    AppInit.htmlReady(function () {\r\n        // Register for events\r\n        window.document.body.addEventListener("keydown", _keydownCaptureListener, true);\r\n        $(exports).on("beforeMenuPopup", _beforeMenuPopup);\r\n        \r\n        // Close all popups when a command is executed\r\n        $(CommandManager).on("beforeExecuteCommand", function (jqEvent, commandId) {\r\n            removeCurrentPopUp();\r\n        });\r\n    });\r\n    \r\n    exports.addPopUp            = addPopUp;\r\n    exports.removePopUp         = removePopUp;\r\n    exports.listenToContextMenu = listenToContextMenu;\r\n});\r\n\n//# sourceURL=/widgets/PopUpManager.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\ndefine(\'utils/ViewUtils\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'file/FileUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var _         = require("thirdparty/lodash"),\r\n        FileUtils = require("file/FileUtils");\r\n    \r\n    var SCROLL_SHADOW_HEIGHT = 5;\r\n    \r\n    /**\r\n     * @private\r\n     */\r\n    var _resizeHandlers = [];\r\n\r\n    /** \r\n     * Positions shadow background elements to indicate vertical scrolling.\r\n     * @param {!DOMElement} $displayElement the DOMElement that displays the shadow\r\n     * @param {!Object} $scrollElement the object that is scrolled\r\n     * @param {!DOMElement} $shadowTop div .scroller-shadow.top\r\n     * @param {!DOMElement} $shadowBottom div .scroller-shadow.bottom\r\n     * @param {boolean} isPositionFixed When using absolute position, top remains at 0.\r\n     */\r\n    function _updateScrollerShadow($displayElement, $scrollElement, $shadowTop, $shadowBottom, isPositionFixed) {\r\n        var offsetTop           = 0,\r\n            scrollElement       = $scrollElement.get(0),\r\n            scrollTop           = scrollElement.scrollTop,\r\n            topShadowOffset     = Math.min(scrollTop - SCROLL_SHADOW_HEIGHT, 0),\r\n            displayElementWidth = $displayElement.width();\r\n        \r\n        if ($shadowTop) {\r\n            $shadowTop.css("background-position", "0px " + topShadowOffset + "px");\r\n            \r\n            if (isPositionFixed) {\r\n                offsetTop = $displayElement.offset().top;\r\n                $shadowTop.css("top", offsetTop);\r\n            }\r\n            \r\n            if (isPositionFixed) {\r\n                $shadowTop.css("width", displayElementWidth);\r\n            }\r\n        }\r\n        \r\n        if ($shadowBottom) {\r\n            var clientHeight        = scrollElement.clientHeight,\r\n                outerHeight         = $displayElement.outerHeight(),\r\n                scrollHeight        = scrollElement.scrollHeight,\r\n                bottomOffset        = outerHeight - clientHeight,\r\n                bottomShadowOffset  = SCROLL_SHADOW_HEIGHT; // outside of shadow div viewport\r\n            \r\n            if (scrollHeight > clientHeight) {\r\n                bottomShadowOffset -= Math.min(SCROLL_SHADOW_HEIGHT, (scrollHeight - (scrollTop + clientHeight)));\r\n            }\r\n    \r\n            $shadowBottom.css("background-position", "0px " + bottomShadowOffset + "px");\r\n            $shadowBottom.css("top", offsetTop + outerHeight - SCROLL_SHADOW_HEIGHT);\r\n            $shadowBottom.css("width", displayElementWidth);\r\n        }\r\n    }\r\n\r\n    function getOrCreateShadow($displayElement, position, isPositionFixed) {\r\n        var $findShadow = $displayElement.find(".scroller-shadow." + position);\r\n\r\n        if ($findShadow.length === 0) {\r\n            $findShadow = $(window.document.createElement("div")).addClass("scroller-shadow " + position);\r\n            $displayElement.append($findShadow);\r\n        }\r\n        \r\n        if (!isPositionFixed) {\r\n            // position is fixed by default\r\n            $findShadow.css("position", "absolute");\r\n            $findShadow.css(position, "0");\r\n        }\r\n\r\n        return $findShadow;\r\n    }\r\n\r\n    /** \r\n     * Installs event handlers for updatng shadow background elements to indicate vertical scrolling.\r\n     * @param {!DOMElement} displayElement the DOMElement that displays the shadow. Must fire\r\n     *  "contentChanged" events when the element is resized or repositioned.\r\n     * @param {?Object} scrollElement the object that is scrolled. Must fire "scroll" events\r\n     *  when the element is scrolled. If null, the displayElement is used.\r\n     * @param {?boolean} showBottom optionally show the bottom shadow\r\n     */\r\n    function addScrollerShadow(displayElement, scrollElement, showBottom) {\r\n        // use fixed positioning when the display and scroll elements are the same\r\n        var isPositionFixed = false;\r\n        \r\n        if (!scrollElement) {\r\n            scrollElement = displayElement;\r\n            isPositionFixed = true;\r\n        }\r\n        \r\n        // update shadows when the scrolling element is scrolled\r\n        var $displayElement = $(displayElement),\r\n            $scrollElement = $(scrollElement);\r\n        \r\n        var $shadowTop = getOrCreateShadow($displayElement, "top", isPositionFixed);\r\n        var $shadowBottom = (showBottom) ? getOrCreateShadow($displayElement, "bottom", isPositionFixed) : null;\r\n        \r\n        var doUpdate = function () {\r\n            _updateScrollerShadow($displayElement, $scrollElement, $shadowTop, $shadowBottom, isPositionFixed);\r\n        };\r\n        \r\n        $scrollElement.on("scroll.scroller-shadow", doUpdate);\r\n        $displayElement.on("contentChanged.scroller-shadow", doUpdate);\r\n        \r\n        // update immediately\r\n        doUpdate();\r\n    }\r\n    \r\n    /**\r\n     * Remove scroller-shadow effect.\r\n     * @param {!DOMElement} displayElement the DOMElement that displays the shadow\r\n     * @param {?Object} scrollElement the object that is scrolled\r\n     */\r\n    function removeScrollerShadow(displayElement, scrollElement) {\r\n        if (!scrollElement) {\r\n            scrollElement = displayElement;\r\n        }\r\n        \r\n        var $displayElement = $(displayElement),\r\n            $scrollElement = $(scrollElement);\r\n        \r\n        // remove scrollerShadow elements from DOM\r\n        $displayElement.find(".scroller-shadow.top").remove();\r\n        $displayElement.find(".scroller-shadow.bottom").remove();\r\n        \r\n        // remove event handlers\r\n        $scrollElement.off("scroll.scroller-shadow");\r\n        $displayElement.off("contentChanged.scroller-shadow");\r\n    }\r\n    \r\n    /**\r\n     * Utility function to replace jQuery.toggleClass when used with the second argument, which needs to be a true boolean for jQuery\r\n     * @param {!jQueryObject} $domElement The jQueryObject to toggle the Class on\r\n     * @param {!string} className Class name or names (separated by spaces) to toggle\r\n     * @param {!boolean} addClass A truthy value to add the class and a falsy value to remove the class\r\n     */\r\n    function toggleClass($domElement, className, addClass) {\r\n        if (addClass) {\r\n            $domElement.addClass(className);\r\n        } else {\r\n            $domElement.removeClass(className);\r\n        }\r\n    }\r\n    \r\n    /** \r\n     * Within a scrolling DOMElement, creates and positions a styled selection\r\n     * div to align a single selected list item from a ul list element.\r\n     *\r\n     * Assumptions:\r\n     * - scrollerElement is a child of the #sidebar div\r\n     * - ul list element fires a "selectionChanged" event after the\r\n     *   selectedClassName is assigned to a new list item\r\n     * \r\n     * @param {!DOMElement} scrollElement A DOMElement containing a ul list element\r\n     * @param {!string} selectedClassName A CSS class name on at most one list item in the contained list\r\n     */\r\n    function sidebarList($scrollerElement, selectedClassName, leafClassName) {\r\n        var $listElement = $scrollerElement.find("ul"),\r\n            $selectionMarker,\r\n            $selectionExtension,\r\n            $sidebar = $("#sidebar"),\r\n            showExtension = true;\r\n        \r\n        // build selectionMarker and position absolute within the scroller\r\n        $selectionMarker = $(window.document.createElement("div")).addClass("sidebar-selection");\r\n        $scrollerElement.prepend($selectionMarker);\r\n        \r\n        // enable scrolling\r\n        $scrollerElement.css("overflow", "auto");\r\n        \r\n        // use relative postioning for clipping the selectionMarker within the scrollElement\r\n        $scrollerElement.css("position", "relative");\r\n        \r\n        // build selectionExtension and position fixed to the window\r\n        $selectionExtension = $(window.document.createElement("div")).addClass("sidebar-selection-extension");\r\n        \r\n        $scrollerElement.append($selectionExtension);\r\n        \r\n        selectedClassName = "." + (selectedClassName || "selected");\r\n        \r\n        var updateSelectionExtension = function () {\r\n            var selectionMarkerHeight = $selectionMarker.height(),\r\n                selectionMarkerOffset = $selectionMarker.offset(),  // offset relative to *document*\r\n                scrollerOffset = $scrollerElement.offset(),\r\n                selectionExtensionHeight = $selectionExtension.outerHeight(),\r\n                scrollerTop = scrollerOffset.top,\r\n                scrollerBottom = scrollerTop + $scrollerElement.outerHeight(),\r\n                scrollerLeft = scrollerOffset.left,\r\n                selectionExtensionTop = selectionMarkerOffset.top;\r\n            \r\n            $selectionExtension.css("top", selectionExtensionTop);\r\n            $selectionExtension.css("left", $sidebar.width() - $selectionExtension.outerWidth());\r\n            toggleClass($selectionExtension, "selectionExtension-visible", showExtension);\r\n                \r\n            var selectionExtensionClipOffsetYBy = Math.floor((selectionMarkerHeight - selectionExtensionHeight) / 2),\r\n                selectionExtensionBottom = selectionExtensionTop + selectionExtensionHeight + selectionExtensionClipOffsetYBy;\r\n            \r\n            if (selectionExtensionTop < scrollerTop || selectionExtensionBottom > scrollerBottom) {\r\n                $selectionExtension.css("clip", "rect(" + Math.max(scrollerTop - selectionExtensionTop - selectionExtensionClipOffsetYBy, 0) + "px, auto, " +\r\n                                           (selectionExtensionHeight - Math.max(selectionExtensionBottom - scrollerBottom, 0)) + "px, auto)");\r\n            } else {\r\n                $selectionExtension.css("clip", "");\r\n            }\r\n        };\r\n        \r\n        var hideSelectionMarker = function (event) {\r\n            $selectionExtension.addClass("forced-hidden");\r\n            $selectionMarker.addClass("forced-hidden");\r\n        };\r\n        \r\n        var updateSelectionMarker = function (event, reveal) {\r\n            // find the selected list item\r\n            var $listItem = $listElement.find(selectedClassName).closest("li");\r\n            \r\n            if (leafClassName) {\r\n                showExtension = $listItem.hasClass(leafClassName);\r\n            }\r\n\r\n            $selectionExtension.removeClass("forced-hidden");\r\n            $selectionMarker.removeClass("forced-hidden");\r\n            \r\n            // always hide selection visuals first to force layout (issue #719)\r\n            $selectionExtension.hide();\r\n            $selectionMarker.hide();\r\n            \r\n            if ($listItem.length === 1) {\r\n                // list item position is relative to scroller\r\n                var selectionMarkerTop = $listItem.offset().top - $scrollerElement.offset().top + $scrollerElement.get(0).scrollTop;\r\n                    \r\n                // force selection width to match scroller\r\n                $selectionMarker.width($scrollerElement.get(0).scrollWidth);\r\n                \r\n                // move the selectionMarker position to align with the list item\r\n                $selectionMarker.css("top", selectionMarkerTop);\r\n                $selectionMarker.show();\r\n                \r\n                updateSelectionExtension();\r\n                $selectionExtension.show();\r\n            \r\n                // fully scroll to the selectionMarker if it\'s not initially in the viewport\r\n                var scrollerElement = $scrollerElement.get(0),\r\n                    scrollerHeight = scrollerElement.clientHeight,\r\n                    selectionMarkerHeight = $selectionMarker.height(),\r\n                    selectionMarkerBottom = selectionMarkerTop + selectionMarkerHeight,\r\n                    currentScrollBottom = scrollerElement.scrollTop + scrollerHeight;\r\n                \r\n                // update scrollTop to reveal the selected list item\r\n                if (reveal) {\r\n                    if (selectionMarkerTop >= currentScrollBottom) {\r\n                        $listItem.get(0).scrollIntoView(false);\r\n                    } else if (selectionMarkerBottom <= scrollerElement.scrollTop) {\r\n                        $listItem.get(0).scrollIntoView(true);\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        \r\n        $listElement.on("selectionChanged", updateSelectionMarker);\r\n        $scrollerElement.on("scroll", updateSelectionExtension);\r\n        $scrollerElement.on("selectionRedraw", updateSelectionExtension);\r\n        $scrollerElement.on("selectionHide", hideSelectionMarker);\r\n        \r\n        // update immediately\r\n        updateSelectionMarker();\r\n        \r\n        // update clipping when the window resizes\r\n        _resizeHandlers.push(updateSelectionExtension);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     */\r\n    function _handleResize() {\r\n        _resizeHandlers.forEach(function (f) {\r\n            f.apply();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Determine how much of an element rect is clipped in view.\r\n     *\r\n     * @param {!DOMElement} $view - A jQuery scrolling container\r\n     * @param {!{top: number, left: number, height: number, width: number}}\r\n     *          elementRect - rectangle of element\'s default position/size\r\n     * @return {{top: number, right: number, bottom: number, left: number}}\r\n     *          amount element rect is clipped in each direction\r\n     */\r\n    function getElementClipSize($view, elementRect) {\r\n        var delta,\r\n            clip = { top: 0, right: 0, bottom: 0, left: 0 },\r\n            viewOffset = $view.offset() || { top: 0, left: 0},\r\n            viewScroller = $view.get(0);\r\n\r\n        // Check if element extends below viewport\r\n        delta = (elementRect.top + elementRect.height) - (viewOffset.top + $view.height());\r\n        if (delta > 0) {\r\n            clip.bottom = delta;\r\n        }\r\n\r\n        // Check if element extends above viewport\r\n        delta = viewOffset.top - elementRect.top;\r\n        if (delta > 0) {\r\n            clip.top = delta;\r\n        }\r\n\r\n        // Check if element extends to the left of viewport\r\n        delta = viewOffset.left - elementRect.left;\r\n        if (delta > 0) {\r\n            clip.left = delta;\r\n        }\r\n\r\n        // Check if element extends to the right of viewport\r\n        delta = (elementRect.left + elementRect.width) - (viewOffset.left + $view.width());\r\n        if (delta > 0) {\r\n            clip.right = delta;\r\n        }\r\n\r\n        return clip;\r\n    }\r\n\r\n    /**\r\n     * Within a scrolling DOMElement, if necessary, scroll element into viewport.\r\n     *\r\n     * To Perform the minimum amount of scrolling necessary, cases should be handled as follows:\r\n     * - element already completely in view : no scrolling\r\n     * - element above    viewport          : scroll view so element is at top\r\n     * - element left of  viewport          : scroll view so element is at left\r\n     * - element below    viewport          : scroll view so element is at bottom\r\n     * - element right of viewport          : scroll view so element is at right\r\n     *\r\n     * Assumptions:\r\n     * - $view is a scrolling container\r\n     *\r\n     * @param {!DOMElement} $view - A jQuery scrolling container\r\n     * @param {!DOMElement} $element - A jQuery element\r\n     * @param {?boolean} scrollHorizontal - whether to also scroll horizontally\r\n     */\r\n    function scrollElementIntoView($view, $element, scrollHorizontal) {\r\n        var viewOffset = $view.offset(),\r\n            viewScroller = $view.get(0),\r\n            element = $element.get(0),\r\n            elementOffset = $element.offset();\r\n\r\n        // scroll minimum amount\r\n        var elementRect = {\r\n                top:    elementOffset.top,\r\n                left:   elementOffset.left,\r\n                height: $element.height(),\r\n                width:  $element.width()\r\n            },\r\n            clip = getElementClipSize($view, elementRect);\r\n        \r\n        if (clip.bottom > 0) {\r\n            // below viewport\r\n            $view.scrollTop($view.scrollTop() + clip.bottom);\r\n        } else if (clip.top > 0) {\r\n            // above viewport\r\n            $view.scrollTop($view.scrollTop() - clip.top);\r\n        }\r\n\r\n        if (scrollHorizontal) {\r\n            if (clip.left > 0) {\r\n                $view.scrollLeft($view.scrollLeft() - clip.left);\r\n            } else if (clip.right > 0) {\r\n                $view.scrollLeft($view.scrollLeft() + clip.right);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * HTML formats a file entry name  for display in the sidebar.\r\n     * @param {!File} entry File entry to display\r\n     * @return {string} HTML formatted string\r\n     */\r\n    function getFileEntryDisplay(entry) {\r\n        var name = entry.name,\r\n            ext = FileUtils.getSmartFileExtension(name),\r\n            i = name.lastIndexOf("." + ext);\r\n        \r\n        if (i > 0) {\r\n            // Escape all HTML-sensitive characters in filename.\r\n            name = _.escape(name.substring(0, i)) + "<span class=\'extension\'>" + _.escape(name.substring(i)) + "</span>";\r\n        } else {\r\n            name = _.escape(name);\r\n        }\r\n        \r\n        return name;\r\n    }\r\n    \r\n    /**\r\n     * Determine the minimum directory path to distinguish duplicate file names\r\n     * for each file in list.\r\n     *\r\n     * @param {Array.<File>} files - list of Files with the same filename\r\n     * @return {Array.<string>} directory paths to match list of files\r\n     */\r\n    function getDirNamesForDuplicateFiles(files) {\r\n        // Must have at least two files in list for this to make sense\r\n        if (files.length <= 1) {\r\n            return [];\r\n        }\r\n\r\n        // First collect paths from the list of files and fill map with them\r\n        var map = {}, filePaths = [], displayPaths = [];\r\n        files.forEach(function (file, index) {\r\n            var fp = file.fullPath.split("/");\r\n            fp.pop(); // Remove the filename itself\r\n            displayPaths[index] = fp.pop();\r\n            filePaths[index] = fp;\r\n\r\n            if (!map[displayPaths[index]]) {\r\n                map[displayPaths[index]] = [index];\r\n            } else {\r\n                map[displayPaths[index]].push(index);\r\n            }\r\n        });\r\n\r\n        // This function is used to loop through map and resolve duplicate names\r\n        var processMap = function (map) {\r\n            var didSomething = false;\r\n            _.forEach(map, function (arr, key) {\r\n                // length > 1 means we have duplicates that need to be resolved\r\n                if (arr.length > 1) {\r\n                    arr.forEach(function (index) {\r\n                        if (filePaths[index].length !== 0) {\r\n                            displayPaths[index] = filePaths[index].pop() + "/" + displayPaths[index];\r\n                            didSomething = true;\r\n\r\n                            if (!map[displayPaths[index]]) {\r\n                                map[displayPaths[index]] = [index];\r\n                            } else {\r\n                                map[displayPaths[index]].push(index);\r\n                            }\r\n                        }\r\n                    });\r\n                }\r\n                delete map[key];\r\n            });\r\n            return didSomething;\r\n        };\r\n\r\n        var repeat;\r\n        do {\r\n            repeat = processMap(map);\r\n        } while (repeat);\r\n\r\n        return displayPaths;\r\n    }\r\n\r\n    function traverseViewArray(viewArray, startIndex, direction) {\r\n        if (Math.abs(direction) !== 1) {\r\n            console.error("traverseViewArray called with unsupported direction: " + direction.toString());\r\n            return null;\r\n        }\r\n        if (startIndex === -1) {\r\n            // If doc not in view list, return most recent view list item\r\n            if (viewArray.length > 0) {\r\n                return viewArray[0];\r\n            }\r\n        } else if (viewArray.length > 1) {\r\n            // If doc is in view list, return next/prev item with wrap-around\r\n            startIndex += direction;\r\n            if (startIndex >= viewArray.length) {\r\n                startIndex = 0;\r\n            } else if (startIndex < 0) {\r\n                startIndex = viewArray.length - 1;\r\n            }\r\n\r\n            return viewArray[startIndex];\r\n        }\r\n        \r\n        // If no doc open or view list empty, there is no "next" file\r\n        return null;\r\n    }\r\n    \r\n    // handle all resize handlers in a single listener\r\n    $(window).resize(_handleResize);\r\n\r\n    // Define public API\r\n    exports.SCROLL_SHADOW_HEIGHT         = SCROLL_SHADOW_HEIGHT;\r\n    exports.addScrollerShadow            = addScrollerShadow;\r\n    exports.removeScrollerShadow         = removeScrollerShadow;\r\n    exports.sidebarList                  = sidebarList;\r\n    exports.scrollElementIntoView        = scrollElementIntoView;\r\n    exports.getElementClipSize           = getElementClipSize;\r\n    exports.getFileEntryDisplay          = getFileEntryDisplay;\r\n    exports.toggleClass                  = toggleClass;\r\n    exports.getDirNamesForDuplicateFiles = getDirNamesForDuplicateFiles;\r\n    exports.traverseViewArray            = traverseViewArray;\r\n});\n//# sourceURL=/utils/ViewUtils.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets, window, MouseEvent */\r\n\r\ndefine(\'command/Menus\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'utils/Global\',\'command/Commands\',\'command/KeyBindingManager\',\'utils/StringUtils\',\'command/CommandManager\',\'widgets/PopUpManager\',\'utils/ViewUtils\',\'utils/DeprecationWarning\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var _ = require("thirdparty/lodash");\r\n\r\n    // Load dependent modules\r\n    var Global              = require("utils/Global"),\r\n        Commands            = require("command/Commands"),\r\n        KeyBindingManager   = require("command/KeyBindingManager"),\r\n        StringUtils         = require("utils/StringUtils"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        PopUpManager        = require("widgets/PopUpManager"),\r\n        ViewUtils           = require("utils/ViewUtils"),\r\n        DeprecationWarning  = require("utils/DeprecationWarning");\r\n\r\n    /**\r\n     * Brackets Application Menu Constants\r\n     * @enum {string}\r\n     */\r\n    var AppMenuBar = {\r\n        FILE_MENU       : "file-menu",\r\n        EDIT_MENU       : "edit-menu",\r\n        FIND_MENU       : "find-menu",\r\n        VIEW_MENU       : "view-menu",\r\n        NAVIGATE_MENU   : "navigate-menu",\r\n        HELP_MENU       : "help-menu"\r\n    };\r\n\r\n    /**\r\n     * Brackets Context Menu Constants\r\n     * @enum {string}\r\n     */\r\n    var ContextMenuIds = {\r\n        EDITOR_MENU:                    "editor-context-menu",\r\n        INLINE_EDITOR_MENU:             "inline-editor-context-menu",\r\n        PROJECT_MENU:                   "project-context-menu",\r\n        WORKING_SET_CONTEXT_MENU:       "workingset-context-menu",\r\n        WORKING_SET_CONFIG_MENU:        "workingset-configuration-menu"\r\n    };\r\n\r\n    /**\r\n     * Brackets Application Menu Section Constants\r\n     * It is preferred that plug-ins specify the location of new MenuItems\r\n     * in terms of a menu section rather than a specific MenuItem. This provides\r\n     * looser coupling to Bracket\'s internal MenuItems and makes menu organization\r\n     * more semantic.\r\n     * Use these constants as the "relativeID" parameter when calling addMenuItem() and\r\n     * specify a position of FIRST_IN_SECTION or LAST_IN_SECTION.\r\n     *\r\n     * Menu sections are denoted by dividers or the beginning/end of a menu\r\n     */\r\n    var MenuSection = {\r\n        // Menu Section                     Command ID to mark the section\r\n        FILE_OPEN_CLOSE_COMMANDS:           {sectionMarker: Commands.FILE_NEW},\r\n        FILE_SAVE_COMMANDS:                 {sectionMarker: Commands.FILE_SAVE},\r\n        FILE_LIVE:                          {sectionMarker: Commands.FILE_LIVE_FILE_PREVIEW},\r\n        FILE_EXTENSION_MANAGER:             {sectionMarker: Commands.FILE_EXTENSION_MANAGER},\r\n\r\n        EDIT_UNDO_REDO_COMMANDS:            {sectionMarker: Commands.EDIT_UNDO},\r\n        EDIT_TEXT_COMMANDS:                 {sectionMarker: Commands.EDIT_CUT},\r\n        EDIT_SELECTION_COMMANDS:            {sectionMarker: Commands.EDIT_SELECT_ALL},\r\n        EDIT_MODIFY_SELECTION:              {sectionMarker: Commands.EDIT_INDENT},\r\n        EDIT_COMMENT_SELECTION:             {sectionMarker: Commands.EDIT_LINE_COMMENT},\r\n        EDIT_CODE_HINTS_COMMANDS:           {sectionMarker: Commands.SHOW_CODE_HINTS},\r\n        EDIT_TOGGLE_OPTIONS:                {sectionMarker: Commands.TOGGLE_CLOSE_BRACKETS},\r\n        \r\n        // DEPRECATED: Old Edit menu sections redirected to existing Edit menu section\r\n        EDIT_FIND_COMMANDS:                 {sectionMarker: Commands.TOGGLE_CLOSE_BRACKETS},\r\n        EDIT_REPLACE_COMMANDS:              {sectionMarker: Commands.TOGGLE_CLOSE_BRACKETS},\r\n        \r\n        FIND_FIND_COMMANDS:                 {sectionMarker: Commands.CMD_FIND},\r\n        FIND_FIND_IN_COMMANDS:              {sectionMarker: Commands.CMD_FIND_IN_FILES},\r\n        FIND_REPLACE_COMMANDS:              {sectionMarker: Commands.CMD_REPLACE},\r\n        \r\n        VIEW_HIDESHOW_COMMANDS:             {sectionMarker: Commands.VIEW_HIDE_SIDEBAR},\r\n        VIEW_FONTSIZE_COMMANDS:             {sectionMarker: Commands.VIEW_INCREASE_FONT_SIZE},\r\n        VIEW_TOGGLE_OPTIONS:                {sectionMarker: Commands.TOGGLE_ACTIVE_LINE},\r\n\r\n        NAVIGATE_GOTO_COMMANDS:             {sectionMarker: Commands.NAVIGATE_QUICK_OPEN},\r\n        NAVIGATE_DOCUMENTS_COMMANDS:        {sectionMarker: Commands.NAVIGATE_NEXT_DOC},\r\n        NAVIGATE_OS_COMMANDS:               {sectionMarker: Commands.NAVIGATE_SHOW_IN_FILE_TREE},\r\n        NAVIGATE_QUICK_EDIT_COMMANDS:       {sectionMarker: Commands.TOGGLE_QUICK_EDIT},\r\n        NAVIGATE_QUICK_DOCS_COMMANDS:       {sectionMarker: Commands.TOGGLE_QUICK_DOCS}\r\n    };\r\n\r\n\r\n    /**\r\n     * Insertion position constants\r\n     * Used by addMenu(), addMenuItem(), and addSubMenu() to\r\n     * specify the relative position of a newly created menu object\r\n     * @enum {string}\r\n     */\r\n    var BEFORE           = "before",\r\n        AFTER            = "after",\r\n        FIRST            = "first",\r\n        LAST             = "last",\r\n        FIRST_IN_SECTION = "firstInSection",\r\n        LAST_IN_SECTION  = "lastInSection";\r\n\r\n    /**\r\n     * Other constants\r\n     */\r\n    var DIVIDER = "---";\r\n\r\n    /**\r\n     * Error Codes from Brackets Shell\r\n     * @enum {number}\r\n     */\r\n    var NO_ERROR           = 0,\r\n        ERR_UNKNOWN        = 1,\r\n        ERR_INVALID_PARAMS = 2,\r\n        ERR_NOT_FOUND      = 3;\r\n\r\n    /**\r\n     * Maps menuID\'s to Menu objects\r\n     * @type {Object.<string, Menu>}\r\n     */\r\n    var menuMap = {};\r\n\r\n    /**\r\n     * Maps contextMenuID\'s to ContextMenu objects\r\n     * @type {Object.<string, ContextMenu>}\r\n     */\r\n    var contextMenuMap = {};\r\n\r\n    /**\r\n     * Maps menuItemID\'s to MenuItem objects\r\n     * @type {Object.<string, MenuItem>}\r\n     */\r\n    var menuItemMap = {};\r\n\r\n    /**\r\n     * Retrieves the Menu object for the corresponding id.\r\n     * @param {string} id\r\n     * @return {Menu}\r\n     */\r\n    function getMenu(id) {\r\n        return menuMap[id];\r\n    }\r\n\r\n    /**\r\n     * Retrieves the map of all Menu objects.\r\n     * @return {Object.<string, Menu>}\r\n     */\r\n    function getAllMenus() {\r\n        return menuMap;\r\n    }\r\n\r\n    /**\r\n     * Retrieves the ContextMenu object for the corresponding id.\r\n     * @param {string} id\r\n     * @return {ContextMenu}\r\n     */\r\n    function getContextMenu(id) {\r\n        return contextMenuMap[id];\r\n    }\r\n\r\n    /**\r\n     * Check whether a ContextMenu exists for the given id.\r\n     * @param {string} id\r\n     * @return {boolean}\r\n     */\r\n    function _isContextMenu(id) {\r\n        return !!getContextMenu(id);\r\n    }\r\n\r\n    function _isHTMLMenu(id) {\r\n        return (!brackets.nativeMenus || _isContextMenu(id));\r\n    }\r\n\r\n    /**\r\n     * Retrieves the MenuItem object for the corresponding id.\r\n     * @param {string} id\r\n     * @return {MenuItem}\r\n     */\r\n    function getMenuItem(id) {\r\n        return menuItemMap[id];\r\n    }\r\n\r\n    function _getHTMLMenu(id) {\r\n        return $("#" + StringUtils.jQueryIdEscape(id)).get(0);\r\n    }\r\n\r\n    function _getHTMLMenuItem(id) {\r\n        return $("#" + StringUtils.jQueryIdEscape(id)).get(0);\r\n    }\r\n\r\n    function _addKeyBindingToMenuItem($menuItem, key, displayKey) {\r\n        var $shortcut = $menuItem.find(".menu-shortcut");\r\n\r\n        if ($shortcut.length === 0) {\r\n            $shortcut = $("<span class=\'menu-shortcut\' />");\r\n            $menuItem.append($shortcut);\r\n        }\r\n\r\n        $shortcut.data("key", key);\r\n        $shortcut.text(KeyBindingManager.formatKeyDescriptor(displayKey));\r\n    }\r\n\r\n    function _addExistingKeyBinding(menuItem) {\r\n        var bindings = KeyBindingManager.getKeyBindings(menuItem.getCommand().getID()),\r\n            binding = null;\r\n\r\n        if (bindings.length > 0) {\r\n            // add the latest key binding\r\n            binding = bindings[bindings.length - 1];\r\n            _addKeyBindingToMenuItem($(_getHTMLMenuItem(menuItem.id)), binding.key, binding.displayKey);\r\n        }\r\n\r\n        return binding;\r\n    }\r\n\r\n    var _menuDividerIDCount = 1;\r\n    function _getNextMenuItemDividerID() {\r\n        return "brackets-menuDivider-" + _menuDividerIDCount++;\r\n    }\r\n\r\n    // Help function for inserting elements into a list\r\n    function _insertInList($list, $element, position, $relativeElement) {\r\n        // Determine where to insert. Default is LAST.\r\n        var inserted = false;\r\n        if (position) {\r\n\r\n            // Adjust relative position for menu section positions since $relativeElement\r\n            // has already been resolved by _getRelativeMenuItem() to a menuItem\r\n            if (position === FIRST_IN_SECTION) {\r\n                position = BEFORE;\r\n            } else if (position === LAST_IN_SECTION) {\r\n                position = AFTER;\r\n            }\r\n\r\n            if (position === FIRST) {\r\n                $list.prepend($element);\r\n                inserted = true;\r\n            } else if ($relativeElement && $relativeElement.length > 0) {\r\n                if (position === AFTER) {\r\n                    $relativeElement.after($element);\r\n                    inserted = true;\r\n                } else if (position === BEFORE) {\r\n                    $relativeElement.before($element);\r\n                    inserted = true;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Default to LAST\r\n        if (!inserted) {\r\n            $list.append($element);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * MenuItem represents a single menu item that executes a Command or a menu divider. MenuItems\r\n     * may have a sub-menu. A MenuItem may correspond to an HTML-based\r\n     * menu item or a native menu item if Brackets is running in a native application shell\r\n     *\r\n     * Since MenuItems may have a native implementation clients should create MenuItems through\r\n     * addMenuItem() and should NOT construct a MenuItem object directly.\r\n     * Clients should also not access HTML content of a menu directly and instead use\r\n     * the MenuItem API to query and modify menus items.\r\n     *\r\n     * MenuItems are views on to Command objects so modify the underlying Command to modify the\r\n     * name, enabled, and checked state of a MenuItem. The MenuItem will update automatically\r\n     *\r\n     * @constructor\r\n     * @private\r\n     *\r\n     * @param {string} id\r\n     * @param {string|Command} command - the Command this MenuItem will reflect.\r\n     *                                   Use DIVIDER to specify a menu divider\r\n     */\r\n    function MenuItem(id, command) {\r\n        this.id = id;\r\n        this.isDivider = (command === DIVIDER);\r\n        this.isNative = false;\r\n\r\n        if (!this.isDivider) {\r\n            // Bind event handlers\r\n            this._enabledChanged = this._enabledChanged.bind(this);\r\n            this._checkedChanged = this._checkedChanged.bind(this);\r\n            this._nameChanged = this._nameChanged.bind(this);\r\n            this._keyBindingAdded = this._keyBindingAdded.bind(this);\r\n            this._keyBindingRemoved = this._keyBindingRemoved.bind(this);\r\n\r\n            this._command = command;\r\n            $(this._command)\r\n                .on("enabledStateChange", this._enabledChanged)\r\n                .on("checkedStateChange", this._checkedChanged)\r\n                .on("nameChange", this._nameChanged)\r\n                .on("keyBindingAdded", this._keyBindingAdded)\r\n                .on("keyBindingRemoved", this._keyBindingRemoved);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Menu represents a top-level menu in the menu bar. A Menu may correspond to an HTML-based\r\n     * menu or a native menu if Brackets is running in a native application shell.\r\n     *\r\n     * Since menus may have a native implementation clients should create Menus through\r\n     * addMenu() and should NOT construct a Menu object directly.\r\n     * Clients should also not access HTML content of a menu directly and instead use\r\n     * the Menu API to query and modify menus.\r\n     *\r\n     * @constructor\r\n     * @private\r\n     *\r\n     * @param {string} id\r\n     */\r\n    function Menu(id) {\r\n        this.id = id;\r\n    }\r\n\r\n    Menu.prototype._getMenuItemId = function (commandId) {\r\n        return (this.id + "-" + commandId);\r\n    };\r\n\r\n    /**\r\n     * Determine MenuItem in this Menu, that has the specified command\r\n     *\r\n     * @param {Command} command - the command to search for.\r\n     * @return {?HTMLLIElement} menu item list element\r\n     */\r\n    Menu.prototype._getMenuItemForCommand = function (command) {\r\n        if (!command) {\r\n            return null;\r\n        }\r\n        var foundMenuItem = menuItemMap[this._getMenuItemId(command.getID())];\r\n        if (!foundMenuItem) {\r\n            return null;\r\n        }\r\n        return $(_getHTMLMenuItem(foundMenuItem.id)).closest("li");\r\n    };\r\n\r\n    /**\r\n     * Determine relative MenuItem\r\n     *\r\n     * @param {?string} relativeID - id of command (future: sub-menu).\r\n     * @param {?string} position - only needed when relativeID is a MenuSection\r\n     * @return {?HTMLLIElement} menu item list element\r\n     */\r\n    Menu.prototype._getRelativeMenuItem = function (relativeID, position) {\r\n        var $relativeElement;\r\n        \r\n        if (relativeID) {\r\n            if (position === FIRST_IN_SECTION || position === LAST_IN_SECTION) {\r\n                if (!relativeID.hasOwnProperty("sectionMarker")) {\r\n                    console.error("Bad Parameter in _getRelativeMenuItem(): relativeID must be a MenuSection when position refers to a menu section");\r\n                    return null;\r\n                }\r\n\r\n                // Determine the $relativeElement by traversing the sibling list and\r\n                // stop at the first divider found\r\n                // TODO: simplify using nextUntil()/prevUntil()\r\n                var $sectionMarker = this._getMenuItemForCommand(CommandManager.get(relativeID.sectionMarker));\r\n                if (!$sectionMarker) {\r\n                    console.error("_getRelativeMenuItem(): MenuSection " + relativeID.sectionMarker +\r\n                                  " not found in Menu " + this.id);\r\n                    return null;\r\n                }\r\n                var $listElem = $sectionMarker;\r\n                $relativeElement = $listElem;\r\n                while (true) {\r\n                    $listElem = (position === FIRST_IN_SECTION ? $listElem.prev() : $listElem.next());\r\n                    if ($listElem.length === 0) {\r\n                        break;\r\n                    } else if ($listElem.find(".divider").length > 0) {\r\n                        break;\r\n                    } else {\r\n                        $relativeElement = $listElem;\r\n                    }\r\n                }\r\n\r\n            } else {\r\n                if (relativeID.hasOwnProperty("sectionMarker")) {\r\n                    console.error("Bad Parameter in _getRelativeMenuItem(): if relativeID is a MenuSection, position must be FIRST_IN_SECTION or LAST_IN_SECTION");\r\n                    return null;\r\n                }\r\n\r\n                // handle FIRST, LAST, BEFORE, & AFTER\r\n                var command = CommandManager.get(relativeID);\r\n                if (command) {\r\n                    // Lookup Command for this Command id\r\n                    // Find MenuItem that has this command\r\n                    $relativeElement = this._getMenuItemForCommand(command);\r\n                }\r\n                if (!$relativeElement) {\r\n                    console.error("_getRelativeMenuItem(): MenuItem with Command id " + relativeID +\r\n                                  " not found in Menu " + this.id);\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            return $relativeElement;\r\n\r\n        } else if (position && position !== FIRST && position !== LAST) {\r\n            console.error("Bad Parameter in _getRelativeMenuItem(): relative position specified with no relativeID");\r\n            return null;\r\n        }\r\n\r\n        return $relativeElement;\r\n    };\r\n\r\n    /**\r\n     * Removes the specified menu item from this Menu. Key bindings are unaffected; use KeyBindingManager\r\n     * directly to remove key bindings if desired.\r\n     *\r\n     * @param {!string | Command} command - command the menu would execute if we weren\'t deleting it.\r\n     */\r\n    Menu.prototype.removeMenuItem = function (command) {\r\n        var menuItemID,\r\n            commandID;\r\n\r\n        if (!command) {\r\n            console.error("removeMenuItem(): missing required parameters: command");\r\n            return;\r\n        }\r\n\r\n        if (typeof (command) === "string") {\r\n            var commandObj = CommandManager.get(command);\r\n            if (!commandObj) {\r\n                console.error("removeMenuItem(): command not found: " + command);\r\n                return;\r\n            }\r\n\r\n            commandID = command;\r\n        } else {\r\n            commandID = command.getID();\r\n        }\r\n        menuItemID = this._getMenuItemId(commandID);\r\n\r\n        if (_isHTMLMenu(this.id)) {\r\n            // Targeting parent to get the menu item <a> and the <li> that contains it\r\n            $(_getHTMLMenuItem(menuItemID)).parent().remove();\r\n        } else {\r\n            brackets.app.removeMenuItem(commandID, function (err) {\r\n                if (err) {\r\n                    console.error("removeMenuItem() -- command not found: " + commandID + " (error: " + err + ")");\r\n                }\r\n            });\r\n        }\r\n\r\n        delete menuItemMap[menuItemID];\r\n    };\r\n\r\n    /**\r\n     * Removes the specified menu divider from this Menu.\r\n     *\r\n     * @param {!string} menuItemID - the menu item id of the divider to remove.\r\n     */\r\n    Menu.prototype.removeMenuDivider = function (menuItemID) {\r\n        var menuItem,\r\n            $HTMLMenuItem;\r\n\r\n        if (!menuItemID) {\r\n            console.error("removeMenuDivider(): missing required parameters: menuItemID");\r\n            return;\r\n        }\r\n\r\n        menuItem = getMenuItem(menuItemID);\r\n\r\n        if (!menuItem) {\r\n            console.error("removeMenuDivider(): parameter menuItemID: %s is not a valid menu item id", menuItemID);\r\n            return;\r\n        }\r\n\r\n        if (!menuItem.isDivider) {\r\n            console.error("removeMenuDivider(): parameter menuItemID: %s is not a menu divider", menuItemID);\r\n            return;\r\n        }\r\n\r\n        if (_isHTMLMenu(this.id)) {\r\n            // Targeting parent to get the menu divider <hr> and the <li> that contains it\r\n            $HTMLMenuItem = $(_getHTMLMenuItem(menuItemID)).parent();\r\n            if ($HTMLMenuItem) {\r\n                $HTMLMenuItem.remove();\r\n            } else {\r\n                console.error("removeMenuDivider(): HTML menu divider not found: %s", menuItemID);\r\n                return;\r\n            }\r\n        } else {\r\n            brackets.app.removeMenuItem(menuItem.dividerId, function (err) {\r\n                if (err) {\r\n                    console.error("removeMenuDivider() -- divider not found: %s (error: %s)", menuItemID, err);\r\n                }\r\n            });\r\n        }\r\n\r\n        if (!menuItemMap[menuItemID]) {\r\n            console.error("removeMenuDivider(): menu divider not found in menuItemMap: %s", menuItemID);\r\n            return;\r\n        }\r\n\r\n        delete menuItemMap[menuItemID];\r\n    };\r\n\r\n    /**\r\n     * Adds a new menu item with the specified id and display text. The insertion position is\r\n     * specified via the relativeID and position arguments which describe a position\r\n     * relative to another MenuItem or MenuGroup. It is preferred that plug-ins\r\n     * insert new  MenuItems relative to a menu section rather than a specific\r\n     * MenuItem (see Menu Section Constants).\r\n     *\r\n     * TODO: Sub-menus are not yet supported, but when they are implemented this API will\r\n     * allow adding new MenuItems to sub-menus as well.\r\n     *\r\n     * Note, keyBindings are bound to Command objects not MenuItems. The provided keyBindings\r\n     *      will be bound to the supplied Command object rather than the MenuItem.\r\n     *\r\n     * @param {!string | Command} command - the command the menu will execute.\r\n     *      Pass Menus.DIVIDER for a menu divider, or just call addMenuDivider() instead.\r\n     * @param {?string | Array.<{key: string, platform: string}>}  keyBindings - register one\r\n     *      one or more key bindings to associate with the supplied command.\r\n     * @param {?string} position - constant defining the position of new MenuItem relative to\r\n     *      other MenuItems. Values:\r\n     *          - With no relativeID, use Menus.FIRST or LAST (default is LAST)\r\n     *          - Relative to a command id, use BEFORE or AFTER (required)\r\n     *          - Relative to a MenuSection, use FIRST_IN_SECTION or LAST_IN_SECTION (required)\r\n     * @param {?string} relativeID - command id OR one of the MenuSection.* constants. Required\r\n     *      for all position constants except FIRST and LAST.\r\n     *\r\n     * @return {MenuItem} the newly created MenuItem\r\n     */\r\n    Menu.prototype.addMenuItem = function (command, keyBindings, position, relativeID) {\r\n        var menuID = this.id,\r\n            id,\r\n            $menuItem,\r\n            $link,\r\n            menuItem,\r\n            name,\r\n            commandID;\r\n        \r\n        if (relativeID === MenuSection.EDIT_FIND_COMMANDS) {\r\n            DeprecationWarning.deprecationWarning("Add " + command + " Command to the Find Menu instead of the Edit Menu.", true);\r\n            DeprecationWarning.deprecationWarning("Use MenuSection.FIND_FIND_COMMANDS instead of MenuSection.EDIT_FIND_COMMANDS.", true);\r\n        } else if (relativeID === MenuSection.EDIT_REPLACE_COMMANDS) {\r\n            DeprecationWarning.deprecationWarning("Add " + command + " Command to the Find Menu instead of the Edit Menu.", true);\r\n            DeprecationWarning.deprecationWarning("Use MenuSection.FIND_REPLACE_COMMANDS instead of MenuSection.EDIT_REPLACE_COMMANDS.", true);\r\n        }\r\n        \r\n        if (!command) {\r\n            console.error("addMenuItem(): missing required parameters: command");\r\n            return null;\r\n        }\r\n\r\n        if (typeof (command) === "string") {\r\n            if (command === DIVIDER) {\r\n                name = DIVIDER;\r\n                commandID = _getNextMenuItemDividerID();\r\n            } else {\r\n                commandID = command;\r\n                command = CommandManager.get(commandID);\r\n                if (!command) {\r\n                    console.error("addMenuItem(): commandID not found: " + commandID);\r\n                    return null;\r\n                }\r\n                name = command.getName();\r\n            }\r\n        } else {\r\n            commandID = command.getID();\r\n            name = command.getName();\r\n        }\r\n\r\n        // Internal id is the a composite of the parent menu id and the command id.\r\n        id = this._getMenuItemId(commandID);\r\n\r\n        if (menuItemMap[id]) {\r\n            console.log("MenuItem added with same id of existing MenuItem: " + id);\r\n            return null;\r\n        }\r\n\r\n        // create MenuItem\r\n        menuItem = new MenuItem(id, command);\r\n        menuItemMap[id] = menuItem;\r\n\r\n        // create MenuItem DOM\r\n        if (_isHTMLMenu(this.id)) {\r\n            if (name === DIVIDER) {\r\n                $menuItem = $("<li><hr class=\'divider\' id=\'" + id + "\' /></li>");\r\n            } else {\r\n                // Create the HTML Menu\r\n                $menuItem = $("<li><a href=\'#\' id=\'" + id + "\'> <span class=\'menu-name\'></span></a></li>");\r\n\r\n                $menuItem.on("click", function () {\r\n                    menuItem._command.execute();\r\n                });\r\n            }\r\n\r\n            // Insert menu item\r\n            var $relativeElement = this._getRelativeMenuItem(relativeID, position);\r\n            _insertInList($("li#" + StringUtils.jQueryIdEscape(this.id) + " > ul.dropdown-menu"),\r\n                          $menuItem, position, $relativeElement);\r\n        } else {\r\n            var bindings = KeyBindingManager.getKeyBindings(commandID),\r\n                binding,\r\n                bindingStr = "",\r\n                displayStr = "";\r\n\r\n            if (bindings && bindings.length > 0) {\r\n                binding = bindings[bindings.length - 1];\r\n                bindingStr = binding.displayKey || binding.key;\r\n            }\r\n\r\n            if (bindingStr.length > 0) {\r\n                displayStr = KeyBindingManager.formatKeyDescriptor(bindingStr);\r\n            }\r\n\r\n            if (position === FIRST_IN_SECTION || position === LAST_IN_SECTION) {\r\n                if (!relativeID.hasOwnProperty("sectionMarker")) {\r\n                    console.error("Bad Parameter in _getRelativeMenuItem(): relativeID must be a MenuSection when position refers to a menu section");\r\n                    return null;\r\n                }\r\n\r\n                // For sections, pass in the marker for that section.\r\n                relativeID = relativeID.sectionMarker;\r\n            }\r\n\r\n            brackets.app.addMenuItem(this.id, name, commandID, bindingStr, displayStr, position, relativeID, function (err) {\r\n                switch (err) {\r\n                case NO_ERROR:\r\n                    break;\r\n                case ERR_INVALID_PARAMS:\r\n                    console.error("addMenuItem(): Invalid Parameters when adding the command " + commandID);\r\n                    break;\r\n                case ERR_NOT_FOUND:\r\n                    console.error("_getRelativeMenuItem(): MenuItem with Command id " + relativeID + " not found in the Menu " + menuID);\r\n                    break;\r\n                default:\r\n                    console.error("addMenuItem(); Unknown Error (" + err + ") when adding the command " + commandID);\r\n                }\r\n            });\r\n            menuItem.isNative = true;\r\n        }\r\n\r\n        // Initialize MenuItem state\r\n        if (menuItem.isDivider) {\r\n            menuItem.dividerId = commandID;\r\n        } else {\r\n            if (keyBindings) {\r\n                // Add key bindings. The MenuItem listens to the Command object to update MenuItem DOM with shortcuts.\r\n                if (!Array.isArray(keyBindings)) {\r\n                    keyBindings = [keyBindings];\r\n                }\r\n            }\r\n\r\n            // Note that keyBindings passed during MenuItem creation take precedent over any existing key bindings\r\n            KeyBindingManager.addBinding(commandID, keyBindings);\r\n\r\n            // Look for existing key bindings\r\n            _addExistingKeyBinding(menuItem, commandID);\r\n\r\n            menuItem._checkedChanged();\r\n            menuItem._enabledChanged();\r\n            menuItem._nameChanged();\r\n        }\r\n\r\n        return menuItem;\r\n    };\r\n\r\n    /**\r\n     * Inserts divider item in menu.\r\n     * @param {?string} position - constant defining the position of new the divider relative\r\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants).\r\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\r\n     *      divider will be positioned relative to. Required for all position constants\r\n     *      except FIRST and LAST\r\n     *\r\n     * @return {MenuItem} the newly created divider\r\n     */\r\n    Menu.prototype.addMenuDivider = function (position, relativeID) {\r\n        return this.addMenuItem(DIVIDER, "", position, relativeID);\r\n    };\r\n\r\n    /**\r\n     * NOT IMPLEMENTED\r\n     * Alternative JSON based API to addMenuItem()\r\n     *\r\n     * All properties are required unless noted as optional.\r\n     *\r\n     * @param { Array.<{\r\n     *              id:         string,\r\n     *              command:    string | Command,\r\n     *              ?bindings:   string | Array.<{key: string, platform: string}>,\r\n     *          }>} jsonStr\r\n     *        }\r\n     * @param {?string} position - constant defining the position of new the MenuItem relative\r\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants).\r\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\r\n     *      menuItem will be positioned relative to. Required when position is\r\n     *      AFTER or BEFORE, ignored when position is FIRST or LAST.\r\n     *\r\n     * @return {MenuItem} the newly created MenuItem\r\n     */\r\n    // Menu.prototype.createMenuItemsFromJSON = function (jsonStr, position, relativeID) {\r\n    //     NOT IMPLEMENTED\r\n    // };\r\n\r\n\r\n    /**\r\n     * NOT IMPLEMENTED\r\n     * @param {!string} text displayed in menu item\r\n     * @param {!string} id\r\n     * @param {?string} position - constant defining the position of new the MenuItem relative\r\n     *      to other MenuItems. Default is LAST.  (see Insertion position constants)\r\n     * @param {?string} relativeID - id of menuItem, sub-menu, or menu section that the new\r\n     *      menuItem will be positioned relative to. Required when position is\r\n     *      AFTER or BEFORE, ignored when position is FIRST or LAST.\r\n     *\r\n     * @return {MenuItem} newly created menuItem for sub-menu\r\n     */\r\n    // MenuItem.prototype.createSubMenu = function (text, id, position, relativeID) {\r\n    //     NOT IMPLEMENTED\r\n    // };\r\n\r\n    /**\r\n     * Gets the Command associated with a MenuItem\r\n     * @return {Command}\r\n     */\r\n    MenuItem.prototype.getCommand = function () {\r\n        return this._command;\r\n    };\r\n\r\n    /**\r\n     * NOT IMPLEMENTED\r\n     * Returns the parent MenuItem if the menu item is a sub-menu, returns null otherwise.\r\n     * @return {MenuItem}\r\n     */\r\n    // MenuItem.prototype.getParentMenuItem = function () {\r\n    //     NOT IMPLEMENTED;\r\n    // };\r\n\r\n    /**\r\n     * Returns the parent Menu for this MenuItem\r\n     * @return {Menu}\r\n     */\r\n    MenuItem.prototype.getParentMenu = function () {\r\n        var parent = $(_getHTMLMenuItem(this.id)).parents(".dropdown").get(0);\r\n        if (!parent) {\r\n            return null;\r\n        }\r\n\r\n        return getMenu(parent.id);\r\n    };\r\n\r\n    /**\r\n     * Synchronizes MenuItem checked state with underlying Command checked state\r\n     */\r\n    MenuItem.prototype._checkedChanged = function () {\r\n        var checked = !!this._command.getChecked();\r\n        if (this.isNative) {\r\n            var enabled = !!this._command.getEnabled();\r\n            brackets.app.setMenuItemState(this._command.getID(), enabled, checked, function (err) {\r\n                if (err) {\r\n                    console.log("Error setting menu item state: " + err);\r\n                }\r\n            });\r\n        } else {\r\n            ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), "checked", checked);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Synchronizes MenuItem enabled state with underlying Command enabled state\r\n     */\r\n    MenuItem.prototype._enabledChanged = function () {\r\n        if (this.isNative) {\r\n            var enabled = !!this._command.getEnabled();\r\n            var checked = !!this._command.getChecked();\r\n            brackets.app.setMenuItemState(this._command.getID(), enabled, checked, function (err) {\r\n                if (err) {\r\n                    console.log("Error setting menu item state: " + err);\r\n                }\r\n            });\r\n        } else {\r\n            ViewUtils.toggleClass($(_getHTMLMenuItem(this.id)), "disabled", !this._command.getEnabled());\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Synchronizes MenuItem name with underlying Command name\r\n     */\r\n    MenuItem.prototype._nameChanged = function () {\r\n        if (this.isNative) {\r\n            brackets.app.setMenuTitle(this._command.getID(), this._command.getName(), function (err) {\r\n                if (err) {\r\n                    console.log("Error setting menu title: " + err);\r\n                }\r\n            });\r\n        } else {\r\n            $(_getHTMLMenuItem(this.id)).find(".menu-name").text(this._command.getName());\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Updates MenuItem DOM with a keyboard shortcut label\r\n     */\r\n    MenuItem.prototype._keyBindingAdded = function (event, keyBinding) {\r\n        if (this.isNative) {\r\n            var shortcutKey = keyBinding.displayKey || keyBinding.key;\r\n            brackets.app.setMenuItemShortcut(this._command.getID(), shortcutKey, KeyBindingManager.formatKeyDescriptor(shortcutKey), function (err) {\r\n                if (err) {\r\n                    console.error("Error setting menu item shortcut: " + err);\r\n                }\r\n            });\r\n        } else {\r\n            _addKeyBindingToMenuItem($(_getHTMLMenuItem(this.id)), keyBinding.key, keyBinding.displayKey);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Updates MenuItem DOM to remove keyboard shortcut label\r\n     */\r\n    MenuItem.prototype._keyBindingRemoved = function (event, keyBinding) {\r\n        if (this.isNative) {\r\n            brackets.app.setMenuItemShortcut(this._command.getID(), "", "", function (err) {\r\n                if (err) {\r\n                    console.error("Error setting menu item shortcut: " + err);\r\n                }\r\n            });\r\n        } else {\r\n            var $shortcut = $(_getHTMLMenuItem(this.id)).find(".menu-shortcut");\r\n\r\n            if ($shortcut.length > 0 && $shortcut.data("key") === keyBinding.key) {\r\n                // check for any other bindings\r\n                if (_addExistingKeyBinding(this) === null) {\r\n                    $shortcut.empty();\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Closes all menus that are open\r\n     */\r\n    function closeAll() {\r\n        $(".dropdown").removeClass("open");\r\n    }\r\n\r\n    /**\r\n     * Adds a top-level menu to the application menu bar which may be native or HTML-based.\r\n     *\r\n     * @param {!string} name - display text for menu\r\n     * @param {!string} id - unique identifier for a menu.\r\n     *      Core Menus in Brackets use a simple  title as an id, for example "file-menu".\r\n     *      Extensions should use the following format: "author.myextension.mymenuname".\r\n     * @param {?string} position - constant defining the position of new the Menu relative\r\n     *  to other Menus. Default is LAST (see Insertion position constants).\r\n     *\r\n     * @param {?string} relativeID - id of Menu the new Menu will be positioned relative to. Required\r\n     *      when position is AFTER or BEFORE, ignored when position is FIRST or LAST\r\n     *\r\n     * @return {?Menu} the newly created Menu\r\n     */\r\n    function addMenu(name, id, position, relativeID) {\r\n        name = _.escape(name);\r\n        var $menubar = $("#titlebar .nav"),\r\n            menu;\r\n\r\n        if (!name || !id) {\r\n            console.error("call to addMenu() is missing required parameters");\r\n            return null;\r\n        }\r\n\r\n        // Guard against duplicate menu ids\r\n        if (menuMap[id]) {\r\n            console.log("Menu added with same name and id of existing Menu: " + id);\r\n            return null;\r\n        }\r\n\r\n        menu = new Menu(id);\r\n        menuMap[id] = menu;\r\n\r\n        if (!_isHTMLMenu(id)) {\r\n            brackets.app.addMenu(name, id, position, relativeID, function (err) {\r\n                switch (err) {\r\n                case NO_ERROR:\r\n                    // Make sure name is up to date\r\n                    brackets.app.setMenuTitle(id, name, function (err) {\r\n                        if (err) {\r\n                            console.error("setMenuTitle() -- error: " + err);\r\n                        }\r\n                    });\r\n                    break;\r\n                case ERR_UNKNOWN:\r\n                    console.error("addMenu(): Unknown Error when adding the menu " + id);\r\n                    break;\r\n                case ERR_INVALID_PARAMS:\r\n                    console.error("addMenu(): Invalid Parameters when adding the menu " + id);\r\n                    break;\r\n                case ERR_NOT_FOUND:\r\n                    console.error("addMenu(): Menu with command " + relativeID + " could not be found when adding the menu " + id);\r\n                    break;\r\n                default:\r\n                    console.error("addMenu(): Unknown Error (" + err + ") when adding the menu " + id);\r\n                }\r\n            });\r\n            return menu;\r\n        }\r\n\r\n        var $toggle = $("<a href=\'#\' class=\'dropdown-toggle\' data-toggle=\'dropdown\'>" + name + "</a>"),\r\n            $popUp = $("<ul class=\'dropdown-menu\'></ul>"),\r\n            $newMenu = $("<li class=\'dropdown\' id=\'" + id + "\'></li>").append($toggle).append($popUp);\r\n\r\n        // Insert menu\r\n        var $relativeElement = relativeID && $(_getHTMLMenu(relativeID));\r\n        _insertInList($menubar, $newMenu, position, $relativeElement);\r\n\r\n        // Install ESC key handling\r\n        PopUpManager.addPopUp($popUp, closeAll, false);\r\n\r\n        // todo error handling\r\n\r\n        return menu;\r\n    }\r\n\r\n    /**\r\n     * Removes a top-level menu from the application menu bar which may be native or HTML-based.\r\n     *\r\n     * @param {!string} id - unique identifier for a menu.\r\n     *      Core Menus in Brackets use a simple title as an id, for example "file-menu".\r\n     *      Extensions should use the following format: "author.myextension.mymenuname".\r\n     */\r\n    function removeMenu(id) {\r\n        var menu,\r\n            commandID = "";\r\n\r\n        if (!id) {\r\n            console.error("removeMenu(): missing required parameter: id");\r\n            return;\r\n        }\r\n\r\n        if (!menuMap[id]) {\r\n            console.error("removeMenu(): menu id not found: %s", id);\r\n            return;\r\n        }\r\n\r\n        // Remove all of the menu items in the menu\r\n        menu = getMenu(id);\r\n        \r\n        _.forEach(menuItemMap, function (value, key) {\r\n            if (key.substring(0, id.length) === id) {\r\n                if (value.isDivider) {\r\n                    menu.removeMenuDivider(key);\r\n                } else {\r\n                    commandID = value.getCommand();\r\n                    menu.removeMenuItem(commandID);\r\n                }\r\n            }\r\n        });\r\n\r\n        if (_isHTMLMenu(id)) {\r\n            $(_getHTMLMenu(id)).remove();\r\n        } else {\r\n            brackets.app.removeMenu(id, function (err) {\r\n                if (err) {\r\n                    console.error("removeMenu() -- id not found: " + id + " (error: " + err + ")");\r\n                }\r\n            });\r\n        }\r\n\r\n        delete menuMap[id];\r\n    }\r\n\r\n    /**\r\n     * Represents a context menu that can open at a specific location in the UI.\r\n     *\r\n     * Clients should not create this object directly and should instead use registerContextMenu()\r\n     * to create new ContextMenu objects.\r\n     *\r\n     * Context menus in brackets may be HTML-based or native so clients should not reach into\r\n     * the HTML and should instead manipulate ContextMenus through the API.\r\n     *\r\n     * Events:\r\n     * - beforeContextMenuOpen\r\n     *\r\n     * @constructor\r\n     * @extends {Menu}\r\n     */\r\n    function ContextMenu(id) {\r\n        Menu.apply(this, arguments);\r\n\r\n        var $newMenu = $("<li class=\'dropdown context-menu\' id=\'" + StringUtils.jQueryIdEscape(id) + "\'></li>"),\r\n            $popUp = $("<ul class=\'dropdown-menu\'></ul>"),\r\n            $toggle = $("<a href=\'#\' class=\'dropdown-toggle\' data-toggle=\'dropdown\'></a>").hide();\r\n\r\n        // assemble the menu fragments\r\n        $newMenu.append($toggle).append($popUp);\r\n\r\n        // insert into DOM\r\n        $("#context-menu-bar > ul").append($newMenu);\r\n\r\n        var self = this;\r\n        PopUpManager.addPopUp($popUp,\r\n            function () {\r\n                self.close();\r\n            },\r\n            false);\r\n\r\n        // Listen to ContextMenu\'s beforeContextMenuOpen event to first close other popups\r\n        PopUpManager.listenToContextMenu(this);\r\n    }\r\n    ContextMenu.prototype = Object.create(Menu.prototype);\r\n    ContextMenu.prototype.constructor = ContextMenu;\r\n    ContextMenu.prototype.parentClass = Menu.prototype;\r\n\r\n\r\n    /**\r\n     * Displays the ContextMenu at the specified location and dispatches the\r\n     * "beforeContextMenuOpen" event.The menu location may be adjusted to prevent\r\n     * clipping by the browser window. All other menus and ContextMenus will be closed\r\n     * bofore a new menu is shown.\r\n     *\r\n     * @param {MouseEvent | {pageX:number, pageY:number}} mouseOrLocation - pass a MouseEvent\r\n     *      to display the menu near the mouse or pass in an object with page x/y coordinates\r\n     *      for a specific location.\r\n     */\r\n    ContextMenu.prototype.open = function (mouseOrLocation) {\r\n\r\n        if (!mouseOrLocation || !mouseOrLocation.hasOwnProperty("pageX") || !mouseOrLocation.hasOwnProperty("pageY")) {\r\n            console.error("ContextMenu open(): missing required parameter");\r\n            return;\r\n        }\r\n\r\n        var $window = $(window),\r\n            escapedId = StringUtils.jQueryIdEscape(this.id),\r\n            $menuAnchor = $("#" + escapedId),\r\n            $menuWindow = $("#" + escapedId + " > ul"),\r\n            posTop  = mouseOrLocation.pageY,\r\n            posLeft = mouseOrLocation.pageX;\r\n\r\n        // only show context menu if it has menu items\r\n        if ($menuWindow.children().length <= 0) {\r\n            return;\r\n        }\r\n\r\n        $(this).triggerHandler("beforeContextMenuOpen");\r\n\r\n        // close all other dropdowns\r\n        closeAll();\r\n\r\n        // adjust positioning so menu is not clipped off bottom or right\r\n        var elementRect = {\r\n                top:    posTop,\r\n                left:   posLeft,\r\n                height: $menuWindow.height() + 25,\r\n                width:  $menuWindow.width()\r\n            },\r\n            clip = ViewUtils.getElementClipSize($window, elementRect);\r\n        \r\n        if (clip.bottom > 0) {\r\n            posTop = Math.max(0, posTop - clip.bottom);\r\n        }\r\n        posTop -= 30;   // shift top for hidden parent element\r\n        posLeft += 5;\r\n\r\n        \r\n        if (clip.right > 0) {\r\n            posLeft = Math.max(0, posLeft - clip.right);\r\n        }\r\n        \r\n        // open the context menu at final location\r\n        $menuAnchor.addClass("open")\r\n                   .css({"left": posLeft, "top": posTop});\r\n    };\r\n\r\n\r\n    /**\r\n     * Closes the context menu.\r\n     */\r\n    ContextMenu.prototype.close = function () {\r\n        $("#" + StringUtils.jQueryIdEscape(this.id)).removeClass("open");\r\n    };\r\n\r\n    /**\r\n     * Detect if current context menu is already open\r\n     */\r\n    ContextMenu.prototype.isOpen = function () {\r\n        return $("#" + StringUtils.jQueryIdEscape(this.id)).hasClass("open");\r\n    };\r\n\r\n\r\n    /**\r\n     * Associate a context menu to a DOM element.\r\n     * This static function take care of registering event handlers for the click event\r\n     * listener and passing the right "position" object to the Context#open method\r\n     */\r\n    ContextMenu.assignContextMenuToSelector = function (selector, cmenu) {\r\n        $(selector).on("click", function (e) {\r\n            var buttonOffset,\r\n                buttonHeight;\r\n\r\n            e.stopPropagation();\r\n\r\n            if (cmenu.isOpen()) {\r\n                cmenu.close();\r\n            } else {\r\n                buttonOffset = $(this).offset();\r\n                buttonHeight = $(this).outerHeight();\r\n                cmenu.open({\r\n                    pageX: buttonOffset.left,\r\n                    pageY: buttonOffset.top + buttonHeight\r\n                });\r\n            }\r\n        });\r\n    };\r\n\r\n\r\n    /**\r\n     * Registers new context menu with Brackets.\r\n\r\n     * Extensions should generally use the predefined context menus built into Brackets. Use this\r\n     * API to add a new context menu to UI that is specific to an extension.\r\n     *\r\n     * After registering  a new context menu clients should:\r\n     *      - use addMenuItem() to add items to the context menu\r\n     *      - call open() to show the context menu.\r\n     *      For example:\r\n     *      $("#my_ID").contextmenu(function (e) {\r\n     *          if (e.which === 3) {\r\n     *              my_cmenu.open(e);\r\n     *          }\r\n     *      });\r\n     *\r\n     * To make menu items be contextual to things like selection, listen for the "beforeContextMenuOpen"\r\n     * to make changes to Command objects before the context menu is shown. MenuItems are views of\r\n     * Commands, which control a MenuItem\'s name, enabled state, and checked state.\r\n     *\r\n     * @param {string} id - unique identifier for context menu.\r\n     *      Core context menus in Brackets use a simple title as an id.\r\n     *      Extensions should use the following format: "author.myextension.mycontextmenu name"\r\n     * @return {?ContextMenu} the newly created context menu\r\n     */\r\n    function registerContextMenu(id) {\r\n        if (!id) {\r\n            console.error("call to registerContextMenu() is missing required parameters");\r\n            return null;\r\n        }\r\n\r\n        // Guard against duplicate menu ids\r\n        if (contextMenuMap[id]) {\r\n            console.log("Context Menu added with same name and id of existing Context Menu: " + id);\r\n            return null;\r\n        }\r\n\r\n        var cmenu = new ContextMenu(id);\r\n        contextMenuMap[id] = cmenu;\r\n        return cmenu;\r\n    }\r\n\r\n    // Deprecated menu ids\r\n    DeprecationWarning.deprecateConstant(ContextMenuIds, "WORKING_SET_MENU", "WORKING_SET_CONTEXT_MENU");\r\n    DeprecationWarning.deprecateConstant(ContextMenuIds, "WORKING_SET_SETTINGS_MENU", "WORKING_SET_CONFIG_MENU");\r\n    \r\n    // Define public API\r\n    exports.AppMenuBar = AppMenuBar;\r\n    exports.ContextMenuIds = ContextMenuIds;\r\n    exports.MenuSection = MenuSection;\r\n    exports.BEFORE = BEFORE;\r\n    exports.AFTER = AFTER;\r\n    exports.LAST = LAST;\r\n    exports.FIRST = FIRST;\r\n    exports.FIRST_IN_SECTION = FIRST_IN_SECTION;\r\n    exports.LAST_IN_SECTION = LAST_IN_SECTION;\r\n    exports.DIVIDER = DIVIDER;\r\n    exports.getMenu = getMenu;\r\n    exports.getAllMenus = getAllMenus;\r\n    exports.getMenuItem = getMenuItem;\r\n    exports.getContextMenu = getContextMenu;\r\n    exports.addMenu = addMenu;\r\n    exports.removeMenu = removeMenu;\r\n    exports.registerContextMenu = registerContextMenu;\r\n    exports.closeAll = closeAll;\r\n    exports.Menu = Menu;\r\n    exports.MenuItem = MenuItem;\r\n    exports.ContextMenu = ContextMenu;\r\n});\r\n\n//# sourceURL=/command/Menus.js'),eval("/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n/**\r\n * Represents a file that will never exist on disk - a placeholder backing file for untitled Documents. NO ONE\r\n * other than DocumentManager should create instances of InMemoryFile. It is valid to test for one (`instanceof\r\n * InMemoryFile`), but it's better to check `doc.isUntitled` where possible.\r\n * \r\n * Attempts to read/write an InMemoryFile will always fail, and exists() always yields false. InMemoryFile.fullPath\r\n * is just a placeholder, and should not be displayed anywhere in the UI; fullPath IS guaranteed to be unique, however.\r\n * \r\n * An InMemoryFile is not added to the filesystem index, so if you ask the the filesystem anything about this\r\n * object, it won't know what you're talking about (`filesystem.getFileForPath(someInMemFile.fullPath)` will not\r\n * return someInMemFile).\r\n */\r\ndefine('document/InMemoryFile',['require','exports','module','filesystem/File','filesystem/FileSystemError'],function (require, exports, module) {\r\n    \"use strict\";\r\n    \r\n    var File            = require(\"filesystem/File\"),\r\n        FileSystemError = require(\"filesystem/FileSystemError\");\r\n    \r\n    function InMemoryFile(fullPath, fileSystem) {\r\n        File.call(this, fullPath, fileSystem);\r\n    }\r\n    \r\n    InMemoryFile.prototype = Object.create(File.prototype);\r\n    InMemoryFile.prototype.constructor = InMemoryFile;\r\n    InMemoryFile.prototype.parentClass = File.prototype;\r\n    \r\n    // Stub out invalid calls inherited from File\r\n    \r\n    /**\r\n     * Reject any attempts to read the file.\r\n     *\r\n     * Read a file as text. \r\n     *\r\n     * @param {Object=} options Currently unused.\r\n     * @param {function (number, string, object)} callback\r\n     */\r\n    InMemoryFile.prototype.read = function (options, callback) {\r\n        if (typeof (options) === \"function\") {\r\n            callback = options;\r\n        }\r\n        callback(FileSystemError.NOT_FOUND);\r\n    };\r\n    \r\n    /**\r\n     * Rejects any attempts to write the file.\r\n     *\r\n     * @param {string} data Data to write.\r\n     * @param {string=} encoding Encoding for data. Defaults to UTF-8.\r\n     * @param {!function (err, object)} callback Callback that is passed the\r\n     *              error code and the file's new stats if the write is sucessful.\r\n     */\r\n    InMemoryFile.prototype.write = function (data, encoding, callback) {\r\n        if (typeof (encoding) === \"function\") {\r\n            callback = encoding;\r\n        }\r\n        callback(FileSystemError.NOT_FOUND);\r\n    };\r\n    \r\n    \r\n    // Stub out invalid calls inherited from FileSystemEntry\r\n    \r\n    InMemoryFile.prototype.exists = function (callback) {\r\n        callback(null, false);\r\n    };\r\n    \r\n    InMemoryFile.prototype.stat = function (callback) {\r\n        callback(FileSystemError.NOT_FOUND);\r\n    };\r\n    \r\n    InMemoryFile.prototype.unlink = function (callback) {\r\n        callback(FileSystemError.NOT_FOUND);\r\n    };\r\n    \r\n    InMemoryFile.prototype.rename = function (newName, callback) {\r\n        callback(FileSystemError.NOT_FOUND);\r\n    };\r\n    \r\n    InMemoryFile.prototype.moveToTrash = function (callback) {\r\n        callback(FileSystemError.NOT_FOUND);\r\n    };\r\n    \r\n    // Export this class\r\n    module.exports = InMemoryFile;\r\n});\r\n\n//# sourceURL=/document/InMemoryFile.js"),eval('define(\'text!htmlContent/pane.html\',[],function () { return \'<div id="{{id}}" class="view-pane">\\r\\n    <div class="pane-header"></div>\\r\\n    <div class="pane-content">\\r\\n        <div class="not-editor"></div>\\r\\n    </div>\\r\\n</div>\';});\n\n//# sourceURL=/text!htmlContent/pane.html'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, Mustache */\r\n\r\n /**\r\n  * Pane objects host views of files, editors, etc... Clients cannot access\r\n  * Pane objects directly. Instead the implementation is protected by the \r\n  * MainViewManager -- however View Factories are given a Pane object which \r\n  * they can use to add views.  References to Pane objects should not be kept\r\n  * as they may be destroyed and removed from the DOM.\r\n  * \r\n  * To get a custom view, there are two components:\r\n  * \r\n  *  1) A View Factory   \r\n  *  2) A View Object  \r\n  *\r\n  * View objects are anonymous object that have a particular interface. \r\n  *\r\n  * Views can be added to a pane but do not have to exist in the Pane object\'s view list.  \r\n  * Such views are "temporary views".  Temporary views are not serialized with the Pane state\r\n  * or reconstituted when the pane is serialized from disk.  They are destroyed at the earliest\r\n  * opportunity.\r\n  *\r\n  * Temporary views are added by calling `Pane.showView()` and passing it the view object. The view \r\n  * will be destroyed when the next view is shown, the pane is mereged with another pane or the "Close All"\r\n  * command is exectuted on the Pane.  Temporary Editor Views do not contain any modifications and are\r\n  * added to the workingset (and are no longer tempoary views) once the document has been modified. They \r\n  * will remain in the working set until closed from that point on.\r\n  *\r\n  * Views that have a longer life span are added by calling addView to associate the view with a \r\n  * filename in the _views object.  These views are not destroyed until they are removed from the pane\r\n  * by calling one of the following: removeView, removeViews, or _reset\r\n  *\r\n  * Pane Object Events:  \r\n  *\r\n  *  - viewListChange - Whenever there is a file change to a file in the working set.  These 2 events: `DocumentManger.pathRemove` \r\n  *  and `DocumentManger.fileNameChange` will cause a `viewListChange` event so the WorkingSetView can update.\r\n  *\r\n  *  - currentViewChange - triggered whenever the current view changes.\r\n  *             (e, newView:View, oldView:View)\r\n  *\r\n  * View Interface:  \r\n  *\r\n  * The view is an anonymous object which has the following method signatures. see ImageViewer for an example or the sample\r\n  * provided with Brackets `src/extensions/samples/BracketsConfigCentral`  \r\n  *\r\n  *     {\r\n  *         $el:jQuery \r\n  *         getFile: function ():!File \r\n  *         updateLayout: function(forceRefresh:boolean) \r\n  *         destroy: function()\r\n  *         getScrollPos: function():*=\r\n  *         adjustScrollPos: function(state:Object=, heightDelta:number)=\r\n  *         notifyContainerChange: function()=\r\n  *         notifyVisibilityChange: function(boolean)=\r\n  *     }\r\n  *  \r\n  * When views are created they can be added to the pane by calling `pane.addView()`.  \r\n  * Views can be created and parented by attaching directly  to `pane.$el` \r\n  *\r\n  *     this._codeMirror = new CodeMirror(pane.$el, ...)\r\n  *\r\n  * Factories can create a view that\'s initially hidden by calling `pane.addView(view)` and passing `false` for the show parameter.\r\n  * Hidden views can be later shown by calling `pane.showView(view)`\r\n  *\r\n  * `$el:jQuery!`\r\n  *\r\n  *  property that stores the jQuery wrapped DOM element of the view. All views must have one so pane objects can manipulate the DOM\r\n  *  element when necessary (e.g. `showView`, `_reparent`, etc...)\r\n  *\r\n  * `getFile():File!`\r\n  *\r\n  *  Called throughout the life of a View when the current file is queried by the system.\r\n  *\r\n  * `updateLayout(forceRefresh:boolean)`\r\n  *  \r\n  *  Called to notify the view that it should be resized to fit its parent container.  This may be called several times\r\n  *  or only once.  Views can ignore the `forceRefresh` flag. It is used for editor views to force a relayout of the editor\r\n  *  which probably isn\'t necessary for most views.  Views should implement their html to be dynamic and not rely on this\r\n  *  function to be called whenever possible.\r\n  *\r\n  * `destroy()`\r\n  *\r\n  *  Views must implement a destroy method to remove their DOM element at the very least.  There is no default\r\n  *  implementation and views are hidden before this method is called. The Pane object doesn\'t make assumptions\r\n  *  about when it is safe to remove a node. In some instances other cleanup  must take place before a the DOM \r\n  *  node is destroyed so the implementation details are left to the view.  \r\n  *\r\n  *  Views can implement a simple destroy by calling \r\n  *\r\n  *      this.$el.remove()\r\n  *\r\n  *  These members are optional and need not be implemented by Views \r\n  *\r\n  *      getScrollPos()\r\n  *      adjustScrollPos()\r\n  *\r\n  *  The system at various times will want to save and restore a view\'s scroll position.  The data returned by `getScrollPos()`\r\n  *  is specific to the view and will be passed back to `adjustScrollPos()` when the scroll position needs to be restored.\r\n  *\r\n  *  When Modal Bars are invoked, the system calls `getScrollPos()` so that the current scroll psotion of all visible Views can be cached.\r\n  *  That cached scroll position is later passed to `adjustScrollPos()` along with a height delta.  The height delta is used to\r\n  *  scroll the view so that it doesn\'t appear to have "jumped" when invoking the Modal Bar.  \r\n  *\r\n  *  Height delta will be a positive when the Modal Bar is being shown and negative number when the Modal Bar is being hidden.  \r\n  *\r\n  *  `getViewState()` is another optional member that is used to cache a view\'s state when hiding or destroying a view or closing the project.\r\n  *  The data returned by this member is stored in `ViewStateManager` and is saved with the project.  \r\n  *\r\n  *  Views or View Factories are responsible for restoring the view state when the view of that file is created by recalling the cached state \r\n  *  \r\n  *      var view = createIconView(file, pane);\r\n  *      view.restoreViewState(ViewStateManager.getViewState(file.fullPath));\r\n  *\r\n  *  Notifications\r\n  *  The following optional methods receive notifications from the Pane object when certain events take place which affect the view:\r\n  *\r\n  * `notifyContainerChange()` \r\n  *\r\n  *  Optional Notification callback called when the container changes. The view can perform any synchronization or state update\r\n  *  it needs to do when its parent container changes.\r\n  *  \r\n  * `notifyVisiblityChange()`\r\n  * \r\n  *  Optional Notification callback called when the view\'s vsibility changes.  The view can perform any synchronization or\r\n  *  state update it needs to do when its visiblity state changes.\r\n  */\r\ndefine(\'view/Pane\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'filesystem/FileSystem\',\'filesystem/File\',\'document/InMemoryFile\',\'view/ViewStateManager\',\'view/MainViewManager\',\'document/DocumentManager\',\'command/CommandManager\',\'command/Commands\',\'strings\',\'utils/ViewUtils\',\'text!htmlContent/pane.html\'],function (require, exports, module) {\r\n    "use strict";\r\n        \r\n    var _                   = require("thirdparty/lodash"),\r\n        FileSystem          = require("filesystem/FileSystem"),\r\n        File                = require("filesystem/File"),\r\n        InMemoryFile        = require("document/InMemoryFile"),\r\n        ViewStateManager    = require("view/ViewStateManager"),\r\n        MainViewManager     = require("view/MainViewManager"),\r\n        DocumentManager     = require("document/DocumentManager"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        Commands            = require("command/Commands"),\r\n        Strings             = require("strings"),\r\n        ViewUtils           = require("utils/ViewUtils"),\r\n        paneTemplate        = require("text!htmlContent/pane.html");\r\n    \r\n    \r\n    /**\r\n     * @typedef {!$el: jQuery, getFile:function():!File, updateLayout:function(forceRefresh:boolean), destroy:function(),  getScrollPos:function():?,  adjustScrollPos:function(state:Object=, heightDelta:number)=, getViewState:function():?*=, restoreViewState:function(viewState:!*)=, notifyContainerChange:function()=, notifyVisibilityChange:function(boolean)=} View\r\n     */\r\n    \r\n    /**\r\n     * Pane Objects are constructed by the MainViewManager object when a Pane view is needed\r\n     * @see {@link MainViewManager} for more information\r\n     *\r\n     * @constructor\r\n     * @param {!string} id - The id to use to identify this pane\r\n     * @param {!JQuery} $container - The parent $container to place the pane view\r\n     */\r\n    function Pane(id, $container) {\r\n        this._initialize();\r\n        \r\n        // Setup the container and the element we\'re inserting\r\n        var self = this,\r\n            $el = $container.append(Mustache.render(paneTemplate, {id: id})).find("#" + id),\r\n            $header  = $el.find(".pane-header"),\r\n            $content = $el.find(".pane-content");\r\n        \r\n        $el.on("focusin.pane", function (e) {\r\n            self._lastFocusedElement = e.target;\r\n        });\r\n\r\n        this._lastFocusedElement = $el[0];\r\n        \r\n        // Make these properties read only\r\n        Object.defineProperty(this,  "id", {\r\n            get: function () {\r\n                return id;\r\n            },\r\n            set: function () {\r\n                console.error("cannot change the id of a working pane");\r\n            }\r\n        });\r\n\r\n        Object.defineProperty(this,  "$el", {\r\n            get: function () {\r\n                return $el;\r\n            },\r\n            set: function () {\r\n                console.error("cannot change the DOM node of a working pane");\r\n            }\r\n        });\r\n\r\n        Object.defineProperty(this,  "$header", {\r\n            get: function () {\r\n                return $header;\r\n            },\r\n            set: function () {\r\n                console.error("cannot change the DOM node of a working pane");\r\n            }\r\n        });\r\n\r\n        Object.defineProperty(this,  "$content", {\r\n            get: function () {\r\n                return $content;\r\n            },\r\n            set: function () {\r\n                console.error("cannot change the DOM node of a working pane");\r\n            }\r\n        });\r\n\r\n        Object.defineProperty(this,  "$container", {\r\n            get: function () {\r\n                return $container;\r\n            },\r\n            set: function () {\r\n                console.error("cannot change the DOM node of a working pane");\r\n            }\r\n        });\r\n\r\n        this._updateHeaderText();\r\n\r\n        // Listen to document events so we can update ourself\r\n        $(DocumentManager).on(this._makeEventName("fileNameChange"),  _.bind(this._handleFileNameChange, this));\r\n        $(DocumentManager).on(this._makeEventName("pathDeleted"), _.bind(this._handleFileDeleted, this));\r\n        $(MainViewManager).on(this._makeEventName("activePaneChange"), _.bind(this._handleActivePaneChange, this));\r\n    }\r\n\r\n    /**\r\n     * id of the pane\r\n     * @readonly\r\n     * @type {!string}\r\n     */\r\n    Pane.prototype.id = null;\r\n    \r\n    /**\r\n     * container where the pane lives\r\n     * @readonly\r\n     * @type {JQuery}\r\n     */\r\n    Pane.prototype.$container = null;\r\n    \r\n    /**\r\n     * the wrapped DOM node of this pane\r\n     * @readonly\r\n     * @type {JQuery}\r\n     */\r\n    Pane.prototype.$el = null;\r\n  \r\n    /**\r\n     * the wrapped DOM node that contains name of current view, or informational string if there is no view\r\n     * @readonly\r\n     * @type {JQuery}\r\n     */\r\n    Pane.prototype.$header = null;\r\n  \r\n    /**\r\n     * the wrapped DOM node that contains views\r\n     * @readonly\r\n     * @type {JQuery}\r\n     */\r\n    Pane.prototype.$content = null;\r\n  \r\n    /**\r\n     * The list of files views\r\n     * @type {Array.<File>}\r\n     */\r\n    Pane.prototype._viewList = [];\r\n\r\n    /**\r\n     * The list of files views in MRU order\r\n     * @type {Array.<File>}\r\n     */\r\n    Pane.prototype._viewListMRUOrder = [];\r\n\r\n    /**\r\n     * The list of files views in Added order\r\n     * @type {Array.<File>}\r\n     */\r\n    Pane.prototype._viewListAddedOrder = [];\r\n    \r\n    /**\r\n     * Dictionary mapping fullpath to view\r\n     * @type {Object.<!string, !View>}\r\n     * @private\r\n     */\r\n    Pane.prototype._views = {};\r\n\r\n    /**\r\n     * The current view\r\n     * @type {?View}\r\n     * @private\r\n     */\r\n    Pane.prototype._currentView = null;\r\n    \r\n    /**\r\n     * The last thing that received a focus event\r\n     * @type {?DomElement}\r\n     * @private\r\n     */\r\n    Pane.prototype._lastFocusedElement = null;\r\n    \r\n    /**\r\n     * Initializes the Pane to its default state\r\n     * @private\r\n     */\r\n    Pane.prototype._initialize = function () {\r\n        this._viewList = [];\r\n        this._viewListMRUOrder = [];\r\n        this._viewListAddedOrder = [];\r\n        this._views = {};\r\n        this._currentView = null;\r\n        this.showInterstitial(true);\r\n    };\r\n    \r\n   /**\r\n     * Creates a pane event namespaced to this pane\r\n     * (pass an empty string to generate just the namespace key to pass to jQuery to turn off all events handled by this pane)\r\n     * @private\r\n     * @param {!string} name - the name of the event to namespace \r\n     * @return {string} an event namespaced to this pane\r\n     */\r\n    Pane.prototype._makeEventName = function (name) {\r\n        return name + ".pane-" + this.id;\r\n    };\r\n\r\n   /**\r\n     * Reparents a view to this pane\r\n     * @private\r\n     * @param {!View} view - the view to reparent\r\n     */\r\n    Pane.prototype._reparent = function (view) {\r\n        view.$el.appendTo(this.$content);\r\n        this._views[view.getFile().fullPath] = view;\r\n        if (view.notifyContainerChange) {\r\n            view.notifyContainerChange();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Hides the current view if there is one, shows the \r\n     *  interstitial screen and notifies that the view changed\r\n     */\r\n    Pane.prototype._hideCurrentView = function () {\r\n        if (this._currentView) {\r\n            var currentView = this._currentView;\r\n            this._setViewVisibility(this._currentView, false);\r\n            this.showInterstitial(true);\r\n            this._currentView = null;\r\n            this._notifyCurrentViewChange(null, currentView);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Merges the another Pane object\'s contents into this Pane \r\n     * @param {!Pane} Other - Pane from which to copy \r\n     */\r\n    Pane.prototype.mergeFrom = function (other) {\r\n        // save this because we\'re setting it to null and we\r\n        //  may need to destroy it if it\'s a temporary view\r\n        var otherCurrentView = other._currentView;\r\n        \r\n        // Hide the current view while we \r\n        //  merge the 2 panes together\r\n        other._hideCurrentView();\r\n        \r\n        // Copy the File lists\r\n        this._viewList = _.union(this._viewList, other._viewList);\r\n        this._viewListMRUOrder = _.union(this._viewListMRUOrder, other._viewListMRUOrder);\r\n        this._viewListAddedOrder = _.union(this._viewListAddedOrder, other._viewListAddedOrder);\r\n        \r\n        var self = this,\r\n            viewsToDestroy = [];\r\n\r\n        // Copy the views\r\n        _.forEach(other._views, function (view) {\r\n            var file = view.getFile(),\r\n                fullPath = file && file.fullPath;\r\n            if (fullPath && other.findInViewList(fullPath) !== -1) {\r\n                // switch the container to this Pane\r\n                self._reparent(view);\r\n            } else {\r\n                // We don\'t copy temporary views so destroy them\r\n                viewsToDestroy.push(view);\r\n            }\r\n        });\r\n\r\n        // 1-off views \r\n        if (otherCurrentView && !other._isViewNeeded(otherCurrentView) && viewsToDestroy.indexOf(otherCurrentView) === -1) {\r\n            viewsToDestroy.push(otherCurrentView);\r\n        }\r\n        \r\n        // Destroy temporary views\r\n        _.forEach(viewsToDestroy, function (view) {\r\n            view.destroy();\r\n        });\r\n\r\n        // this _reset all internal data structures\r\n        //  and will set the current view to null \r\n        other._initialize();\r\n    };\r\n    \r\n    /**\r\n     * Removes the DOM node for the Pane, removes all \r\n     *  event handlers and _resets all internal data structures\r\n     */\r\n    Pane.prototype.destroy = function () {\r\n        if (this._currentView ||\r\n                Object.keys(this._views).length > 0 ||\r\n                this._viewList.length > 0) {\r\n            console.warn("destroying a pane that isn\'t empty");\r\n        }\r\n\r\n        this._reset();\r\n        \r\n        $(DocumentManager).off(this._makeEventName(""));\r\n        $(MainViewManager).off(this._makeEventName(""));\r\n\r\n        this.$el.off(".pane");\r\n        this.$el.remove();\r\n    };\r\n    \r\n   /**\r\n     * Returns a copy of the view file list\r\n     * @return {!Array.<File>} \r\n     */\r\n    Pane.prototype.getViewList = function () {\r\n        return _.clone(this._viewList);\r\n    };\r\n    \r\n    /**\r\n     * Returns the number of entries in the view file list\r\n     * @return {number} \r\n     */\r\n    Pane.prototype.getViewListSize = function () {\r\n        return this._viewList.length;\r\n    };\r\n    \r\n    /**\r\n     * Returns the index of the item in the view file list \r\n     * @param {!string} fullPath the full path of the item to look for \r\n     * @return {number} index of the item or -1 if not found\r\n     */\r\n    Pane.prototype.findInViewList = function (fullPath) {\r\n        return _.findIndex(this._viewList, function (file) {\r\n            return file.fullPath === fullPath;\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * Returns the order in which the item was added\r\n     * @param {!string} fullPath the full path of the item to look for \r\n     * @return {number} order of the item or -1 if not found\r\n     */\r\n    Pane.prototype.findInViewListAddedOrder = function (fullPath) {\r\n        return _.findIndex(this._viewListAddedOrder, function (file) {\r\n            return file.fullPath === fullPath;\r\n        });\r\n    };\r\n    \r\n   /**\r\n     * Returns the order in which the item was last used\r\n     * @param {!string} fullPath the full path of the item to look for \r\n     * @return {number} order of the item or -1 if not found. \r\n     *      0 indicates most recently used, followed by 1 and so on...\r\n     */\r\n    Pane.prototype.findInViewListMRUOrder = function (fullPath) {\r\n        return _.findIndex(this._viewListMRUOrder, function (file) {\r\n            return file.fullPath === fullPath;\r\n        });\r\n    };\r\n    \r\n    /** \r\n     * Return value from reorderItem when the Item was not found \r\n     * @see {@link reorderItem()}\r\n     * @const \r\n     */\r\n    Pane.prototype.ITEM_NOT_FOUND = -1;\r\n    \r\n    /** \r\n     * Return value from reorderItem when the Item was found at its natural index \r\n     * and the workingset does not need to be resorted\r\n     * @see {@link reorderItem()}\r\n     * @const \r\n     */\r\n    Pane.prototype.ITEM_FOUND_NO_SORT = 0;\r\n    \r\n    /** \r\n     * Return value from reorderItem when the Item was found and reindexed \r\n     * and the workingset needs to be resorted\r\n     * @see {@link reorderItem()}\r\n     * @const \r\n     */\r\n    Pane.prototype.ITEM_FOUND_NEEDS_SORT = 1;\r\n\r\n    /**\r\n     * reorders the specified file in the view list to the desired position\r\n     *\r\n     * @param {File} file - the file object of the item to reorder\r\n     * @param {number=} index - the new position of the item\r\n     * @param {boolean=} force - true to force the item into that position, false otherwise.  (Requires an index be requested)\r\n     * @return {number} this function returns one of the following manifest constants:  \r\n     *            ITEM_NOT_FOUND        : The request file object was not found   \r\n     *            ITEM_FOUND_NO_SORT    : The request file object was found but it was already at the requested index   \r\n     *            ITEM_FOUND_NEEDS_SORT : The request file object was found and moved to a new index and the list should be resorted   \r\n     */\r\n    Pane.prototype.reorderItem = function (file, index, force) {\r\n        var indexRequested = (index !== undefined && index !== null && index >= 0),\r\n            curIndex = this.findInViewList(file.fullPath);\r\n        \r\n        if (curIndex !== -1) {\r\n            // File is in view list, but not at the specifically requested index - only need to reorder\r\n            if (force || (indexRequested && curIndex !== index)) {\r\n                var entry = this._viewList.splice(curIndex, 1)[0];\r\n                this._viewList.splice(index, 0, entry);\r\n                return this.ITEM_FOUND_NEEDS_SORT;\r\n            }\r\n            return this.ITEM_FOUND_NO_SORT;\r\n        }\r\n        \r\n        return this.ITEM_NOT_FOUND;\r\n    };\r\n    \r\n    /**\r\n     * Determines if a file can be added to our file list\r\n     * @private\r\n     * @param {!File} file - file object to test\r\n     * @return {boolean} true if it can be added, false if not\r\n     */\r\n    Pane.prototype._canAddFile = function (file) {\r\n        return ((this._views.hasOwnProperty(file.fullPath) && this.findInViewList(file.fullPath) === -1) ||\r\n                    (!MainViewManager._getPaneIdForPath(file.fullPath)));\r\n    };\r\n    \r\n    /**\r\n     * Adds the given file to the end of the workingset, if it is not already in the list\r\n     * @private\r\n     * @param {!File} file\r\n     * @param {Object=} inPlace record with inPlace add data (index, indexRequested). Used internally\r\n     */\r\n    Pane.prototype._addToViewList = function (file, inPlace) {\r\n        if (inPlace && inPlace.indexRequested) {\r\n            // If specified, insert into the workingset at this 0-based index\r\n            this._viewList.splice(inPlace.index, 0, file);\r\n        } else {\r\n            // If no index is specified, just add the file to the end of the workingset.\r\n            this._viewList.push(file);\r\n        }\r\n        \r\n        // Add to MRU order: either first or last, depending on whether it\'s already the current doc or not\r\n        var currentPath = this.getCurrentlyViewedPath();\r\n        if (currentPath && currentPath === file.fullPath) {\r\n            this._viewListMRUOrder.unshift(file);\r\n        } else {\r\n            this._viewListMRUOrder.push(file);\r\n        }\r\n        \r\n        // Add first to Added order\r\n        this._viewListAddedOrder.unshift(file);\r\n    };\r\n\r\n                \r\n    /**\r\n     * Adds the given file to the end of the workingset, if it is not already in the list\r\n     * Does not change which document is currently open in the editor. Completes synchronously.\r\n     * @param {!File} file - file to add\r\n     * @param {number=} index - position where to add the item\r\n     * @return {number} index of where the item was added\r\n     */\r\n    Pane.prototype.addToViewList = function (file, index) {\r\n        var indexRequested = (index !== undefined && index !== null && index >= 0 && index < this._viewList.length);\r\n\r\n        this._addToViewList(file, {indexRequested: indexRequested, index: index});\r\n        \r\n        if (!indexRequested) {\r\n            index = this._viewList.length - 1;\r\n        }\r\n        \r\n        return index;\r\n    };\r\n    \r\n\r\n    /**\r\n     * Adds the given file list to the end of the workingset. \r\n     * @param {!Array.<File>} fileList\r\n     * @return {!Array.<File>} list of files added to the list\r\n     */\r\n    Pane.prototype.addListToViewList = function (fileList) {\r\n        var self = this,\r\n            uniqueFileList = [];\r\n\r\n        // Process only files not already in view list\r\n        fileList.forEach(function (file) {\r\n            if (self._canAddFile(file)) {\r\n                self._addToViewList(file);\r\n                uniqueFileList.push(file);\r\n            }\r\n        });\r\n\r\n        return uniqueFileList;\r\n    };\r\n    \r\n    Pane.prototype._notifyCurrentViewChange = function (newView, oldView) {\r\n        this._updateHeaderText();\r\n        \r\n        $(this).triggerHandler("currentViewChange", [newView, oldView]);\r\n    };\r\n    \r\n    /**\r\n     * Removes the specifed file from all internal lists, destroys the view of the file (if there is one)\r\n     *  and shows the interstitial page if the current view is destroyed\r\n     * @private\r\n     * @param {!File} file - file to remove\r\n     * @param {boolean} preventViewChange - false to hide the current view if removing the current view, true \r\n     *                                      to prevent the current view from changing.\r\n     *\r\n     * When passing true for preventViewChange, it is assumed that the caller will perform an OPEN_FILE op\r\n     * to show the next file in line to view.  Since the file was removed from the workingset in _doRemove\r\n     * its view is now considered to be a temporary view and the call to showView for the OPEN_FILE op \r\n     * will destroy the view. the caller needs to handle the reject case in the event of failure\r\n     *\r\n     * @return {boolean} true if removed, false if the file was not found either in a list or view\r\n     */\r\n    Pane.prototype._doRemove = function (file, preventViewChange) {\r\n        \r\n        // If it\'s in the view list then we need to remove it \r\n        var index = this.findInViewList(file.fullPath);\r\n        \r\n        if (index > -1) {\r\n            // Remove it from all 3 view lists\r\n            this._viewList.splice(index, 1);\r\n            this._viewListMRUOrder.splice(this.findInViewListMRUOrder(file.fullPath), 1);\r\n            this._viewListAddedOrder.splice(this.findInViewListAddedOrder(file.fullPath), 1);\r\n        }\r\n        \r\n        // Destroy the view\r\n        var view = this._views[file.fullPath];\r\n\r\n        if (view) {\r\n            if (!preventViewChange) {\r\n                if (this._currentView === view) {\r\n                    // if we\'re removing the current\r\n                    //  view then we need to hide the view\r\n                    this._hideCurrentView();\r\n                }\r\n                delete this._views[file.fullPath];\r\n                view.destroy();\r\n            }\r\n        }\r\n        \r\n        return ((index > -1) || Boolean(view));\r\n    };\r\n    \r\n    /**\r\n     * Moves the specified file to the front of the MRU list\r\n     * @param {!File} file\r\n     */\r\n    Pane.prototype.makeViewMostRecent = function (file) {\r\n        var index = this.findInViewListMRUOrder(file.fullPath);\r\n        if (index !== -1) {\r\n            this._viewListMRUOrder.splice(index, 1);\r\n            this._viewListMRUOrder.unshift(file);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Sorts items in the pane\'s view list\r\n     * @param {function(paneId:!string, left:!string, right:!string):number} compareFn - the function used to compare items in the viewList\r\n     */\r\n    \r\n    /**\r\n     * invokes Array.sort method on the internal view list. \r\n     * @param {sortFunctionCallback} compareFn - the function to call to determine if the \r\n     */\r\n    Pane.prototype.sortViewList = function (compareFn) {\r\n        this._viewList.sort(_.partial(compareFn, this.id));\r\n    };\r\n\r\n    /**\r\n     * Swaps two items in the file view list (used while dragging items in the working set view)\r\n     * @param {number} index1 - the index of the first item to swap\r\n     * @param {number} index2 - the index of the second item to swap\r\n     * @return {boolean}} true \r\n     */\r\n    Pane.prototype.swapViewListIndexes = function (index1, index2) {\r\n        var temp = this._viewList[index1];\r\n        this._viewList[index1] = this._viewList[index2];\r\n        this._viewList[index2] = temp;\r\n        return true;\r\n    };\r\n    \r\n    /**\r\n     * Traverses the list and returns the File object of the next item in the MRU order\r\n     * @param {!number} direction - Must be 1 or -1 to traverse forward or backward\r\n     * @param {string=} current - the fullPath of the item where traversal is to start. \r\n     *                              If this paramater is ommitted then the path of the current view is used.\r\n     *                              If the current view is a temporary view then the first item in the MRU list is returned\r\n     * @return {?File}  The File object of the next item in the travesal order or null if there isn\'t one.\r\n     */\r\n    Pane.prototype.traverseViewListByMRU = function (direction, current) {\r\n        if (!current && this._currentView) {\r\n            var file = this._currentView.getFile();\r\n            current = file && file.fullPath;\r\n        }\r\n        \r\n        var index = current ? this.findInViewListMRUOrder(current) : -1;\r\n        return ViewUtils.traverseViewArray(this._viewListMRUOrder, index, direction);\r\n    };\r\n    \r\n    /**\r\n     * Updates text in pane header\r\n     * @private\r\n     */\r\n    Pane.prototype._updateHeaderText = function () {\r\n        var file = this.getCurrentlyViewedFile();\r\n        if (file) {\r\n            this.$header.text(file.name);\r\n        } else {\r\n            this.$header.html(Strings.EMPTY_VIEW_HEADER);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Event handler when a file changes name\r\n     * @private\r\n     * @param {!JQuery.Event} e - jQuery event object\r\n     * @param {!string} oldname - path of the file that was renamed\r\n     * @param {!string} newname - the new path to the file\r\n     */\r\n    Pane.prototype._handleFileNameChange = function (e, oldname, newname) {\r\n        // Check to see if we need to dispatch a viewListChange event\r\n        // The list contains references to file objects and, for a rename event, \r\n        // the File object\'s name has changed by the time we\'ve gotten the event.\r\n        // So, we need to look for the file by its new name to determine if\r\n        // if we need to dispatch the event which may look funny\r\n        var dispatchEvent = (this.findInViewList(newname) >= 0);\r\n        \r\n        // rename the view \r\n        if (this._views.hasOwnProperty(oldname)) {\r\n            var view = this._views[oldname];\r\n\r\n            this._views[newname] = view;\r\n            delete this._views[oldname];\r\n        }\r\n        \r\n        this._updateHeaderText();\r\n        \r\n        // dispatch the change event\r\n        if (dispatchEvent) {\r\n            $(this).triggerHandler("viewListChange");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Event handler when a file is deleted\r\n     * @private\r\n     * @param {!JQuery.Event} e - jQuery event object\r\n     * @param {!string} fullPath - path of the file that was deleted\r\n     */\r\n    Pane.prototype._handleFileDeleted = function (e, fullPath) {\r\n        if (this.removeView({fullPath: fullPath})) {\r\n            $(this).triggerHandler("viewListChange");\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Shows the pane\'s interstitial page\r\n     * @param {boolean} show - show or hide the interstitial page\r\n     */\r\n    Pane.prototype.showInterstitial = function (show) {\r\n        if (this.$content) {\r\n            this.$content.find(".not-editor").css("display", (show) ? "" : "none");\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * retrieves the view object for the given path\r\n     * @param {!string}  path - the fullPath of the view to retrieve\r\n     * @return {boolean} show - show or hide the interstitial page\r\n     */\r\n    Pane.prototype.getViewForPath = function (path) {\r\n        return this._views[path];\r\n    };\r\n    \r\n    /**\r\n     * Adds a view to the pane\r\n     * @param {!View} view - the View object to add \r\n     * @param {boolean} show - true to show the view right away, false otherwise\r\n     */\r\n    Pane.prototype.addView = function (view, show) {\r\n        var file = view.getFile(),\r\n            path = file && file.fullPath;\r\n        \r\n        if (!path) {\r\n            console.error("cannot add a view that does not have a fullPath");\r\n            return;\r\n        }\r\n        \r\n        if (view.$el.parent() !== this.$content) {\r\n            this._reparent(view);\r\n        } else {\r\n            this._views[path] = view;\r\n        }\r\n\r\n        \r\n        if (show) {\r\n            this.showView(view);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Shows or hides a view\r\n     * @param {!View} view - the to show or hide\r\n     * @param {boolean} visible - true to show the view, false to hide it\r\n     * @private\r\n     */\r\n    Pane.prototype._setViewVisibility = function (view, visible) {\r\n        view.$el.css("display", (visible ? "" : "none"));\r\n        if (view.notifyVisibilityChange) {\r\n            view.notifyVisibilityChange(visible);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Swaps the current view with the requested view. \r\n     * If the interstitial page is shown, it is hidden. \r\n     * If the currentView is a temporary view, it is destroyed.\r\n     * @param {!View} view - the to show\r\n     */\r\n    Pane.prototype.showView = function (view) {\r\n        if (this._currentView && this._currentView === view) {\r\n            this._setViewVisibility(this._currentView, true);\r\n            this.updateLayout(true);\r\n            return;\r\n        }\r\n        \r\n        var file = view.getFile(),\r\n            newPath = file && file.fullPath,\r\n            oldView = this._currentView;\r\n        \r\n        if (this._currentView) {\r\n            if (this._currentView.getFile()) {\r\n                ViewStateManager.updateViewState(this._currentView);\r\n            }\r\n            this._setViewVisibility(this._currentView, false);\r\n        } else {\r\n            this.showInterstitial(false);\r\n        }\r\n        \r\n        this._currentView = view;\r\n        this._setViewVisibility(this._currentView, true);\r\n        this.updateLayout();\r\n        \r\n        this._notifyCurrentViewChange(view, oldView);\r\n        \r\n        if (oldView) {\r\n            this.destroyViewIfNotNeeded(oldView);\r\n        }\r\n        \r\n        if (!this._views.hasOwnProperty(newPath)) {\r\n            console.error(newPath + " found in pane working set but pane.addView() has not been called for the view created for it");\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Update header and content height\r\n     */\r\n    Pane.prototype._updateHeaderHeight = function () {\r\n        var paneContentHeight = this.$el.height();\r\n        \r\n        // Adjust pane content height for header\r\n        if (MainViewManager.getPaneCount() > 1) {\r\n            this.$header.show();\r\n            paneContentHeight -= this.$header.outerHeight();\r\n        } else {\r\n            this.$header.hide();\r\n        }\r\n        \r\n        this.$content.height(paneContentHeight);\r\n    };\r\n    \r\n    /**\r\n     * Sets pane content height. Updates the layout causing the current view to redraw itself\r\n     * @param {boolean} forceRefresh - true to force a resize and refresh of the current view,\r\n     * false if just to resize forceRefresh is only used by Editor views to force a relayout\r\n     * of all editor DOM elements. Custom View implementations should just ignore this flag.\r\n     */\r\n    Pane.prototype.updateLayout = function (forceRefresh) {\r\n        this._updateHeaderHeight();\r\n        if (this._currentView) {\r\n            this._currentView.updateLayout(forceRefresh);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Determines if the view can be disposed of\r\n     * @private\r\n     * @param {!View} view - the View object to test\r\n     * @return {boolean}} true if the view can be disposed, false if not\r\n     */\r\n    Pane.prototype._isViewNeeded = function (view) {\r\n        var path = view.getFile().fullPath,\r\n            currentPath = this.getCurrentlyViewedPath();\r\n        \r\n        return ((this._currentView && currentPath === path) || (this.findInViewList(path) !== -1));\r\n    };\r\n    \r\n    \r\n    /**\r\n     * Retrieves the File object of the current view\r\n     * @return {?File} the File object of the current view or null if there isn\'t one\r\n     */\r\n    Pane.prototype.getCurrentlyViewedFile = function () {\r\n        return this._currentView ? this._currentView.getFile() : null;\r\n    };\r\n    \r\n    /**\r\n     * Retrieves the path of the current view\r\n     * @return {?string} the path of the current view or null if there isn\'t one\r\n     */\r\n    Pane.prototype.getCurrentlyViewedPath = function () {\r\n        var file = this.getCurrentlyViewedFile();\r\n        return file ? file.fullPath : null;\r\n    };\r\n    \r\n    /**\r\n     * destroys the view if it isn\'t needed\r\n     * @param {View} view - the view to destroy\r\n     */\r\n    Pane.prototype.destroyViewIfNotNeeded = function (view) {\r\n        if (!this._isViewNeeded(view)) {\r\n            var file = view.getFile(),\r\n                path = file && file.fullPath;\r\n            delete this._views[path];\r\n            view.destroy();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * _resets the pane to an empty state\r\n     * @private\r\n     */\r\n    Pane.prototype._reset = function () {\r\n        var views = [],\r\n            view = this._currentView;\r\n\r\n        _.forEach(this._views, function (_view) {\r\n            views.push(_view);\r\n        });\r\n        \r\n        // If the current view is a temporary view,\r\n        //  add it to the destroy list to dispose of\r\n        if (this._currentView && views.indexOf(this._currentView) === -1) {\r\n            views.push(this._currentView);\r\n        }\r\n        \r\n        // This will reinitialize the object back to \r\n        //  the default state\r\n        this._initialize();\r\n        \r\n        if (view) {\r\n            this._notifyCurrentViewChange(null, view);\r\n        }\r\n\r\n        // Now destroy the views\r\n        views.forEach(function (_view) {\r\n            _view.destroy();\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * Executes a FILE_OPEN command to open a file\r\n     * @param  {!string} fullPath - path of the file to open\r\n     * @return {jQuery.promise} promise that will resolve when the file is opened\r\n     */\r\n    Pane.prototype._execOpenFile = function (fullPath) {\r\n        return CommandManager.execute(Commands.FILE_OPEN, { fullPath: fullPath, paneId: this.id});\r\n    };\r\n    \r\n    /**\r\n     * Removes the view and opens the next view\r\n     * @param {File} file - the file to close\r\n     * @param {boolean} suppressOpenNextFile - suppresses opening the next file in MRU order\r\n     * @return {boolean} true if the file was removed from the working set\r\n     *  This function will remove a temporary view of a file but will return false in that case\r\n     */\r\n    Pane.prototype.removeView = function (file, suppressOpenNextFile) {\r\n        var nextFile = !suppressOpenNextFile && this.traverseViewListByMRU(1, file.fullPath);\r\n        if (nextFile && nextFile.fullPath !== file.fullPath && this.getCurrentlyViewedPath() === file.fullPath) {\r\n            var self = this,\r\n                fullPath = nextFile.fullPath,\r\n                needOpenNextFile = this.findInViewList(fullPath) !== -1;\r\n            \r\n            if (this._doRemove(file, needOpenNextFile)) {\r\n                if (needOpenNextFile) {\r\n                    this._execOpenFile(fullPath)\r\n                        .fail(function () {\r\n                            // the FILE_OPEN op failed so\r\n                            //  we need to cleanup by hiding and destroying the current view\r\n                            self._hideCurrentView();\r\n                            var view = self._views[file.fullPath];\r\n                            delete self._views[file.fullPath];\r\n                            view.destroy();\r\n                        });\r\n                }\r\n                return true;\r\n            } else {\r\n                // Nothing was removed so don\'t try to remove it again\r\n                return false;\r\n            }\r\n        } else {\r\n            return this._doRemove(file);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Removes the specifed file from all internal lists, destroys the view of the file (if there is one)\r\n     *  and shows the interstitial page if the current view is destroyed. \r\n     * @param {!Array.<File>}  list - Array of files to remove\r\n     * @return {!Array.<File>} Array of File objects removed from the working set. \r\n     *  This function will remove temporary views but the file objects for those views will not be found\r\n     *  in the result set.  Only the file objects removed from the working set are returned.\r\n     */\r\n    Pane.prototype.removeViews = function (list) {\r\n        var self = this;\r\n        \r\n        return list.filter(function (file) {\r\n            return (self.removeView(file));\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * Gives focus to the last thing that had focus, the current view or the pane in that order\r\n     */\r\n    Pane.prototype.focus = function () {\r\n        // Blur the currently focused element which will move focus to the BODY tag\r\n        //  If the element we want to focus below cannot receive the input focus such as an ImageView\r\n        //  This will remove focus from the current view which is important if the current view is \r\n        //  a codemirror view. \r\n        document.activeElement.blur();\r\n        \r\n        if (this._lastFocusedElement && $(this._lastFocusedElement).is(":visible")) {\r\n            $(this._lastFocusedElement).focus();\r\n        } else if (this._currentView) {\r\n            this._currentView.$el.focus();\r\n        } else {\r\n            this.$el.focus();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * MainViewManager.activePaneChange handler\r\n     * @param {jQuery.event} e - event data\r\n     * @param {!string} activePaneId - the new active pane id\r\n     */\r\n    Pane.prototype._handleActivePaneChange = function (e, activePaneId) {\r\n        this.$el.toggleClass("active-pane", Boolean(activePaneId === this.id));\r\n    };\r\n    \r\n    \r\n    \r\n    /**\r\n     * serializes the pane state from JSON\r\n     * @param {!Object} state - the state to load \r\n     * @return {jQuery.Promise} A promise which resolves to \r\n     *              {fullPath:string, paneId:string} \r\n     *              which can be passed as command data to FILE_OPEN\r\n     */\r\n    Pane.prototype.loadState = function (state) {\r\n        var filesToAdd = [],\r\n            viewStates = {},\r\n            activeFile,\r\n            data,\r\n            self = this;\r\n        \r\n        var getInitialViewFilePath = function () {\r\n            return (self._viewList.length > 0) ? self._viewList[0].fullPath : null;\r\n        };\r\n\r\n        _.forEach(state, function (entry) {\r\n            filesToAdd.push(FileSystem.getFileForPath(entry.file));\r\n            if (entry.active) {\r\n                activeFile = entry.file;\r\n            }\r\n            if (entry.viewState) {\r\n                viewStates[entry.file] = entry.viewState;\r\n            }\r\n        });\r\n        \r\n        this.addListToViewList(filesToAdd);\r\n        \r\n        ViewStateManager.addViewStates(viewStates);\r\n        \r\n        activeFile = activeFile || getInitialViewFilePath();\r\n       \r\n        if (activeFile) {\r\n            data = {paneId: self.id, fullPath: activeFile};\r\n        }\r\n        \r\n        return new $.Deferred().resolve(data);\r\n    };\r\n    \r\n    /**\r\n     * Returns the JSON-ified state of the object so it can be serialize\r\n     * @return {!Object} state - the state to save \r\n     */\r\n    Pane.prototype.saveState = function () {\r\n        var view,\r\n            result = [],\r\n            currentlyViewedPath = this.getCurrentlyViewedPath();\r\n\r\n        // Save the current view state first\r\n        if (this._currentView && this._currentView.getFile()) {\r\n            // We save the view state of the current view before \r\n            //  hiding the view and showing to a different file\r\n            // But the current view\'s view state may not be\r\n            //  up to date in the view state cache so update it\r\n            //  before we save so we don\'t JSON-ify stale data.\r\n            ViewStateManager.updateViewState(this._currentView);\r\n        }\r\n        \r\n        // walk the list of views and save\r\n        this._viewList.forEach(function (file) {\r\n            // Do not persist untitled document paths\r\n            if (!(file instanceof InMemoryFile)) {\r\n                result.push({\r\n                    file: file.fullPath,\r\n                    active: (file.fullPath === currentlyViewedPath),\r\n                    viewState:  ViewStateManager.getViewState(file)\r\n                });\r\n            }\r\n        });\r\n        \r\n        return result;\r\n    };\r\n    \r\n    /**\r\n     * gets the current view\'s scroll state data\r\n     * @return {Object=} scroll state - the current scroll state\r\n     */\r\n    Pane.prototype.getScrollState = function () {\r\n        if (this._currentView && this._currentView.getScrollPos) {\r\n            return {scrollPos: this._currentView.getScrollPos()};\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * tells the current view to restore its scroll state from cached data and apply a height delta\r\n     * @param {Object=} state - the current scroll state\r\n     * @param {number=} heightDelta - the amount to add or subtract from the state\r\n     */\r\n    Pane.prototype.restoreAndAdjustScrollState = function (state, heightDelta) {\r\n        if (this._currentView && state && state.scrollPos && this._currentView.adjustScrollPos) {\r\n            this._currentView.adjustScrollPos(state.scrollPos, heightDelta);\r\n        }\r\n    };\r\n    \r\n    exports.Pane = Pane;\r\n});\n//# sourceURL=/view/Pane.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, window, $, brackets */\r\n\r\n/**\r\n * MainViewManager Manages the arrangement of all open panes as well as provides the controller\r\n * logic behind all views in the MainView (e.g. ensuring that a file doesn\'t appear in 2 lists)\r\n *\r\n * Each pane contains one or more views wich are created by a view factory and inserted into a pane list. \r\n * There may be several panes managed  by the MainViewManager with each pane containing a list of views.  \r\n * The panes are always visible and  the layout is determined by the MainViewManager and the user.  \r\n *\r\n * Currently we support only 2 panes.\r\n *\r\n * All of the WorkingSet APIs take a paneId Argument.  This can be an actual pane Id, ALL_PANES (in most cases) \r\n * or ACTIVE_PANE. ALL_PANES may not be supported for some APIs.  See the API for details.\r\n *\r\n * This module dispatches several events:\r\n *\r\n *    - activePaneChange - When the active pane changes.  There will always be an active pane.\r\n *          (e, newPaneId:string, oldPaneId:string) \r\n *    - currentFileChange -- When the user has switched to another pane, file, document. When the user closes a view\r\n *      and there are no other views to show the current file will be null.  \r\n *          (e, newFile:File, newPaneId:string, oldFile:File, oldPaneId:string)\r\n *    - paneLayoutChange -- When Orientation changes.\r\n *          (e, orientation:string)\r\n *    - paneCreate -- When a pane is created\r\n *          (e, paneId:string)\r\n *    - paneDestroy -- When a pane is destroyed\r\n *          (e, paneId:string)\r\n *      \r\n *\r\n *    To listen for working set changes, you must listen to *all* of these events:\r\n *    - workingSetAdd -- When a file is added to the working set \r\n *          (e, fileAdded:File, index:number, paneId:string)\r\n *    - workingSetAddList -- When multiple files are added to the working set \r\n *          (e, fileAdded:Array.<File>, paneId:string)\r\n *    - workingSetRemove -- When a file is removed from the working set \r\n *          (e, fileRemoved:File, suppressRedraw:boolean, paneId:string)\r\n *    - workingSetRemoveList -- When multiple files are removed from the working set \r\n *          (e, filesRemoved:Array.<File>, paneId:string)\r\n *    - workingSetSort -- When a pane\'s view array is reordered without additions or removals.\r\n *          (e, paneId:string)\r\n *    - workingSetUpdate -- When changes happen due to system events such as a file being deleted.\r\n *                              listeners should discard all working set info and rebuilt it from the pane \r\n *                              by calling getWorkingSet()\r\n *          (e, paneId:string)\r\n *    - _workingSetDisableAutoSort -- When the working set is reordered by manually dragging a file. \r\n *          (e, paneId:string) For Internal Use Only.\r\n *\r\n * These are jQuery events, so to listen for them you do something like this:\r\n *    `$(MainViewManager).on("eventname", handler);`\r\n *\r\n */\r\ndefine(\'view/MainViewManager\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'strings\',\'utils/AppInit\',\'command/CommandManager\',\'view/MainViewFactory\',\'view/ViewStateManager\',\'command/Menus\',\'command/Commands\',\'editor/EditorManager\',\'filesystem/FileSystem\',\'filesystem/FileSystemError\',\'document/DocumentManager\',\'preferences/PreferencesManager\',\'project/ProjectManager\',\'view/WorkspaceManager\',\'document/InMemoryFile\',\'utils/Async\',\'utils/ViewUtils\',\'utils/Resizer\',\'view/Pane\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _                   = require("thirdparty/lodash"),\r\n        Strings             = require("strings"),\r\n        AppInit             = require("utils/AppInit"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        MainViewFactory     = require("view/MainViewFactory"),\r\n        ViewStateManager    = require("view/ViewStateManager"),\r\n        Menus               = require("command/Menus"),\r\n        Commands            = require("command/Commands"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        FileSystem          = require("filesystem/FileSystem"),\r\n        FileSystemError     = require("filesystem/FileSystemError"),\r\n        DocumentManager     = require("document/DocumentManager"),\r\n        PreferencesManager  = require("preferences/PreferencesManager"),\r\n        ProjectManager      = require("project/ProjectManager"),\r\n        WorkspaceManager    = require("view/WorkspaceManager"),\r\n        InMemoryFile        = require("document/InMemoryFile"),\r\n        AsyncUtils          = require("utils/Async"),\r\n        ViewUtils           = require("utils/ViewUtils"),\r\n        Resizer             = require("utils/Resizer"),\r\n        Pane                = require("view/Pane").Pane;\r\n        \r\n\r\n    /** \r\n     * Temporary internal command \r\n     *  May go away once we have implemented @Larz0\'s UI treatment\r\n     * @const\r\n     * @private\r\n     */\r\n    var CMD_ID_SPLIT_VERTICALLY = "cmd.splitVertically";\r\n\r\n    /** \r\n     * Temporary internal command \r\n     *  May go away once we have implemented @Larz0\'s UI treatment\r\n     * @const\r\n     * @private\r\n     */\r\n    var CMD_ID_SPLIT_HORIZONTALLY = "cmd.splitHorizontally";\r\n    \r\n    /** \r\n     * Preference setting name for the MainView Saved State\r\n     * @const\r\n     * @private\r\n     */\r\n    var PREFS_NAME          = "mainView.state";\r\n    \r\n    /** \r\n     * Legacy Preference setting name used to migrate old preferences\r\n     * @const\r\n     * @private\r\n     */\r\n    var OLD_PREFS_NAME      = "project.files";\r\n    \r\n    /** \r\n     * Special paneId shortcut that can be used to specify that\r\n     * all panes should be targeted by the API.  \r\n     * Not all APIs support this constnant. \r\n     * Check the API documentation before use.\r\n     * @const\r\n     */\r\n    var ALL_PANES           = "ALL_PANES";\r\n\r\n    /** \r\n     * Special paneId shortcut that can be used to specify that\r\n     * the API should target the focused pane only.  \r\n     * All APIs support this shortcut.\r\n     * @const\r\n     */\r\n    var ACTIVE_PANE        = "ACTIVE_PANE";\r\n        \r\n    /** \r\n     * Internal pane id\r\n     * @const\r\n     * @private\r\n     */\r\n    var FIRST_PANE          = "first-pane";\r\n\r\n    /** \r\n     * Internal pane id\r\n     * @const\r\n     * @private\r\n     */\r\n    var SECOND_PANE         = "second-pane";\r\n    \r\n    /*\r\n     * NOTE: The following commands and constants will change \r\n     *        when implementing the UX UI Treatment @larz0\r\n     */\r\n\r\n    /** \r\n     * Vertical layout state name\r\n     * @const\r\n     * @private\r\n     */\r\n    var VERTICAL            = "VERTICAL";\r\n\r\n    /** \r\n     * Horizontal layout state name\r\n     * @const\r\n     * @private\r\n     */\r\n    var HORIZONTAL          = "HORIZONTAL";\r\n    \r\n    /**\r\n     * The minimum width or height that a pane can be\r\n     * @const\r\n     * @private\r\n     */\r\n    var MIN_PANE_SIZE      = 75;\r\n    \r\n    /**\r\n     * Command Object for splitting vertically\r\n     * @type {!Command}\r\n     * @private\r\n     */\r\n    var _cmdSplitVertically;\r\n\r\n    /**\r\n     * Command Object for splitting horizontally\r\n     * @type {!Command} \r\n     * @private\r\n     */\r\n    var _cmdSplitHorizontally;\r\n    \r\n    /**\r\n     * current orientation (null, VERTICAL or HORIZONTAL)\r\n     * @type {string=} \r\n     * @private\r\n     */\r\n    var _orientation = null;\r\n    \r\n    /**\r\n     * current pane id. May not be null\r\n     * @type {!string}\r\n     * @private\r\n     */\r\n    var _activePaneId = null;\r\n    \r\n    /**\r\n     * DOM element hosting the Main View.\r\n     * @type {jQuery}\r\n     * @private\r\n     */\r\n    var _$el;\r\n    \r\n    /**\r\n     * Maps paneId to Pane objects\r\n     * @type {Object.<string, Pane>} \r\n     * @private\r\n     */\r\n    var _panes = {};\r\n    \r\n    \r\n    /**\r\n     * map of pane scroll states\r\n     * @type {Object.map<string, *>} \r\n     * @private\r\n     */\r\n    var _paneScrollStates = {};\r\n    \r\n    \r\n    /**\r\n     * flag indicating if traversing is currently taking place\r\n     * When True, changes the current pane\'s MRU list will not be updated. \r\n     * Useful for next/previous keyboard navigation (until Ctrl is released)\r\n     * or for incremental-search style document preview like Quick Open will eventually have.\r\n     * @type {!boolean}\r\n     * @private\r\n     */\r\n    var _traversingFileList = false;\r\n\r\n    /**\r\n     * The global MRU list (for traversing)\r\n     * @type {Array.<file:File, paneId:string>}\r\n     */\r\n    var _mruList = [];\r\n    \r\n    /**\r\n     * localized pane titles \r\n     * @type {Object.<FIRST_PANE|SECOND_PANE, <VERTICAL.string, HORIZONTAL.string>}}\r\n     *  Localized string for first and second panes in the current orientation.  \r\n     * @see {@link getPaneTitle()} for more information\r\n     * @private\r\n     */\r\n    var _paneTitles  = {};\r\n        \r\n    /*\r\n     * Initialize _paneTitles\r\n     */\r\n    _paneTitles[FIRST_PANE] = {};\r\n    _paneTitles[SECOND_PANE] = {};\r\n    \r\n    _paneTitles[FIRST_PANE][VERTICAL]     = Strings.LEFT;\r\n    _paneTitles[FIRST_PANE][HORIZONTAL]   = Strings.TOP;\r\n    _paneTitles[SECOND_PANE][VERTICAL]    = Strings.RIGHT;\r\n    _paneTitles[SECOND_PANE][HORIZONTAL]  = Strings.BOTTOM;\r\n    \r\n    /**\r\n     * Makes a MRU List Entry\r\n     * @param {!File} File - the file\r\n     * @param {!string} paneId - the paneId\r\n     * @return {{file:File, paneId:string}}\r\n     * @private\r\n     */\r\n    function _makeMRUListEntry(file, paneId) {\r\n        return {file: file, paneId: paneId};\r\n    }\r\n    \r\n    /**\r\n     * Retrieves the currently active Pane Id\r\n     * @return {!string} Active Pane\'s ID.\r\n     */\r\n    function getActivePaneId() {\r\n        return _activePaneId;\r\n    }\r\n    \r\n    /**\r\n     * Retrieves the Pane object for the given paneId\r\n     * @param {!string} paneId - id of the pane to retrieve\r\n     * @return {?Pane} the Pane object or null if a pane object doesn\'t exist for the pane\r\n     * @private\r\n     */\r\n    function _getPane(paneId) {\r\n        if (!paneId || paneId === ACTIVE_PANE) {\r\n            paneId = getActivePaneId();\r\n        }\r\n        \r\n        if (_panes[paneId]) {\r\n            return _panes[paneId];\r\n        }\r\n        \r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Focuses the current pane. If the current pane has a current view, then the pane will focus the view.\r\n     */\r\n    function focusActivePane() {\r\n        _getPane(ACTIVE_PANE).focus();\r\n    }\r\n    \r\n    /**\r\n     * Determines if the pane id is a special pane id\r\n     * @param {!string} paneId - the id to test\r\n     * @return {boolean} true if the pane id is a special identifier, false if not\r\n     */\r\n    function _isSpecialPaneId(paneId) {\r\n        return paneId === ACTIVE_PANE || paneId === ALL_PANES;\r\n    }\r\n    \r\n    /**\r\n     * Makes the file the most recent for the pane and the global mru lists\r\n     * @param {!string} paneId - id of the pane to mae th file most recent or ACTIVE_PANE\r\n     * @param {!File} file - File object to make most recent\r\n     * @private\r\n     */\r\n    function _makeFileMostRecent(paneId, file) {\r\n        var index,\r\n            entry,\r\n            pane = _getPane(paneId);\r\n\r\n        if (!_traversingFileList) {\r\n            pane.makeViewMostRecent(file);\r\n        \r\n            index = _.findIndex(_mruList, function (record) {\r\n                return (record.file === file && record.paneId === paneId);\r\n            });\r\n\r\n            entry = _makeMRUListEntry(file, pane.id);\r\n\r\n            if (index !== -1) {\r\n                _mruList.splice(index, 1);\r\n                _mruList.unshift(entry);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Makes the Pane\'s current file the most recent\r\n     * @param {!string} paneId - id of the pane to mae th file most recent or ACTIVE_PANE\r\n     * @param {!File} file - File object to make most recent\r\n     * @private\r\n     */\r\n    function _makePaneMostRecent(paneId) {\r\n        var index,\r\n            entry,\r\n            pane = _getPane(paneId);\r\n\r\n        if (pane.getCurrentlyViewedFile()) {\r\n            _makeFileMostRecent(paneId, pane.getCurrentlyViewedFile());\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Switch active pane to the specified pane Id\r\n     * @param {!string} paneId - the id of the pane to activate\r\n     */\r\n    function setActivePaneId(newPaneId) {\r\n        if (!_isSpecialPaneId(newPaneId) && newPaneId !== _activePaneId) {\r\n            var oldPaneId = _activePaneId,\r\n                oldPane = _getPane(ACTIVE_PANE),\r\n                newPane = _getPane(newPaneId);\r\n            \r\n            if (!newPane) {\r\n                throw new Error("invalid pane id: " + newPaneId);\r\n            }\r\n            \r\n            _activePaneId = newPaneId;\r\n            \r\n            $(exports).triggerHandler("activePaneChange", [newPaneId, oldPaneId]);\r\n            $(exports).triggerHandler("currentFileChange", [_getPane(ACTIVE_PANE).getCurrentlyViewedFile(),\r\n                                                            newPaneId,\r\n                                                            oldPane.getCurrentlyViewedFile(),\r\n                                                            oldPaneId]);\r\n            \r\n            _makePaneMostRecent(_activePaneId);\r\n        }\r\n        \r\n        focusActivePane();\r\n    }\r\n    \r\n    /**\r\n     * Retrieves the Pane ID for the specified container\r\n     * @param {!jQuery} $el - the element of the pane to fetch\r\n     * @return {?string} the id of the pane that matches the container or undefined if a pane doesn\'t exist for that container\r\n     */\r\n    function _getPaneFromElement($el) {\r\n        return _.find(_panes, function (pane) {\r\n            if (pane.$el[0] === $el[0]) {\r\n                return pane;\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Retrieves the currently viewed file of the specified paneId\r\n     * @param {string=} paneId - the id of the pane in which to retrieve the currently viewed file\r\n     * @return {?File} File object of the currently viewed file, null if there isn\'t one or undefined if there isn\'t a matching pane\r\n     */\r\n    function getCurrentlyViewedFile(paneId) {\r\n        var pane = _getPane(paneId);\r\n        return pane ? pane.getCurrentlyViewedFile() : null;\r\n    }\r\n \r\n    /**\r\n     * Retrieves the currently viewed path of the pane specified by paneId\r\n     * @param {!string} paneId - the id of the pane in which to retrieve the currently viewed path\r\n     * @return {?string} the path of the currently viewed file or null if there isn\'t one\r\n     */\r\n    function getCurrentlyViewedPath(paneId) {\r\n        var file = getCurrentlyViewedFile(paneId);\r\n        return file ? file.fullPath : null;\r\n    }\r\n    \r\n    /**\r\n     * EditorManager.activeEditorChange handler \r\n     *   This event is triggered when an visible editor gains focus\r\n     *   Therefore we need to Activate the pane that the active editor belongs to\r\n     * @private\r\n     * @param {!jQuery.Event} e - jQuery Event object\r\n     * @param {Editor=} current - editor being made the current editor\r\n     */\r\n    function _activeEditorChange(e, current) {\r\n        if (current) {\r\n            var $container = current.$el.parent().parent(),\r\n                pane = _getPaneFromElement($container);\r\n\r\n            if (pane) {\r\n                // Editor is a full editor\r\n                if (pane.id !== _activePaneId) {\r\n                    // we just need to set the active pane in this case\r\n                    //  it will dispatch the currentFileChange message as well\r\n                    //  as dispatching other events when the active pane changes\r\n                    setActivePaneId(pane.id);\r\n                }\r\n            } else {\r\n                // Editor is an inline editor, find the parent pane\r\n                var parents = $container.parents(".view-pane");\r\n                if (parents.length === 1) {\r\n                    $container = $(parents[0]);\r\n                    pane = _getPaneFromElement($container);\r\n                    if (pane) {\r\n                        if (pane.id !== _activePaneId) {\r\n                            // activate the pane which will put focus in the pane\'s doc\r\n                            setActivePaneId(pane.id);\r\n                            // reset the focus to the inline editor\r\n                            current.focus();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Iterates over the pane or ALL_PANES and calls the callback function for each.\r\n     * @param {!string} paneId - id of the pane in which to adjust the scroll state, ALL_PANES or ACTIVE_PANE\r\n     * @param {!function(!pane:Pane):boolean} callback - function to callback on to perform work. \r\n     * The callback will receive a Pane and should return false to stop iterating.\r\n     * @private\r\n     */\r\n    function _forEachPaneOrPanes(paneId, callback) {\r\n        if (paneId === ALL_PANES) {\r\n            _.forEach(_panes, callback);\r\n        } else {\r\n            callback(_getPane(paneId));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Caches the specified pane\'s current scroll state\r\n     * If there was already cached state for the specified pane, it is discarded and overwritten\r\n     * @param {!string} paneId - id of the pane in which to cache the scroll state,\r\n     *                            ALL_PANES or ACTIVE_PANE\r\n     */\r\n    function cacheScrollState(paneId) {\r\n        _forEachPaneOrPanes(paneId, function (pane) {\r\n            _paneScrollStates[pane.id] = pane.getScrollState();\r\n        });\r\n    }\r\n\r\n    \r\n    /**\r\n     * Restores the scroll state from cache and applies the heightDelta \r\n     * The view implementation is responsible for applying or ignoring the heightDelta.\r\n     * This is used primarily when a modal bar opens to keep the editor from scrolling the current \r\n     * page out of view in order to maintain the appearance. \r\n     * The state is removed from the cache after calling this function.  \r\n     * @param {!string} paneId - id of the pane in which to adjust the scroll state, \r\n     *                              ALL_PANES or ACTIVE_PANE\r\n     * @param {!number} heightDelta - delta H to apply to the scroll state\r\n     */\r\n    function restoreAdjustedScrollState(paneId, heightDelta) {\r\n        _forEachPaneOrPanes(paneId, function (pane) {\r\n            pane.restoreAndAdjustScrollState(_paneScrollStates[pane.id], heightDelta);\r\n            delete _paneScrollStates[pane.id];\r\n        });\r\n    }\r\n        \r\n    \r\n    /**\r\n     * Retrieves the WorkingSet for the given PaneId not including temporary views\r\n     * @param {!string} paneId - id of the pane in which to get the view list, ALL_PANES or ACTIVE_PANE\r\n     * @return {Array.<File>}\r\n     */\r\n    function getWorkingSet(paneId) {\r\n        var result = [];\r\n\r\n        _forEachPaneOrPanes(paneId, function (pane) {\r\n            var viewList = pane.getViewList();\r\n            result = _.union(result, viewList);\r\n        });\r\n\r\n        return result;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Retrieves the list of all open files inlcuding temporary views\r\n     * @return {array.<File>} the list of all open files in all open panes\r\n     */\r\n    function getAllOpenFiles() {\r\n        var result = getWorkingSet(ALL_PANES);\r\n        _.forEach(_panes, function (pane) {\r\n            var file = pane.getCurrentlyViewedFile();\r\n            if (file) {\r\n                result = _.union(result, [file]);\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Retrieves the list of all open pane ids\r\n     * @return {array.<string>} the list of all open panes\r\n     */\r\n    function getPaneIdList() {\r\n        return Object.keys(_panes);\r\n    }\r\n    \r\n    /**\r\n     * Retrieves the size of the selected pane\'s view list\r\n     * @param {!string} paneId - id of the pane in which to get the workingset size.\r\n     *      Can use `ALL_PANES` or `ACTIVE_PANE`\r\n     * @return {!number} the number of items in the specified pane \r\n     */\r\n    function getWorkingSetSize(paneId) {\r\n        var result = 0;\r\n        _forEachPaneOrPanes(paneId, function (pane) {\r\n            result += pane.getViewListSize();\r\n        });\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Retrieves the title to display in the workingset view\r\n     * @param {!string} paneId - id of the pane in which to get the title\r\n     * @return {?string} title\r\n     */\r\n    function getPaneTitle(paneId) {\r\n        return _paneTitles[paneId][_orientation];\r\n    }\r\n    \r\n    /**\r\n     * Retrieves the number of panes\r\n     * @return {number} \r\n     */\r\n    function getPaneCount() {\r\n        return Object.keys(_panes).length;\r\n    }\r\n    \r\n    /**\r\n     * Helper to abastract the common working set search functions\r\n     * @param {!string} paneId - id of the pane to search or ALL_PANES to search all panes\r\n     * @param {!string} fullPath - path of the file to locate\r\n     * @param {!string} method - name of the method to use for searching \r\n     *       "findInViewList", "findInViewListAddedOrder" or "FindInViewListMRUOrder" \r\n     * \r\n     * @private\r\n     */\r\n    function _doFindInWorkingSet(paneId, fullPath, method) {\r\n        var result = -1;\r\n        _forEachPaneOrPanes(paneId, function (pane) {\r\n            var index = pane[method].call(pane, fullPath);\r\n            if (index >= 0) {\r\n                result = index;\r\n                return false;\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Finds all instances of the specified file in all working sets.  \r\n     * If there is a temporary view of the file, it is not part of the result set\r\n     * @param {!string} fullPath - path of the file to find views of\r\n     * @return {Array.<{pane:string, index:number}>} an array of paneId/index records \r\n     */\r\n    function findInAllWorkingSets(fullPath) {\r\n        var index,\r\n            result = [];\r\n        \r\n        _.forEach(_panes, function (pane) {\r\n            index = pane.findInViewList(fullPath);\r\n            if (index >= 0) {\r\n                result.push({paneId: pane.id, index: index});\r\n            }\r\n        });\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Gets the index of the file matching fullPath in the workingset\r\n     * @param {!string} paneId - id of the pane in which to search or ALL_PANES or ACTIVE_PANE\r\n     * @param {!string} fullPath - full path of the file to search for\r\n     * @return {number} index, -1 if not found.\r\n     */\r\n    function findInWorkingSet(paneId, fullPath) {\r\n        return _doFindInWorkingSet(paneId, fullPath, "findInViewList");\r\n    }\r\n    \r\n    /**\r\n     * Gets the index of the file matching fullPath in the added order workingset\r\n     * @param {!string} paneId - id of the pane in which to search or ALL_PANES or ACTIVE_PANE\r\n     * @param {!string} fullPath - full path of the file to search for\r\n     * @return {number} index, -1 if not found.\r\n     */\r\n    function findInWorkingSetByAddedOrder(paneId, fullPath) {\r\n        return _doFindInWorkingSet(paneId, fullPath, "findInViewListAddedOrder");\r\n    }\r\n    \r\n    /**\r\n     * Gets the index of the file matching fullPath in the MRU order workingset\r\n     * @param {!string} paneId - id of the pane in which to search or ALL_PANES or ACTIVE_PANE\r\n     * @param {!string} fullPath - full path of the file to search for\r\n     * @return {number} index, -1 if not found.\r\n     */\r\n    function findInWorkingSetByMRUOrder(paneId, fullPath) {\r\n        return _doFindInWorkingSet(paneId, fullPath, "findInViewListMRUOrder");\r\n    }\r\n\r\n    /**\r\n     * @private \r\n     * Retrieves pane id where the specified file has been opened. Used to ensure that a file\r\n     *  is open in only one pane so this will change once support for multiple views is added\r\n     * The result includes panes with a temporary view of the file not just working set instances\r\n     * @param {!string} fullPath - full path of the file to search for\r\n     * @return {?string} pane id where the file has been opened or null if it wasn\'t found\r\n     */\r\n    function _getPaneIdForPath(fullPath) {\r\n        // Search all working sets and pull off the first one\r\n        var info = findInAllWorkingSets(fullPath).shift();\r\n\r\n        // Look for a view that has not been added to a working set\r\n        if (!info) {\r\n            _.forEach(_panes, function (pane) {\r\n                if (pane.getCurrentlyViewedPath() === fullPath) {\r\n                    info = {paneId: pane.id};\r\n                    return false;\r\n                }\r\n            });\r\n        }\r\n        \r\n        if (!info) {\r\n            return null;\r\n        }\r\n\r\n        return info.paneId;\r\n    }\r\n    \r\n    /**\r\n     * Adds the given file to the end of the workingset, if it is not already there.  \r\n     *  This API does not create a view of the file, it just adds it to the working set\r\n     * Views of files in the working set are persisted and are not destroyed until the user \r\n     *  closes the file using FILE_CLOSE; Views are created using FILE_OPEN and, when opened, are\r\n     *  made the current view. If a File is already opened then the file is just made current\r\n     *  and its view is shown.\r\n     * @param {!string} paneId - The id of the pane in which to add the file object to or ACTIVE_PANE\r\n     * @param {!File} file - The File object to add to the workingset\r\n     * @param {number=} index - Position to add to list (defaults to last); -1 is ignored\r\n     * @param {boolean=} forceRedraw - If true, a workingset change notification is always sent\r\n     *    (useful if suppressRedraw was used with removeView() earlier)\r\n     */\r\n    function addToWorkingSet(paneId, file, index, force) {\r\n        // look for the file to have already been added to another pane\r\n        var pane = _getPane(paneId),\r\n            existingPaneId = _getPaneIdForPath(file.fullPath);\r\n\r\n        if (!pane) {\r\n            throw new Error("invalid pane id: " + paneId);\r\n        }\r\n\r\n        if (findInWorkingSet(ALL_PANES, file.fullPath) !== -1) {\r\n            return;\r\n        }\r\n        \r\n        // if it\'s already open in another pane, then just use that pane\r\n        if (existingPaneId && existingPaneId !== pane.id) {\r\n            pane = _getPane(existingPaneId);\r\n        }\r\n        \r\n        var result = pane.reorderItem(file, index, force),\r\n            entry = _makeMRUListEntry(file, pane.id);\r\n\r\n        \r\n        // handles the case of save as so that the file remains in the \r\n        //  the same location in the working set as the file that was renamed\r\n        if (result === pane.ITEM_FOUND_NEEDS_SORT) {\r\n            console.warn("pane.reorderItem returned pane.ITEM_FOUND_NEEDS_SORT which shouldn\'t happen " + file);\r\n            $(exports).triggerHandler("workingSetSort", [pane.id]);\r\n        } else if (result === pane.ITEM_NOT_FOUND) {\r\n            index = pane.addToViewList(file, index);\r\n\r\n            // Add to or update the position in MRU\r\n            if (pane.getCurrentlyViewedFile() === file) {\r\n                _mruList.unshift(entry);\r\n            } else {\r\n                _mruList.push(entry);\r\n            }\r\n\r\n            $(exports).triggerHandler("workingSetAdd", [file, index, pane.id]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds the given file list to the end of the workingset.\r\n     * @param {!string} paneId - The id of the pane in which to add the file object to or ACTIVE_PANE\r\n     * @param {!Array.<File>} fileList - Array of files to add to the pane\r\n     */\r\n    function addListToWorkingSet(paneId, fileList) {\r\n        var uniqueFileList,\r\n            pane = _getPane(paneId);\r\n\r\n        uniqueFileList = pane.addListToViewList(fileList);\r\n        \r\n        uniqueFileList.forEach(function (file) {\r\n            _mruList.push(_makeMRUListEntry(file, pane.id));\r\n        });\r\n        \r\n        $(exports).triggerHandler("workingSetAddList", [uniqueFileList, pane.id]);\r\n        \r\n        //  find all of the files that could be added but were not \r\n        var unsolvedList = fileList.filter(function (item) {\r\n            // if the file open in another pane, then add it to the list of unsolvedList\r\n            return (pane.findInViewList(item.fullPath) === -1 && _getPaneIdForPath(item.fullPath));\r\n        });\r\n\r\n        // Use the pane id of the first one in the list for pane id and recurse\r\n        //  if we add more panes, then this will recurse until all items in the list are satisified\r\n        if (unsolvedList.length) {\r\n            addListToWorkingSet(_getPaneIdForPath(unsolvedList[0].fullPath), unsolvedList);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Removes a file from the global MRU list. Future versions of this \r\n     *  implementation may support the ALL_PANES constant but FOCUS_PANE is not allowed\r\n     * @param {!string} paneId - Must be a valid paneId (not a shortcut e.g. ALL_PANES)\r\n     @ @param {File} file The file object to remove.\r\n     * @private\r\n     */\r\n    function _removeFileFromMRU(paneId, file) {\r\n        var index,\r\n            compare = function (record) {\r\n                return (record.file === file && record.paneId === paneId);\r\n            };\r\n        \r\n        // find and remove all instances\r\n        do {\r\n            index = _.findIndex(_mruList, compare);\r\n            if (index !== -1) {\r\n                _mruList.splice(index, 1);\r\n            }\r\n        } while (index !== -1);\r\n    }\r\n    \r\n    /**\r\n     * Removes a file the specified pane\r\n     * @param {!string} paneId - Must be a valid paneId (not a shortcut e.g. ALL_PANES)\r\n     * @param {!File} file - the File to remove\r\n     * @param {boolean=} suppressRedraw - true to tell listeners not to redraw \r\n     *          Use the suppressRedraw flag when calling this function along with many changes to prevent flicker\r\n     * @private\r\n     */\r\n    function _removeView(paneId, file, suppressRedraw) {\r\n        var pane = _getPane(paneId);\r\n\r\n        if (pane.removeView(file)) {\r\n            _removeFileFromMRU(pane.id, file);\r\n            $(exports).triggerHandler("workingSetRemove", [file, suppressRedraw, pane.id]);\r\n        }\r\n    }\r\n    \r\n    function _removeDeletedFileFromMRU(e, fullPath) {\r\n        var index,\r\n            compare = function (record) {\r\n                return (record.file.fullPath === fullPath);\r\n            };\r\n        \r\n        // find and remove all instances\r\n        do {\r\n            index = _.findIndex(_mruList, compare);\r\n            if (index !== -1) {\r\n                _mruList.splice(index, 1);\r\n            }\r\n        } while (index !== -1);\r\n    }\r\n    \r\n    /**\r\n     * sorts the pane\'s view list \r\n     * @param {!string} paneId - id of the pane to sort, ALL_PANES or ACTIVE_PANE\r\n     * @param {sortFunctionCallback} compareFn - callback to determine sort order (called on each item)\r\n     * @see {@link Pane.sortViewList()} for more information\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort|Sort Array - MDN}\r\n     * @privaate\r\n     */\r\n    function _sortWorkingSet(paneId, compareFn) {\r\n        _forEachPaneOrPanes(paneId, function (pane) {\r\n            pane.sortViewList(compareFn);\r\n            $(exports).triggerHandler("workingSetSort", [pane.id]);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Mutually exchanges the files at the indexes passed by parameters.\r\n     * @param {!string} paneId - id of the pane to swap indices or ACTIVE_PANE\r\n     * @param {!number} index1 - the index on the left\r\n     * @param {!number} index2 - the index on the rigth\r\n     * @private\r\n     */\r\n    function _swapWorkingSetListIndexes(paneId, index1, index2) {\r\n        var pane = _getPane(paneId);\r\n\r\n        pane.swapViewListIndexes(index1, index2);\r\n        $(exports).triggerHandler("workingSetSort", [pane.id]);\r\n        $(exports).triggerHandler("_workingSetDisableAutoSort", [pane.id]);\r\n    }\r\n    \r\n    /**\r\n     * Get the next or previous file in the MRU list.\r\n     * @param {!number} direction - Must be 1 or -1 to traverse forward or backward\r\n     * @return {?{file:File, paneId:string}} The File object of the next item in the travesal order or null if there aren\'t any files to traverse.\r\n     *                                        may return current file if there are no other files to traverse.\r\n     */\r\n    function traverseToNextViewByMRU(direction) {\r\n        var file = getCurrentlyViewedFile(),\r\n            paneId = getActivePaneId(),\r\n            index = _.findIndex(_mruList, function (record) {\r\n                return (record.file === file && record.paneId === paneId);\r\n            });\r\n        \r\n        return ViewUtils.traverseViewArray(_mruList, index, direction);\r\n    }\r\n    \r\n    /**\r\n     * Indicates that traversal has begun. \r\n     * Can be called any number of times.\r\n     */\r\n    function beginTraversal() {\r\n        _traversingFileList = true;\r\n    }\r\n    \r\n    /**\r\n     * Un-freezes the MRU list after one or more beginTraversal() calls.\r\n     * Whatever file is current is bumped to the front of the MRU list.\r\n     */\r\n    function endTraversal() {\r\n        var pane = _getPane(ACTIVE_PANE);\r\n        \r\n        if (_traversingFileList) {\r\n            _traversingFileList = false;\r\n            \r\n            _makeFileMostRecent(pane.id, pane.getCurrentlyViewedFile());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Synchronizes the pane\'s sizer element, updates the pane\'s resizer maxsize value \r\n     *   and tells the pane to update its layout\r\n     * @param {boolean} forceRefresh - true to force a resize and refresh of the entire view\r\n     * @private\r\n     */\r\n    function _synchronizePaneSize(pane, forceRefresh) {\r\n        var available;\r\n        \r\n        if (_orientation === VERTICAL) {\r\n            available = _$el.innerWidth();\r\n        } else {\r\n            available = _$el.innerHeight();\r\n        }\r\n    \r\n        // Update the pane\'s sizer element if it has one and update the max size\r\n        Resizer.resyncSizer(pane.$el);\r\n        pane.$el.data("maxsize", available - MIN_PANE_SIZE);\r\n        pane.updateLayout(forceRefresh);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Event handler for "workspaceUpdateLayout" to update the layout\r\n     * @param {jQuery.Event} event - jQuery event object\r\n     * @param {number} viewAreaHeight - unused\r\n     * @param {boolean} forceRefresh - true to force a resize and refresh of the entire view\r\n     * @private\r\n     */\r\n    function _updateLayout(event, viewAreaHeight, forceRefresh) {\r\n        var available;\r\n        \r\n        if (_orientation === VERTICAL) {\r\n            available = _$el.innerWidth();\r\n        } else {\r\n            available = _$el.innerHeight();\r\n        }\r\n        \r\n        _.forEach(_panes, function (pane) {\r\n            // For VERTICAL orientation, we set the second pane to be width: auto\r\n            //  so that it resizes to fill the available space in the containing div\r\n            // unfortunately, that doesn\'t work in the HORIZONTAL orientation so we \r\n            //  must update the height and convert it into a percentage\r\n            if (pane.id === SECOND_PANE && _orientation === HORIZONTAL) {\r\n                var percentage = ((_panes[FIRST_PANE].$el.height() + 1) / available);\r\n                pane.$el.css("height", 100 - (percentage * 100) + "%");\r\n            }\r\n\r\n            _synchronizePaneSize(pane, forceRefresh);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Sets up the initial layout so panes are evenly distributed\r\n     * This also sets css properties that aid in the layout when _updateLayout is called\r\n     * @param {boolean} forceRefresh - true to force a resize and refresh of the entire view\r\n     * @private\r\n     */\r\n    function _initialLayout(forceRefresh) {\r\n        var panes = Object.keys(_panes),\r\n            size = 100 / panes.length;\r\n        \r\n        _.forEach(_panes, function (pane) {\r\n            if (pane.id === FIRST_PANE) {\r\n                if (_orientation === VERTICAL) {\r\n                    pane.$el.css({height: "100%",\r\n                                  width: size + "%",\r\n                                  float: "left"\r\n                                 });\r\n                } else {\r\n                    pane.$el.css({ height: size + "%",\r\n                                   width: "100%"\r\n                                 });\r\n                }\r\n            } else {\r\n                if (_orientation === VERTICAL) {\r\n                    pane.$el.css({  height: "100%",\r\n                                    width: "auto",\r\n                                    float: "none"\r\n                                 });\r\n                } else {\r\n                    pane.$el.css({ width: "100%",\r\n                                   height: "50%"\r\n                                 });\r\n                }\r\n            }\r\n            \r\n            _synchronizePaneSize(pane, forceRefresh);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Updates the command check states of the split vertical and split horizontal commands\r\n     * @private\r\n     */\r\n    function _updateCommandState() {\r\n        _cmdSplitVertically.setChecked(_orientation === VERTICAL);\r\n        _cmdSplitHorizontally.setChecked(_orientation === HORIZONTAL);\r\n    }\r\n    \r\n    /**\r\n     * Creates a pane for paneId if one doesn\'t already exist\r\n     * @param {!string} paneId - id of the pane to create\r\n     * @private\r\n     * @return {Pane} - the pane object of the pane \r\n     */\r\n    function _createPaneIfNecessary(paneId) {\r\n        var currentPane,\r\n            pane;\r\n        \r\n        if (!_panes.hasOwnProperty(paneId)) {\r\n            pane = new Pane(paneId, _$el);\r\n            _panes[paneId] = pane;\r\n            \r\n            $(exports).triggerHandler("paneCreate", [pane.id]);\r\n            \r\n            pane.$el.on("click.mainview dragover.mainview", function () {\r\n                setActivePaneId(pane.id);\r\n            });\r\n\r\n            $(pane).on("viewListChange.mainview", function () {\r\n                $(exports).triggerHandler("workingSetUpdate", [pane.id]);\r\n            });\r\n            $(pane).on("currentViewChange.mainview", function (e, newView, oldView) {\r\n                if (_activePaneId === pane.id) {\r\n                    $(exports).triggerHandler("currentFileChange",\r\n                                              [newView && newView.getFile(),\r\n                                               pane.id, oldView && oldView.getFile(),\r\n                                               pane.id]);\r\n                }\r\n            });\r\n        }\r\n\r\n        \r\n        return _panes[paneId];\r\n    }\r\n    \r\n    /**\r\n     * Makes the first pane resizable\r\n     * @private\r\n     */\r\n    function _makeFirstPaneResizable() {\r\n        var firstPane = _panes[FIRST_PANE];\r\n        Resizer.makeResizable(firstPane.$el,\r\n                              _orientation === HORIZONTAL ? Resizer.DIRECTION_VERTICAL : Resizer.DIRECTION_HORIZONTAL,\r\n                              _orientation === HORIZONTAL ? Resizer.POSITION_BOTTOM : Resizer.POSITION_RIGHT,\r\n                              MIN_PANE_SIZE, false, false, false, true);\r\n        \r\n        firstPane.$el.on("panelResizeUpdate", function () {\r\n            _updateLayout();\r\n        });\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Creates a split for the specified orientation\r\n     * @private\r\n     * @param {!string} orientation (VERTICAL|HORIZONTAL)\r\n     */\r\n    function _doSplit(orientation) {\r\n        var firstPane = _panes[FIRST_PANE];\r\n        Resizer.removeSizable(firstPane.$el);\r\n\r\n        _orientation = orientation;\r\n        _createPaneIfNecessary(SECOND_PANE);\r\n        _makeFirstPaneResizable();\r\n        _updateCommandState();\r\n        \r\n        // reset the layout to 50/50 split\r\n        // if we changed orientation then\r\n        //  the percentages are reset as well\r\n        _initialLayout();\r\n        \r\n        $(exports).triggerHandler("paneLayoutChange", [_orientation]);\r\n    }\r\n    \r\n    /**\r\n     * Edits a document in the specified pane.\r\n     * This function is only used by Unit Tests (which construct Mock Documents), \r\n     *  The Deprecated API "setCurrentDocument" and by File > New \r\n     *  because there is yet to be an established File object for the Document which is required \r\n     *  for the open API.  \r\n     * Do not use this API unless you have a document object without a file object\r\n     * @param {!string} paneId - id of the pane in which to open the document\r\n     * @param {!Document} doc - document to edit\r\n     * @private\r\n     */\r\n    function _edit(paneId, doc) {\r\n        var currentPaneId = _getPaneIdForPath(doc.file.fullPath),\r\n            oldPane = _getPane(ACTIVE_PANE),\r\n            oldFile = oldPane.getCurrentlyViewedFile();\r\n            \r\n        if (currentPaneId) {\r\n            // If the doc is open in another pane\r\n            //  then switch to that pane and call open document\r\n            //  which will really just show the view as it has always done\r\n            //  we could just do pane.showView(doc._masterEditor) in that\r\n            //  case but Editor Manager may do some state syncing \r\n            paneId = currentPaneId;\r\n            setActivePaneId(paneId);\r\n        }\r\n        \r\n        var pane = _getPane(paneId);\r\n        \r\n        // If file is untitled or otherwise not within project tree, add it to\r\n        // working set right now (don\'t wait for it to become dirty)\r\n        if (doc.isUntitled() || !ProjectManager.isWithinProject(doc.file.fullPath)) {\r\n            addToWorkingSet(paneId, doc.file);\r\n        }\r\n        \r\n        // open document will show the editor if there is one already\r\n        EditorManager.openDocument(doc, pane);\r\n        _makeFileMostRecent(paneId, doc.file);\r\n    }\r\n    \r\n    /**\r\n     * Opens a file in the specified pane this can be used to open a file with a custom viewer\r\n     * or a document for editing.  If it\'s a document for editing, edit is called on the document \r\n     * @param {!string} paneId - id of the pane in which to open the document\r\n     * @param {!File} file - file to open\r\n     * @return {jQuery.Promise}  promise that resolves to a File object or \r\n     *                           rejects with a File error or string\r\n     */\r\n    function _open(paneId, file) {\r\n        var oldPane = _getPane(ACTIVE_PANE),\r\n            oldFile = oldPane.getCurrentlyViewedFile(),\r\n            result = new $.Deferred();\r\n        \r\n        if (!file || !_getPane(paneId)) {\r\n            throw new Error("bad argument");\r\n        }\r\n\r\n        var currentPaneId = _getPaneIdForPath(file.fullPath);\r\n\r\n        if (currentPaneId) {\r\n            // If the doc is open in another pane\r\n            //  then switch to that pane and call open document\r\n            //  which will really just show the view as it has always done\r\n            //  we could just do pane.showView(doc._masterEditor) in that\r\n            //  case but Editor Manager may do some state syncing             \r\n            paneId = currentPaneId;\r\n            setActivePaneId(paneId);\r\n        }\r\n        \r\n        // See if there is already a view for the file\r\n        var pane = _getPane(paneId),\r\n            view = pane.getViewForPath(file.fullPath);\r\n\r\n        // See if there is a factory to create a view for this file\r\n        //  we want to do this first because, we don\'t want our internal \r\n        //  editor to edit files for which there are suitable viewfactories\r\n        var factory = MainViewFactory.findSuitableFactoryForPath(file.fullPath);\r\n\r\n        if (factory) {\r\n            file.exists(function (fileError, fileExists) {\r\n                if (fileExists) {\r\n                    // let the factory open the file and create a view for it\r\n                    factory.openFile(file, pane)\r\n                        .done(function () {\r\n                            // if we opened a file that isn\'t in the project\r\n                            //  then add the file to the working set\r\n                            if (!ProjectManager.isWithinProject(file.fullPath)) {\r\n                                addToWorkingSet(paneId, file);\r\n                            }\r\n                            result.resolve(file);\r\n                        })\r\n                        .fail(function (fileError) {\r\n                            result.reject(fileError);\r\n                        });\r\n                } else {\r\n                    result.reject(fileError || FileSystemError.NOT_FOUND);\r\n                }\r\n            });\r\n        } else {\r\n            DocumentManager.getDocumentForPath(file.fullPath)\r\n                .done(function (doc) {\r\n                    _edit(paneId, doc);\r\n                    result.resolve(doc.file);\r\n                })\r\n                .fail(function (fileError) {\r\n                    result.reject(fileError);\r\n                });\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Merges second pane into first pane and opens the current file\r\n     * @private\r\n     */\r\n    function _mergePanes() {\r\n        if (_panes.hasOwnProperty(SECOND_PANE)) {\r\n            \r\n            var firstPane = _panes[FIRST_PANE],\r\n                secondPane = _panes[SECOND_PANE],\r\n                fileList = secondPane.getViewList(),\r\n                lastViewed = getCurrentlyViewedFile();\r\n            \r\n            Resizer.removeSizable(firstPane.$el);\r\n            firstPane.mergeFrom(secondPane);\r\n        \r\n            $(exports).triggerHandler("workingSetRemoveList", [fileList, secondPane.id]);\r\n\r\n            setActivePaneId(firstPane.id);\r\n            \r\n            secondPane.$el.off(".mainview");\r\n            $(secondPane).off(".mainview");\r\n\r\n            secondPane.destroy();\r\n            delete _panes[SECOND_PANE];\r\n            $(exports).triggerHandler("paneDestroy", secondPane.id);\r\n            $(exports).triggerHandler("workingSetAddList", [fileList, firstPane.id]);\r\n\r\n            _mruList.forEach(function (record) {\r\n                if (record.paneId === secondPane.id) {\r\n                    record.paneId = firstPane.id;\r\n                }\r\n            });\r\n            \r\n            _orientation = null;\r\n            // this will set the remaining pane to 100%\r\n            _initialLayout();\r\n            _updateCommandState();\r\n            \r\n            $(exports).triggerHandler("paneLayoutChange", [_orientation]);\r\n\r\n            // if the current view before the merger was in the pane\r\n            //  that went away then reopen it so that it\'s now the current view again\r\n            if (lastViewed && getCurrentlyViewedFile() !== lastViewed) {\r\n                exports._open(firstPane.id, lastViewed);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Closes a file in the specified pane or panes\r\n     * @param {!string} paneId - id of the pane in which to open the document\r\n     * @param {!File} file - file to close\r\n     * @param {Object={noOpenNextFile:boolean}} optionsIn - options \r\n     * This function does not fail if the file is not open\r\n     */\r\n    function _close(paneId, file, optionsIn) {\r\n        var options = optionsIn || {};\r\n        _forEachPaneOrPanes(paneId, function (pane) {\r\n            if (pane.removeView(file, options.noOpenNextFile)) {\r\n                _removeFileFromMRU(pane.id, file);\r\n                $(exports).triggerHandler("workingSetRemove", [file, false, pane.id]);\r\n                return false;\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Closes a list of file in the specified pane or panes\r\n     * @param {!string} paneId - id of the pane in which to open the document\r\n     * @param {!Array.<File>} fileList - files to close\r\n     * This function does not fail if the file is not open\r\n     */\r\n    function _closeList(paneId, fileList) {\r\n        _forEachPaneOrPanes(paneId, function (pane) {\r\n            var closedList = pane.removeViews(fileList);\r\n            closedList.forEach(function (file) {\r\n                _removeFileFromMRU(pane.id, file);\r\n            });\r\n\r\n            $(exports).triggerHandler("workingSetRemoveList", [closedList, pane.id]);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Closes all files in the specified pane or panes\r\n     * @param {!string} paneId - id of the pane in which to open the document\r\n     * This function does not fail if the file is not open\r\n     */\r\n    function _closeAll(paneId) {\r\n        _forEachPaneOrPanes(paneId, function (pane) {\r\n            var closedList = pane.getViewList();\r\n            closedList.forEach(function (file) {\r\n                _removeFileFromMRU(pane.id, file);\r\n            });\r\n\r\n            pane._reset();\r\n            $(exports).triggerHandler("workingSetRemoveList", [closedList, pane.id]);\r\n        });\r\n    }\r\n\r\n    \r\n    /**\r\n     * Finds which pane a document belongs to\r\n     * @param {!Document} document - the document to locate\r\n     * @return {?Pane} the pane where the document lives or NULL if it isn\'t in a pane\r\n     * @private\r\n     */\r\n    function _findPaneForDocument(document) {\r\n        // First check for an editor view of the document \r\n        var pane = _getPaneFromElement($(document._masterEditor.$el.parent().parent()));\r\n        \r\n        if (!pane) {\r\n            // No view of the document, it may be in a working set and not yet opened\r\n            var info = findInAllWorkingSets(document.file.fullPath).shift();\r\n            if (info) {\r\n                pane = _panes[info.paneId];\r\n            }\r\n        }\r\n        \r\n        return pane;\r\n    }\r\n    \r\n    /**\r\n     * Destroys an editor object if a document is no longer referenced\r\n     * @param {!Document} doc - document to destroy\r\n     */\r\n    function _destroyEditorIfNotNeeded(document) {\r\n        if (!(document instanceof DocumentManager.Document)) {\r\n            throw new Error("_destroyEditorIfUnneeded() should be passed a Document");\r\n        }\r\n        if (document._masterEditor) {\r\n            // findPaneForDocument tries to locate the pane in which the document\r\n            //  is either opened or will be opened (in the event that the document is\r\n            //  in a working set but has yet to be opened) and then asks the pane\r\n            //  to destroy the view if it doesn\'t need it anymore\r\n            var pane = _findPaneForDocument(document);\r\n            \r\n            if (pane) {\r\n                // let the pane deceide if it wants to destroy the view if it\'s no needed\r\n                pane.destroyViewIfNotNeeded(document._masterEditor);\r\n            } else {\r\n                // in this case, the document isn\'t referenced at all so just destroy it\r\n                document._masterEditor.destroy();\r\n            }\r\n        }\r\n    }\r\n\r\n    \r\n    /**\r\n     * Loads the workingset state\r\n     * @private\r\n     */\r\n    function _loadViewState(e) {\r\n        // file root is appended for each project\r\n        var panes,\r\n            filesToOpen,\r\n            viewStates,\r\n            activeFile,\r\n            promises = [],\r\n            context = { location : { scope: "user",\r\n                                     layer: "project" } },\r\n            state = PreferencesManager.getViewState(PREFS_NAME, context);\r\n\r\n        function convertViewState() {\r\n            var context = { location : { scope: "user",\r\n                                         layer: "project" } },\r\n                files = PreferencesManager.getViewState(OLD_PREFS_NAME, context);\r\n\r\n            if (!files) {\r\n                // nothing to convert\r\n                return;\r\n            }\r\n\r\n            var result = {\r\n                orientation: null,\r\n                activePaneId: FIRST_PANE,\r\n                panes: {\r\n                    "first-pane": []\r\n                }\r\n            };\r\n\r\n            // Add all files to the workingset without verifying that\r\n            // they still exist on disk (for faster project switching)\r\n            files.forEach(function (value) {\r\n                result.panes[FIRST_PANE].push(value);\r\n            });\r\n\r\n            return result;\r\n        }\r\n        \r\n        if (!state) {\r\n            // not converted yet\r\n            state = convertViewState();\r\n        }\r\n\r\n        // reset\r\n        _mergePanes();\r\n        _mruList = [];\r\n        ViewStateManager.reset();\r\n        \r\n        if (state) {\r\n\r\n            panes = Object.keys(state.panes);\r\n            _orientation = (panes.length > 1) ? state.orientation : null;\r\n\r\n            _.forEach(state.panes, function (paneState, paneId) {\r\n                var pane = _createPaneIfNecessary(paneId),\r\n                    promise = pane.loadState(paneState);\r\n                \r\n                promises.push(promise);\r\n            });\r\n\r\n            AsyncUtils.waitForAll(promises).then(function (opensList) {\r\n\r\n                // this will set the default layout of 50/50 or 100 \r\n                //  based on the number of panes\r\n                _initialLayout();\r\n                \r\n                // More than 1 pane, then make it resizable\r\n                //  and layout the panes from serialized state\r\n                if (panes.length > 1) {\r\n                    _makeFirstPaneResizable();\r\n\r\n                    // If the split state was serialized correctly\r\n                    //  then setup the splits according to was serialized\r\n                    // Avoid a zero and negative split percentages\r\n                    if ($.isNumeric(state.splitPercentage) && state.splitPercentage > 0) {\r\n                        var prop;\r\n                        if (_orientation === VERTICAL) {\r\n                            prop = "width";\r\n                        } else {\r\n                            prop = "height";\r\n                        }\r\n\r\n                        _panes[FIRST_PANE].$el.css(prop, state.splitPercentage * 100 + "%");\r\n                        _updateLayout();\r\n                    }\r\n                }\r\n                \r\n                _updateCommandState();\r\n\r\n                if (_orientation) {\r\n                    $(exports).triggerHandler("paneLayoutChange", _orientation);\r\n                }\r\n\r\n                _.forEach(_panes, function (pane) {\r\n                    var fileList = pane.getViewList();\r\n\r\n                    fileList.forEach(function (file) {\r\n                        _mruList.push(_makeMRUListEntry(file, pane.id));\r\n                    });\r\n                    $(exports).triggerHandler("workingSetAddList", [fileList, pane.id]);\r\n                });\r\n                \r\n                promises = [];\r\n                \r\n                opensList.forEach(function (openData) {\r\n                    if (openData) {\r\n                        promises.push(CommandManager.execute(Commands.FILE_OPEN, openData));\r\n                    }\r\n                });\r\n                \r\n                // finally set the active pane\r\n                AsyncUtils.waitForAll(promises).then(function () {\r\n                    setActivePaneId(state.activePaneId);\r\n                });\r\n            });\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Saves the workingset state\r\n     * @private\r\n     */\r\n    function _saveViewState() {\r\n        function _computeSplitPercentage() {\r\n            var available,\r\n                used;\r\n\r\n            if (getPaneCount() === 1) {\r\n                // just short-circuit here and\r\n                //  return 100% to avoid any rounding issues\r\n                return 1;\r\n            } else {\r\n                if (_orientation === VERTICAL) {\r\n                    available = _$el.innerWidth();\r\n                    used = _panes[FIRST_PANE].$el.width();\r\n                } else {\r\n                    available = _$el.innerHeight();\r\n                    used = _panes[FIRST_PANE].$el.height();\r\n                }\r\n\r\n                return used / available;\r\n            }\r\n        }\r\n\r\n        var projectRoot     = ProjectManager.getProjectRoot(),\r\n            context         = { location : { scope: "user",\r\n                                         layer: "project",\r\n                                         layerID: projectRoot.fullPath } },\r\n            \r\n            state = {\r\n                orientation: _orientation,\r\n                activePaneId: getActivePaneId(),\r\n                splitPercentage: _computeSplitPercentage(),\r\n                panes: {\r\n                }\r\n            };\r\n        \r\n\r\n        if (!projectRoot) {\r\n            return;\r\n        }\r\n        \r\n        _.forEach(_panes, function (pane) {\r\n            state.panes[pane.id] = pane.saveState();\r\n        });\r\n\r\n        PreferencesManager.setViewState(PREFS_NAME, state, context);\r\n    }\r\n    \r\n    /**\r\n     * Initializes the MainViewManager\'s view state\r\n     * @param {jQuery} $container - the container where the main view will live\r\n     * @private\r\n     */\r\n    function _initialize($container) {\r\n        if (_activePaneId) {\r\n            throw new Error("MainViewManager has already been initialized");\r\n        }\r\n        _$el = $container;\r\n        _createPaneIfNecessary(FIRST_PANE);\r\n        _activePaneId = FIRST_PANE;\r\n        // One-time init so the pane has the "active" appearance   \r\n        _panes[FIRST_PANE]._handleActivePaneChange(undefined, _activePaneId);\r\n        _initialLayout();\r\n    }\r\n    \r\n    /** \r\n     * handles the split vertically command\r\n     * @private\r\n     */\r\n    function _handleSplitVertically() {\r\n        if (_orientation === VERTICAL) {\r\n            _mergePanes();\r\n        } else {\r\n            _doSplit(VERTICAL);\r\n        }\r\n    }\r\n    \r\n    /** \r\n     * handles the split horizontally command\r\n     * @private\r\n     */\r\n    function _handleSplitHorizontially() {\r\n        if (_orientation === HORIZONTAL) {\r\n            _mergePanes();\r\n        } else {\r\n            _doSplit(HORIZONTAL);\r\n        }\r\n    }\r\n    \r\n    /** \r\n     * Changes the layout scheme\r\n     * @param {!number} rows (may be 1 or 2)\r\n     * @param {!number} columns (may be 1 or 2) \r\n     * @summay Rows or Columns may be 1 or 2 but both cannot be 2. 1x2, 2x1 or 1x1 are the legal values\r\n     */\r\n    function setLayoutScheme(rows, columns) {\r\n        if ((rows < 1) || (rows > 2) || (columns < 1) || (columns > 2) || (columns === 2 && rows === 2)) {\r\n            console.error("setLayoutScheme unsupported layout " + rows + ", " + columns);\r\n            return false;\r\n        }\r\n        \r\n        if (rows === columns) {\r\n            _mergePanes();\r\n        } else if (rows > columns) {\r\n            _doSplit(HORIZONTAL);\r\n        } else {\r\n            _doSplit(VERTICAL);\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /** \r\n     * Retrieves the current layout scheme\r\n     * @return {!{rows: number, columns: number>}}\r\n     */\r\n    function getLayoutScheme() {\r\n        var result = {\r\n            rows: 1,\r\n            columns: 1\r\n        };\r\n\r\n        if (_orientation === HORIZONTAL) {\r\n            result.rows = 2;\r\n        } else if (_orientation === VERTICAL) {\r\n            result.columns = 2;\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /** \r\n     * Add an app ready callback to register global commands. \r\n     */\r\n    AppInit.appReady(function () {\r\n        var menu = Menus.getMenu(Menus.AppMenuBar.VIEW_MENU);\r\n        if (menu) {\r\n            menu.addMenuDivider();\r\n            menu.addMenuItem(CMD_ID_SPLIT_VERTICALLY);\r\n            menu.addMenuItem(CMD_ID_SPLIT_HORIZONTALLY);\r\n        }\r\n        \r\n        _updateCommandState();\r\n    });\r\n\r\n    /**\r\n     * Setup a ready event to initialize ourself\r\n     */\r\n    AppInit.htmlReady(function () {\r\n        _initialize($("#editor-holder"));\r\n    });\r\n    \r\n    // Event handlers\r\n    $(ProjectManager).on("projectOpen",                       _loadViewState);\r\n    $(ProjectManager).on("beforeProjectClose beforeAppClose", _saveViewState);\r\n    $(WorkspaceManager).on("workspaceUpdateLayout",           _updateLayout);\r\n    $(EditorManager).on("activeEditorChange",                 _activeEditorChange);\r\n    $(DocumentManager).on("pathDeleted",                      _removeDeletedFileFromMRU);\r\n    \r\n    \r\n    // Init \r\n    \r\n    // NOTE: These strings and these commands will go away with the \r\n    //        the SplitView UI Story. These are Temporary Commands to\r\n    //        use the feature.\r\n    _cmdSplitVertically = CommandManager.register("Split Vertically",\r\n                                                  CMD_ID_SPLIT_VERTICALLY,\r\n                                                  _handleSplitVertically);\r\n    _cmdSplitHorizontally = CommandManager.register("Split Horizontally",\r\n                                                    CMD_ID_SPLIT_HORIZONTALLY,\r\n                                                    _handleSplitHorizontially);\r\n\r\n    // Unit Test Helpers\r\n    exports._initialize                   = _initialize;\r\n    exports._getPane                      = _getPane;\r\n        \r\n    // Private Helpers\r\n    exports._removeView                   = _removeView;\r\n    \r\n    // Private API\r\n    exports._sortWorkingSet               = _sortWorkingSet;\r\n    exports._swapWorkingSetListIndexes    = _swapWorkingSetListIndexes;\r\n    exports._destroyEditorIfNotNeeded     = _destroyEditorIfNotNeeded;\r\n    exports._edit                         = _edit;\r\n    exports._open                         = _open;\r\n    exports._close                        = _close;\r\n    exports._closeAll                     = _closeAll;\r\n    exports._closeList                    = _closeList;\r\n    exports._getPaneIdForPath             = _getPaneIdForPath;\r\n    \r\n    // WorkingSet Management  \r\n    exports.addToWorkingSet               = addToWorkingSet;\r\n    exports.addListToWorkingSet           = addListToWorkingSet;\r\n    exports.getWorkingSetSize             = getWorkingSetSize;\r\n    exports.getWorkingSet                 = getWorkingSet;\r\n    \r\n    // Pane state\r\n    exports.cacheScrollState              = cacheScrollState;\r\n    exports.restoreAdjustedScrollState    = restoreAdjustedScrollState;\r\n\r\n    // Searching\r\n    exports.findInWorkingSet              = findInWorkingSet;\r\n    exports.findInWorkingSetByAddedOrder  = findInWorkingSetByAddedOrder;\r\n    exports.findInWorkingSetByMRUOrder    = findInWorkingSetByMRUOrder;\r\n    exports.findInAllWorkingSets          = findInAllWorkingSets;\r\n    \r\n    // Traversal\r\n    exports.beginTraversal                = beginTraversal;\r\n    exports.endTraversal                  = endTraversal;\r\n    exports.traverseToNextViewByMRU            = traverseToNextViewByMRU;\r\n    \r\n    // PaneView Attributes\r\n    exports.getActivePaneId               = getActivePaneId;\r\n    exports.setActivePaneId               = setActivePaneId;\r\n    exports.getPaneIdList                 = getPaneIdList;\r\n    exports.getPaneTitle                  = getPaneTitle;\r\n    exports.getPaneCount                  = getPaneCount;\r\n    \r\n    exports.getAllOpenFiles               = getAllOpenFiles;\r\n    exports.focusActivePane               = focusActivePane;\r\n    \r\n    // Layout\r\n    exports.setLayoutScheme               = setLayoutScheme;\r\n    exports.getLayoutScheme               = getLayoutScheme;\r\n    \r\n    // Convenience\r\n    exports.getCurrentlyViewedFile        = getCurrentlyViewedFile;\r\n    exports.getCurrentlyViewedPath        = getCurrentlyViewedPath;\r\n    \r\n    // Constants\r\n    exports.ALL_PANES                     = ALL_PANES;\r\n    exports.ACTIVE_PANE                   = ACTIVE_PANE;\r\n});\r\n\n//# sourceURL=/view/MainViewManager.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n/**\r\n * Utilities for dealing with animations in the UI.\r\n */\r\ndefine(\'utils/AnimationUtils\',[\'require\',\'exports\',\'module\',\'utils/Async\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var Async   = require("utils/Async");\r\n    \r\n    /**\r\n     * Start an animation by adding the given class to the given target. When the\r\n     * animation is complete, removes the class, clears the event handler we attach\r\n     * to watch for the animation to finish, and resolves the returned promise.\r\n     *\r\n     * @param {Element} target The DOM node to animate.\r\n     * @param {string} animClass The class that applies the animation/transition to the target.\r\n     * @param {number=} timeoutDuration Time to wait in ms before rejecting promise. Default is 400.\r\n     * @return {$.Promise} A promise that is resolved when the animation completes. Never rejected.\r\n     */\r\n    function animateUsingClass(target, animClass, timeoutDuration) {\r\n        var result  = new $.Deferred(),\r\n            $target = $(target);\r\n        \r\n        timeoutDuration = timeoutDuration || 400;\r\n        \r\n        function finish(e) {\r\n            if (e.target === target) {\r\n                result.resolve();\r\n            }\r\n        }\r\n        \r\n        function cleanup() {\r\n            $target\r\n                .removeClass(animClass)\r\n                .off("webkitTransitionEnd", finish);\r\n        }\r\n        \r\n        if ($target.is(":hidden")) {\r\n            // Don\'t do anything if the element is hidden because webkitTransitionEnd wouldn\'t fire\r\n            result.resolve();\r\n        } else {\r\n            // Note that we can\'t just use $.one() here because we only want to remove\r\n            // the handler when we get the transition end event for the correct target (not\r\n            // a child).\r\n            $target\r\n                .addClass(animClass)\r\n                .on("webkitTransitionEnd", finish);\r\n        }\r\n        \r\n        // Use timeout in case transition end event is not sent\r\n        return Async.withTimeout(result.promise(), timeoutDuration, true)\r\n            .done(cleanup);\r\n    }\r\n    \r\n    exports.animateUsingClass = animateUsingClass;\r\n});\r\n\n//# sourceURL=/utils/AnimationUtils.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n/**\r\n */\r\ndefine(\'document/TextRange\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    /**\r\n     * Stores a range of lines that is automatically maintained as the Document changes. The range\r\n     * MAY drop out of sync with the Document in certain edge cases; startLine & endLine will become\r\n     * null when that happens.\r\n     *\r\n     * Important: you must dispose() a TextRange when you\'re done with it. Because TextRange addRef()s\r\n     * the Document (in order to listen to it), you will leak Documents otherwise.\r\n     *\r\n     * TextRange dispatches these events:\r\n     *  - change -- When the range boundary line numbers change (due to a Document change)\r\n     *  - contentChange -- When the actual content of the range changes. This might or might not\r\n     *    be accompanied by a change in the boundary line numbers.\r\n     *  - lostSync -- When the backing Document changes in such a way that the range can no longer\r\n     *    accurately be maintained. Generally, occurs whenever an edit spans a range boundary.\r\n     *    After this, startLine & endLine will be unusable (set to null).\r\n     *    Also occurs when the document is deleted, though startLine & endLine won\'t be modified\r\n     * These events only ever occur in response to Document changes, so if you are already listening\r\n     * to the Document, you could ignore the TextRange events and just read its updated value in your\r\n     * own Document change handler.\r\n     *\r\n     * @constructor\r\n     *\r\n     * @param {!Document} document\r\n     * @param {number} startLine First line in range (0-based, inclusive)\r\n     * @param {number} endLine   Last line in range (0-based, inclusive)\r\n     */\r\n    function TextRange(document, startLine, endLine) {\r\n        this.startLine = startLine;\r\n        this.endLine = endLine;\r\n        \r\n        this.document = document;\r\n        document.addRef();\r\n        // store this-bound versions of listeners so we can remove them later\r\n        this._handleDocumentChange = this._handleDocumentChange.bind(this);\r\n        this._handleDocumentDeleted = this._handleDocumentDeleted.bind(this);\r\n        $(document).on("change", this._handleDocumentChange);\r\n        $(document).on("deleted", this._handleDocumentDeleted);\r\n    }\r\n    \r\n    /** Detaches from the Document. The TextRange will no longer update or send change events */\r\n    TextRange.prototype.dispose = function (editor, change) {\r\n        // Disconnect from Document\r\n        this.document.releaseRef();\r\n        $(this.document).off("change", this._handleDocumentChange);\r\n        $(this.document).off("deleted", this._handleDocumentDeleted);\r\n    };\r\n    \r\n    \r\n    /**\r\n     * Containing document\r\n     * @type {!Document}\r\n     */\r\n    TextRange.prototype.document = null;\r\n\r\n    /**\r\n     * Starting Line\r\n     * @type {?number} Null after "lostSync" is dispatched\r\n     */\r\n    TextRange.prototype.startLine = null;\r\n\r\n    /**\r\n     * Ending Line\r\n     * @type {?number} Null after "lostSync" is dispatched\r\n     */\r\n    TextRange.prototype.endLine = null;\r\n    \r\n    \r\n    /**\r\n     * Applies a single Document change object (out of the linked list of multiple such objects)\r\n     * to this range.\r\n     * @param {Object} change The CodeMirror change record.\r\n     * @return {{hasChanged: boolean, hasContentChanged: boolean}} Whether the range boundary\r\n     *     and/or content has changed.\r\n     */\r\n    TextRange.prototype._applySingleChangeToRange = function (change) {\r\n        // console.log(this + " applying change to (" +\r\n        //         (change.from && (change.from.line+","+change.from.ch)) + " - " +\r\n        //         (change.to && (change.to.line+","+change.to.ch)) + ")");\r\n        \r\n        // Special case: the range is no longer meaningful since the entire text was replaced\r\n        if (!change.from || !change.to) {\r\n            this.startLine = null;\r\n            this.endLine = null;\r\n            return {hasChanged: true, hasContentChanged: true};\r\n            \r\n        // Special case: certain changes around the edges of the range are problematic, because\r\n        // if they\'re undone, we\'ll be unable to determine how to fix up the range to include the\r\n        // undone content. (The "undo" will just look like an insertion outside our bounds.) So\r\n        // in those cases, we destroy the range instead of fixing it up incorrectly. The specific\r\n        // cases are:\r\n        // 1. Edit crosses the start boundary of the inline editor (defined as character 0 \r\n        //    of the first line).\r\n        // 2. Edit crosses the end boundary of the inline editor (defined as the newline at\r\n        //    the end of the last line).\r\n        // Note: we also used to disallow edits that start at the beginning of the range (character 0\r\n        //    of the first line) if they crossed a newline. This was a vestige from before case #1\r\n        //    was added; now that edits crossing the top boundary (actually, undos of such edits) are\r\n        //    out of the picture, edits on the first line of the range unambiguously belong inside it.\r\n        } else if ((change.from.line < this.startLine && change.to.line >= this.startLine) ||\r\n                   (change.from.line <= this.endLine && change.to.line > this.endLine)) {\r\n            this.startLine = null;\r\n            this.endLine = null;\r\n            return {hasChanged: true, hasContentChanged: true};\r\n            \r\n        // Normal case: update the range end points if any content was added before them. Note that\r\n        // we don\'t rely on line handles for this since we want to gracefully handle cases where the\r\n        // start or end line was deleted during a change.\r\n        } else {\r\n            var numAdded = change.text.length - (change.to.line - change.from.line + 1);\r\n            var result = {hasChanged: false, hasContentChanged: false};\r\n            \r\n            // This logic is so simple because we\'ve already excluded all cases where the change\r\n            // crosses the range boundaries\r\n            if (numAdded !== 0) {\r\n                if (change.to.line < this.startLine) {\r\n                    this.startLine += numAdded;\r\n                    result.hasChanged = true;\r\n                }\r\n                if (change.to.line <= this.endLine) {\r\n                    this.endLine += numAdded;\r\n                    result.hasChanged = true;\r\n                }\r\n            }\r\n            if (change.from.line >= this.startLine && change.from.line <= this.endLine) {\r\n                // Since we know the change doesn\'t cross the range boundary, as long as the\r\n                // start of the change is within the range, we know the content changed.\r\n                result.hasContentChanged = true;\r\n            }\r\n            \r\n            // console.log("Now " + this);\r\n            \r\n            return result;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Updates the range based on the changeList from a Document "change" event. Dispatches a\r\n     * "change" event if the range was adjusted at all. Dispatches a "lostSync" event instead if the\r\n     * range can no longer be accurately maintained.\r\n     */\r\n    TextRange.prototype._applyChangesToRange = function (changeList) {\r\n        var hasChanged = false, hasContentChanged = false;\r\n        var i;\r\n        for (i = 0; i < changeList.length; i++) {\r\n            // Apply this step of the change list\r\n            var result = this._applySingleChangeToRange(changeList[i]);\r\n            hasChanged = hasChanged || result.hasChanged;\r\n            hasContentChanged = hasContentChanged || result.hasContentChanged;\r\n            \r\n            // If we lost sync with the range, just bail now\r\n            if (this.startLine === null || this.endLine === null) {\r\n                $(this).triggerHandler("lostSync");\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (hasChanged) {\r\n            $(this).triggerHandler("change");\r\n        }\r\n        if (hasContentChanged) {\r\n            $(this).triggerHandler("contentChange");\r\n        }\r\n    };\r\n    \r\n    TextRange.prototype._handleDocumentChange = function (event, doc, changeList) {\r\n        this._applyChangesToRange(changeList);\r\n    };\r\n    \r\n    TextRange.prototype._handleDocumentDeleted = function (event) {\r\n        $(this).triggerHandler("lostSync");\r\n    };\r\n    \r\n    \r\n    /* (pretty toString(), to aid debugging) */\r\n    TextRange.prototype.toString = function () {\r\n        return "[TextRange " + this.startLine + "-" + this.endLine + " in " + this.document + "]";\r\n    };\r\n    \r\n    \r\n    // Define public API\r\n    exports.TextRange = TextRange;\r\n});\r\n\n//# sourceURL=/document/TextRange.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n/**\r\n * Functions for iterating through tokens in the current editor buffer. Useful for doing\r\n * light parsing that can rely purely on information gathered by the code coloring mechanism.\r\n */\r\n\r\ndefine(\'utils/TokenUtils\',[\'require\',\'exports\',\'module\',\'thirdparty/CodeMirror2/lib/codemirror\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var CodeMirror = require("thirdparty/CodeMirror2/lib/codemirror");\r\n    \r\n   /**\r\n     * Creates a context object for the given editor and position, suitable for passing to the\r\n     * move functions.\r\n     * @param {CodeMirror} editor\r\n     * @param {{ch:{string}, line:{number}} pos\r\n     * @return {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}}\r\n     */\r\n    function getInitialContext(editor, pos) {\r\n        return {\r\n            "editor": editor,\r\n            "pos": pos,\r\n            "token": editor.getTokenAt(pos, true)\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Moves the given context backwards by one token.\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} ctx\r\n     * @param {boolean=} precise If code is being edited, use true (default) for accuracy.\r\n     *      If parsing unchanging code, use false to use cache for performance.\r\n     * @return {boolean} whether the context changed\r\n     */\r\n    function movePrevToken(ctx, precise) {\r\n        if (precise === undefined) {\r\n            precise = true;\r\n        }\r\n        \r\n        if (ctx.pos.ch <= 0 || ctx.token.start <= 0) {\r\n            //move up a line\r\n            if (ctx.pos.line <= 0) {\r\n                return false; //at the top already\r\n            }\r\n            ctx.pos.line--;\r\n            ctx.pos.ch = ctx.editor.getLine(ctx.pos.line).length;\r\n        } else {\r\n            ctx.pos.ch = ctx.token.start;\r\n        }\r\n        ctx.token = ctx.editor.getTokenAt(ctx.pos, precise);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Moves the given context forward by one token.\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} ctx\r\n     * @param {boolean=} precise If code is being edited, use true (default) for accuracy.\r\n     *      If parsing unchanging code, use false to use cache for performance.\r\n     * @return {boolean} whether the context changed\r\n     */\r\n    function moveNextToken(ctx, precise) {\r\n        var eol = ctx.editor.getLine(ctx.pos.line).length;\r\n        if (precise === undefined) {\r\n            precise = true;\r\n        }\r\n        \r\n        if (ctx.pos.ch >= eol || ctx.token.end >= eol) {\r\n            //move down a line\r\n            if (ctx.pos.line >= ctx.editor.lineCount() - 1) {\r\n                return false; //at the bottom\r\n            }\r\n            ctx.pos.line++;\r\n            ctx.pos.ch = 0;\r\n        } else {\r\n            ctx.pos.ch = ctx.token.end + 1;\r\n        }\r\n        ctx.token = ctx.editor.getTokenAt(ctx.pos, precise);\r\n        return true;\r\n    }\r\n    \r\n   /**\r\n     * Moves the given context in the given direction, skipping any whitespace it hits.\r\n     * @param {function} moveFxn the function to move the context\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} ctx\r\n     * @return {boolean} whether the context changed\r\n     */\r\n    function moveSkippingWhitespace(moveFxn, ctx) {\r\n        if (!moveFxn(ctx)) {\r\n            return false;\r\n        }\r\n        while (!ctx.token.type && !/\\S/.test(ctx.token.string)) {\r\n            if (!moveFxn(ctx)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * In the given context, get the character offset of pos from the start of the token.\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @return {number}\r\n     */\r\n    function offsetInToken(ctx) {\r\n        var offset = ctx.pos.ch - ctx.token.start;\r\n        if (offset < 0) {\r\n            console.log("CodeHintUtils: _offsetInToken - Invalid context: pos not in the current token!");\r\n        }\r\n        return offset;\r\n    }\r\n\r\n    /**\r\n     * Returns the mode object and mode name string at a given position\r\n     * @param {CodeMirror} cm CodeMirror instance\r\n     * @param {line:{number}, ch:{number}} pos Position to query for mode\r\n     * @return {mode:{Object}, name:string}\r\n     */\r\n    function getModeAt(cm, pos) {\r\n        var outerMode = cm.getMode(),\r\n            modeData = CodeMirror.innerMode(outerMode, cm.getTokenAt(pos, true).state),\r\n            name;\r\n\r\n        name = (modeData.mode.name === "xml") ?\r\n                modeData.mode.configuration : modeData.mode.name;\r\n\r\n        return {mode: modeData.mode, name: name};\r\n    }\r\n\r\n    exports.movePrevToken           = movePrevToken;\r\n    exports.moveNextToken           = moveNextToken;\r\n    exports.moveSkippingWhitespace  = moveSkippingWhitespace;\r\n    exports.getInitialContext       = getInitialContext;\r\n    exports.offsetInToken           = offsetInToken;\r\n    exports.getModeAt               = getModeAt;\r\n});\r\n\n//# sourceURL=/utils/TokenUtils.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\ndefine(\'utils/ValidationUtils\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    \r\n    /**\r\n     * Used to validate whether type of unknown value is an integer.\r\n     * \r\n     * @param {*} value Value for which to validate its type\r\n     * @return {boolean} true if value is an integer\r\n     */\r\n    function isInteger(value) {\r\n        // Validate value is a number\r\n        if (typeof (value) !== "number" || isNaN(parseInt(value, 10))) {\r\n            return false;\r\n        }\r\n\r\n        // Validate number is an integer\r\n        if (value > 0 && Math.floor(value) !== value) {\r\n            return false;\r\n        } else if (value < 0 && Math.ceil(value) !== value) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Used to validate whether type of unknown value is an integer, and, if so,\r\n     * is it within the option lower and upper limits.\r\n     * \r\n     * @param {*} value Value for which to validate its type\r\n     * @param {number=} lowerLimit Optional lower limit (inclusive)\r\n     * @param {number=} upperLimit Optional upper limit (inclusive)\r\n     * @return {boolean} true if value is an interger, and optionally in specified range.\r\n     */\r\n    function isIntegerInRange(value, lowerLimit, upperLimit) {\r\n        // Validate value is an integer\r\n        if (!isInteger(value)) {\r\n            return false;\r\n        }\r\n\r\n        // Validate integer is in range\r\n        var hasLowerLimt = (typeof (lowerLimit) === "number"),\r\n            hasUpperLimt = (typeof (upperLimit) === "number");\r\n\r\n        return ((!hasLowerLimt || value >= lowerLimit) && (!hasUpperLimt || value <= upperLimit));\r\n    }\r\n\r\n\r\n    // Define public API\r\n    exports.isInteger               = isInteger;\r\n    exports.isIntegerInRange        = isIntegerInRange;\r\n});\r\n\n//# sourceURL=/utils/ValidationUtils.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\n/**\r\n * Editor is a 1-to-1 wrapper for a CodeMirror editor instance. It layers on Brackets-specific\r\n * functionality and provides APIs that cleanly pass through the bits of CodeMirror that the rest\r\n * of our codebase may want to interact with. An Editor is always backed by a Document, and stays\r\n * in sync with its content; because Editor keeps the Document alive, it\'s important to always\r\n * destroy() an Editor that\'s going away so it can release its Document ref.\r\n *\r\n * For now, there\'s a distinction between the "master" Editor for a Document - which secretly acts\r\n * as the Document\'s internal model of the text state - and the multitude of "slave" secondary Editors\r\n * which, via Document, sync their changes to and from that master.\r\n *\r\n * For now, direct access to the underlying CodeMirror object is still possible via `_codeMirror` --\r\n * but this is considered deprecated and may go away.\r\n *\r\n * The Editor object dispatches the following events:\r\n *    - keyEvent -- When any key event happens in the editor (whether it changes the text or not).\r\n *      Event handlers are passed `({Editor}, {KeyboardEvent})`. The 2nd arg is the raw DOM event.\r\n *      Note: most listeners will only want to respond when `event.type === "keypress"`.\r\n *    - cursorActivity -- When the user moves the cursor or changes the selection, or an edit occurs.\r\n *      Note: do not listen to this in order to be generally informed of edits--listen to the\r\n *      "change" event on Document instead.\r\n *    - scroll -- When the editor is scrolled, either by user action or programmatically.\r\n *    - lostContent -- When the backing Document changes in such a way that this Editor is no longer\r\n *      able to display accurate text. This occurs if the Document\'s file is deleted, or in certain\r\n *      Document->editor syncing edge cases that we do not yet support (the latter cause will\r\n *      eventually go away).\r\n *    - optionChange -- Triggered when an option for the editor is changed. The 2nd arg to the listener\r\n *      is a string containing the editor option that is changing. The 3rd arg, which can be any\r\n *      data type, is the new value for the editor option.\r\n *    - beforeDestroy - Triggered before the object is about to dispose of all its internal state data \r\n *      so that listeners can cache things like scroll pos, etc...\r\n *\r\n * The Editor also dispatches "change" events internally, but you should listen for those on\r\n * Documents, not Editors.\r\n *\r\n * These are jQuery events, so to listen for them you do something like this:\r\n *     `$(editorInstance).on("eventname", handler);`\r\n */\r\ndefine(\'editor/Editor\',[\'require\',\'exports\',\'module\',\'utils/AnimationUtils\',\'utils/Async\',\'thirdparty/CodeMirror2/lib/codemirror\',\'command/Menus\',\'utils/PerfUtils\',\'widgets/PopUpManager\',\'preferences/PreferencesManager\',\'strings\',\'document/TextRange\',\'utils/TokenUtils\',\'utils/ValidationUtils\',\'utils/ViewUtils\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var AnimationUtils     = require("utils/AnimationUtils"),\r\n        Async              = require("utils/Async"),\r\n        CodeMirror         = require("thirdparty/CodeMirror2/lib/codemirror"),\r\n        Menus              = require("command/Menus"),\r\n        PerfUtils          = require("utils/PerfUtils"),\r\n        PopUpManager       = require("widgets/PopUpManager"),\r\n        PreferencesManager = require("preferences/PreferencesManager"),\r\n        Strings            = require("strings"),\r\n        TextRange          = require("document/TextRange").TextRange,\r\n        TokenUtils         = require("utils/TokenUtils"),\r\n        ValidationUtils    = require("utils/ValidationUtils"),\r\n        ViewUtils          = require("utils/ViewUtils"),\r\n        _                  = require("thirdparty/lodash");\r\n    \r\n    /** Editor preferences */\r\n    var CLOSE_BRACKETS    = "closeBrackets",\r\n        CLOSE_TAGS        = "closeTags",\r\n        HIGHLIGHT_MATCHES = "highlightMatches",\r\n        SCROLL_PAST_END   = "scrollPastEnd",\r\n        SHOW_LINE_NUMBERS = "showLineNumbers",\r\n        SMART_INDENT      = "smartIndent",\r\n        SOFT_TABS         = "softTabs",\r\n        SPACE_UNITS       = "spaceUnits",\r\n        STYLE_ACTIVE_LINE = "styleActiveLine",\r\n        TAB_SIZE          = "tabSize",\r\n        WORD_WRAP         = "wordWrap",\r\n        USE_TAB_CHAR      = "useTabChar";\r\n    \r\n    var cmOptions         = {};\r\n    \r\n    /**\r\n     * Constants\r\n     * @type {number}\r\n     */\r\n    var MIN_SPACE_UNITS         =  0,\r\n        MIN_TAB_SIZE            =  1,\r\n        DEFAULT_SPACE_UNITS     =  4,\r\n        DEFAULT_TAB_SIZE        =  4,\r\n        MAX_SPACE_UNITS         = 10,\r\n        MAX_TAB_SIZE            = 10;\r\n    \r\n    // Mappings from Brackets preferences to CodeMirror options\r\n    cmOptions[CLOSE_BRACKETS]     = "autoCloseBrackets";\r\n    cmOptions[CLOSE_TAGS]         = "autoCloseTags";\r\n    cmOptions[HIGHLIGHT_MATCHES]  = "highlightSelectionMatches";\r\n    cmOptions[SCROLL_PAST_END]    = "scrollPastEnd";\r\n    cmOptions[SHOW_LINE_NUMBERS]  = "lineNumbers";\r\n    cmOptions[SMART_INDENT]       = "smartIndent";\r\n    cmOptions[SPACE_UNITS]        = "indentUnit";\r\n    cmOptions[STYLE_ACTIVE_LINE]  = "styleActiveLine";\r\n    cmOptions[TAB_SIZE]           = "tabSize";\r\n    cmOptions[USE_TAB_CHAR]       = "indentWithTabs";\r\n    cmOptions[WORD_WRAP]          = "lineWrapping";\r\n    \r\n    PreferencesManager.definePreference(CLOSE_BRACKETS,    "boolean", false);\r\n    PreferencesManager.definePreference(CLOSE_TAGS,        "Object", { whenOpening: true, whenClosing: true, indentTags: [] });\r\n    PreferencesManager.definePreference(HIGHLIGHT_MATCHES, "boolean", false);\r\n    PreferencesManager.definePreference(SCROLL_PAST_END,   "boolean", false);\r\n    PreferencesManager.definePreference(SHOW_LINE_NUMBERS, "boolean", true);\r\n    PreferencesManager.definePreference(SMART_INDENT,      "boolean", true);\r\n    PreferencesManager.definePreference(SOFT_TABS,         "boolean", true);\r\n    PreferencesManager.definePreference(SPACE_UNITS,       "number", DEFAULT_SPACE_UNITS, {\r\n        validator: _.partialRight(ValidationUtils.isIntegerInRange, MIN_SPACE_UNITS, MAX_SPACE_UNITS)\r\n    });\r\n    PreferencesManager.definePreference(STYLE_ACTIVE_LINE, "boolean", false);\r\n    PreferencesManager.definePreference(TAB_SIZE,          "number", DEFAULT_TAB_SIZE, {\r\n        validator: _.partialRight(ValidationUtils.isIntegerInRange, MIN_TAB_SIZE, MAX_TAB_SIZE)\r\n    });\r\n    PreferencesManager.definePreference(USE_TAB_CHAR,      "boolean", false);\r\n    PreferencesManager.definePreference(WORD_WRAP,         "boolean", true);\r\n    \r\n    var editorOptions = Object.keys(cmOptions);\r\n\r\n    /** Editor preferences */\r\n    \r\n    /**\r\n     * Guard flag to prevent focus() reentrancy (via blur handlers), even across Editors\r\n     * @type {boolean}\r\n     */\r\n    var _duringFocus = false;\r\n    \r\n    /**\r\n     * Constant: ignore upper boundary when centering text\r\n     * @type {number}\r\n     */\r\n    var BOUNDARY_CHECK_NORMAL   = 0,\r\n        BOUNDARY_IGNORE_TOP     = 1;\r\n\r\n    /**\r\n     * @private\r\n     * Create a copy of the given CodeMirror position\r\n     * @param {!CodeMirror.Pos} pos \r\n     * @return {CodeMirror.Pos}\r\n     */\r\n    function _copyPos(pos) {\r\n        return new CodeMirror.Pos(pos.line, pos.ch);\r\n    }\r\n\r\n    /**\r\n     * Helper functions to check options.\r\n     * @param {number} options BOUNDARY_CHECK_NORMAL or BOUNDARY_IGNORE_TOP\r\n     */\r\n    function _checkTopBoundary(options) {\r\n        return (options !== BOUNDARY_IGNORE_TOP);\r\n    }\r\n    function _checkBottomBoundary(options) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * List of all current (non-destroy()ed) Editor instances. Needed when changing global preferences\r\n     * that affect all editors, e.g. tabbing or color scheme settings.\r\n     * @type {Array.<Editor>}\r\n     */\r\n    var _instances = [];\r\n    \r\n    /**\r\n     * Creates a new CodeMirror editor instance bound to the given Document. The Document need not have\r\n     * a "master" Editor realized yet, even if makeMasterEditor is false; in that case, the first time\r\n     * an edit occurs we will automatically ask EditorManager to create a "master" editor to render the\r\n     * Document modifiable.\r\n     *\r\n     * ALWAYS call destroy() when you are done with an Editor - otherwise it will leak a Document ref.\r\n     *\r\n     * @constructor\r\n     *\r\n     * @param {!Document} document\r\n     * @param {!boolean} makeMasterEditor  If true, this Editor will set itself as the (secret) "master"\r\n     *          Editor for the Document. If false, this Editor will attach to the Document as a "slave"/\r\n     *          secondary editor.\r\n     * @param {!jQueryObject|DomNode} container  Container to add the editor to.\r\n     * @param {{startLine: number, endLine: number}=} range If specified, range of lines within the document\r\n     *          to display in this editor. Inclusive.\r\n     */\r\n    function Editor(document, makeMasterEditor, container, range) {\r\n        var self = this;\r\n        \r\n        _instances.push(this);\r\n        \r\n        // Attach to document: add ref & handlers\r\n        this.document = document;\r\n        document.addRef();\r\n        \r\n        if (container.jquery) {\r\n            // CodeMirror wants a DOM element, not a jQuery wrapper\r\n            container = container.get(0);\r\n        }\r\n        \r\n        var $container = $(container);\r\n        \r\n        if (range) {    // attach this first: want range updated before we process a change\r\n            this._visibleRange = new TextRange(document, range.startLine, range.endLine);\r\n        }\r\n        \r\n        // store this-bound version of listeners so we can remove them later\r\n        this._handleDocumentChange = this._handleDocumentChange.bind(this);\r\n        this._handleDocumentDeleted = this._handleDocumentDeleted.bind(this);\r\n        this._handleDocumentLanguageChanged = this._handleDocumentLanguageChanged.bind(this);\r\n        $(document).on("change", this._handleDocumentChange);\r\n        $(document).on("deleted", this._handleDocumentDeleted);\r\n        $(document).on("languageChanged", this._handleDocumentLanguageChanged);\r\n\r\n        var mode = this._getModeFromDocument();\r\n        \r\n        // (if makeMasterEditor, we attach the Doc back to ourselves below once we\'re fully initialized)\r\n        \r\n        this._inlineWidgets = [];\r\n        this._inlineWidgetQueues = {};\r\n        this._hideMarks = [];\r\n        this._lastEditorWidth = null;\r\n        \r\n        this._$messagePopover = null;\r\n        \r\n        // Editor supplies some standard keyboard behavior extensions of its own\r\n        var codeMirrorKeyMap = {\r\n            "Tab": function () { self._handleTabKey(); },\r\n            "Shift-Tab": "indentLess",\r\n\r\n            "Left": function (instance) {\r\n                self._handleSoftTabNavigation(-1, "moveH");\r\n            },\r\n            "Right": function (instance) {\r\n                self._handleSoftTabNavigation(1, "moveH");\r\n            },\r\n            "Backspace": function (instance) {\r\n                self._handleSoftTabNavigation(-1, "deleteH");\r\n            },\r\n            "Delete": function (instance) {\r\n                self._handleSoftTabNavigation(1, "deleteH");\r\n            },\r\n            "Esc": function (instance) {\r\n                if (self.getSelections().length > 1) {\r\n                    CodeMirror.commands.singleSelection(instance);\r\n                } else {\r\n                    self.removeAllInlineWidgets();\r\n                }\r\n            },\r\n            "Cmd-Left": "goLineStartSmart"\r\n        };\r\n        \r\n        var currentOptions = this._currentOptions = _.zipObject(\r\n            editorOptions,\r\n            _.map(editorOptions, function (prefName) {\r\n                return self._getOption(prefName);\r\n            })\r\n        );\r\n        \r\n        // When panes are created *after* the showLineNumbers option has been turned off\r\n        //  we need to apply the show-line-padding class or the text will be juxtaposed \r\n        //  to the edge of the editor which makes it not easy to read.  The code below to handle\r\n        //  that the option change only applies the class to panes that have already been created\r\n        // This line ensures that the class is applied to any editor created after the fact\r\n        $container.toggleClass("show-line-padding", Boolean(!this._getOption("showLineNumbers")));\r\n        \r\n        // Create the CodeMirror instance\r\n        // (note: CodeMirror doesn\'t actually require using \'new\', but jslint complains without it)\r\n        this._codeMirror = new CodeMirror(container, {\r\n            autoCloseBrackets           : currentOptions[CLOSE_BRACKETS],\r\n            autoCloseTags               : currentOptions[CLOSE_TAGS],\r\n            coverGutterNextToScrollbar  : true,\r\n            cursorScrollMargin          : 3,\r\n            dragDrop                    : false,\r\n            electricChars               : false,   // we use our own impl of this to avoid CodeMirror bugs; see _checkElectricChars()\r\n            extraKeys                   : codeMirrorKeyMap,\r\n            highlightSelectionMatches   : currentOptions[HIGHLIGHT_MATCHES],\r\n            indentUnit                  : currentOptions[USE_TAB_CHAR] ? currentOptions[TAB_SIZE] : currentOptions[SPACE_UNITS],\r\n            indentWithTabs              : currentOptions[USE_TAB_CHAR],\r\n            lineNumbers                 : currentOptions[SHOW_LINE_NUMBERS],\r\n            lineWrapping                : currentOptions[WORD_WRAP],\r\n            matchBrackets               : { maxScanLineLength: 50000, maxScanLines: 1000 },\r\n            matchTags                   : { bothTags: true },\r\n            scrollPastEnd               : !range && currentOptions[SCROLL_PAST_END],\r\n            smartIndent                 : currentOptions[SMART_INDENT],\r\n            styleActiveLine             : currentOptions[STYLE_ACTIVE_LINE],\r\n            tabSize                     : currentOptions[TAB_SIZE]\r\n        });\r\n        \r\n        // Can\'t get CodeMirror\'s focused state without searching for\r\n        // CodeMirror-focused. Instead, track focus via onFocus and onBlur\r\n        // options and track state with this._focused\r\n        this._focused = false;\r\n        \r\n        this._installEditorListeners();\r\n        \r\n        $(this).on("cursorActivity", function (jqEvent, editor) {\r\n            self._handleCursorActivity(jqEvent);\r\n        });\r\n        $(this).on("keypress", function (jqEvent, editor, cmEvent) {\r\n            self._handleKeypressEvents(cmEvent);\r\n        });\r\n        $(this).on("change", function (jqEvent, editor, changeList) {\r\n            self._handleEditorChange(changeList);\r\n        });\r\n        \r\n        // Set code-coloring mode BEFORE populating with text, to avoid a flash of uncolored text\r\n        this._codeMirror.setOption("mode", mode);\r\n        \r\n        // Initially populate with text. This will send a spurious change event, so need to make\r\n        // sure this is understood as a \'sync from document\' case, not a genuine edit\r\n        this._duringSync = true;\r\n        this._resetText(document.getText());\r\n        this._duringSync = false;\r\n        \r\n        if (range) {\r\n            this._updateHiddenLines();\r\n            this.setCursorPos(range.startLine, 0);\r\n        }\r\n\r\n        // Now that we\'re fully initialized, we can point the document back at us if needed\r\n        if (makeMasterEditor) {\r\n            document._makeEditable(this);\r\n        }\r\n        \r\n        // Add scrollTop property to this object for the scroll shadow code to use\r\n        Object.defineProperty(this, "scrollTop", {\r\n            get: function () {\r\n                return this._codeMirror.getScrollInfo().top;\r\n            }\r\n        });\r\n        \r\n        // Add an $el getter for Pane Views\r\n        Object.defineProperty(this,  "$el", {\r\n            get: function () {\r\n                return $(this.getRootElement());\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Removes this editor from the DOM and detaches from the Document. If this is the "master"\r\n     * Editor that is secretly providing the Document\'s backing state, then the Document reverts to\r\n     * a read-only string-backed mode.\r\n     */\r\n    Editor.prototype.destroy = function () {\r\n        $(this).triggerHandler("beforeDestroy", [this]);\r\n\r\n        // CodeMirror docs for getWrapperElement() say all you have to do is "Remove this from your\r\n        // tree to delete an editor instance."\r\n        $(this.getRootElement()).remove();\r\n        \r\n        _instances.splice(_instances.indexOf(this), 1);\r\n        \r\n        // Disconnect from Document\r\n        this.document.releaseRef();\r\n        $(this.document).off("change", this._handleDocumentChange);\r\n        $(this.document).off("deleted", this._handleDocumentDeleted);\r\n        $(this.document).off("languageChanged", this._handleDocumentLanguageChanged);\r\n        \r\n        if (this._visibleRange) {   // TextRange also refs the Document\r\n            this._visibleRange.dispose();\r\n        }\r\n        \r\n        // If we\'re the Document\'s master editor, disconnecting from it has special meaning\r\n        if (this.document._masterEditor === this) {\r\n            this.document._makeNonEditable();\r\n        }\r\n        \r\n        // Destroying us destroys any inline widgets we\'re hosting. Make sure their closeCallbacks\r\n        // run, at least, since they may also need to release Document refs\r\n        var self = this;\r\n        this._inlineWidgets.forEach(function (inlineWidget) {\r\n            self._removeInlineWidgetInternal(inlineWidget);\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Checks if the user just typed a closing brace/bracket/paren, and considers automatically\r\n     * back-indenting it if so.\r\n     */\r\n    Editor.prototype._checkElectricChars = function (event) {\r\n        var instance = this._codeMirror,\r\n            keyStr = String.fromCharCode(event.which || event.keyCode);\r\n\r\n        if (/[\\]\\{\\}\\)]/.test(keyStr)) {\r\n            // If all text before the cursor is whitespace, auto-indent it\r\n            var cursor = this.getCursorPos();\r\n            var lineStr = instance.getLine(cursor.line);\r\n            var nonWS = lineStr.search(/\\S/);\r\n\r\n            if (nonWS === -1 || nonWS >= cursor.ch) {\r\n                if (nonWS === -1) {\r\n                    // if the line is all whitespace, move the cursor to the end of the line\r\n                    // before indenting so that embedded whitespace such as indents are not\r\n                    // orphaned to the right of the electric char being inserted\r\n                    this.setCursorPos(cursor.line, this.document.getLine(cursor.line).length);\r\n                }\r\n                // Need to do the auto-indent on a timeout to ensure\r\n                // the keypress is handled before auto-indenting.\r\n                // This is the same timeout value used by the\r\n                // electricChars feature in CodeMirror.\r\n                window.setTimeout(function () {\r\n                    instance.indentLine(cursor.line);\r\n                }, 75);\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Handle any cursor movement in editor, including selecting and unselecting text.\r\n     * @param {!Event} event\r\n     */\r\n    Editor.prototype._handleCursorActivity = function (event) {\r\n        this._updateStyleActiveLine();\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Handle CodeMirror key events.\r\n     * @param {!Event} event\r\n     */\r\n    Editor.prototype._handleKeypressEvents = function (event) {\r\n        this._checkElectricChars(event);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Helper function for `_handleTabKey()` (case 2) - see comment in that function.\r\n     * @param {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>} selections\r\n     *     The selections to indent.\r\n     */\r\n    Editor.prototype._addIndentAtEachSelection = function (selections) {\r\n        var instance = this._codeMirror,\r\n            usingTabs = instance.getOption("indentWithTabs"),\r\n            indentUnit = instance.getOption("indentUnit"),\r\n            edits = [];\r\n        \r\n        _.each(selections, function (sel) {\r\n            var indentStr = "", i, numSpaces;\r\n            if (usingTabs) {\r\n                indentStr = "\\t";\r\n            } else {\r\n                numSpaces = indentUnit - (sel.start.ch % indentUnit);\r\n                for (i = 0; i < numSpaces; i++) {\r\n                    indentStr += " ";\r\n                }\r\n            }\r\n            edits.push({edit: {text: indentStr, start: sel.start}});\r\n        });\r\n        \r\n        this.document.doMultipleEdits(edits);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Helper function for `_handleTabKey()` (case 3) - see comment in that function.\r\n     * @param {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>} selections\r\n     *     The selections to indent.\r\n     */\r\n    Editor.prototype._autoIndentEachSelection = function (selections) {\r\n        // Capture all the line lengths, so we can tell if anything changed.\r\n        // Note that this function should only be called if all selections are within a single line.\r\n        var instance = this._codeMirror,\r\n            lineLengths = {};\r\n        _.each(selections, function (sel) {\r\n            lineLengths[sel.start.line] = instance.getLine(sel.start.line).length;\r\n        });\r\n        \r\n        // First, try to do a smart indent on all selections.\r\n        CodeMirror.commands.indentAuto(instance);\r\n        \r\n        // If there were no code or selection changes, then indent each selection one more indent.\r\n        var changed = false,\r\n            newSelections = this.getSelections();\r\n        if (newSelections.length === selections.length) {\r\n            _.each(selections, function (sel, index) {\r\n                var newSel = newSelections[index];\r\n                if (CodeMirror.cmpPos(sel.start, newSel.start) !== 0 ||\r\n                        CodeMirror.cmpPos(sel.end, newSel.end) !== 0 ||\r\n                        instance.getLine(sel.start.line).length !== lineLengths[sel.start.line]) {\r\n                    changed = true;\r\n                    // Bail - we don\'t need to look any further once we\'ve found a change.\r\n                    return false;\r\n                }\r\n            });\r\n        } else {\r\n            changed = true;\r\n        }\r\n        \r\n        if (!changed) {\r\n            CodeMirror.commands.indentMore(instance);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Handle Tab key press.\r\n     */\r\n    Editor.prototype._handleTabKey = function () {\r\n        // Tab key handling is done as follows:\r\n        // 1. If any of the selections are multiline, just add one indent level to the \r\n        //    beginning of all lines that intersect any selection.\r\n        // 2. Otherwise, if any of the selections is a cursor or single-line range that \r\n        //    ends at or after the first non-whitespace character in a line:\r\n        //    - if indentation is set to tabs, just insert a hard tab before each selection.\r\n        //    - if indentation is set to spaces, insert the appropriate number of spaces before\r\n        //      each selection to get to its next soft tab stop.\r\n        // 3. Otherwise (all selections are cursors or single-line, and are in the whitespace \r\n        //    before their respective lines), try to autoindent each line based on the mode.\r\n        //    If none of the cursors moved and no space was added, then add one indent level\r\n        //    to the beginning of all lines.\r\n        \r\n        // Note that in case 2, we do the "dumb" insertion even if the cursor is immediately\r\n        // before the first non-whitespace character in a line. It might seem more convenient\r\n        // to do autoindent in that case. However, the problem is if that line is already\r\n        // indented past its "proper" location. In that case, we don\'t want Tab to\r\n        // *outdent* the line. If we had more control over the autoindent algorithm or\r\n        // implemented it ourselves, we could handle that case separately.\r\n\r\n        var instance = this._codeMirror,\r\n            selectionType = "indentAuto",\r\n            selections = this.getSelections();\r\n\r\n        _.each(selections, function (sel) {\r\n            if (sel.start.line !== sel.end.line) {\r\n                // Case 1 - we found a multiline selection. We can bail as soon as we find one of these.\r\n                selectionType = "indentAtBeginning";\r\n                return false;\r\n            } else if (sel.end.ch > 0 && sel.end.ch >= instance.getLine(sel.end.line).search(/\\S/)) {\r\n                // Case 2 - we found a selection that ends at or after the first non-whitespace\r\n                // character on the line. We need to keep looking in case we find a later multiline\r\n                // selection though.\r\n                selectionType = "indentAtSelection";\r\n            }\r\n        });\r\n        \r\n        switch (selectionType) {\r\n        case "indentAtBeginning":\r\n            // Case 1\r\n            CodeMirror.commands.indentMore(instance);\r\n            break;\r\n                \r\n        case "indentAtSelection":\r\n            // Case 2\r\n            this._addIndentAtEachSelection(selections);\r\n            break;\r\n                \r\n        case "indentAuto":\r\n            // Case 3\r\n            this._autoIndentEachSelection(selections);\r\n            break;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Handle left arrow, right arrow, backspace and delete keys when soft tabs are used.\r\n     * @param {number} direction Direction of movement: 1 for forward, -1 for backward\r\n     * @param {string} functionName name of the CodeMirror function to call if we handle the key\r\n     */\r\n    Editor.prototype._handleSoftTabNavigation = function (direction, functionName) {\r\n        var instance = this._codeMirror,\r\n            overallJump = null;\r\n        \r\n        if (!instance.getOption("indentWithTabs") && PreferencesManager.get(SOFT_TABS)) {\r\n            var indentUnit = instance.getOption("indentUnit");\r\n            \r\n            _.each(this.getSelections(), function (sel) {\r\n                if (CodeMirror.cmpPos(sel.start, sel.end) !== 0) {\r\n                    // This is a range - it will just collapse/be deleted regardless of the jump we set, so\r\n                    // we can just ignore it and continue. (We don\'t want to return false in this case since\r\n                    // we want to keep looking at other ranges.)\r\n                    return;\r\n                }\r\n                \r\n                var cursor = sel.start,\r\n                    jump   = cursor.ch % indentUnit,\r\n                    line   = instance.getLine(cursor.line);\r\n\r\n                // Don\'t do any soft tab handling if there are non-whitespace characters before the cursor in\r\n                // any of the selections.\r\n                if (line.substr(0, cursor.ch).search(/\\S/) !== -1) {\r\n                    jump = null;\r\n                } else if (direction === 1) { // right\r\n                    jump = indentUnit - jump;\r\n\r\n                    // Don\'t jump if it would take us past the end of the line, or if there are\r\n                    // non-whitespace characters within the jump distance.\r\n                    if (cursor.ch + jump > line.length || line.substr(cursor.ch, jump).search(/\\S/) !== -1) {\r\n                        jump = null;\r\n                    }\r\n                } else { // left\r\n                    // If we are on the tab boundary, jump by the full amount,\r\n                    // but not beyond the start of the line.\r\n                    if (jump === 0) {\r\n                        jump = indentUnit;\r\n                    }\r\n                    if (cursor.ch - jump < 0) {\r\n                        jump = null;\r\n                    } else {\r\n                        // We\'re moving left, so negate the jump.\r\n                        jump = -jump;\r\n                    }\r\n                }\r\n\r\n                // Did we calculate a jump, and is this jump value either the first one or \r\n                // consistent with all the other jumps? If so, we\'re good. Otherwise, bail \r\n                // out of the foreach, since as soon as we hit an inconsistent jump we don\'t\r\n                // have to look any further.\r\n                if (jump !== null &&\r\n                        (overallJump === null || overallJump === jump)) {\r\n                    overallJump = jump;\r\n                } else {\r\n                    overallJump = null;\r\n                    return false;\r\n                }\r\n            });\r\n        }\r\n        \r\n        if (overallJump === null) {\r\n            // Just do the default move, which is one char in the given direction.\r\n            overallJump = direction;\r\n        }\r\n        instance[functionName](overallJump, "char");\r\n    };\r\n    \r\n    /**\r\n     * Determine the mode to use from the document\'s language\r\n     * Uses "text/plain" if the language does not define a mode\r\n     * @return string The mode to use\r\n     */\r\n    Editor.prototype._getModeFromDocument = function () {\r\n        // We\'d like undefined/null/"" to mean plain text mode. CodeMirror defaults to plaintext for any\r\n        // unrecognized mode, but it complains on the console in that fallback case: so, convert\r\n        // here so we\'re always explicit, avoiding console noise.\r\n        return this.document.getLanguage().getMode() || "text/plain";\r\n    };\r\n    \r\n        \r\n    /**\r\n     * Selects all text and maintains the current scroll position.\r\n     */\r\n    Editor.prototype.selectAllNoScroll = function () {\r\n        var cm = this._codeMirror,\r\n            info = this._codeMirror.getScrollInfo();\r\n        \r\n        // Note that we do not have to check for the visible range here. This\r\n        // concern is handled internally by code mirror.\r\n        cm.operation(function () {\r\n            cm.scrollTo(info.left, info.top);\r\n            cm.execCommand("selectAll");\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * @return {boolean} True if editor is not showing the entire text of the document (i.e. an inline editor)\r\n     */\r\n    Editor.prototype.isTextSubset = function () {\r\n        return Boolean(this._visibleRange);\r\n    };\r\n    \r\n    /**\r\n     * Ensures that the lines that are actually hidden in the inline editor correspond to\r\n     * the desired visible range.\r\n     */\r\n    Editor.prototype._updateHiddenLines = function () {\r\n        if (this._visibleRange) {\r\n            var cm = this._codeMirror,\r\n                self = this;\r\n            cm.operation(function () {\r\n                self._hideMarks.forEach(function (mark) {\r\n                    if (mark) {\r\n                        mark.clear();\r\n                    }\r\n                });\r\n                self._hideMarks = [];\r\n                self._hideMarks.push(self._hideLines(0, self._visibleRange.startLine));\r\n                self._hideMarks.push(self._hideLines(self._visibleRange.endLine + 1, self.lineCount()));\r\n            });\r\n        }\r\n    };\r\n    \r\n    Editor.prototype._applyChanges = function (changeList) {\r\n        // _visibleRange has already updated via its own Document listener. See if this change caused\r\n        // it to lose sync. If so, our whole view is stale - signal our owner to close us.\r\n        if (this._visibleRange) {\r\n            if (this._visibleRange.startLine === null || this._visibleRange.endLine === null) {\r\n                $(this).triggerHandler("lostContent");\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Apply text changes to CodeMirror editor\r\n        var cm = this._codeMirror;\r\n        cm.operation(function () {\r\n            var change, newText, i;\r\n            for (i = 0; i < changeList.length; i++) {\r\n                change = changeList[i];\r\n                newText = change.text.join(\'\\n\');\r\n                if (!change.from || !change.to) {\r\n                    if (change.from || change.to) {\r\n                        console.error("Change record received with only one end undefined--replacing entire text");\r\n                    }\r\n                    cm.setValue(newText);\r\n                } else {\r\n                    cm.replaceRange(newText, change.from, change.to, change.origin);\r\n                }\r\n                \r\n            }\r\n        });\r\n        \r\n        // The update above may have inserted new lines - must hide any that fall outside our range\r\n        this._updateHiddenLines();\r\n    };\r\n    \r\n    /**\r\n     * Responds to changes in the CodeMirror editor\'s text, syncing the changes to the Document.\r\n     * There are several cases where we want to ignore a CodeMirror change:\r\n     *  - if we\'re the master editor, editor changes can be ignored because Document is already listening\r\n     *    for our changes\r\n     *  - if we\'re a secondary editor, editor changes should be ignored if they were caused by us reacting\r\n     *    to a Document change\r\n     */\r\n    Editor.prototype._handleEditorChange = function (changeList) {\r\n        // we\'re currently syncing from the Document, so don\'t echo back TO the Document\r\n        if (this._duringSync) {\r\n            return;\r\n        }\r\n        \r\n        // Secondary editor: force creation of "master" editor backing the model, if doesn\'t exist yet\r\n        this.document._ensureMasterEditor();\r\n        \r\n        if (this.document._masterEditor !== this) {\r\n            // Secondary editor:\r\n            // we\'re not the ground truth; if we got here, this was a real editor change (not a\r\n            // sync from the real ground truth), so we need to sync from us into the document\r\n            // (which will directly push the change into the master editor).\r\n            // FUTURE: Technically we should add a replaceRange() method to Document and go through\r\n            // that instead of talking to its master editor directly. It\'s not clear yet exactly\r\n            // what the right Document API would be, though.\r\n            this._duringSync = true;\r\n            this.document._masterEditor._applyChanges(changeList);\r\n            this._duringSync = false;\r\n            \r\n            // Update which lines are hidden inside our editor, since we\'re not going to go through\r\n            // _applyChanges() in our own editor.\r\n            this._updateHiddenLines();\r\n        }\r\n        // Else, Master editor:\r\n        // we\'re the ground truth; nothing else to do, since Document listens directly to us\r\n        // note: this change might have been a real edit made by the user, OR this might have\r\n        // been a change synced from another editor\r\n        \r\n        // The "editorChange" event is mostly for the use of the CodeHintManager.\r\n        // It differs from the normal "change" event, that it\'s actually publicly usable,\r\n        // whereas the "change" event should be listened to on the document. Also the\r\n        // Editor dispatches a change event before this event is dispatched, because\r\n        // CodeHintManager needs to hook in here when other things are already done.\r\n        $(this).triggerHandler("editorChange", [this, changeList]);\r\n    };\r\n    \r\n    /**\r\n     * Responds to changes in the Document\'s text, syncing the changes into our CodeMirror instance.\r\n     * There are several cases where we want to ignore a Document change:\r\n     *  - if we\'re the master editor, Document changes should be ignored because we already have the right\r\n     *    text (either the change originated with us, or it has already been set into us by Document)\r\n     *  - if we\'re a secondary editor, Document changes should be ignored if they were caused by us sending\r\n     *    the document an editor change that originated with us\r\n     */\r\n    Editor.prototype._handleDocumentChange = function (event, doc, changeList) {\r\n        var change;\r\n        \r\n        // we\'re currently syncing to the Document, so don\'t echo back FROM the Document\r\n        if (this._duringSync) {\r\n            return;\r\n        }\r\n        \r\n        if (this.document._masterEditor !== this) {\r\n            // Secondary editor:\r\n            // we\'re not the ground truth; and if we got here, this was a Document change that\r\n            // didn\'t come from us (e.g. a sync from another editor, a direct programmatic change\r\n            // to the document, or a sync from external disk changes)... so sync from the Document\r\n            this._duringSync = true;\r\n            this._applyChanges(changeList);\r\n            this._duringSync = false;\r\n        }\r\n        // Else, Master editor:\r\n        // we\'re the ground truth; nothing to do since Document change is just echoing our\r\n        // editor changes\r\n    };\r\n    \r\n    /**\r\n     * Responds to the Document\'s underlying file being deleted. The Document is now basically dead,\r\n     * so we must close.\r\n     */\r\n    Editor.prototype._handleDocumentDeleted = function (event) {\r\n        // Pass the delete event along as the cause (needed in MultiRangeInlineEditor)\r\n        $(this).triggerHandler("lostContent", [event]);\r\n    };\r\n    \r\n    /**\r\n     * Responds to language changes, for instance when the file extension is changed.\r\n     */\r\n    Editor.prototype._handleDocumentLanguageChanged = function (event) {\r\n        this._codeMirror.setOption("mode", this._getModeFromDocument());\r\n    };\r\n    \r\n    \r\n    /**\r\n     * Install event handlers on the CodeMirror instance, translating them into\r\n     * jQuery events on the Editor instance.\r\n     */\r\n    Editor.prototype._installEditorListeners = function () {\r\n        var self = this;\r\n        \r\n        // Redispatch these CodeMirror key events as jQuery events\r\n        function _onKeyEvent(instance, event) {\r\n            $(self).triggerHandler("keyEvent", [self, event]);  // deprecated\r\n            $(self).triggerHandler(event.type, [self, event]);\r\n            return event.defaultPrevented;   // false tells CodeMirror we didn\'t eat the event\r\n        }\r\n        this._codeMirror.on("keydown",  _onKeyEvent);\r\n        this._codeMirror.on("keypress", _onKeyEvent);\r\n        this._codeMirror.on("keyup",    _onKeyEvent);\r\n        \r\n        // FUTURE: if this list grows longer, consider making this a more generic mapping\r\n        // NOTE: change is a "private" event--others shouldn\'t listen to it on Editor, only on\r\n        // Document\r\n        // Also, note that we use the new "changes" event in v4, which provides an array of\r\n        // change objects. Our own event is still called just "change".\r\n        this._codeMirror.on("changes", function (instance, changeList) {\r\n            $(self).triggerHandler("change", [self, changeList]);\r\n        });\r\n        this._codeMirror.on("beforeChange", function (instance, changeObj) {\r\n            $(self).triggerHandler("beforeChange", [self, changeObj]);\r\n        });\r\n        this._codeMirror.on("cursorActivity", function (instance) {\r\n            $(self).triggerHandler("cursorActivity", [self]);\r\n        });\r\n        this._codeMirror.on("scroll", function (instance) {\r\n            // If this editor is visible, close all dropdowns on scroll.\r\n            // (We don\'t want to do this if we\'re just scrolling in a non-visible editor\r\n            // in response to some document change event.)\r\n            if (self.isFullyVisible()) {\r\n                Menus.closeAll();\r\n            }\r\n\r\n            $(self).triggerHandler("scroll", [self]);\r\n        });\r\n\r\n        // Convert CodeMirror onFocus events to EditorManager activeEditorChanged\r\n        this._codeMirror.on("focus", function () {\r\n            self._focused = true;\r\n            $(self).triggerHandler("focus", [self]);\r\n        });\r\n        \r\n        this._codeMirror.on("blur", function () {\r\n            self._focused = false;\r\n            $(self).triggerHandler("blur", [self]);\r\n        });\r\n\r\n        this._codeMirror.on("update", function (instance) {\r\n            $(self).triggerHandler("update", [self]);\r\n        });\r\n        this._codeMirror.on("overwriteToggle", function (instance, newstate) {\r\n            $(self).triggerHandler("overwriteToggle", [self, newstate]);\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * Sets the contents of the editor, clears the undo/redo history and marks the document clean. Dispatches a change event.\r\n     * Semi-private: only Document should call this.\r\n     * @param {!string} text\r\n     */\r\n    Editor.prototype._resetText = function (text) {\r\n        var perfTimerName = PerfUtils.markStart("Editor._resetText()\\t" + (!this.document || this.document.file.fullPath));\r\n\r\n        var cursorPos = this.getCursorPos(),\r\n            scrollPos = this.getScrollPos();\r\n        \r\n        // This *will* fire a change event, but we clear the undo immediately afterward\r\n        this._codeMirror.setValue(text);\r\n        \r\n        // Make sure we can\'t undo back to the empty state before setValue(), and mark\r\n        // the document clean.\r\n        this._codeMirror.clearHistory();\r\n        this._codeMirror.markClean();\r\n        \r\n        // restore cursor and scroll positions\r\n        this.setCursorPos(cursorPos);\r\n        this.setScrollPos(scrollPos.x, scrollPos.y);\r\n\r\n        PerfUtils.addMeasurement(perfTimerName);\r\n    };\r\n\r\n   /**\r\n    * Gets the file associated with this editor\r\n    * This is a required Pane-View interface method\r\n    * @return {!File} the file associated with this editor\r\n    */\r\n    Editor.prototype.getFile = function () {\r\n        return this.document.file;\r\n    };\r\n    \r\n    /**\r\n     * Gets the current cursor position within the editor.\r\n     * @param {boolean} expandTabs  If true, return the actual visual column number instead of the character offset in\r\n     *      the "ch" property.\r\n     * @param {?string} which Optional string indicating which end of the\r\n     *  selection to return. It may be "start", "end", "head" (the side of the\r\n     *  selection that moves when you press shift+arrow), or "anchor" (the\r\n     *  fixed side of the selection). Omitting the argument is the same as\r\n     *  passing "head". A {line, ch} object will be returned.)\r\n     * @return {!{line:number, ch:number}}\r\n     */\r\n    Editor.prototype.getCursorPos = function (expandTabs, which) {\r\n        // Translate "start" and "end" to the official CM names (it actually\r\n        // supports them as-is, but that isn\'t documented and we don\'t want to\r\n        // rely on it).\r\n        if (which === "start") {\r\n            which = "from";\r\n        } else if (which === "end") {\r\n            which = "to";\r\n        }\r\n        var cursor = _copyPos(this._codeMirror.getCursor(which));\r\n        \r\n        if (expandTabs) {\r\n            cursor.ch = this.getColOffset(cursor);\r\n        }\r\n        return cursor;\r\n    };\r\n    \r\n    /**\r\n     * Returns the display column (zero-based) for a given string-based pos. Differs from pos.ch only\r\n     * when the line contains preceding \\t chars. Result depends on the current tab size setting.\r\n     * @param {!{line:number, ch:number}} pos\r\n     * @return {number}\r\n     */\r\n    Editor.prototype.getColOffset = function (pos) {\r\n        var line    = this._codeMirror.getRange({line: pos.line, ch: 0}, pos),\r\n            tabSize = null,\r\n            column  = 0,\r\n            i;\r\n\r\n        for (i = 0; i < line.length; i++) {\r\n            if (line[i] === \'\\t\') {\r\n                if (tabSize === null) {\r\n                    tabSize = Editor.getTabSize();\r\n                }\r\n                if (tabSize > 0) {\r\n                    column += (tabSize - (column % tabSize));\r\n                }\r\n            } else {\r\n                column++;\r\n            }\r\n        }\r\n        return column;\r\n    };\r\n    \r\n    /**\r\n     * Returns the string-based pos for a given display column (zero-based) in given line. Differs from column\r\n     * only when the line contains preceding \\t chars. Result depends on the current tab size setting.\r\n     * @param {number} lineNum Line number\r\n     * @param {number} column Display column number\r\n     * @return {number}\r\n     */\r\n    Editor.prototype.getCharIndexForColumn = function (lineNum, column) {\r\n        var line    = this._codeMirror.getLine(lineNum),\r\n            tabSize = null,\r\n            iCol    = 0,\r\n            i;\r\n\r\n        for (i = 0; iCol < column; i++) {\r\n            if (line[i] === \'\\t\') {\r\n                if (tabSize === null) {\r\n                    tabSize = Editor.getTabSize();\r\n                }\r\n                if (tabSize > 0) {\r\n                    iCol += (tabSize - (iCol % tabSize));\r\n                }\r\n            } else {\r\n                iCol++;\r\n            }\r\n        }\r\n        return i;\r\n    };\r\n    \r\n    /**\r\n     * Sets the cursor position within the editor. Removes any selection.\r\n     * @param {number} line  The 0 based line number.\r\n     * @param {number} ch  The 0 based character position; treated as 0 if unspecified.\r\n     * @param {boolean=} center  True if the view should be centered on the new cursor position.\r\n     * @param {boolean=} expandTabs  If true, use the actual visual column number instead of the character offset as\r\n     *      the "ch" parameter.\r\n     */\r\n    Editor.prototype.setCursorPos = function (line, ch, center, expandTabs) {\r\n        if (expandTabs) {\r\n            ch = this.getColOffset({line: line, ch: ch});\r\n        }\r\n        this._codeMirror.setCursor(line, ch);\r\n        if (center) {\r\n            this.centerOnCursor();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Set the editor size in pixels or percentage\r\n     * @param {(number|string)} width\r\n     * @param {(number|string)} height\r\n     */\r\n    Editor.prototype.setSize = function (width, height) {\r\n        this._codeMirror.setSize(width, height);\r\n    };\r\n    \r\n    /** @const */\r\n    var CENTERING_MARGIN = 0.15;\r\n    \r\n    /**\r\n     * Scrolls the editor viewport to vertically center the line with the cursor,\r\n     * but only if the cursor is currently near the edges of the viewport or\r\n     * entirely outside the viewport.\r\n     *\r\n     * This does not alter the horizontal scroll position.\r\n     *\r\n     * @param {number} centerOptions Option value, or 0 for no options; one of the BOUNDARY_* constants above.\r\n     */\r\n    Editor.prototype.centerOnCursor = function (centerOptions) {\r\n        var $scrollerElement = $(this.getScrollerElement());\r\n        var editorHeight = $scrollerElement.height();\r\n        \r\n        // we need to make adjustments for the statusbar\'s padding on the bottom and the menu bar on top.\r\n        var statusBarHeight = $scrollerElement.outerHeight() - editorHeight;\r\n        var menuBarHeight = $scrollerElement.offset().top;\r\n        \r\n        var documentCursorPosition = this._codeMirror.cursorCoords(null, "local").bottom;\r\n        var screenCursorPosition = this._codeMirror.cursorCoords(null, "page").bottom - menuBarHeight;\r\n        \r\n        // If the cursor is already reasonably centered, we won\'t\r\n        // make any change. "Reasonably centered" is defined as\r\n        // not being within CENTERING_MARGIN of the top or bottom\r\n        // of the editor (where CENTERING_MARGIN is a percentage\r\n        // of the editor height).\r\n        // For finding the first item (i.e. find while typing), do\r\n        // not center if hit is in first half of screen because this\r\n        // appears to be an unnecesary scroll.\r\n        if ((_checkTopBoundary(centerOptions) && (screenCursorPosition < editorHeight * CENTERING_MARGIN)) ||\r\n                (_checkBottomBoundary(centerOptions) && (screenCursorPosition > editorHeight * (1 - CENTERING_MARGIN)))) {\r\n\r\n            var pos = documentCursorPosition - editorHeight / 2 + statusBarHeight;\r\n            var info = this._codeMirror.getScrollInfo();\r\n            pos = Math.min(Math.max(pos, 0), (info.height - info.clientHeight));\r\n            this.setScrollPos(null, pos);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Given a position, returns its index within the text (assuming \\n newlines)\r\n     * @param {!{line:number, ch:number}}\r\n     * @return {number}\r\n     */\r\n    Editor.prototype.indexFromPos = function (coords) {\r\n        return this._codeMirror.indexFromPos(coords);\r\n    };\r\n\r\n    /**\r\n     * Returns true if pos is between start and end (INclusive at start; EXclusive at end by default,\r\n     * but overridable via the endInclusive flag).\r\n     * @param {{line:number, ch:number}} pos\r\n     * @param {{line:number, ch:number}} start\r\n     * @param {{line:number, ch:number}} end\r\n     * @param {boolean} endInclusive\r\n     *\r\n     */\r\n    Editor.prototype.posWithinRange = function (pos, start, end, endInclusive) {\r\n        if (start.line <= pos.line && end.line >= pos.line) {\r\n            if (endInclusive) {\r\n                return (start.line < pos.line || start.ch <= pos.ch) &&  // inclusive\r\n                    (end.line > pos.line   || end.ch >= pos.ch);      // inclusive\r\n            } else {\r\n                return (start.line < pos.line || start.ch <= pos.ch) &&  // inclusive\r\n                    (end.line > pos.line   || end.ch > pos.ch);       // exclusive\r\n            }\r\n                   \r\n        }\r\n        return false;\r\n    };\r\n    \r\n    /**\r\n     * @return {boolean} True if there\'s a text selection; false if there\'s just an insertion point\r\n     */\r\n    Editor.prototype.hasSelection = function () {\r\n        return this._codeMirror.somethingSelected();\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Takes an anchor/head pair and returns a start/end pair where the start is guaranteed to be <= end, and a "reversed" flag indicating\r\n     * if the head is before the anchor.\r\n     * @param {!{line: number, ch: number}} anchorPos\r\n     * @param {!{line: number, ch: number}} headPos\r\n     * @return {!{start:{line:number, ch:number}, end:{line:number, ch:number}}, reversed:boolean} the normalized range with start <= end\r\n     */\r\n    function _normalizeRange(anchorPos, headPos) {\r\n        if (headPos.line < anchorPos.line || (headPos.line === anchorPos.line && headPos.ch < anchorPos.ch)) {\r\n            return {start: _copyPos(headPos), end: _copyPos(anchorPos), reversed: true};\r\n        } else {\r\n            return {start: _copyPos(anchorPos), end: _copyPos(headPos), reversed: false};\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Gets the current selection; if there is more than one selection, returns the primary selection\r\n     * (generally the last one made). Start is inclusive, end is exclusive. If there is no selection,\r\n     * returns the current cursor position as both the start and end of the range (i.e. a selection\r\n     * of length zero). If `reversed` is set, then the head of the selection (the end of the selection\r\n     * that would be changed if the user extended the selection) is before the anchor. \r\n     * @return {!{start:{line:number, ch:number}, end:{line:number, ch:number}}, reversed:boolean}\r\n     */\r\n    Editor.prototype.getSelection = function () {\r\n        return _normalizeRange(this.getCursorPos(false, "anchor"), this.getCursorPos(false, "head"));\r\n    };\r\n    \r\n    /**\r\n     * Returns an array of current selections, nonoverlapping and sorted in document order. \r\n     * Each selection is a start/end pair, with the start guaranteed to come before the end.\r\n     * Cursors are represented as a range whose start is equal to the end.\r\n     * If `reversed` is set, then the head of the selection\r\n     * (the end of the selection that would be changed if the user extended the selection)\r\n     * is before the anchor. \r\n     * If `primary` is set, then that selection is the primary selection.\r\n     * @return {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>}\r\n     */\r\n    Editor.prototype.getSelections = function () {\r\n        var primarySel = this.getSelection();\r\n        return _.map(this._codeMirror.listSelections(), function (sel) {\r\n            var result = _normalizeRange(sel.anchor, sel.head);\r\n            if (result.start.line === primarySel.start.line && result.start.ch === primarySel.start.ch &&\r\n                    result.end.line === primarySel.end.line && result.end.ch === primarySel.end.ch) {\r\n                result.primary = true;\r\n            } else {\r\n                result.primary = false;\r\n            }\r\n            return result;\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * Takes the given selections, and expands each selection so it encompasses whole lines. Merges\r\n     * adjacent line selections together. Keeps track of each original selection associated with a given\r\n     * line selection (there might be multiple if individual selections were merged into a single line selection).\r\n     * Useful for doing multiple-selection-aware line edits.\r\n     *\r\n     * @param {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>} selections\r\n     *      The selections to expand.\r\n     * @param {{expandEndAtStartOfLine: boolean, mergeAdjacent: boolean}} options\r\n     *      expandEndAtStartOfLine: true if a range selection that ends at the beginning of a line should be expanded\r\n     *          to encompass the line. Default false.\r\n     *      mergeAdjacent: true if adjacent line ranges should be merged. Default true.\r\n     * @return {Array.<{selectionForEdit: {start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}, \r\n     *                  selectionsToTrack: Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>}>}\r\n     *      The combined line selections. For each selection, `selectionForEdit` is the line selection, and `selectionsToTrack` is\r\n     *      the set of original selections that combined to make up the given line selection. Note that the selectionsToTrack will\r\n     *      include the original objects passed in `selections`, so if it is later mutated the original passed-in selections will be\r\n     *      mutated as well.\r\n     */\r\n    Editor.prototype.convertToLineSelections = function (selections, options) {\r\n        var self = this;\r\n        options = options || {};\r\n        _.defaults(options, { expandEndAtStartOfLine: false, mergeAdjacent: true });\r\n        \r\n        // Combine adjacent lines with selections so they don\'t collide with each other, as they would\r\n        // if we did them individually.\r\n        var combinedSelections = [], prevSel;\r\n        _.each(selections, function (sel) {\r\n            var newSel = _.cloneDeep(sel);\r\n            \r\n            // Adjust selection to encompass whole lines.\r\n            newSel.start.ch = 0;\r\n            // The end of the selection becomes the start of the next line, if it isn\'t already\r\n            // or if expandEndAtStartOfLine is set.\r\n            var hasSelection = (newSel.start.line !== newSel.end.line) || (newSel.start.ch !== newSel.end.ch);\r\n            if (options.expandEndAtStartOfLine || !hasSelection || newSel.end.ch !== 0) {\r\n                newSel.end = {line: newSel.end.line + 1, ch: 0};\r\n            }\r\n\r\n            // If the start of the new selection is within the range of the previous (expanded) selection, merge\r\n            // the two selections together, but keep track of all the original selections that were related to this\r\n            // selection, so they can be properly adjusted. (We only have to check for the start being inside the previous\r\n            // range - it can\'t be before it because the selections started out sorted.)\r\n            if (prevSel && self.posWithinRange(newSel.start, prevSel.selectionForEdit.start, prevSel.selectionForEdit.end, options.mergeAdjacent)) {\r\n                prevSel.selectionForEdit.end.line = newSel.end.line;\r\n                prevSel.selectionsToTrack.push(sel);\r\n            } else {\r\n                prevSel = {selectionForEdit: newSel, selectionsToTrack: [sel]};\r\n                combinedSelections.push(prevSel);\r\n            }\r\n        });\r\n        return combinedSelections;\r\n    };\r\n    \r\n    /**\r\n     * Returns the currently selected text, or "" if no selection. Includes \\n if the\r\n     * selection spans multiple lines (does NOT reflect the Document\'s line-endings style). By\r\n     * default, returns only the contents of the primary selection, unless `allSelections` is true.\r\n     * @param {boolean=} allSelections Whether to return the contents of all selections (separated\r\n     *     by newlines) instead of just the primary selection. Default false.\r\n     * @return {!string} The selected text.\r\n     */\r\n    Editor.prototype.getSelectedText = function (allSelections) {\r\n        if (allSelections) {\r\n            return this._codeMirror.getSelection();\r\n        } else {\r\n            var sel = this.getSelection();\r\n            return this.document.getRange(sel.start, sel.end);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Sets the current selection. Start is inclusive, end is exclusive. Places the cursor at the\r\n     * end of the selection range. Optionally centers around the cursor after\r\n     * making the selection\r\n     *\r\n     * @param {!{line:number, ch:number}} start\r\n     * @param {{line:number, ch:number}=} end If not specified, defaults to start.\r\n     * @param {boolean} center true to center the viewport\r\n     * @param {number} centerOptions Option value, or 0 for no options; one of the BOUNDARY_* constants above.\r\n     * @param {?string} origin An optional string that describes what other selection or edit operations this\r\n     *      should be merged with for the purposes of undo. See Document.replaceRange() for more details.\r\n     */\r\n    Editor.prototype.setSelection = function (start, end, center, centerOptions, origin) {\r\n        this.setSelections([{start: start, end: end || start}], center, centerOptions, origin);\r\n    };\r\n    \r\n    /**\r\n     * Sets a multiple selection, with the "primary" selection (the one returned by\r\n     * getSelection() and getCursorPos()) defaulting to the last if not specified.\r\n     * Overlapping ranges will be automatically merged, and the selection will be sorted.\r\n     * Optionally centers around the primary selection after making the selection.\r\n     * @param {!Array<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean}>} selections\r\n     *      The selection ranges to set. If the start and end of a range are the same, treated as a cursor.\r\n     *      If reversed is true, set the anchor of the range to the end instead of the start.\r\n     *      If primary is true, this is the primary selection. Behavior is undefined if more than\r\n     *      one selection has primary set to true. If none has primary set to true, the last one is primary.\r\n     * @param {boolean} center true to center the viewport around the primary selection.\r\n     * @param {number} centerOptions Option value, or 0 for no options; one of the BOUNDARY_* constants above.\r\n     * @param {?string} origin An optional string that describes what other selection or edit operations this\r\n     *      should be merged with for the purposes of undo. See Document.replaceRange() for more details.\r\n     */\r\n    Editor.prototype.setSelections = function (selections, center, centerOptions, origin) {\r\n        var primIndex = selections.length - 1, options;\r\n        if (origin) {\r\n            options = { origin: origin };\r\n        }\r\n        this._codeMirror.setSelections(_.map(selections, function (sel, index) {\r\n            if (sel.primary) {\r\n                primIndex = index;\r\n            }\r\n            return { anchor: sel.reversed ? sel.end : sel.start, head: sel.reversed ? sel.start : sel.end };\r\n        }), primIndex, options);\r\n        if (center) {\r\n            this.centerOnCursor(centerOptions);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the editors overwrite mode state. If null is passed, the state is toggled.\r\n     *\r\n     * @param {?boolean} start\r\n     */\r\n    Editor.prototype.toggleOverwrite = function (state) {\r\n        this._codeMirror.toggleOverwrite(state);\r\n    };\r\n\r\n    /**\r\n     * Selects word that the given pos lies within or adjacent to. If pos isn\'t touching a word\r\n     * (e.g. within a token like "//"), moves the cursor to pos without selecting a range.\r\n     * Adapted from selectWordAt() in CodeMirror v2.\r\n     * @param {!{line:number, ch:number}}\r\n     */\r\n    Editor.prototype.selectWordAt = function (pos) {\r\n        var line = this.document.getLine(pos.line),\r\n            start = pos.ch,\r\n            end = pos.ch;\r\n        \r\n        function isWordChar(ch) {\r\n            return (/\\w/).test(ch) || ch.toUpperCase() !== ch.toLowerCase();\r\n        }\r\n        \r\n        while (start > 0 && isWordChar(line.charAt(start - 1))) {\r\n            --start;\r\n        }\r\n        while (end < line.length && isWordChar(line.charAt(end))) {\r\n            ++end;\r\n        }\r\n        this.setSelection({line: pos.line, ch: start}, {line: pos.line, ch: end});\r\n    };\r\n    \r\n    /**\r\n     * Gets the total number of lines in the the document (includes lines not visible in the viewport)\r\n     * @return {!number}\r\n     */\r\n    Editor.prototype.lineCount = function () {\r\n        return this._codeMirror.lineCount();\r\n    };\r\n    \r\n    /**\r\n     * Deterines if line is fully visible.\r\n     * @param {number} zero-based index of the line to test\r\n     * @return {boolean} true if the line is fully visible, false otherwise\r\n     */\r\n    Editor.prototype.isLineVisible = function (line) {\r\n        var coords = this._codeMirror.charCoords({line: line, ch: 0}, "local"),\r\n            scrollInfo = this._codeMirror.getScrollInfo(),\r\n            top = scrollInfo.top,\r\n            bottom = scrollInfo.top + scrollInfo.clientHeight;\r\n\r\n        // Check top and bottom and return false for partially visible lines.\r\n        return (coords.top >= top && coords.bottom <= bottom);\r\n    };\r\n    \r\n    /**\r\n     * Gets the number of the first visible line in the editor.\r\n     * @return {number} The 0-based index of the first visible line.\r\n     */\r\n    Editor.prototype.getFirstVisibleLine = function () {\r\n        return (this._visibleRange ? this._visibleRange.startLine : 0);\r\n    };\r\n    \r\n    /**\r\n     * Gets the number of the last visible line in the editor.\r\n     * @return {number} The 0-based index of the last visible line.\r\n     */\r\n    Editor.prototype.getLastVisibleLine = function () {\r\n        return (this._visibleRange ? this._visibleRange.endLine : this.lineCount() - 1);\r\n    };\r\n\r\n    /* Hides the specified line number in the editor\r\n     * @param {!from} line to start hiding from (inclusive)\r\n     * @param {!to} line to end hiding at (exclusive)\r\n     * @return {TextMarker} The CodeMirror mark object that\'s hiding the lines\r\n     */\r\n    Editor.prototype._hideLines = function (from, to) {\r\n        if (to <= from) {\r\n            return;\r\n        }\r\n        \r\n        // We set clearWhenEmpty: false so that if there\'s a blank line at the beginning or end of\r\n        // the document, and that\'s the only hidden line, we can still actually hide it. Doing so\r\n        // requires us to create a 0-length marked span, which would ordinarily be cleaned up by CM\r\n        // if clearWithEmpty is true. See https://groups.google.com/forum/#!topic/codemirror/RB8VNF8ow2w\r\n        var value = this._codeMirror.markText(\r\n            {line: from, ch: 0},\r\n            {line: to - 1, ch: this._codeMirror.getLine(to - 1).length},\r\n            {collapsed: true, inclusiveLeft: true, inclusiveRight: true, clearWhenEmpty: false}\r\n        );\r\n        \r\n        return value;\r\n    };\r\n\r\n    /**\r\n     * Gets the total height of the document in pixels (not the viewport)\r\n     * @return {!number} height in pixels\r\n     */\r\n    Editor.prototype.totalHeight = function () {\r\n        return this.getScrollerElement().scrollHeight;\r\n    };\r\n\r\n    /**\r\n     * Gets the scroller element from the editor.\r\n     * @return {!HTMLDivElement} scroller\r\n     */\r\n    Editor.prototype.getScrollerElement = function () {\r\n        return this._codeMirror.getScrollerElement();\r\n    };\r\n    \r\n    /**\r\n     * Gets the root DOM node of the editor.\r\n     * @return {!HTMLDivElement} The editor\'s root DOM node.\r\n     */\r\n    Editor.prototype.getRootElement = function () {\r\n        return this._codeMirror.getWrapperElement();\r\n    };\r\n\r\n    \r\n    /**\r\n     * Gets the lineSpace element within the editor (the container around the individual lines of code).\r\n     * FUTURE: This is fairly CodeMirror-specific. Logic that depends on this may break if we switch\r\n     * editors.\r\n     * @return {!HTMLDivElement} The editor\'s lineSpace element.\r\n     */\r\n    Editor.prototype._getLineSpaceElement = function () {\r\n        return $(".CodeMirror-lines", this.getScrollerElement()).children().get(0);\r\n    };\r\n    \r\n    /**\r\n     * Returns the current scroll position of the editor.\r\n     * @return {{x:number, y:number}} The x,y scroll position in pixels\r\n     */\r\n    Editor.prototype.getScrollPos = function () {\r\n        var scrollInfo = this._codeMirror.getScrollInfo();\r\n        return { x: scrollInfo.left, y: scrollInfo.top };\r\n    };\r\n    \r\n    /**\r\n     * Restores and adjusts the current scroll position of the editor.\r\n     * @param {{x:number, y:number}} scrollPos - The x,y scroll position in pixels\r\n     * @param {!number} heightDelta - The amount of delta H to apply to the scroll position\r\n     */\r\n    Editor.prototype.adjustScrollPos = function (scrollPos, heightDelta) {\r\n        this._codeMirror.scrollTo(scrollPos.x, scrollPos.y + heightDelta);\r\n    };\r\n    \r\n    /**\r\n     * Sets the current scroll position of the editor.\r\n     * @param {number} x scrollLeft position in pixels\r\n     * @param {number} y scrollTop position in pixels\r\n     */\r\n    Editor.prototype.setScrollPos = function (x, y) {\r\n        this._codeMirror.scrollTo(x, y);\r\n    };\r\n    \r\n    /*\r\n     * Returns the current text height of the editor.\r\n     * @return {number} Height of the text in pixels\r\n     */\r\n    Editor.prototype.getTextHeight = function () {\r\n        return this._codeMirror.defaultTextHeight();\r\n    };\r\n    \r\n    /**\r\n     * Adds an inline widget below the given line. If any inline widget was already open for that\r\n     * line, it is closed without warning.\r\n     * @param {!{line:number, ch:number}} pos  Position in text to anchor the inline.\r\n     * @param {!InlineWidget} inlineWidget The widget to add.\r\n     * @param {boolean=} scrollLineIntoView Scrolls the associated line into view. Default true.\r\n     * @return {$.Promise} A promise object that is resolved when the widget has been added (but might\r\n     *     still be animating open). Never rejected.\r\n     */\r\n    Editor.prototype.addInlineWidget = function (pos, inlineWidget, scrollLineIntoView) {\r\n        var self = this,\r\n            queue = this._inlineWidgetQueues[pos.line],\r\n            deferred = new $.Deferred();\r\n        if (!queue) {\r\n            queue = new Async.PromiseQueue();\r\n            this._inlineWidgetQueues[pos.line] = queue;\r\n        }\r\n        queue.add(function () {\r\n            self._addInlineWidgetInternal(pos, inlineWidget, scrollLineIntoView, deferred);\r\n            return deferred.promise();\r\n        });\r\n        return deferred.promise();\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Does the actual work of addInlineWidget().\r\n     */\r\n    Editor.prototype._addInlineWidgetInternal = function (pos, inlineWidget, scrollLineIntoView, deferred) {\r\n        var self = this;\r\n        \r\n        this.removeAllInlineWidgetsForLine(pos.line).done(function () {\r\n            if (scrollLineIntoView === undefined) {\r\n                scrollLineIntoView = true;\r\n            }\r\n    \r\n            if (scrollLineIntoView) {\r\n                self._codeMirror.scrollIntoView(pos);\r\n            }\r\n    \r\n            inlineWidget.info = self._codeMirror.addLineWidget(pos.line, inlineWidget.htmlContent,\r\n                                                               { coverGutter: true, noHScroll: true });\r\n            CodeMirror.on(inlineWidget.info.line, "delete", function () {\r\n                self._removeInlineWidgetInternal(inlineWidget);\r\n            });\r\n            self._inlineWidgets.push(inlineWidget);\r\n\r\n            // Set up the widget to start closed, then animate open when its initial height is set.\r\n            inlineWidget.$htmlContent.height(0);\r\n            AnimationUtils.animateUsingClass(inlineWidget.htmlContent, "animating")\r\n                .done(function () {\r\n                    deferred.resolve();\r\n                });\r\n\r\n            // Callback to widget once parented to the editor. The widget should call back to\r\n            // setInlineWidgetHeight() in order to set its initial height and animate open.\r\n            inlineWidget.onAdded();\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * Removes all inline widgets\r\n     */\r\n    Editor.prototype.removeAllInlineWidgets = function () {\r\n        // copy the array because _removeInlineWidgetInternal will modify the original\r\n        var widgets = [].concat(this.getInlineWidgets());\r\n        \r\n        return Async.doInParallel(\r\n            widgets,\r\n            this.removeInlineWidget.bind(this)\r\n        );\r\n    };\r\n    \r\n    /**\r\n     * Removes the given inline widget.\r\n     * @param {number} inlineWidget The widget to remove.\r\n     * @return {$.Promise} A promise that is resolved when the inline widget is fully closed and removed from the DOM.\r\n     */\r\n    Editor.prototype.removeInlineWidget = function (inlineWidget) {\r\n        var deferred = new $.Deferred(),\r\n            self = this;\r\n\r\n        function finishRemoving() {\r\n            self._codeMirror.removeLineWidget(inlineWidget.info);\r\n            self._removeInlineWidgetInternal(inlineWidget);\r\n            deferred.resolve();\r\n        }\r\n            \r\n        if (!inlineWidget.closePromise) {\r\n            // Remove the inline widget from our internal list immediately, so\r\n            // everyone external to us knows it\'s essentially already gone. We\r\n            // don\'t want to wait until it\'s done animating closed (but we do want\r\n            // the other stuff in _removeInlineWidgetInternal to wait until then).\r\n            self._removeInlineWidgetFromList(inlineWidget);\r\n            \r\n            // If we\'re not visible (in which case the widget will have 0 client height),\r\n            // don\'t try to do the animation, because nothing will happen and we won\'t get\r\n            // called back right away. (The animation would happen later when we switch\r\n            // back to the editor.)\r\n            if (self.isFullyVisible()) {\r\n                AnimationUtils.animateUsingClass(inlineWidget.htmlContent, "animating")\r\n                    .done(finishRemoving);\r\n                inlineWidget.$htmlContent.height(0);\r\n            } else {\r\n                finishRemoving();\r\n            }\r\n            inlineWidget.closePromise = deferred.promise();\r\n        }\r\n        return inlineWidget.closePromise;\r\n    };\r\n    \r\n    /**\r\n     * Removes all inline widgets for a given line\r\n     * @param {number} lineNum The line number to modify\r\n     */\r\n    Editor.prototype.removeAllInlineWidgetsForLine = function (lineNum) {\r\n        var lineInfo = this._codeMirror.lineInfo(lineNum),\r\n            widgetInfos = (lineInfo && lineInfo.widgets) ? [].concat(lineInfo.widgets) : null,\r\n            self = this;\r\n        \r\n        if (widgetInfos && widgetInfos.length) {\r\n            // Map from CodeMirror LineWidget to Brackets InlineWidget\r\n            var inlineWidget,\r\n                allWidgetInfos = this._inlineWidgets.map(function (w) {\r\n                    return w.info;\r\n                });\r\n\r\n            return Async.doInParallel(\r\n                widgetInfos,\r\n                function (info) {\r\n                    // Lookup the InlineWidget object using the same index\r\n                    inlineWidget = self._inlineWidgets[allWidgetInfos.indexOf(info)];\r\n                    if (inlineWidget) {\r\n                        return self.removeInlineWidget(inlineWidget);\r\n                    } else {\r\n                        return new $.Deferred().resolve().promise();\r\n                    }\r\n                }\r\n            );\r\n        } else {\r\n            return new $.Deferred().resolve().promise();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Cleans up the given inline widget from our internal list of widgets. It\'s okay\r\n     * to call this multiple times for the same widget--it will just do nothing if\r\n     * the widget has already been removed.\r\n     * @param {InlineWidget} inlineWidget  an inline widget.\r\n     */\r\n    Editor.prototype._removeInlineWidgetFromList = function (inlineWidget) {\r\n        var l = this._inlineWidgets.length,\r\n            i;\r\n        for (i = 0; i < l; i++) {\r\n            if (this._inlineWidgets[i] === inlineWidget) {\r\n                this._inlineWidgets.splice(i, 1);\r\n                break;\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Removes the inline widget from the editor and notifies it to clean itself up.\r\n     * @param {InlineWidget} inlineWidget  an inline widget.\r\n     */\r\n    Editor.prototype._removeInlineWidgetInternal = function (inlineWidget) {\r\n        if (!inlineWidget.isClosed) {\r\n            this._removeInlineWidgetFromList(inlineWidget);\r\n            inlineWidget.onClosed();\r\n            inlineWidget.isClosed = true;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Returns a list of all inline widgets currently open in this editor. Each entry contains the\r\n     * inline\'s id, and the data parameter that was passed to addInlineWidget().\r\n     * @return {!Array.<{id:number, data:Object}>}\r\n     */\r\n    Editor.prototype.getInlineWidgets = function () {\r\n        return this._inlineWidgets;\r\n    };\r\n    \r\n      /**\r\n     * Returns the currently focused inline widget, if any.\r\n     * @return {?InlineWidget}\r\n     */\r\n    Editor.prototype.getFocusedInlineWidget = function () {\r\n        var result = null;\r\n        \r\n        this.getInlineWidgets().forEach(function (widget) {\r\n            if (widget.hasFocus()) {\r\n                result = widget;\r\n            }\r\n        });\r\n        \r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Display temporary popover message at current cursor position. Display message above\r\n     * cursor if space allows, otherwise below.\r\n     *\r\n     * @param {string} errorMsg Error message to display\r\n     */\r\n    Editor.prototype.displayErrorMessageAtCursor = function (errorMsg) {\r\n        var arrowBelow, cursorPos, cursorCoord, popoverRect,\r\n            top, left, clip, arrowCenter, arrowLeft,\r\n            self = this,\r\n            POPOVER_MARGIN = 10,\r\n            POPOVER_ARROW_HALF_WIDTH = 10,\r\n            POPOVER_ARROW_HALF_BASE = POPOVER_ARROW_HALF_WIDTH + 3; // 3 is border radius\r\n\r\n        function _removeListeners() {\r\n            $(self).off(".msgbox");\r\n        }\r\n\r\n        // PopUpManager.removePopUp() callback\r\n        function _clearMessagePopover() {\r\n            if (self._$messagePopover && self._$messagePopover.length > 0) {\r\n                // self._$messagePopover.remove() is done by PopUpManager\r\n                self._$messagePopover = null;\r\n            }\r\n            _removeListeners();\r\n        }\r\n        \r\n        // PopUpManager.removePopUp() is called either directly by this closure, or by\r\n        // PopUpManager as a result of another popup being invoked.\r\n        function _removeMessagePopover() {\r\n            if (self._$messagePopover) {\r\n                PopUpManager.removePopUp(self._$messagePopover);\r\n            }\r\n        }\r\n\r\n        function _addListeners() {\r\n            $(self)\r\n                .on("blur.msgbox",           _removeMessagePopover)\r\n                .on("change.msgbox",         _removeMessagePopover)\r\n                .on("cursorActivity.msgbox", _removeMessagePopover)\r\n                .on("update.msgbox",         _removeMessagePopover);\r\n        }\r\n\r\n        // Only 1 message at a time\r\n        if (this._$messagePopover) {\r\n            _removeMessagePopover();\r\n        }\r\n        \r\n        // Make sure cursor is in view\r\n        cursorPos = this.getCursorPos();\r\n        this._codeMirror.scrollIntoView(cursorPos);\r\n        \r\n        // Determine if arrow is above or below\r\n        cursorCoord = this._codeMirror.charCoords(cursorPos);\r\n        \r\n        // Assume popover height is max of 2 lines\r\n        arrowBelow = (cursorCoord.top > 100);\r\n        \r\n        // Text is dynamic, so build popover first so we can measure final width\r\n        this._$messagePopover = $("<div/>").addClass("popover-message").appendTo($("body"));\r\n        if (!arrowBelow) {\r\n            $("<div/>").addClass("arrowAbove").appendTo(this._$messagePopover);\r\n        }\r\n        $("<div/>").addClass("text").appendTo(this._$messagePopover).html(errorMsg);\r\n        if (arrowBelow) {\r\n            $("<div/>").addClass("arrowBelow").appendTo(this._$messagePopover);\r\n        }\r\n        \r\n        // Estimate where to position popover.\r\n        top = (arrowBelow) ? cursorCoord.top - this._$messagePopover.height() - POPOVER_MARGIN\r\n                           : cursorCoord.bottom + POPOVER_MARGIN;\r\n        left = cursorCoord.left - (this._$messagePopover.width() / 2);\r\n        \r\n        popoverRect = {\r\n            top:    top,\r\n            left:   left,\r\n            height: this._$messagePopover.height(),\r\n            width:  this._$messagePopover.width()\r\n        };\r\n        \r\n        // See if popover is clipped on any side\r\n        clip = ViewUtils.getElementClipSize($("#editor-holder"), popoverRect);\r\n\r\n        // Prevent horizontal clipping\r\n        if (clip.left > 0) {\r\n            left += clip.left;\r\n        } else if (clip.right > 0) {\r\n            left -= clip.right;\r\n        }\r\n        \r\n        // Popover text and arrow are positioned individually\r\n        this._$messagePopover.css({"top": top, "left": left});\r\n        \r\n        // Position popover arrow centered over/under cursor...\r\n        arrowCenter = cursorCoord.left - left;\r\n\r\n        // ... but don\'t let it slide off text box\r\n        arrowCenter = Math.min(popoverRect.width - POPOVER_ARROW_HALF_BASE,\r\n                               Math.max(arrowCenter, POPOVER_ARROW_HALF_BASE));\r\n\r\n        arrowLeft = arrowCenter - POPOVER_ARROW_HALF_WIDTH;\r\n        if (arrowBelow) {\r\n            this._$messagePopover.find(".arrowBelow").css({"margin-left": arrowLeft});\r\n        } else {\r\n            this._$messagePopover.find(".arrowAbove").css({"margin-left": arrowLeft});\r\n        }\r\n\r\n        // Add listeners\r\n        PopUpManager.addPopUp(this._$messagePopover, _clearMessagePopover, true);\r\n        _addListeners();\r\n\r\n        // Animate open\r\n        AnimationUtils.animateUsingClass(this._$messagePopover[0], "animateOpen").done(function () {\r\n            // Make sure we still have a popover\r\n            if (self._$messagePopover && self._$messagePopover.length > 0) {\r\n                self._$messagePopover.addClass("open");\r\n\r\n                // Don\'t add scroll listeners until open so we don\'t get event\r\n                // from scrolling cursor into view\r\n                $(self).on("scroll.msgbox", _removeMessagePopover);\r\n\r\n                // Animate closed -- which includes delay to show message\r\n                AnimationUtils.animateUsingClass(self._$messagePopover[0], "animateClose", 6000)\r\n                    .done(_removeMessagePopover);\r\n            }\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * Returns the offset of the top of the virtual scroll area relative to the browser window (not the editor\r\n     * itself). Mainly useful for calculations related to scrollIntoView(), where you\'re starting with the\r\n     * offset() of a child widget (relative to the browser window) and need to figure out how far down it is from\r\n     * the top of the virtual scroll area (excluding the top padding).\r\n     * @return {number}\r\n     */\r\n    Editor.prototype.getVirtualScrollAreaTop = function () {\r\n        var topPadding = this._getLineSpaceElement().offsetTop, // padding within mover\r\n            scroller = this.getScrollerElement();\r\n        return $(scroller).offset().top - scroller.scrollTop + topPadding;\r\n    };\r\n\r\n    /**\r\n     * Sets the height of an inline widget in this editor.\r\n     * @param {!InlineWidget} inlineWidget The widget whose height should be set.\r\n     * @param {!number} height The height of the widget.\r\n     * @param {boolean} ensureVisible Whether to scroll the entire widget into view.\r\n     */\r\n    Editor.prototype.setInlineWidgetHeight = function (inlineWidget, height, ensureVisible) {\r\n        var self = this,\r\n            node = inlineWidget.htmlContent,\r\n            oldHeight = (node && $(node).height()) || 0,\r\n            changed = (oldHeight !== height),\r\n            isAttached = inlineWidget.info !== undefined;\r\n\r\n        function updateHeight() {\r\n            // Notify CodeMirror for the height change.\r\n            if (isAttached) {\r\n                inlineWidget.info.changed();\r\n            }\r\n        }\r\n        \r\n        function setOuterHeight() {\r\n            function finishAnimating(e) {\r\n                if (e.target === node) {\r\n                    updateHeight();\r\n                    $(node).off("webkitTransitionEnd", finishAnimating);\r\n                }\r\n            }\r\n            $(node).height(height);\r\n            if ($(node).hasClass("animating")) {\r\n                $(node).on("webkitTransitionEnd", finishAnimating);\r\n            } else {\r\n                updateHeight();\r\n            }\r\n        }\r\n\r\n        // Make sure we set an explicit height on the widget, so children can use things like\r\n        // min-height if they want.\r\n        if (changed || !node.style.height) {\r\n            // If we\'re animating, set the wrapper\'s height on a timeout so the layout is finished before we animate.\r\n            if ($(node).hasClass("animating")) {\r\n                window.setTimeout(setOuterHeight, 0);\r\n            } else {\r\n                setOuterHeight();\r\n            }\r\n        }\r\n\r\n        if (ensureVisible && isAttached) {\r\n            var offset = $(node).offset(), // offset relative to document\r\n                position = $(node).position(), // position within parent linespace\r\n                scrollerTop = self.getVirtualScrollAreaTop();\r\n\r\n            self._codeMirror.scrollIntoView({\r\n                left: position.left,\r\n                top: offset.top - scrollerTop,\r\n                right: position.left, // don\'t try to make the right edge visible\r\n                bottom: offset.top + height - scrollerTop\r\n            });\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Get the starting line number for an inline widget.\r\n     * @param {!InlineWidget} inlineWidget\r\n     * @return {number} The line number of the widget or -1 if not found.\r\n     */\r\n    Editor.prototype._getInlineWidgetLineNumber = function (inlineWidget) {\r\n        return this._codeMirror.getLineNumber(inlineWidget.info.line);\r\n    };\r\n    \r\n    /** Gives focus to the editor control */\r\n    Editor.prototype.focus = function () {\r\n        // Focusing an editor synchronously triggers focus/blur handlers. If a blur handler attemps to focus\r\n        // another editor, we\'ll put CM in a bad state (because CM assumes programmatically focusing itself\r\n        // will always succeed, and if you\'re in the middle of another focus change that appears to be untrue).\r\n        // So instead, we simply ignore reentrant focus attempts.\r\n        // See bug #2951 for an example of this happening and badly hosing things.\r\n        if (_duringFocus) {\r\n            return;\r\n        }\r\n        \r\n        _duringFocus = true;\r\n        try {\r\n            this._codeMirror.focus();\r\n        } finally {\r\n            _duringFocus = false;\r\n        }\r\n    };\r\n    \r\n    /** Returns true if the editor has focus */\r\n    Editor.prototype.hasFocus = function () {\r\n        return this._focused;\r\n    };\r\n    \r\n    /* \r\n     * @typedef {scrollPos:{x:number, y:number},Array.<{start:{line:number, ch:number},end:{line:number, ch:number}}>} EditorViewState\r\n     */\r\n    \r\n    /* \r\n     * returns the view state for the editor\r\n     * @return {!EditorViewState}\r\n     */\r\n    Editor.prototype.getViewState = function () {\r\n        return {\r\n            selections: this.getSelections(),\r\n            scrollPos: this.getScrollPos()\r\n        };\r\n        \r\n    };\r\n    \r\n    /*\r\n     * Restores the view state\r\n     * @param {!EditorViewState} viewState - the view state object to restore\r\n     */\r\n    Editor.prototype.restoreViewState = function (viewState) {\r\n        if (viewState.selection) {\r\n            // We no longer write out single-selection, but there might be some view state\r\n            // from an older version.\r\n            this.setSelection(viewState.selection.start, viewState.selection.end);\r\n        }\r\n        if (viewState.selections) {\r\n            this.setSelections(viewState.selections);\r\n        }\r\n        if (viewState.scrollPos) {\r\n            this.setScrollPos(viewState.scrollPos.x, viewState.scrollPos.y);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Re-renders the editor UI\r\n     * @param {boolean=} handleResize true if this is in response to resizing the editor. Default false.\r\n     */\r\n    Editor.prototype.refresh = function (handleResize) {\r\n        // If focus is currently in a child of the CodeMirror editor (e.g. in an inline widget), but not in\r\n        // the CodeMirror input field itself, remember the focused item so we can restore focus after the\r\n        // refresh (which might cause the widget to be removed from the display list temporarily).\r\n        var focusedItem = window.document.activeElement,\r\n            restoreFocus = $.contains(this._codeMirror.getScrollerElement(), focusedItem);\r\n        this._codeMirror.refresh();\r\n        if (restoreFocus) {\r\n            focusedItem.focus();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Re-renders the editor, and all children inline editors.\r\n     * @param {boolean=} handleResize true if this is in response to resizing the editor. Default false.\r\n     */\r\n    Editor.prototype.refreshAll = function (handleResize) {\r\n        this.refresh(handleResize);\r\n        this.getInlineWidgets().forEach(function (inlineWidget) {\r\n            inlineWidget.refresh();\r\n        });\r\n    };\r\n    \r\n    /** Undo the last edit. */\r\n    Editor.prototype.undo = function () {\r\n        this._codeMirror.undo();\r\n    };\r\n    \r\n    /** Redo the last un-done edit. */\r\n    Editor.prototype.redo = function () {\r\n        this._codeMirror.redo();\r\n    };\r\n    \r\n    /**\r\n     * View API Visibility Change Notification handler.  This is also\r\n     * called by the native "setVisible" API which refresh can be optimized\r\n     * @param {boolean} show true to show the editor, false to hide it\r\n     * @param {boolean} refresh true (default) to refresh the editor, false to skip refreshing it\r\n     */\r\n    Editor.prototype.notifyVisibilityChange = function (show, refresh) {\r\n        if (show && (refresh || refresh === undefined)) {\r\n            this.refresh();\r\n        }\r\n        if (show) {\r\n            this._inlineWidgets.forEach(function (inlineWidget) {\r\n                inlineWidget.onParentShown();\r\n            });\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Shows or hides the editor within its parent. Does not force its ancestors to\r\n     * become visible.\r\n     * @param {boolean} show true to show the editor, false to hide it\r\n     * @param {boolean} refresh true (default) to refresh the editor, false to skip refreshing it\r\n     */\r\n    Editor.prototype.setVisible = function (show, refresh) {\r\n        this.$el.css("display", (show ? "" : "none"));\r\n        this.notifyVisibilityChange(show, refresh);\r\n    };\r\n    \r\n    /**\r\n     * Returns true if the editor is fully visible--i.e., is in the DOM, all ancestors are\r\n     * visible, and has a non-zero width/height.\r\n     */\r\n    Editor.prototype.isFullyVisible = function () {\r\n        return $(this.getRootElement()).is(":visible");\r\n    };\r\n    \r\n    /**\r\n     * Gets the syntax-highlighting mode for the given range.\r\n     * Returns null if the mode at the start of the selection differs from the mode at the end -\r\n     * an *approximation* of whether the mode is consistent across the whole range (a pattern like\r\n     * A-B-A would return A as the mode, not null).\r\n     *\r\n     * @param {!{line: number, ch: number}} start The start of the range to check.\r\n     * @param {!{line: number, ch: number}} end The end of the range to check.\r\n     * @param {boolean=} knownMixed Whether we already know we\'re in a mixed mode and need to check both\r\n     *     the start and end.\r\n     * @return {?(Object|string)} Name of syntax-highlighting mode, or object containing a "name" property\r\n     *     naming the mode along with configuration options required by the mode.\r\n     * @see {@link LanguageManager#getLanguageForPath()} and {@link Language#getMode()}.\r\n     */\r\n    Editor.prototype.getModeForRange = function (start, end, knownMixed) {\r\n        var outerMode = this._codeMirror.getMode(),\r\n            startMode = TokenUtils.getModeAt(this._codeMirror, start),\r\n            endMode = TokenUtils.getModeAt(this._codeMirror, end);\r\n        if (!knownMixed && outerMode.name === startMode.name) {\r\n            // Mode does not vary: just use the editor-wide mode name\r\n            return this._codeMirror.getOption("mode");\r\n        } else if (!startMode || !endMode || startMode.name !== endMode.name) {\r\n            return null;\r\n        } else {\r\n            return startMode;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Gets the syntax-highlighting mode for the current selection or cursor position. (The mode may\r\n     * vary within one file due to embedded languages, e.g. JS embedded in an HTML script block). See\r\n     * `getModeForRange()` for how this is determined for a single selection.\r\n     *\r\n     * If there are multiple selections, this will return a mode only if all the selections are individually\r\n     * consistent and resolve to the same mode.\r\n     *\r\n     * @return {?(Object|string)} Name of syntax-highlighting mode, or object containing a "name" property\r\n     *     naming the mode along with configuration options required by the mode.\r\n     * @see {@link LanguageManager#getLanguageForPath()} and {@link Language#getMode()}.\r\n     */\r\n    Editor.prototype.getModeForSelection = function () {\r\n        // Check for mixed mode info\r\n        var self        = this,\r\n            sels        = this.getSelections(),\r\n            primarySel  = this.getSelection(),\r\n            outerMode   = this._codeMirror.getMode(),\r\n            startMode   = TokenUtils.getModeAt(this._codeMirror, primarySel.start),\r\n            isMixed     = (outerMode.name !== startMode.name);\r\n\r\n        if (isMixed) {\r\n            // Shortcut the first check to avoid getModeAt(), which can be expensive\r\n            if (primarySel.start.line !== primarySel.end.line || primarySel.start.ch !== primarySel.end.ch) {\r\n                var endMode = TokenUtils.getModeAt(this._codeMirror, primarySel.end);\r\n                \r\n                if (startMode.name !== endMode.name) {\r\n                    return null;\r\n                }\r\n            }\r\n\r\n            // If mixed mode, check that mode is the same at start & end of each selection\r\n            var hasMixedSel = _.some(sels, function (sel) {\r\n                if (sels === primarySel) {\r\n                    // We already checked this before, so we know it\'s not mixed.\r\n                    return false;\r\n                }\r\n                \r\n                var rangeMode = self.getModeForRange(sel.start, sel.end, true);\r\n                return (!rangeMode || rangeMode.name !== startMode.name);\r\n            });\r\n            if (hasMixedSel) {\r\n                return null;\r\n            }\r\n\r\n            return startMode.name;\r\n        } else {\r\n            // Mode does not vary: just use the editor-wide mode\r\n            return this._codeMirror.getOption("mode");\r\n        }\r\n    };\r\n    \r\n    /*\r\n     * gets the language for the selection. (Javascript selected from an HTML document or CSS selected from an HTML document, etc...)\r\n     * @return {!Language} \r\n     */\r\n    Editor.prototype.getLanguageForSelection = function () {\r\n        return this.document.getLanguage().getLanguageForMode(this.getModeForSelection());\r\n    };\r\n    \r\n    /**\r\n     * Gets the syntax-highlighting mode for the document.\r\n     *\r\n     * @return {Object|String} Object or Name of syntax-highlighting mode; see {@link LanguageManager#getLanguageForPath()} and {@link Language#getMode()}.\r\n     */\r\n    Editor.prototype.getModeForDocument = function () {\r\n        return this._codeMirror.getOption("mode");\r\n    };\r\n\r\n    /**\r\n     * The Document we\'re bound to\r\n     * @type {!Document}\r\n     */\r\n    Editor.prototype.document = null;\r\n\r\n\r\n    /**\r\n     * The Editor\'s last known width.  \r\n     * Used in conjunction with updateLayout to recompute the layout \r\n     * if the the parent container changes its size since our last layout update.\r\n     * @type {?number}\r\n     */\r\n    Editor.prototype._lastEditorWidth = null;\r\n    \r\n    \r\n    /**\r\n     * If true, we\'re in the middle of syncing to/from the Document. Used to ignore spurious change\r\n     * events caused by us (vs. change events caused by others, which we need to pay attention to).\r\n     * @type {!boolean}\r\n     */\r\n    Editor.prototype._duringSync = false;\r\n\r\n    /**\r\n     * @private\r\n     * NOTE: this is actually "semi-private": EditorManager also accesses this field... as well as\r\n     * a few other modules. However, we should try to gradually move most code away from talking to\r\n     * CodeMirror directly.\r\n     * @type {!CodeMirror}\r\n     */\r\n    Editor.prototype._codeMirror = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {!Array.<{id:number, data:Object}>}\r\n     */\r\n    Editor.prototype._inlineWidgets = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {?TextRange}\r\n     */\r\n    Editor.prototype._visibleRange = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {Object}\r\n     * Promise queues for inline widgets being added to a given line.\r\n     */\r\n    Editor.prototype._inlineWidgetQueues = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {Array}\r\n     * A list of objects corresponding to the markers that are hiding lines in the current editor.\r\n     */\r\n    Editor.prototype._hideMarks = null;\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Retrieve the value of the named preference for this document.\r\n     * \r\n     * @param {string} prefName Name of preference to retrieve.\r\n     * @return {*} current value of that pref\r\n     */\r\n    Editor.prototype._getOption = function (prefName) {\r\n        return PreferencesManager.get(prefName, this.document.file.fullPath);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Updates the editor to the current value of prefName for the file being edited.\r\n     * \r\n     * @param {string} prefName Name of the preference to visibly update\r\n     */\r\n    Editor.prototype._updateOption = function (prefName) {\r\n        var oldValue = this._currentOptions[prefName],\r\n            newValue = this._getOption(prefName);\r\n        \r\n        if (oldValue !== newValue) {\r\n            this._currentOptions[prefName] = newValue;\r\n            \r\n            if (prefName === USE_TAB_CHAR) {\r\n                this._codeMirror.setOption(cmOptions[prefName], newValue);\r\n                this._codeMirror.setOption("indentUnit", newValue === true ?\r\n                                           this._currentOptions[TAB_SIZE] :\r\n                                           this._currentOptions[SPACE_UNITS]\r\n                                          );\r\n            } else if (prefName === STYLE_ACTIVE_LINE) {\r\n                this._updateStyleActiveLine();\r\n            } else if (prefName === SCROLL_PAST_END && this._visibleRange) {\r\n                // Do not apply this option to inline editors\r\n                return;\r\n            } else if (prefName === SHOW_LINE_NUMBERS) {\r\n                Editor._toggleLinePadding(!newValue);\r\n                this._codeMirror.setOption(cmOptions[SHOW_LINE_NUMBERS], newValue);\r\n                this.refreshAll();\r\n            } else {\r\n                this._codeMirror.setOption(cmOptions[prefName], newValue);\r\n            }\r\n            \r\n            $(this).triggerHandler("optionChange", [prefName, newValue]);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Used to ensure that "style active line" is turned off when there is a selection.\r\n     */\r\n    Editor.prototype._updateStyleActiveLine = function () {\r\n        if (this.hasSelection()) {\r\n            if (this._codeMirror.getOption("styleActiveLine")) {\r\n                this._codeMirror.setOption("styleActiveLine", false);\r\n            }\r\n        } else {\r\n            this._codeMirror.setOption("styleActiveLine", this._currentOptions[STYLE_ACTIVE_LINE]);\r\n        }\r\n    };\r\n\r\n    /** \r\n     * resizes the editor to fill its parent container\r\n     * should not be used on inline editors\r\n     * @param {boolean=} forceRefresh - forces the editor to update its layout \r\n     *                                   even if it already matches the container\'s height / width\r\n     */\r\n    Editor.prototype.updateLayout = function (forceRefresh) {\r\n        var curRoot = this.getRootElement(),\r\n            curWidth = $(curRoot).width(),\r\n            $editorHolder = this.$el.parent(),\r\n            editorAreaHt = $editorHolder.height();\r\n        \r\n        if (!curRoot.style.height || $(curRoot).height() !== editorAreaHt) {\r\n            // Call setSize() instead of $.height() to allow CodeMirror to\r\n            // check for options like line wrapping\r\n            this.setSize(null, editorAreaHt);\r\n            if (forceRefresh === undefined) {\r\n                forceRefresh = true;\r\n            }\r\n        } else if (curWidth !== this._lastEditorWidth) {\r\n            if (forceRefresh === undefined) {\r\n                forceRefresh = true;\r\n            }\r\n        }\r\n        this._lastEditorWidth = curWidth;\r\n\r\n        if (forceRefresh) {\r\n            this.refreshAll(forceRefresh);\r\n        }\r\n    };\r\n    \r\n    \r\n    // Global settings that affect Editor instances that share the same preference locations\r\n\r\n    /**\r\n     * Sets whether to use tab characters (vs. spaces) when inserting new text.\r\n     * Affects any editors that share the same preference location.\r\n     * @param {boolean} value\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean} true if value was valid\r\n     */\r\n    Editor.setUseTabChar = function (value, fullPath) {\r\n        var options = fullPath && {context: fullPath};\r\n        return PreferencesManager.set(USE_TAB_CHAR, value, options);\r\n    };\r\n    \r\n    /**\r\n     * Gets whether the specified or current file uses tab characters (vs. spaces) when inserting new text\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean}\r\n     */\r\n    Editor.getUseTabChar = function (fullPath) {\r\n        return PreferencesManager.get(USE_TAB_CHAR, fullPath);\r\n    };\r\n    \r\n    /**\r\n     * Sets tab character width.\r\n     * Affects any editors that share the same preference location.\r\n     * @param {number} value\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean} true if value was valid\r\n     */\r\n    Editor.setTabSize = function (value, fullPath) {\r\n        var options = fullPath && {context: fullPath};\r\n        return PreferencesManager.set(TAB_SIZE, value, options);\r\n    };\r\n    \r\n    /**\r\n     * Get indent unit\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {number}\r\n     */\r\n    Editor.getTabSize = function (fullPath) {\r\n        return PreferencesManager.get(TAB_SIZE, fullPath);\r\n    };\r\n    \r\n    /**\r\n     * Sets indentation width.\r\n     * Affects any editors that share the same preference location.\r\n     * @param {number} value\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean} true if value was valid\r\n     */\r\n    Editor.setSpaceUnits = function (value, fullPath) {\r\n        var options = fullPath && {context: fullPath};\r\n        return PreferencesManager.set(SPACE_UNITS, value, options);\r\n    };\r\n    \r\n    /**\r\n     * Get indentation width\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {number}\r\n     */\r\n    Editor.getSpaceUnits = function (fullPath) {\r\n        return PreferencesManager.get(SPACE_UNITS, fullPath);\r\n    };\r\n    \r\n    /**\r\n     * Sets the auto close brackets.\r\n     * Affects any editors that share the same preference location.\r\n     * @param {boolean} value\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean} true if value was valid\r\n     */\r\n    Editor.setCloseBrackets = function (value, fullPath) {\r\n        var options = fullPath && {context: fullPath};\r\n        return PreferencesManager.set(CLOSE_BRACKETS, value, options);\r\n    };\r\n    \r\n    /**\r\n     * Gets whether the specified or current file uses auto close brackets\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean}\r\n     */\r\n    Editor.getCloseBrackets = function (fullPath) {\r\n        return PreferencesManager.get(CLOSE_BRACKETS, fullPath);\r\n    };\r\n    \r\n    /**\r\n     * Sets show line numbers option.\r\n     * Affects any editors that share the same preference location.\r\n     * @param {boolean} value\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean} true if value was valid\r\n     */\r\n    Editor.setShowLineNumbers = function (value, fullPath) {\r\n        var options = fullPath && {context: fullPath};\r\n        return PreferencesManager.set(SHOW_LINE_NUMBERS, value, options);\r\n    };\r\n    \r\n    /**\r\n     * Returns true if show line numbers is enabled for the specified or current file\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean}\r\n     */\r\n    Editor.getShowLineNumbers = function (fullPath) {\r\n        return PreferencesManager.get(SHOW_LINE_NUMBERS, fullPath);\r\n    };\r\n    \r\n    /**\r\n     * Sets show active line option.\r\n     * Affects any editors that share the same preference location.\r\n     * @param {boolean} value\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean} true if value was valid\r\n     */\r\n    Editor.setShowActiveLine = function (value, fullPath) {\r\n        return PreferencesManager.set(STYLE_ACTIVE_LINE, value);\r\n    };\r\n    \r\n    /**\r\n     * Returns true if show active line is enabled for the specified or current file\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean}\r\n     */\r\n    Editor.getShowActiveLine = function (fullPath) {\r\n        return PreferencesManager.get(STYLE_ACTIVE_LINE, fullPath);\r\n    };\r\n    \r\n    /**\r\n     * Sets word wrap option.\r\n     * Affects any editors that share the same preference location.\r\n     * @param {boolean} value\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean} true if value was valid\r\n     */\r\n    Editor.setWordWrap = function (value, fullPath) {\r\n        var options = fullPath && {context: fullPath};\r\n        return PreferencesManager.set(WORD_WRAP, value, options);\r\n    };\r\n    \r\n    /**\r\n     * Returns true if word wrap is enabled for the specified or current file\r\n     * @param {string=} fullPath Path to file to get preference for\r\n     * @return {boolean}\r\n     */\r\n    Editor.getWordWrap = function (fullPath) {\r\n        return PreferencesManager.get(WORD_WRAP, fullPath);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Toggles the left padding of all code editors.  Used to provide more\r\n     * space between the code text and the left edge of the editor when\r\n     * line numbers are hidden.\r\n     * @param {boolean} showLinePadding\r\n     */\r\n    Editor._toggleLinePadding = function (showLinePadding) {\r\n        // apply class to all pane DOM nodes\r\n        var $holders = [];\r\n        _instances.forEach(function (editor) {\r\n            var $editorHolder = editor.$el.parent();\r\n            if ($holders.indexOf($editorHolder) === -1) {\r\n                $holders.push($editorHolder);\r\n            }\r\n        });\r\n        \r\n        _.each($holders, function ($holder) {\r\n            $holder.toggleClass("show-line-padding", Boolean(showLinePadding));\r\n        });\r\n    };\r\n    \r\n    // Set up listeners for preference changes\r\n    editorOptions.forEach(function (prefName) {\r\n        PreferencesManager.on("change", prefName, function () {\r\n            _instances.forEach(function (editor) {\r\n                editor._updateOption(prefName);\r\n            });\r\n        });\r\n    });\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Manage the conversion from old-style localStorage prefs to the new file-based ones.\r\n     */\r\n    function _convertPreferences() {\r\n        var rules = {};\r\n        editorOptions.forEach(function (setting) {\r\n            rules[setting] = "user";\r\n        });\r\n        PreferencesManager.convertPreferences(module, rules);\r\n    }\r\n    \r\n    _convertPreferences();\r\n    \r\n    // Define public API\r\n    exports.Editor                  = Editor;\r\n    exports.BOUNDARY_CHECK_NORMAL   = BOUNDARY_CHECK_NORMAL;\r\n    exports.BOUNDARY_IGNORE_TOP     = BOUNDARY_IGNORE_TOP;\r\n});\r\n\n//# sourceURL=/editor/Editor.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\ndefine(\'editor/InlineWidget\',[\'require\',\'exports\',\'module\',\'editor/EditorManager\',\'utils/KeyEvent\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    // Load dependent modules\r\n    var EditorManager       = require("editor/EditorManager"),\r\n        KeyEvent            = require("utils/KeyEvent");\r\n    \r\n    /**\r\n     * @constructor\r\n     *\r\n     */\r\n    function InlineWidget() {\r\n        var self = this;\r\n        \r\n        // create the outer wrapper div\r\n        this.htmlContent = window.document.createElement("div");\r\n        this.$htmlContent = $(this.htmlContent).addClass("inline-widget no-focus").attr("tabindex", "-1");\r\n        this.$htmlContent.append("<div class=\'shadow top\' />")\r\n            .append("<div class=\'shadow bottom\' />")\r\n            .append("<a href=\'#\' class=\'close no-focus\'>&times;</a>");\r\n\r\n        // create the close button\r\n        this.$closeBtn = this.$htmlContent.find(".close");\r\n        this.$closeBtn.click(function (e) {\r\n            self.close();\r\n            e.stopImmediatePropagation();\r\n        });\r\n\r\n        this.$htmlContent.on("keydown", function (e) {\r\n            if (e.keyCode === KeyEvent.DOM_VK_ESCAPE) {\r\n                self.close();\r\n                e.stopImmediatePropagation();\r\n            }\r\n        });\r\n    }\r\n    InlineWidget.prototype.htmlContent = null;\r\n    InlineWidget.prototype.$htmlContent = null;\r\n    InlineWidget.prototype.id = null;\r\n    InlineWidget.prototype.hostEditor = null;\r\n\r\n    /**\r\n     * Initial height of inline widget in pixels. Can be changed later via hostEditor.setInlineWidgetHeight()\r\n     * @type {number}\r\n     */\r\n    InlineWidget.prototype.height = 0;\r\n    \r\n    /**\r\n     * Closes this inline widget and all its contained Editors\r\n     * @return {$.Promise} A promise that\'s resolved when the widget is fully closed.\r\n     */\r\n    InlineWidget.prototype.close = function () {\r\n        return EditorManager.closeInlineWidget(this.hostEditor, this);\r\n        // closeInlineWidget() causes our onClosed() handler to be called\r\n    };\r\n    \r\n    /**\r\n     * @return {boolean} True if any part of the inline widget is focused\r\n     */\r\n    InlineWidget.prototype.hasFocus = function () {\r\n        var focusedItem = window.document.activeElement,\r\n            htmlContent = this.$htmlContent[0];\r\n        return $.contains(htmlContent, focusedItem) || htmlContent === focusedItem;\r\n    };\r\n    \r\n    /**\r\n     * Called any time inline is closed, whether manually or automatically.\r\n     */\r\n    InlineWidget.prototype.onClosed = function () {\r\n        $(this).triggerHandler("close");\r\n    };\r\n\r\n    /**\r\n     * Called once content is parented in the host editor\'s DOM. Useful for performing tasks like setting\r\n     * focus or measuring content, which require htmlContent to be in the DOM tree.\r\n     * \r\n     * IMPORTANT: onAdded() MUST be overridden to call hostEditor.setInlineWidgetHeight() at least once to\r\n     * set the initial height (required to animate it open). The widget will never open otherwise.\r\n     */\r\n    InlineWidget.prototype.onAdded = function () {\r\n        $(this).triggerHandler("add");\r\n    };\r\n\r\n    /**\r\n     * @param {Editor} hostEditor\r\n     */\r\n    InlineWidget.prototype.load = function (hostEditor) {\r\n        this.hostEditor = hostEditor;\r\n    };\r\n    \r\n    /**\r\n     * Called when the editor containing the inline is made visible.\r\n     */\r\n    InlineWidget.prototype.onParentShown = function () {\r\n        // do nothing - base implementation\r\n    };\r\n    \r\n    /**\r\n     * Called when the parent editor does a full refresh--for example, when the font size changes.\r\n     */\r\n    InlineWidget.prototype.refresh = function () {\r\n        // do nothing - base implementation\r\n    };\r\n    \r\n    exports.InlineWidget = InlineWidget;\r\n\r\n});\r\n\n//# sourceURL=/editor/InlineWidget.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n// FUTURE: Merge part (or all) of this class with MultiRangeInlineEditor\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\ndefine(\'editor/InlineTextEditor\',[\'require\',\'exports\',\'module\',\'thirdparty/CodeMirror2/lib/codemirror\',\'document/DocumentManager\',\'editor/EditorManager\',\'command/CommandManager\',\'command/Commands\',\'editor/InlineWidget\',\'utils/KeyEvent\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    // Load dependent modules\r\n    var CodeMirror          = require("thirdparty/CodeMirror2/lib/codemirror"),\r\n        DocumentManager     = require("document/DocumentManager"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        Commands            = require("command/Commands"),\r\n        InlineWidget        = require("editor/InlineWidget").InlineWidget,\r\n        KeyEvent            = require("utils/KeyEvent");\r\n\r\n    /**\r\n     * Shows or hides the dirty indicator\r\n     * @private\r\n     */\r\n    function _showDirtyIndicator($indicatorDiv, isDirty) {\r\n        // Show or hide the dirty indicator by adjusting\r\n        // the width of the div.\r\n        $indicatorDiv.css("width", isDirty ? 16 : 0);\r\n    }\r\n    \r\n    /**\r\n     * Respond to dirty flag change event. If the dirty flag is associated with an inline editor,\r\n     * show (or hide) the dirty indicator.\r\n     * @private\r\n     */\r\n    function _dirtyFlagChangeHandler(event, doc) {\r\n        var $dirtyIndicators = $(".inline-text-editor .dirty-indicator"),\r\n            $indicator;\r\n        \r\n        $dirtyIndicators.each(function (index, indicator) {\r\n            $indicator = $(this);\r\n            if ($indicator.data("fullPath") === doc.file.fullPath) {\r\n                _showDirtyIndicator($indicator, doc.isDirty);\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * @constructor\r\n     * @extends {InlineWidget}\r\n     */\r\n    function InlineTextEditor() {\r\n        InlineWidget.call(this);\r\n\r\n        this.editor = null;\r\n        \r\n        // We need to set this as a capture handler so CodeMirror doesn\'t handle Esc before we see it.\r\n        this.handleKeyDown = this.handleKeyDown.bind(this);\r\n        this.htmlContent.addEventListener("keydown", this.handleKeyDown, true);\r\n    }\r\n    InlineTextEditor.prototype = Object.create(InlineWidget.prototype);\r\n    InlineTextEditor.prototype.constructor = InlineTextEditor;\r\n    InlineTextEditor.prototype.parentClass = InlineWidget.prototype;\r\n    \r\n    InlineTextEditor.prototype.$wrapper = null;\r\n    /** @type {Editor} */\r\n    InlineTextEditor.prototype.editor = null;\r\n    InlineTextEditor.prototype.$editorHolder = null;\r\n    InlineTextEditor.prototype.$header = null;\r\n    InlineTextEditor.prototype.$filename = null;\r\n\r\n   /**\r\n     * Given a host editor and its inline editors, find the widest gutter and make all the others match\r\n     * @param {!Editor} hostEditor Host editor containing all the inline editors to sync\r\n     * @private\r\n     */\r\n    function _syncGutterWidths(hostEditor) {\r\n        var allHostedEditors = EditorManager.getInlineEditors(hostEditor);\r\n        \r\n        // add the host itself to the list too\r\n        allHostedEditors.push(hostEditor);\r\n        \r\n        var maxWidth = 0;\r\n        allHostedEditors.forEach(function (editor) {\r\n            var $gutter = $(editor._codeMirror.getGutterElement()).find(".CodeMirror-linenumbers");\r\n            $gutter.css("min-width", "");\r\n            var curWidth = $gutter.width();\r\n            if (curWidth > maxWidth) {\r\n                maxWidth = curWidth;\r\n            }\r\n        });\r\n        \r\n        if (allHostedEditors.length === 1) {\r\n            //There\'s only the host, just refresh the gutter\r\n            allHostedEditors[0]._codeMirror.setOption("gutters", allHostedEditors[0]._codeMirror.getOption("gutters"));\r\n            return;\r\n        }\r\n        \r\n        maxWidth = maxWidth + "px";\r\n        allHostedEditors.forEach(function (editor) {\r\n            $(editor._codeMirror.getGutterElement()).find(".CodeMirror-linenumbers").css("min-width", maxWidth);\r\n            \r\n            // Force CodeMirror to refresh the gutter\r\n            editor._codeMirror.setOption("gutters", editor._codeMirror.getOption("gutters"));\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called any time inline was closed, whether manually (via close()) or automatically\r\n     */\r\n    InlineTextEditor.prototype.onClosed = function () {\r\n        InlineTextEditor.prototype.parentClass.onClosed.apply(this, arguments);\r\n            \r\n        _syncGutterWidths(this.hostEditor);\r\n        \r\n        // Destroy the inline editor.\r\n        this.setInlineContent(null);\r\n        this.htmlContent.removeEventListener("keydown", this.handleKeyDown, true);\r\n    };\r\n    \r\n    /**\r\n     * Update the inline editor\'s height when the number of lines change. The\r\n     * base implementation of this method does nothing.\r\n     * @param {boolean} force the editor to resize\r\n     */\r\n    InlineTextEditor.prototype.sizeInlineWidgetToContents = function (force) {\r\n        // brackets_codemirror_overrides.css adds height:auto to CodeMirror\r\n        // Inline editors themselves do not need to be sized, but layouts like\r\n        // the one used in CSSInlineEditor do need some manual layout.\r\n    };\r\n\r\n    /**\r\n     * Some tasks have to wait until we\'ve been parented into the outer editor\r\n     * @param {string} the inline ID that is generated by CodeMirror after the widget that holds the inline\r\n     *  editor is constructed and added to the DOM\r\n     */\r\n    InlineTextEditor.prototype.onAdded = function () {\r\n        var self = this;\r\n\r\n        InlineTextEditor.prototype.parentClass.onAdded.apply(this, arguments);\r\n        \r\n        if (this.editor) {\r\n            this.editor.refresh();\r\n        }\r\n\r\n        // Update display of inline editors when the hostEditor signals a redraw\r\n        CodeMirror.on(this.info, "redraw", function () {\r\n            // At the point where we get the redraw, CodeMirror might not yet have actually\r\n            // re-added the widget to the DOM. This is filed as https://github.com/marijnh/CodeMirror/issues/1226.\r\n            // For now, we can work around it by doing the refresh on a setTimeout().\r\n            window.setTimeout(function () {\r\n                if (self.editor) {\r\n                    self.editor.refresh();\r\n                }\r\n            }, 0);\r\n        });\r\n        \r\n        _syncGutterWidths(this.hostEditor);\r\n        \r\n        if (this.editor) {\r\n            this.editor.focus();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @return {?Editor} If an Editor within this inline editor has focus, returns it. Otherwise returns null.\r\n     */\r\n    InlineTextEditor.prototype.getFocusedEditor = function () {\r\n        if (this.editor && this.editor.hasFocus()) {\r\n            return this.editor;\r\n        }\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Make sure that if we want to handle Esc to cancel a multiple selection, we don\'t let it bubble\r\n     * up to InlineWidget, which will close the edit.\r\n     */\r\n    InlineTextEditor.prototype.handleKeyDown = function (e) {\r\n        if (e.keyCode === KeyEvent.DOM_VK_ESCAPE && this.editor && this.editor.getSelections().length > 1) {\r\n            CodeMirror.commands.singleSelection(this.editor._codeMirror);\r\n            e.stopImmediatePropagation();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sets the document and range to show in the inline editor, or null to destroy the current editor and leave\r\n     * the content blank.\r\n     * @param {Document} doc The document to show, or null to show nothing\r\n     * @param {number} startLine The first line of text in `doc` to show in inline editor. Ignored if doc is null.\r\n     * @param {number} endLine The last line of text in `doc` to show in inline editor. Ignored if doc is null.\r\n     */\r\n    InlineTextEditor.prototype.setInlineContent = function (doc, startLine, endLine) {\r\n        var self = this;\r\n        \r\n        // Destroy the previous editor if we had one and clear out the filename info.\r\n        if (this.editor) {\r\n            $(this.editor).off(".InlineTextEditor");\r\n            this.editor.destroy(); // remove from DOM and release ref on Document\r\n            this.editor = null;\r\n            this.$filename.off(".InlineTextEditor")\r\n                .removeAttr("title");\r\n            this.$filename.html("");\r\n        }\r\n        \r\n        if (!doc) {\r\n            return;\r\n        }\r\n        \r\n        var range = {\r\n            startLine: startLine,\r\n            endLine: endLine\r\n        };\r\n        \r\n        // dirty indicator, with file path stored on it\r\n        var $dirtyIndicatorDiv = $("<div/>")\r\n            .addClass("dirty-indicator")\r\n            .html("&bull;")\r\n            .width(0); // initialize indicator as hidden\r\n        $dirtyIndicatorDiv.data("fullPath", doc.file.fullPath);\r\n        \r\n        this.$lineNumber = $("<span class=\'line-number\'/>");\r\n\r\n        // update contents of filename link\r\n        this.$filename.append($dirtyIndicatorDiv)\r\n            .append(doc.file.name + " : ")\r\n            .append(this.$lineNumber)\r\n            .attr("title", doc.file.fullPath);\r\n        \r\n        // clicking filename jumps to full editor view\r\n        this.$filename.on("click.InlineTextEditor", function () {\r\n            CommandManager.execute(Commands.FILE_OPEN, { fullPath: doc.file.fullPath })\r\n                .done(function () {\r\n                    EditorManager.getCurrentFullEditor().setCursorPos(startLine, 0, true);\r\n                });\r\n        });\r\n\r\n        var inlineInfo = EditorManager.createInlineEditorForDocument(doc, range, this.$editorHolder.get(0));\r\n        this.editor = inlineInfo.editor;\r\n        \r\n        // Init line number display\r\n        this._updateLineRange(inlineInfo.editor);\r\n\r\n        // Always update the widget height when an inline editor completes a\r\n        // display update\r\n        $(this.editor).on("update.InlineTextEditor", function (event, editor) {\r\n            self.sizeInlineWidgetToContents(true);\r\n        });\r\n\r\n        // Size editor to content whenever text changes (via edits here or any\r\n        // other view of the doc: Editor fires "change" any time its text\r\n        // changes, regardless of origin)\r\n        $(this.editor).on("change.InlineTextEditor", function (event, editor) {\r\n            if (self.hostEditor.isFullyVisible()) {\r\n                self.sizeInlineWidgetToContents(true);\r\n                self._updateLineRange(editor);\r\n            }\r\n        });\r\n        \r\n        // If Document\'s file is deleted, or Editor loses sync with Document, delegate to this._onLostContent()\r\n        $(this.editor).on("lostContent.InlineTextEditor", function () {\r\n            self._onLostContent.apply(self, arguments);\r\n        });\r\n        \r\n        // set dirty indicator state\r\n        _showDirtyIndicator($dirtyIndicatorDiv, doc.isDirty);\r\n    };\r\n\r\n    /**\r\n     * Updates start line display.\r\n     * @param {Editor} editor\r\n     */\r\n    InlineTextEditor.prototype._updateLineRange = function (editor) {\r\n        var oldStartLine    = this._startLine,\r\n            oldEndLine      = this._endLine,\r\n            oldLineCount    = this._lineCount;\r\n\r\n        this._startLine = editor.getFirstVisibleLine();\r\n        this._endLine = editor.getLastVisibleLine();\r\n        this._lineCount = this._endLine - this._startLine;\r\n\r\n        this.$lineNumber.text(this._startLine + 1);\r\n    };\r\n\r\n    /**\r\n     * @param {Editor} hostEditor\r\n     */\r\n    InlineTextEditor.prototype.load = function (hostEditor) {\r\n        InlineTextEditor.prototype.parentClass.load.apply(this, arguments);\r\n\r\n        // We don\'t create the actual editor here--that will happen the first time\r\n        // setInlineContent() is called.\r\n        this.$wrapper = $("<div/>").addClass("inline-text-editor").appendTo(this.$htmlContent);\r\n        this.$header = $("<div/>").addClass("inline-editor-header").appendTo(this.$wrapper);\r\n        this.$filename = $("<a/>").addClass("filename").appendTo(this.$header);\r\n        this.$editorHolder = $("<div/>").addClass("inline-editor-holder").appendTo(this.$wrapper);\r\n    };\r\n\r\n    /**\r\n     * Called when the editor containing the inline is made visible.\r\n     */\r\n    InlineTextEditor.prototype.onParentShown = function () {\r\n        InlineTextEditor.prototype.parentClass.onParentShown.apply(this, arguments);\r\n\r\n        // Refresh line number display and codemirror line number gutter\r\n        if (this.editor) {\r\n            this._updateLineRange(this.editor);\r\n            this.editor.refresh();\r\n        }\r\n\r\n        // We need to call this explicitly whenever the host editor is reshown\r\n        this.sizeInlineWidgetToContents(true);\r\n    };\r\n        \r\n    /**\r\n     * If Document\'s file is deleted, or Editor loses sync with Document, just close\r\n     */\r\n    InlineTextEditor.prototype._onLostContent = function () {\r\n        // Note: this closes the entire inline widget if any one Editor loses sync. This seems\r\n        // better than leaving it open but suddenly removing one rule from the result list.\r\n        this.close();\r\n    };\r\n    \r\n    // consolidate all dirty document updates\r\n    $(DocumentManager).on("dirtyFlagChange", _dirtyFlagChangeHandler);\r\n\r\n    exports.InlineTextEditor = InlineTextEditor;\r\n\r\n});\r\n\n//# sourceURL=/editor/InlineTextEditor.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\n/**\r\n * EditorManager owns the UI for the editor area. This essentially mirrors the \'current document\'\r\n * property maintained by DocumentManager\'s model.\r\n *\r\n * Note that there is a little bit of unusual overlap between EditorManager and DocumentManager:\r\n * because the Document state is actually stored in the CodeMirror editor UI, DocumentManager is\r\n * not a pure headless model. Each Document encapsulates an editor instance, and thus EditorManager\r\n * must have some knowledge about Document\'s internal state (we access its _editor property).\r\n *\r\n * This module dispatches the following events:\r\n *    - activeEditorChange --  Fires after the active editor (full or inline). \r\n *\r\n *      Doesn\'t fire when editor temporarily loses focus to a non-editor\r\n *      control (e.g. search toolbar or modal dialog, or window deactivation). \r\n *\r\n *      Does fire when focus moves between inline editor and its full-size container.\r\n *\r\n *      This event tracks `MainViewManagers\'s `currentFileChange` event and all editor\r\n *      objects "focus" event.\r\n *\r\n *          (e, editorGainingFocus:editor, editorLosingFocus:editor)\r\n *\r\n *      The 2nd arg to the listener is which Editor became active; the 3rd arg is\r\n *      which Editor is deactivated as a result. Either one may be null.\r\n *      NOTE (#1257): `getFocusedEditor()` sometimes lags behind this event. Listeners\r\n *      should use the arguments or call `getActiveEditor()` to reliably see which Editor \r\n *      just gained focus.\r\n */\r\ndefine(\'editor/EditorManager\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'command/Commands\',\'view/WorkspaceManager\',\'preferences/PreferencesManager\',\'command/CommandManager\',\'document/DocumentManager\',\'view/MainViewManager\',\'view/ViewStateManager\',\'utils/PerfUtils\',\'editor/Editor\',\'editor/InlineTextEditor\',\'strings\',\'language/LanguageManager\',\'utils/DeprecationWarning\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    // Load dependent modules\r\n    var _                   = require("thirdparty/lodash"),\r\n        Commands            = require("command/Commands"),\r\n        WorkspaceManager    = require("view/WorkspaceManager"),\r\n        PreferencesManager  = require("preferences/PreferencesManager"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        DocumentManager     = require("document/DocumentManager"),\r\n        MainViewManager     = require("view/MainViewManager"),\r\n        ViewStateManager    = require("view/ViewStateManager"),\r\n        PerfUtils           = require("utils/PerfUtils"),\r\n        Editor              = require("editor/Editor").Editor,\r\n        InlineTextEditor    = require("editor/InlineTextEditor").InlineTextEditor,\r\n        Strings             = require("strings"),\r\n        LanguageManager     = require("language/LanguageManager"),\r\n        DeprecationWarning  = require("utils/DeprecationWarning");\r\n    \r\n    \r\n    /**\r\n     * Currently focused Editor (full-size, inline, or otherwise)\r\n     * @type {?Editor}\r\n     * @private\r\n     */\r\n    var _lastFocusedEditor = null;\r\n    \r\n    /**\r\n     * Registered inline-editor widget providers sorted descending by priority. \r\n     * @see {@link #registerInlineEditProvider()}.\r\n     * @type {Array.<{priority:number, provider:function(...)}>}\r\n     * @private\r\n     */\r\n    var _inlineEditProviders = [];\r\n    \r\n    /**\r\n     * Registered inline documentation widget providers sorted descending by priority.\r\n     * @see {@link #registerInlineDocsProvider()}.\r\n     * @type {Array.<{priority:number, provider:function(...)}>}\r\n     * @private\r\n     */\r\n    var _inlineDocsProviders = [];\r\n    \r\n    /**\r\n     * Registered jump-to-definition providers. \r\n     * @see {@link #registerJumpToDefProvider()}.\r\n     * @private\r\n     * @type {Array.<function(...)>}\r\n     */\r\n    var _jumpToDefProviders = [];\r\n    \r\n    \r\n    /**\r\n     * DOM element to house any hidden editors created soley for inline widgets\r\n     * @private\r\n     * @type {jQuery}\r\n     */\r\n    var _$hiddenEditorsContainer;\r\n    \r\n   \r\n    /** \r\n     * Retrieves the visible full-size Editor for the currently opened file in the ACTIVE_PANE\r\n     * @return {?Editor} editor of the current view or null\r\n     */\r\n    function getCurrentFullEditor() {\r\n        var currentPath = MainViewManager.getCurrentlyViewedPath(MainViewManager.ACTIVE_PANE),\r\n            doc = currentPath && DocumentManager.getOpenDocumentForPath(currentPath);\r\n        return doc && doc._masterEditor;\r\n    }\r\n\r\n    \r\n\r\n    /** \r\n     * Updates _viewStateCache from the given editor\'s actual current state \r\n     * @private\r\n     * @param {!Editor} editor - editor to cache data for\r\n     */\r\n    function _saveEditorViewState(editor) {\r\n        ViewStateManager.updateViewState(editor);\r\n    }\r\n    \r\n    /** \r\n     * Updates _viewStateCache from the given editor\'s actual current state \r\n     * @param {!Editor} editor - editor restore cached data \r\n     * @private\r\n     */\r\n    function _restoreEditorViewState(editor) {\r\n        // We want to ignore the current state of the editor, so don\'t call __getViewState()\r\n        var viewState = ViewStateManager.getViewState(editor.document.file);\r\n        if (viewState) {\r\n            editor.restoreViewState(viewState);\r\n        }\r\n    }\r\n    \r\n\r\n	/**\r\n     * Editor focus handler to change the currently active editor\r\n     * @private\r\n     * @param {?Editor} current - the editor that will be the active editor\r\n     */\r\n    function _notifyActiveEditorChanged(current) {\r\n        // Skip if the Editor that gained focus was already the most recently focused editor.\r\n        // This may happen e.g. if the window loses then regains focus.\r\n        if (_lastFocusedEditor === current) {\r\n            return;\r\n        }\r\n        var previous = _lastFocusedEditor;\r\n        _lastFocusedEditor = current;\r\n        \r\n        $(exports).triggerHandler("activeEditorChange", [current, previous]);\r\n    }\r\n	\r\n    /**\r\n     * Current File Changed handler\r\n     * MainViewManager dispatches a "currentFileChange" event whenever the currently viewed \r\n     * file changes.  Which could mean that the previously viewed file has been closed or a \r\n     * non-editor view (image) has been given focus.  _notifyAcitveEditorChanged is also hooked \r\n     * up to editor.focus to handle focus events for editors which handles changing focus between\r\n     * two editors but, because editormanager maintains  a "_lastFocusedEditor" state, we have to\r\n     * "nullify" that state whenever the focus goes to a non-editor or when the current editor is closed\r\n     * @private\r\n     * @param {!jQuery.Event} e - event\r\n     * @param {?File} file - current file (can be null)\r\n     */\r\n    function _handleCurrentFileChange(e, file) {\r\n        var doc = file && DocumentManager.getOpenDocumentForPath(file.fullPath);\r\n        _notifyActiveEditorChanged(doc && doc._masterEditor);\r\n    }\r\n    \r\n    /**\r\n     * Creates a new Editor bound to the given Document.\r\n     * The editor is appended to the given container as a visible child.\r\n     * @private\r\n     * @param {!Document} doc  Document for the Editor\'s content\r\n     * @param {!boolean} makeMasterEditor  If true, the Editor will set itself as the private "master"\r\n     *          Editor for the Document. If false, the Editor will attach to the Document as a "slave."\r\n     * @param {!jQueryObject} container  Container to add the editor to.\r\n     * @param {{startLine: number, endLine: number}=} range If specified, range of lines within the document\r\n     *          to display in this editor. Inclusive.\r\n     * @return {Editor} the newly created editor.\r\n     */\r\n    function _createEditorForDocument(doc, makeMasterEditor, container, range) {\r\n        var editor = new Editor(doc, makeMasterEditor, container, range);\r\n\r\n        $(editor).on("focus", function () {\r\n            _notifyActiveEditorChanged(this);\r\n        });\r\n        \r\n        $(editor).on("beforeDestroy", function () {\r\n            if (editor.$el.is(":visible")) {\r\n                _saveEditorViewState(editor);\r\n            }\r\n        });\r\n        \r\n        return editor;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Finds an inline widget provider from the given list that can offer a widget for the current cursor\r\n     * position, and once the widget has been created inserts it into the editor.\r\n     *\r\n     * @param {!Editor} editor The host editor\r\n     * @param {Array.<{priority:number, provider:function(...)}>} providers \r\n     *      prioritized list of providers\r\n     * @param {string=} defaultErrorMsg Default message to display if no providers return non-null\r\n     * @return {$.Promise} a promise that will be resolved when an InlineWidget \r\n     *      is created or rejected if no inline providers have offered one.\r\n     */\r\n    function _openInlineWidget(editor, providers, defaultErrorMsg) {\r\n        PerfUtils.markStart(PerfUtils.INLINE_WIDGET_OPEN);\r\n        \r\n        // Run through inline-editor providers until one responds\r\n        var pos = editor.getCursorPos(),\r\n            inlinePromise,\r\n            i,\r\n            result = new $.Deferred(),\r\n            errorMsg,\r\n            providerRet;\r\n        \r\n        // Query each provider in priority order. Provider may return:\r\n        // 1. `null` to indicate it does not apply to current cursor position\r\n        // 2. promise that should resolve to an InlineWidget\r\n        // 3. string which indicates provider does apply to current cursor position,\r\n        //    but reason it could not create InlineWidget\r\n        //\r\n        // Keep looping until a provider is found. If a provider is not found,\r\n        // display highest priority error message that was found, otherwise display\r\n        // default error message\r\n        for (i = 0; i < providers.length && !inlinePromise; i++) {\r\n            var provider = providers[i].provider;\r\n            providerRet = provider(editor, pos);\r\n            if (providerRet) {\r\n                if (providerRet.hasOwnProperty("done")) {\r\n                    inlinePromise = providerRet;\r\n                } else if (!errorMsg && typeof (providerRet) === "string") {\r\n                    errorMsg = providerRet;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Use default error message if none other provided\r\n        errorMsg = errorMsg || defaultErrorMsg;\r\n        \r\n        // If one of them will provide a widget, show it inline once ready\r\n        if (inlinePromise) {\r\n            inlinePromise.done(function (inlineWidget) {\r\n                editor.addInlineWidget(pos, inlineWidget).done(function () {\r\n                    PerfUtils.addMeasurement(PerfUtils.INLINE_WIDGET_OPEN);\r\n                    result.resolve();\r\n                });\r\n            }).fail(function () {\r\n                // terminate timer that was started above\r\n                PerfUtils.finalizeMeasurement(PerfUtils.INLINE_WIDGET_OPEN);\r\n                editor.displayErrorMessageAtCursor(errorMsg);\r\n                result.reject();\r\n            });\r\n        } else {\r\n            // terminate timer that was started above\r\n            PerfUtils.finalizeMeasurement(PerfUtils.INLINE_WIDGET_OPEN);\r\n            editor.displayErrorMessageAtCursor(errorMsg);\r\n            result.reject();\r\n        }\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Closes any focused inline widget. Else, asynchronously asks providers to create one.\r\n     *\r\n     * @param {Array.<{priority:number, provider:function(...)}>} providers \r\n     *   prioritized list of providers\r\n     * @param {string=} errorMsg Default message to display if no providers return non-null\r\n     * @return {!Promise} A promise resolved with true if an inline widget is opened or false\r\n     *   when closed. Rejected if there is neither an existing widget to close nor a provider\r\n     *   willing to create a widget (or if no editor is open).\r\n     */\r\n    function _toggleInlineWidget(providers, errorMsg) {\r\n        var result = new $.Deferred();\r\n        \r\n        var currentEditor = getCurrentFullEditor();\r\n        \r\n        if (currentEditor) {\r\n            var inlineWidget = currentEditor.getFocusedInlineWidget();\r\n            \r\n            if (inlineWidget) {\r\n                // an inline widget\'s editor has focus, so close it\r\n                PerfUtils.markStart(PerfUtils.INLINE_WIDGET_CLOSE);\r\n                inlineWidget.close().done(function () {\r\n                    PerfUtils.addMeasurement(PerfUtils.INLINE_WIDGET_CLOSE);\r\n                    // return a resolved promise to CommandManager\r\n                    result.resolve(false);\r\n                });\r\n            } else {\r\n                // main editor has focus, so create an inline editor\r\n                _openInlineWidget(currentEditor, providers, errorMsg).done(function () {\r\n                    result.resolve(true);\r\n                }).fail(function () {\r\n                    result.reject();\r\n                });\r\n            }\r\n        } else {\r\n            // Can not open an inline editor without a host editor\r\n            result.reject();\r\n        }\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Inserts a prioritized provider object into the array in sorted (descending) order.\r\n     * @private\r\n     * @param {Array.<{priority:number, provider:function(...)}>} array\r\n     * @param {number} priority\r\n     * @param {function(...)} provider\r\n     */\r\n    function _insertProviderSorted(array, provider, priority) {\r\n        var index,\r\n            prioritizedProvider = {\r\n                priority: priority,\r\n                provider: provider\r\n            };\r\n        \r\n        for (index = 0; index < array.length; index++) {\r\n            if (array[index].priority < priority) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        array.splice(index, 0, prioritizedProvider);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Creates a hidden, unattached master editor that is needed when a document is created for the \r\n     * sole purpose of creating an inline editor so operations that require a master editor can be performed\r\n     * Only called from Document._ensureMasterEditor()\r\n     * The editor view is placed in a hidden part of the DOM but can later be moved to a visible pane \r\n     * when the document is opened using pane.addView()\r\n     * @param {!Document} doc - document to create a hidden editor for\r\n     */\r\n    function _createUnattachedMasterEditor(doc) {\r\n        // attach to the hidden containers DOM node if necessary\r\n        if (!_$hiddenEditorsContainer) {\r\n            _$hiddenEditorsContainer = $("#hidden-editors");\r\n        }\r\n        // Create an editor\r\n        var editor = _createEditorForDocument(doc, true, _$hiddenEditorsContainer);\r\n        // and hide it\r\n        editor.setVisible(false);\r\n    }\r\n    \r\n    /**\r\n     * Removes the given widget UI from the given hostEditor (agnostic of what the widget\'s content\r\n     * is). The widget\'s onClosed() callback will be run as a result.\r\n     * @param {!Editor} hostEditor The editor containing the widget.\r\n     * @param {!InlineWidget} inlineWidget The inline widget to close.\r\n     * @return {$.Promise} A promise that\'s resolved when the widget is fully closed.\r\n     */\r\n    function closeInlineWidget(hostEditor, inlineWidget) {\r\n        // If widget has focus, return it to the hostEditor & move the cursor to where the inline used to be\r\n        if (inlineWidget.hasFocus()) {\r\n            // Place cursor back on the line just above the inline (the line from which it was opened)\r\n            // If cursor\'s already on that line, leave it be to preserve column position\r\n            var widgetLine = hostEditor._codeMirror.getLineNumber(inlineWidget.info.line);\r\n            var cursorLine = hostEditor.getCursorPos().line;\r\n            if (cursorLine !== widgetLine) {\r\n                hostEditor.setCursorPos({ line: widgetLine, pos: 0 });\r\n            }\r\n            \r\n            hostEditor.focus();\r\n        }\r\n        \r\n        return hostEditor.removeInlineWidget(inlineWidget);\r\n    }\r\n    \r\n    /**\r\n     * Registers a new inline editor provider. When Quick Edit is invoked each registered provider is\r\n     * asked if it wants to provide an inline editor given the current editor and cursor location.\r\n     * An optional priority parameter is used to give providers with higher priority an opportunity\r\n     * to provide an inline editor before providers with lower priority.\r\n     * \r\n     * @param {function(!Editor, !{line:number, ch:number}):?($.Promise|string)} provider\r\n     * @param {number=} priority \r\n     * The provider returns a promise that will be resolved with an InlineWidget, or returns a string\r\n     * indicating why the provider cannot respond to this case (or returns null to indicate no reason).\r\n     */\r\n    function registerInlineEditProvider(provider, priority) {\r\n        if (priority === undefined) {\r\n            priority = 0;\r\n        }\r\n        _insertProviderSorted(_inlineEditProviders, provider, priority);\r\n    }\r\n\r\n    /**\r\n     * Registers a new inline docs provider. When Quick Docs is invoked each registered provider is\r\n     * asked if it wants to provide inline docs given the current editor and cursor location.\r\n     * An optional priority parameter is used to give providers with higher priority an opportunity\r\n     * to provide an inline editor before providers with lower priority.\r\n     * \r\n     * @param {function(!Editor, !{line:number, ch:number}):?($.Promise|string)} provider\r\n     * @param {number=} priority \r\n     * The provider returns a promise that will be resolved with an InlineWidget, or returns a string\r\n     * indicating why the provider cannot respond to this case (or returns null to indicate no reason).\r\n     */\r\n    function registerInlineDocsProvider(provider, priority) {\r\n        if (priority === undefined) {\r\n            priority = 0;\r\n        }\r\n        _insertProviderSorted(_inlineDocsProviders, provider, priority);\r\n    }\r\n    \r\n    /**\r\n     * Registers a new jump-to-definition provider. When jump-to-definition is invoked each\r\n     * registered provider is asked if it wants to provide jump-to-definition results, given\r\n     * the current editor and cursor location. \r\n     * \r\n     * @param {function(!Editor, !{line:number, ch:number}):?$.Promise} provider\r\n     * The provider returns a promise that is resolved whenever it\'s done handling the operation,\r\n     * or returns null to indicate the provider doesn\'t want to respond to this case. It is entirely\r\n     * up to the provider to open the file containing the definition, select the appropriate text, etc.\r\n     */\r\n    function registerJumpToDefProvider(provider) {\r\n        _jumpToDefProviders.push(provider);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Given a host editor, return a list of all Editors in all its open inline widgets. (Ignoring\r\n     * any other inline widgets that might be open but don\'t contain Editors).\r\n     * @param {!Editor} hostEditor\r\n     * @return {Array.<Editor>}\r\n     *\r\n     */\r\n    function getInlineEditors(hostEditor) {\r\n        var inlineEditors = [];\r\n        \r\n        if (hostEditor) {\r\n            hostEditor.getInlineWidgets().forEach(function (widget) {\r\n                if (widget instanceof InlineTextEditor && widget.editor) {\r\n                    inlineEditors.push(widget.editor);\r\n                }\r\n            });\r\n        }\r\n\r\n        return inlineEditors;\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n     * @private\r\n     * Creates a new "full-size" (not inline) Editor for the given Document, and sets it as the\r\n     * Document\'s master backing editor. The editor is not yet visible; \r\n     * Semi-private: should only be called within this module or by Document.\r\n     * @param {!Document} document  Document whose main/full Editor to create\r\n     * @param {!Pane} pane  Pane in which the editor will be hosted\r\n     */\r\n    function _createFullEditorForDocument(document, pane) {\r\n        // Create editor; make it initially invisible\r\n        var editor = _createEditorForDocument(document, true, pane.$content);\r\n        editor.setVisible(false);\r\n        pane.addView(editor);\r\n        $(exports).triggerHandler("_fullEditorCreatedForDocument", [document, editor, pane.id]);\r\n    }\r\n \r\n    \r\n    /**\r\n     * Creates a new inline Editor instance for the given Document.\r\n     * The editor is not yet visible or attached to a host editor.\r\n     * @param {!Document} doc  Document for the Editor\'s content\r\n     * @param {?{startLine:Number, endLine:Number}} range  If specified, all lines outside the given\r\n     *      range are hidden from the editor. Range is inclusive. Line numbers start at 0.\r\n     * @param {HTMLDivContainer} inlineContent\r\n     * @param  {function(inlineWidget)} closeThisInline\r\n     *\r\n     * @return {{content:DOMElement, editor:Editor}}\r\n     */\r\n    function createInlineEditorForDocument(doc, range, inlineContent) {\r\n        // Hide the container for the editor before creating it so that CodeMirror doesn\'t do extra work\r\n        // when initializing the document. When we construct the editor, we have to set its text and then\r\n        // set the (small) visible range that we show in the editor. If the editor is visible, CM has to\r\n        // render a large portion of the document before setting the visible range. By hiding the editor\r\n        // first and showing it after the visible range is set, we avoid that initial render.\r\n        $(inlineContent).hide();\r\n        var inlineEditor = _createEditorForDocument(doc, false, inlineContent, range);\r\n        $(inlineContent).show();\r\n        \r\n        return { content: inlineContent, editor: inlineEditor };\r\n    }\r\n\r\n    /** \r\n     * Returns focus to the last visible editor that had focus. If no editor visible, does nothing.\r\n     * This function should be called to restore editor focus after it has been temporarily\r\n     * removed. For example, after a dialog with editable text is closed.\r\n     */\r\n    function focusEditor() {\r\n        DeprecationWarning.deprecationWarning("Use MainViewManager.focusActivePane() instead of EditorManager.focusEditor().", true);\r\n        MainViewManager.focusActivePane();\r\n    }\r\n    \r\n    /**\r\n     * @deprecated\r\n     * resizes the editor\r\n     */\r\n    function resizeEditor() {\r\n        DeprecationWarning.deprecationWarning("Use WorkspaceManager.recomputeLayout() instead of EditorManager.resizeEditor().", true);\r\n        WorkspaceManager.recomputeLayout();\r\n    }\r\n\r\n    /**\r\n     * Create and/or show the editor for the specified document\r\n     * @param {!Document} document - document to edit\r\n     * @param {!Pane} pane - pane to show it in\r\n     * @private\r\n     */\r\n    function _showEditor(document, pane) {\r\n        // Ensure a main editor exists for this document to show in the UI\r\n        var createdNewEditor = false,\r\n            editor = document._masterEditor;\r\n        \r\n        if (!editor) {\r\n            createdNewEditor = true;\r\n\r\n            // Performance (see #4757) Chrome wastes time messing with selection\r\n            // that will just be changed at end, so clear it for now\r\n            if (window.getSelection && window.getSelection().empty) {  // Chrome\r\n                window.getSelection().empty();\r\n            }\r\n            \r\n            // Editor doesn\'t exist: populate a new Editor with the text\r\n            _createFullEditorForDocument(document, pane);\r\n        } else if (editor.$el.parent() !== pane.$el) {\r\n            // editor does exist but is not a child of the pane so add it to the \r\n            //  pane (which will switch the view\'s container as well)\r\n            pane.addView(editor);\r\n        }\r\n\r\n        // show the view\r\n        pane.showView(document._masterEditor);\r\n\r\n        // give it focus\r\n        document._masterEditor.focus();\r\n\r\n        if (createdNewEditor) {\r\n            _restoreEditorViewState(document._masterEditor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @deprecated use MainViewManager.getCurrentlyViewedFile() instead\r\n     * @return {string=} path of the file currently viewed in the active, full sized editor or null when there is no active editor \r\n     */\r\n    function getCurrentlyViewedPath() {\r\n        DeprecationWarning.deprecationWarning("Use MainViewManager.getCurrentlyViewedFile() instead of EditorManager.getCurrentlyViewedPath().", true);\r\n        \r\n        // We only want to return a path of a document object\r\n        // not other things like images, etc...\r\n        var currentPath = MainViewManager.getCurrentlyViewedPath(MainViewManager.ACTIVE_PANE),\r\n            doc;\r\n        \r\n        if (currentPath) {\r\n            doc = DocumentManager.getOpenDocumentForPath(currentPath);\r\n        }\r\n        \r\n        if (doc) {\r\n            return currentPath;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * @deprecated There is no equivelent API moving forward.  \r\n     * Use MainViewManager._initialize() from a unit test to create a Main View attached to a specific DOM element\r\n     */\r\n    function setEditorHolder() {\r\n        throw new Error("EditorManager.setEditorHolder() has been removed.");\r\n    }\r\n    \r\n    /**\r\n     * @deprecated Register a View Factory instead  \r\n     * @see MainViewManager.registerViewFactory()\r\n     */\r\n    function registerCustomViewer() {\r\n        throw new Error("EditorManager.registerCustomViewer() has been removed.");\r\n    }\r\n\r\n    /** \r\n     * Determines if the file can be opened in an editor\r\n     * @param {!string} fullPath - file to be opened\r\n     * @return {boolean} true if the file can be opened in an editor, false if not\r\n     */\r\n    function canOpenPath(fullPath) {\r\n        return !LanguageManager.getLanguageForPath(fullPath).isBinary();\r\n    }\r\n    \r\n    /** \r\n     * Opens the specified document in the given pane\r\n     * @param {!Document} doc - the document to open\r\n     * @param {!Pane} pane - the pane to open the document in\r\n     * @return {boolean} true if the file can be opened, false if not\r\n     */\r\n    function openDocument(doc, pane) {\r\n        var perfTimerName = PerfUtils.markStart("EditorManager.openDocument():\\t" + (!doc || doc.file.fullPath));\r\n\r\n        if (doc && pane) {\r\n            _showEditor(doc, pane);\r\n        }\r\n\r\n        PerfUtils.addMeasurement(perfTimerName);\r\n    }\r\n    \r\n    /**\r\n     * Returns the currently focused inline widget, if any.\r\n     * @return {?InlineWidget}\r\n     */\r\n    function getFocusedInlineWidget() {\r\n        var currentEditor = getCurrentFullEditor();\r\n        if (currentEditor) {\r\n            return currentEditor.getFocusedInlineWidget();\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Returns the focused Editor within an inline text editor, or null if something else has focus\r\n     * @return {?Editor}\r\n     */\r\n    function _getFocusedInlineEditor() {\r\n        var focusedWidget = getFocusedInlineWidget();\r\n        if (focusedWidget instanceof InlineTextEditor) {\r\n            return focusedWidget.getFocusedEditor();\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Returns the currently focused editor instance (full-sized OR inline editor).\r\n     * This function is similar to getActiveEditor(), with one main difference: this\r\n     * function will only return editors that currently have focus, whereas \r\n     * getActiveEditor() will return the last visible editor that was given focus (but\r\n     * may not currently have focus because, for example, a dialog with editable text\r\n     * is open).\r\n     * @return {?Editor}\r\n     */\r\n    function getFocusedEditor() {\r\n        var currentEditor = getCurrentFullEditor();\r\n        if (currentEditor) {\r\n            \r\n            // See if any inlines have focus\r\n            var focusedInline = _getFocusedInlineEditor();\r\n            if (focusedInline) {\r\n                return focusedInline;\r\n            }\r\n\r\n            // otherwise, see if full-sized editor has focus\r\n            if (currentEditor.hasFocus()) {\r\n                return currentEditor;\r\n            }\r\n        }\r\n        \r\n        return null;\r\n    }\r\n \r\n    /**\r\n     * Returns the current active editor (full-sized OR inline editor). This editor may not \r\n     * have focus at the moment, but it is visible and was the last editor that was given \r\n     * focus. Returns null if no editors are active.\r\n     * @see getFocusedEditor()\r\n     * @return {?Editor}\r\n     */\r\n    function getActiveEditor() {\r\n        return _lastFocusedEditor;\r\n    }\r\n\r\n    \r\n  /**\r\n     * Asynchronously asks providers to handle jump-to-definition.\r\n     * @return {!Promise} Resolved when the provider signals that it\'s done; rejected if no\r\n     *      provider responded or the provider that responded failed.\r\n     */\r\n    function _doJumpToDef() {\r\n        var providers = _jumpToDefProviders;\r\n        var promise,\r\n            i,\r\n            result = new $.Deferred();\r\n        \r\n        var editor = getActiveEditor();\r\n        \r\n        if (editor) {\r\n            var pos = editor.getCursorPos();\r\n\r\n            PerfUtils.markStart(PerfUtils.JUMP_TO_DEFINITION);\r\n            \r\n            // Run through providers until one responds\r\n            for (i = 0; i < providers.length && !promise; i++) {\r\n                var provider = providers[i];\r\n                promise = provider(editor, pos);\r\n            }\r\n\r\n            // Will one of them will provide a result?\r\n            if (promise) {\r\n                promise.done(function () {\r\n                    PerfUtils.addMeasurement(PerfUtils.JUMP_TO_DEFINITION);\r\n                    result.resolve();\r\n                }).fail(function () {\r\n                    // terminate timer that was started above\r\n                    PerfUtils.finalizeMeasurement(PerfUtils.JUMP_TO_DEFINITION);\r\n                    result.reject();\r\n                });\r\n            } else {\r\n                // terminate timer that was started above\r\n                PerfUtils.finalizeMeasurement(PerfUtils.JUMP_TO_DEFINITION);\r\n                result.reject();\r\n            }\r\n            \r\n        } else {\r\n            result.reject();\r\n        }\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    \r\n    /** \r\n     * file removed from pane handler.\r\n     * @param {jQuery.Event} e\r\n     * @param {File|Array.<File>} removedFiles - file, path or array of files or paths that are being removed\r\n     */\r\n    function _handleRemoveFromPaneView(e, removedFiles) {\r\n        var handleFileRemoved = function (file) {\r\n            var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\r\n\r\n            if (doc) {\r\n                MainViewManager._destroyEditorIfNotNeeded(doc);\r\n            }\r\n        };\r\n        \r\n        // when files are removed from a pane then\r\n        //    we should destroy any unnecssary views\r\n        if ($.isArray(removedFiles)) {\r\n            removedFiles.forEach(function (removedFile) {\r\n                handleFileRemoved(removedFile);\r\n            });\r\n        } else {\r\n            handleFileRemoved(removedFiles);\r\n        }\r\n    }\r\n\r\n    \r\n    // File-based preferences handling\r\n    $(exports).on("activeEditorChange", function (e, current) {\r\n        if (current && current.document && current.document.file) {\r\n            PreferencesManager._setCurrentEditingFile(current.document.file.fullPath);\r\n        }\r\n    });\r\n    \r\n    // Initialize: command handlers\r\n    CommandManager.register(Strings.CMD_TOGGLE_QUICK_EDIT, Commands.TOGGLE_QUICK_EDIT, function () {\r\n        return _toggleInlineWidget(_inlineEditProviders, Strings.ERROR_QUICK_EDIT_PROVIDER_NOT_FOUND);\r\n    });\r\n    CommandManager.register(Strings.CMD_TOGGLE_QUICK_DOCS, Commands.TOGGLE_QUICK_DOCS, function () {\r\n        return _toggleInlineWidget(_inlineDocsProviders, Strings.ERROR_QUICK_DOCS_PROVIDER_NOT_FOUND);\r\n    });\r\n    CommandManager.register(Strings.CMD_JUMPTO_DEFINITION, Commands.NAVIGATE_JUMPTO_DEFINITION, _doJumpToDef);\r\n\r\n    // Create PerfUtils measurement\r\n    PerfUtils.createPerfMeasurement("JUMP_TO_DEFINITION", "Jump-To-Definiiton");\r\n\r\n    $(MainViewManager).on("currentFileChange", _handleCurrentFileChange);\r\n    $(MainViewManager).on("workingSetRemove workingSetRemoveList", _handleRemoveFromPaneView);\r\n\r\n    \r\n    // For unit tests and internal use only\r\n    exports._createFullEditorForDocument  = _createFullEditorForDocument;\r\n    exports._notifyActiveEditorChanged    = _notifyActiveEditorChanged;\r\n\r\n    // Internal Use only\r\n    exports._saveEditorViewState          = _saveEditorViewState;\r\n    exports._createUnattachedMasterEditor = _createUnattachedMasterEditor;\r\n    \r\n    // Define public API\r\n    exports.createInlineEditorForDocument = createInlineEditorForDocument;\r\n    exports.getFocusedInlineWidget        = getFocusedInlineWidget;\r\n    exports.getInlineEditors              = getInlineEditors;\r\n    exports.closeInlineWidget             = closeInlineWidget;\r\n    exports.openDocument                  = openDocument;\r\n    exports.canOpenPath                   = canOpenPath;\r\n\r\n    // Convenience Methods\r\n    exports.getActiveEditor               = getActiveEditor;\r\n    exports.getCurrentFullEditor          = getCurrentFullEditor;\r\n    exports.getFocusedEditor              = getFocusedEditor;\r\n    \r\n    \r\n    exports.registerInlineEditProvider    = registerInlineEditProvider;\r\n    exports.registerInlineDocsProvider    = registerInlineDocsProvider;\r\n    exports.registerJumpToDefProvider     = registerJumpToDefProvider;\r\n    \r\n    // Deprecated\r\n    exports.registerCustomViewer          = registerCustomViewer;\r\n    exports.resizeEditor                  = resizeEditor;\r\n    exports.focusEditor                   = focusEditor;\r\n    exports.getCurrentlyViewedPath        = getCurrentlyViewedPath;\r\n    exports.setEditorHolder               = setEditorHolder;\r\n});\r\n\n//# sourceURL=/editor/EditorManager.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\ndefine(\'document/Document\',[\'require\',\'exports\',\'module\',\'editor/EditorManager\',\'file/FileUtils\',\'document/InMemoryFile\',\'utils/PerfUtils\',\'language/LanguageManager\',\'thirdparty/CodeMirror2/lib/codemirror\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var EditorManager       = require("editor/EditorManager"),\r\n        FileUtils           = require("file/FileUtils"),\r\n        InMemoryFile        = require("document/InMemoryFile"),\r\n        PerfUtils           = require("utils/PerfUtils"),\r\n        LanguageManager     = require("language/LanguageManager"),\r\n        CodeMirror          = require("thirdparty/CodeMirror2/lib/codemirror"),\r\n        _                   = require("thirdparty/lodash");\r\n    \r\n    /**\r\n     * Model for the contents of a single file and its current modification state.\r\n     * See DocumentManager documentation for important usage notes.\r\n     *\r\n     * Document dispatches these events:\r\n     *\r\n     * __change__ -- When the text of the editor changes (including due to undo/redo). \r\n     *\r\n     * Passes ({Document}, {ChangeList}), where ChangeList is an array\r\n     * of change record objects. Each change record looks like:\r\n     *\r\n     *     { from: start of change, expressed as {line: <line number>, ch: <character offset>},\r\n     *       to: end of change, expressed as {line: <line number>, ch: <chracter offset>},\r\n     *       text: array of lines of text to replace existing text }\r\n     *      \r\n     * The line and ch offsets are both 0-based.\r\n     *\r\n     * The ch offset in "from" is inclusive, but the ch offset in "to" is exclusive. For example,\r\n     * an insertion of new content (without replacing existing content) is expressed by a range\r\n     * where from and to are the same.\r\n     *\r\n     * If "from" and "to" are undefined, then this is a replacement of the entire text content.\r\n     *\r\n     * IMPORTANT: If you listen for the "change" event, you MUST also addRef() the document \r\n     * (and releaseRef() it whenever you stop listening). You should also listen to the "deleted"\r\n     * event.\r\n     *\r\n     * __deleted__ -- When the file for this document has been deleted. All views onto the document should\r\n     * be closed. The document will no longer be editable or dispatch "change" events.\r\n     * \r\n     * __languageChanged__ -- When the value of getLanguage() has changed. 2nd argument is the old value,\r\n     * 3rd argument is the new value.\r\n     *\r\n     * @constructor\r\n     * @param {!File} file  Need not lie within the project.\r\n     * @param {!Date} initialTimestamp  File\'s timestamp when we read it off disk.\r\n     * @param {!string} rawText  Text content of the file.\r\n     */\r\n    function Document(file, initialTimestamp, rawText) {\r\n        if (!(this instanceof Document)) {  // error if constructor called without \'new\'\r\n            throw new Error("Document constructor must be called with \'new\'");\r\n        }\r\n        \r\n        this.file = file;\r\n        this._updateLanguage();\r\n        this.refreshText(rawText, initialTimestamp, true);\r\n    }\r\n    \r\n    /**\r\n     * Number of clients who want this Document to stay alive. The Document is listed in\r\n     * DocumentManager._openDocuments whenever refCount > 0.\r\n     */\r\n    Document.prototype._refCount = 0;\r\n    \r\n    /**\r\n     * The File for this document. Need not lie within the project.\r\n     * If Document is untitled, this is an InMemoryFile object.\r\n     * @type {!File}\r\n     */\r\n    Document.prototype.file = null;\r\n\r\n    /**\r\n     * The Language for this document. Will be resolved by file extension in the constructor\r\n     * @type {!Language}\r\n     */\r\n    Document.prototype.language = null;\r\n    \r\n    /**\r\n     * Whether this document has unsaved changes or not.\r\n     * When this changes on any Document, DocumentManager dispatches a "dirtyFlagChange" event.\r\n     * @type {boolean}\r\n     */\r\n    Document.prototype.isDirty = false;\r\n    \r\n    /**\r\n     * Whether this document is currently being saved.\r\n     * @type {boolean}\r\n     */\r\n    Document.prototype.isSaving = false;\r\n    \r\n    /**\r\n     * What we expect the file\'s timestamp to be on disk. If the timestamp differs from this, then\r\n     * it means the file was modified by an app other than Brackets.\r\n     * @type {!Date}\r\n     */\r\n    Document.prototype.diskTimestamp = null;\r\n    \r\n    /**\r\n     * The timestamp of the document at the point where the user last said to keep changes that conflict\r\n     * with the current disk version. Can also be -1, indicating that the file was deleted on disk at the\r\n     * last point when the user said to keep changes, or null, indicating that the user has not said to\r\n     * keep changes.\r\n     * Note that this is a time as returned by Date.getTime(), not a Date object.\r\n     * @type {?Number}\r\n     */\r\n    Document.prototype.keepChangesTime = null;\r\n\r\n    /**\r\n     * True while refreshText() is in progress and change notifications shouldn\'t trip the dirty flag.\r\n     * @type {boolean}\r\n     */\r\n    Document.prototype._refreshInProgress = false;\r\n    \r\n    /**\r\n     * The text contents of the file, or null if our backing model is _masterEditor.\r\n     * @type {?string}\r\n     */\r\n    Document.prototype._text = null;\r\n    \r\n    /**\r\n     * Editor object representing the full-size editor UI for this document. May be null if Document\r\n     * has not yet been modified or been the currentDocument; in that case, our backing model is the\r\n     * string _text.\r\n     * @type {?Editor}\r\n     */\r\n    Document.prototype._masterEditor = null;\r\n    \r\n    /**\r\n     * The content\'s line-endings style. If a Document is created on empty text, or text with\r\n     * inconsistent line endings, defaults to the current platform\'s standard endings.\r\n     * @type {FileUtils.LINE_ENDINGS_CRLF|FileUtils.LINE_ENDINGS_LF}\r\n     */\r\n    Document.prototype._lineEndings = null;\r\n    \r\n    /** Add a ref to keep this Document alive */\r\n    Document.prototype.addRef = function () {\r\n        //console.log("+++REF+++ "+this);\r\n        \r\n        if (this._refCount === 0) {\r\n            //console.log("+++ adding to open list");\r\n            if ($(exports).triggerHandler("_afterDocumentCreate", this)) {\r\n                return;\r\n            }\r\n        }\r\n        this._refCount++;\r\n    };\r\n    /** Remove a ref that was keeping this Document alive */\r\n    Document.prototype.releaseRef = function () {\r\n        //console.log("---REF--- "+this);\r\n\r\n        this._refCount--;\r\n        if (this._refCount < 0) {\r\n            console.error("Document ref count has fallen below zero!");\r\n            return;\r\n        }\r\n        if (this._refCount === 0) {\r\n            //console.log("--- removing from open list");\r\n            if ($(exports).triggerHandler("_beforeDocumentDelete", this)) {\r\n                return;\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Attach a backing Editor to the Document, enabling setText() to be called. Assumes Editor has\r\n     * already been initialized with the value of getText(). ONLY Editor should call this (and only\r\n     * when EditorManager has told it to act as the master editor).\r\n     * @param {!Editor} masterEditor\r\n     */\r\n    Document.prototype._makeEditable = function (masterEditor) {\r\n        if (this._masterEditor) {\r\n            console.error("Document is already editable");\r\n        } else {\r\n            this._text = null;\r\n            this._masterEditor = masterEditor;\r\n            $(masterEditor).on("change", this._handleEditorChange.bind(this));\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Detach the backing Editor from the Document, disallowing setText(). The text content is\r\n     * stored back onto _text so other Document clients continue to have read-only access. ONLY\r\n     * Editor.destroy() should call this.\r\n     */\r\n    Document.prototype._makeNonEditable = function () {\r\n        if (!this._masterEditor) {\r\n            console.error("Document is already non-editable");\r\n        } else {\r\n            // _text represents the raw text, so fetch without normalized line endings\r\n            this._text = this.getText(true);\r\n            this._masterEditor = null;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Guarantees that _masterEditor is non-null. If needed, asks EditorManager to create a new master\r\n     * editor bound to this Document (which in turn causes Document._makeEditable() to be called).\r\n     * Should ONLY be called by Editor and Document.\r\n     */\r\n    Document.prototype._ensureMasterEditor = function () {\r\n        if (!this._masterEditor) {\r\n            EditorManager._createUnattachedMasterEditor(this);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Returns the document\'s current contents; may not be saved to disk yet. Whenever this\r\n     * value changes, the Document dispatches a "change" event.\r\n     *\r\n     * @param {boolean=} useOriginalLineEndings If true, line endings in the result depend on the\r\n     *      Document\'s line endings setting (based on OS & the original text loaded from disk).\r\n     *      If false, line endings are always \\n (like all the other Document text getter methods).\r\n     * @return {string}\r\n     */\r\n    Document.prototype.getText = function (useOriginalLineEndings) {\r\n        if (this._masterEditor) {\r\n            // CodeMirror.getValue() always returns text with LF line endings; fix up to match line\r\n            // endings preferred by the document, if necessary\r\n            var codeMirrorText = this._masterEditor._codeMirror.getValue();\r\n            if (useOriginalLineEndings) {\r\n                if (this._lineEndings === FileUtils.LINE_ENDINGS_CRLF) {\r\n                    return codeMirrorText.replace(/\\n/g, "\\r\\n");\r\n                }\r\n            }\r\n            return codeMirrorText;\r\n            \r\n        } else {\r\n            // Optimized path that doesn\'t require creating master editor\r\n            if (useOriginalLineEndings) {\r\n                return this._text;\r\n            } else {\r\n                return Document.normalizeText(this._text);\r\n            }\r\n        }\r\n    };\r\n    \r\n    /** Normalizes line endings the same way CodeMirror would */\r\n    Document.normalizeText = function (text) {\r\n        return text.replace(/\\r\\n/g, "\\n");\r\n    };\r\n    \r\n    /**\r\n     * Sets the contents of the document. Treated as an edit. Line endings will be rewritten to\r\n     * match the document\'s current line-ending style.\r\n     * @param {!string} text The text to replace the contents of the document with.\r\n     */\r\n    Document.prototype.setText = function (text) {\r\n        this._ensureMasterEditor();\r\n        this._masterEditor._codeMirror.setValue(text);\r\n        // _handleEditorChange() triggers "change" event\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Triggers the appropriate events when a change occurs: "change" on the Document instance\r\n     * and "documentChange" on the Document module.\r\n     * @param {Object} changeList Changelist in CodeMirror format\r\n     */\r\n    Document.prototype._notifyDocumentChange = function (changeList) {\r\n        $(this).triggerHandler("change", [this, changeList]);\r\n        $(exports).triggerHandler("documentChange", [this, changeList]);\r\n    };\r\n    \r\n    /**\r\n     * Sets the contents of the document. Treated as reloading the document from disk: the document\r\n     * will be marked clean with a new timestamp, the undo/redo history is cleared, and we re-check\r\n     * the text\'s line-ending style. CAN be called even if there is no backing editor.\r\n     * @param {!string} text The text to replace the contents of the document with.\r\n     * @param {!Date} newTimestamp Timestamp of file at the time we read its new contents from disk.\r\n     * @param {boolean} initial True if this is the initial load of the document. In that case,\r\n     *      we don\'t send change events.\r\n     */\r\n    Document.prototype.refreshText = function (text, newTimestamp, initial) {\r\n        var perfTimerName = PerfUtils.markStart("refreshText:\\t" + (!this.file || this.file.fullPath));\r\n\r\n        // If clean, don\'t transiently mark dirty during refresh\r\n        // (we\'ll still send change events though, of course)\r\n        this._refreshInProgress = true;\r\n        \r\n        if (this._masterEditor) {\r\n            this._masterEditor._resetText(text);  // clears undo history too\r\n            // _handleEditorChange() triggers "change" event for us\r\n        } else {\r\n            this._text = text;\r\n            \r\n            if (!initial) {\r\n                // We fake a change record here that looks like CodeMirror\'s text change records, but\r\n                // omits "from" and "to", by which we mean the entire text has changed.\r\n                // TODO: Dumb to split it here just to join it again in the change handler, but this is\r\n                // the CodeMirror change format. Should we document our change format to allow this to\r\n                // either be an array of lines or a single string?\r\n                this._notifyDocumentChange([{text: text.split(/\\r?\\n/)}]);\r\n            }\r\n        }\r\n        this._updateTimestamp(newTimestamp);\r\n       \r\n        // If Doc was dirty before refresh, reset it to clean now (don\'t always call, to avoid no-op dirtyFlagChange events) Since\r\n        // _resetText() above already ensures Editor state is clean, it\'s safe to skip _markClean() as long as our own state is already clean too.\r\n        if (this.isDirty) {\r\n            this._markClean();\r\n        }\r\n        this._refreshInProgress = false;\r\n        \r\n        // Sniff line-ending style\r\n        this._lineEndings = FileUtils.sniffLineEndings(text);\r\n        if (!this._lineEndings) {\r\n            this._lineEndings = FileUtils.getPlatformLineEndings();\r\n        }\r\n        \r\n        $(exports).triggerHandler("_documentRefreshed", this);\r\n\r\n        PerfUtils.addMeasurement(perfTimerName);\r\n    };\r\n    \r\n    /**\r\n     * Adds, replaces, or removes text. If a range is given, the text at that range is replaced with the\r\n     * given new text; if text == "", then the entire range is effectively deleted. If \'end\' is omitted,\r\n     * then the new text is inserted at that point and all existing text is preserved. Line endings will\r\n     * be rewritten to match the document\'s current line-ending style.\r\n     * \r\n     * IMPORTANT NOTE: Because of #1688, do not use this in cases where you might be\r\n     * operating on a linked document (like the main document for an inline editor) \r\n     * during an outer CodeMirror operation (like a key event that\'s handled by the\r\n     * editor itself). A common case of this is code hints in inline editors. In\r\n     * such cases, use `editor._codeMirror.replaceRange()` instead. This should be\r\n     * fixed when we migrate to use CodeMirror\'s native document-linking functionality.\r\n     *\r\n     * @param {!string} text  Text to insert or replace the range with\r\n     * @param {!{line:number, ch:number}} start  Start of range, inclusive (if \'to\' specified) or insertion point (if not)\r\n     * @param {?{line:number, ch:number}} end  End of range, exclusive; optional\r\n     * @param {?string} origin  Optional string used to batch consecutive edits for undo.\r\n     *     If origin starts with "+", then consecutive edits with the same origin will be batched for undo if \r\n     *     they are close enough together in time.\r\n     *     If origin starts with "*", then all consecutive edit with the same origin will be batched for\r\n     *     undo.\r\n     *     Edits with origins starting with other characters will not be batched.\r\n     *     (Note that this is a higher level of batching than batchOperation(), which already batches all\r\n     *     edits within it for undo. Origin batching works across operations.)\r\n     */\r\n    Document.prototype.replaceRange = function (text, start, end, origin) {\r\n        this._ensureMasterEditor();\r\n        this._masterEditor._codeMirror.replaceRange(text, start, end, origin);\r\n        // _handleEditorChange() triggers "change" event\r\n    };\r\n    \r\n    /**\r\n     * Returns the characters in the given range. Line endings are normalized to \'\\n\'.\r\n     * @param {!{line:number, ch:number}} start  Start of range, inclusive\r\n     * @param {!{line:number, ch:number}} end  End of range, exclusive\r\n     * @return {!string}\r\n     */\r\n    Document.prototype.getRange = function (start, end) {\r\n        this._ensureMasterEditor();\r\n        return this._masterEditor._codeMirror.getRange(start, end);\r\n    };\r\n    \r\n    /**\r\n     * Returns the text of the given line (excluding any line ending characters)\r\n     * @param {number} Zero-based line number\r\n     * @return {!string}\r\n     */\r\n    Document.prototype.getLine = function (lineNum) {\r\n        this._ensureMasterEditor();\r\n        return this._masterEditor._codeMirror.getLine(lineNum);\r\n    };\r\n    \r\n    /**\r\n     * Batches a series of related Document changes. Repeated calls to replaceRange() should be wrapped in a\r\n     * batch for efficiency. Begins the batch, calls doOperation(), ends the batch, and then returns.\r\n     * @param {function()} doOperation\r\n     */\r\n    Document.prototype.batchOperation = function (doOperation) {\r\n        this._ensureMasterEditor();\r\n        \r\n        var self = this;\r\n        self._masterEditor._codeMirror.operation(doOperation);\r\n    };\r\n    \r\n    /**\r\n     * Handles changes from the master backing Editor. Changes are triggered either by direct edits\r\n     * to that Editor\'s UI, OR by our setText()/refreshText() methods.\r\n     * @private\r\n     */\r\n    Document.prototype._handleEditorChange = function (event, editor, changeList) {\r\n        // TODO: This needs to be kept in sync with SpecRunnerUtils.createMockActiveDocument(). In the\r\n        // future, we should fix things so that we either don\'t need mock documents or that this\r\n        // is factored so it will just run in both.\r\n        if (!this._refreshInProgress) {\r\n            // Sync isDirty from CodeMirror state\r\n            var wasDirty = this.isDirty;\r\n            this.isDirty = !editor._codeMirror.isClean();\r\n            \r\n            // Notify if isDirty just changed (this also auto-adds us to working set if needed)\r\n            if (wasDirty !== this.isDirty) {\r\n                $(exports).triggerHandler("_dirtyFlagChange", [this]);\r\n            }\r\n        }\r\n        \r\n        // Notify that Document\'s text has changed\r\n        this._notifyDocumentChange(changeList);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     */\r\n    Document.prototype._markClean = function () {\r\n        this.isDirty = false;\r\n        if (this._masterEditor) {\r\n            this._masterEditor._codeMirror.markClean();\r\n        }\r\n        $(exports).triggerHandler("_dirtyFlagChange", this);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     */\r\n    Document.prototype._updateTimestamp = function (timestamp) {\r\n        this.diskTimestamp = timestamp;\r\n        // Clear the "keep changes" timestamp since it\'s no longer relevant.\r\n        this.keepChangesTime = null;\r\n    };\r\n    \r\n    /** \r\n     * Called when the document is saved (which currently happens in DocumentCommandHandlers). Marks the\r\n     * document not dirty and notifies listeners of the save.\r\n     */\r\n    Document.prototype.notifySaved = function () {\r\n        if (!this._masterEditor) {\r\n            console.log("### Warning: saving a Document that is not modifiable!");\r\n        }\r\n        \r\n        this._markClean();\r\n        \r\n        // TODO: (issue #295) fetching timestamp async creates race conditions (albeit unlikely ones)\r\n        var thisDoc = this;\r\n        this.file.stat(function (err, stat) {\r\n            if (!err) {\r\n                thisDoc._updateTimestamp(stat.mtime);\r\n            } else {\r\n                console.log("Error updating timestamp after saving file: " + thisDoc.file.fullPath);\r\n            }\r\n            $(exports).triggerHandler("_documentSaved", thisDoc);\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * Adjusts a given position taking a given replaceRange-type edit into account. \r\n     * If the position is within the original edit range (start and end inclusive),\r\n     * it gets pushed to the end of the content that replaced the range. Otherwise, \r\n     * if it\'s after the edit, it gets adjusted so it refers to the same character\r\n     * it did before the edit.\r\n     * @param {!{line:number, ch: number}} pos The position to adjust.\r\n     * @param {!Array.<string>} textLines The text of the change, split into an array of lines.\r\n     * @param {!{line: number, ch: number}} start The start of the edit.\r\n     * @param {!{line: number, ch: number}} end The end of the edit.\r\n     * @return {{line: number, ch: number}} The adjusted position.\r\n     */\r\n    Document.prototype.adjustPosForChange = function (pos, textLines, start, end) {\r\n        // Same as CodeMirror.adjustForChange(), but that\'s a private function\r\n        // and Marijn would rather not expose it publicly.\r\n        var change = { text: textLines, from: start, to: end };\r\n\r\n        if (CodeMirror.cmpPos(pos, start) < 0) {\r\n            return pos;\r\n        }\r\n        if (CodeMirror.cmpPos(pos, end) <= 0) {\r\n            return CodeMirror.changeEnd(change);\r\n        }\r\n\r\n        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,\r\n            ch = pos.ch;\r\n        if (pos.line === change.to.line) {\r\n            ch += CodeMirror.changeEnd(change).ch - change.to.ch;\r\n        }\r\n        return {line: line, ch: ch};\r\n    };\r\n    \r\n    /**\r\n     * Like _.each(), but if given a single item not in an array, acts as\r\n     * if it were an array containing just that item.\r\n     */\r\n    function oneOrEach(itemOrArr, cb) {\r\n        if (Array.isArray(itemOrArr)) {\r\n            _.each(itemOrArr, cb);\r\n        } else {\r\n            cb(itemOrArr, 0);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Helper function for edit operations that operate on multiple selections. Takes an "edit list"\r\n     * that specifies a list of replaceRanges that should occur, but where all the positions are with\r\n     * respect to the document state before all the edits (i.e., you don\'t have to figure out how to fix\r\n     * up the selections after each sub-edit). Edits must be non-overlapping (in original-document terms).\r\n     * All the edits are done in a single batch.\r\n     *\r\n     * If your edits are structured in such a way that each individual edit would cause its associated\r\n     * selection to be properly updated, then all you need to specify are the edits themselves, and the\r\n     * selections will automatically be updated as the edits are performed. However, for some\r\n     * kinds of edits, you need to fix up the selection afterwards. In that case, you can specify one\r\n     * or more selections to be associated with each edit. Those selections are assumed to be in terms\r\n     * of the document state after the edit, *as if* that edit were the only one being performed (i.e.,\r\n     * you don\'t have to worry about adjusting for the effect of other edits). If you supply these selections,\r\n     * then this function will adjust them as necessary for the effects of other edits, and then return a\r\n     * flat list of all the selections, suitable for passing to `setSelections()`.\r\n     *\r\n     * @param {!Array.<{edit: {text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}\r\n     *                        | Array.<{text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}>,\r\n     *                  selection: ?{start:{line:number, ch:number}, end:{line:number, ch:number}, \r\n     *                              primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}\r\n     *                        | ?Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, \r\n     *                                  primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}>} edits\r\n     *     Specifies the list of edits to perform in a manner similar to CodeMirror\'s `replaceRange`. This array\r\n     *     will be mutated.\r\n     *\r\n     *     `edit` is the edit to perform:\r\n     *         `text` will replace the current contents of the range between `start` and `end`. \r\n     *         If `end` is unspecified, the text is inserted at `start`.\r\n     *         `start` and `end` should be positions relative to the document *ignoring* all other edit descriptions\r\n     *         (i.e., as if you were only performing this one edit on the document).\r\n     *     If any of the edits overlap, an error will be thrown.\r\n     *\r\n     *     If `selection` is specified, it should be a selection associated with this edit.\r\n     *          If `isBeforeEdit` is set on the selection, the selection will be fixed up for this edit.\r\n     *          If not, it won\'t be fixed up for this edit, meaning it should be expressed in terms of\r\n     *          the document state after this individual edit is performed (ignoring any other edits).\r\n     *          Note that if you were planning on just specifying `isBeforeEdit` for every selection, you can\r\n     *          accomplish the same thing by simply not passing any selections and letting the editor update\r\n     *          the existing selections automatically.\r\n     *\r\n     *     Note that `edit` and `selection` can each be either an individual edit/selection, or a group of\r\n     *     edits/selections to apply in order. This can be useful if you need to perform multiple edits in a row\r\n     *     and then specify a resulting selection that shouldn\'t be fixed up for any of those edits (but should be\r\n     *     fixed up for edits related to other selections). It can also be useful if you have several selections\r\n     *     that should ignore the effects of a given edit because you\'ve fixed them up already (this commonly happens\r\n     *     with line-oriented edits where multiple cursors on the same line should be ignored, but still tracked). \r\n     *     Within an edit group, edit positions must be specified relative to previous edits within that group. Also,\r\n     *     the total bounds of edit groups must not overlap (e.g. edits in one group can\'t surround an edit from another group).\r\n     *\r\n     * @param {?string} origin An optional edit origin that\'s passed through to each replaceRange().\r\n     * @return {Array<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean}>}\r\n     *     The list of passed selections adjusted for the performed edits, if any.\r\n     */\r\n    Document.prototype.doMultipleEdits = function (edits, origin) {\r\n        var self = this;\r\n        \r\n        // Sort the edits backwards, so we don\'t have to adjust the edit positions as we go along\r\n        // (though we do have to adjust the selection positions).\r\n        edits.sort(function (editDesc1, editDesc2) {\r\n            var edit1 = (Array.isArray(editDesc1.edit) ? editDesc1.edit[0] : editDesc1.edit),\r\n                edit2 = (Array.isArray(editDesc2.edit) ? editDesc2.edit[0] : editDesc2.edit);\r\n            // Treat all no-op edits as if they should happen before all other edits (the order\r\n            // doesn\'t really matter, as long as they sort out of the way of the real edits).\r\n            if (!edit1) {\r\n                return -1;\r\n            } else if (!edit2) {\r\n                return 1;\r\n            } else {\r\n                return CodeMirror.cmpPos(edit2.start, edit1.start);\r\n            }\r\n        });\r\n        \r\n        // Pull out the selections, in the same order as the edits.\r\n        var result = _.cloneDeep(_.pluck(edits, "selection"));\r\n        \r\n        // Preflight the edits to specify "end" if unspecified and make sure they don\'t overlap. \r\n        // (We don\'t want to do it during the actual edits, since we don\'t want to apply some of\r\n        // the edits before we find out.)\r\n        _.each(edits, function (editDesc, index) {\r\n            oneOrEach(editDesc.edit, function (edit) {\r\n                if (edit) {\r\n                    if (!edit.end) {\r\n                        edit.end = edit.start;\r\n                    }\r\n                    if (index > 0) {\r\n                        var prevEditGroup = edits[index - 1].edit;\r\n                        // The edits are in reverse order, so we want to make sure this edit ends\r\n                        // before any of the previous ones start.\r\n                        oneOrEach(prevEditGroup, function (prevEdit) {\r\n                            if (CodeMirror.cmpPos(edit.end, prevEdit.start) > 0) {\r\n                                throw new Error("Document.doMultipleEdits(): Overlapping edits specified");\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        });\r\n        \r\n        // Perform the edits.\r\n        this.batchOperation(function () {\r\n            _.each(edits, function (editDesc, index) {\r\n                // Perform this group of edits. The edit positions are guaranteed to be okay\r\n                // since all the previous edits we\'ve done have been later in the document. However,\r\n                // we have to fix up any selections that overlap or come after the edit.\r\n                oneOrEach(editDesc.edit, function (edit) {\r\n                    if (edit) {\r\n                        self.replaceRange(edit.text, edit.start, edit.end, origin);\r\n\r\n                        // Fix up all the selections *except* the one(s) related to this edit list that\r\n                        // are not "before-edit" selections.\r\n                        var textLines = edit.text.split("\\n");\r\n                        _.each(result, function (selections, selIndex) {\r\n                            if (selections) {\r\n                                oneOrEach(selections, function (sel) {\r\n                                    if (sel.isBeforeEdit || selIndex !== index) {\r\n                                        sel.start = self.adjustPosForChange(sel.start, textLines, edit.start, edit.end);\r\n                                        sel.end = self.adjustPosForChange(sel.end, textLines, edit.start, edit.end);\r\n                                    }\r\n                                });\r\n                            }\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        \r\n        result = _.chain(result)\r\n            .filter(function (item) {\r\n                return item !== undefined;\r\n            })\r\n            .flatten()\r\n            .sort(function (sel1, sel2) {\r\n                return CodeMirror.cmpPos(sel1.start, sel2.start);\r\n            })\r\n            .value();\r\n        _.each(result, function (item) {\r\n            delete item.isBeforeEdit;\r\n        });\r\n        return result;\r\n    };\r\n    \r\n    /* (pretty toString(), to aid debugging) */\r\n    Document.prototype.toString = function () {\r\n        var dirtyInfo = (this.isDirty ? " (dirty!)" : " (clean)");\r\n        var editorInfo = (this._masterEditor ? " (Editable)" : " (Non-editable)");\r\n        var refInfo = " refs:" + this._refCount;\r\n        return "[Document " + this.file.fullPath + dirtyInfo + editorInfo + refInfo + "]";\r\n    };\r\n    \r\n    /**\r\n     * Returns the language this document is written in.\r\n     * The language returned is based on the file extension.\r\n     * @return {Language} An object describing the language used in this document\r\n     */\r\n    Document.prototype.getLanguage = function () {\r\n        return this.language;\r\n    };\r\n    \r\n    /**\r\n     * Updates the language to match the current mapping given by LanguageManager\r\n     */\r\n    Document.prototype._updateLanguage = function () {\r\n        var oldLanguage = this.language;\r\n        this.language = LanguageManager.getLanguageForPath(this.file.fullPath);\r\n        if (oldLanguage && oldLanguage !== this.language) {\r\n            $(this).triggerHandler("languageChanged", [oldLanguage, this.language]);\r\n        }\r\n    };\r\n    \r\n    /** Called when Document.file has been modified (due to a rename) */\r\n    Document.prototype._notifyFilePathChanged = function () {\r\n        // File extension may have changed\r\n        this._updateLanguage();\r\n    };\r\n    \r\n    /**\r\n     * Is this an untitled document?\r\n     * \r\n     * @return {boolean} - whether or not the document is untitled\r\n     */\r\n    Document.prototype.isUntitled = function () {\r\n        return this.file instanceof InMemoryFile;\r\n    };\r\n\r\n    // Define public API\r\n    exports.Document = Document;\r\n});\r\n\n//# sourceURL=/document/Document.js'),eval("/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets */\r\n\r\n/**\r\n * FileSyncManager is a set of utilities to help track external modifications to the files and folders\r\n * in the currently open project.\r\n *\r\n * Currently, we detect external changes purely by checking file timestamps against the last-sync\r\n * timestamp recorded on Document. Brackets triggers this check whenever an external change was detected\r\n * by our native file watchers, and on window focus. We recheck all open Documents, but with file caching\r\n * the timestamp check is a fast no-op for everything other than files where a watcher change was just\r\n * notified. If watchers/caching are disabled, we'll essentially check only on window focus, and we'll hit\r\n * the disk to check every open Document's timestamp every time.\r\n *\r\n * FUTURE: Whenever we have a 'project file tree model,' we should manipulate that instead of notifying\r\n * DocumentManager directly. DocumentManager, the tree UI, etc. then all listen to that model for changes.\r\n */\r\ndefine('project/FileSyncManager',['require','exports','module','project/ProjectManager','document/DocumentManager','view/MainViewManager','editor/EditorManager','command/Commands','command/CommandManager','utils/Async','widgets/Dialogs','widgets/DefaultDialogs','strings','utils/StringUtils','file/FileUtils','filesystem/FileSystemError'],function (require, exports, module) {\r\n    \"use strict\";\r\n    \r\n    // Load dependent modules\r\n    var ProjectManager      = require(\"project/ProjectManager\"),\r\n        DocumentManager     = require(\"document/DocumentManager\"),\r\n        MainViewManager     = require(\"view/MainViewManager\"),\r\n        EditorManager       = require(\"editor/EditorManager\"),\r\n        Commands            = require(\"command/Commands\"),\r\n        CommandManager      = require(\"command/CommandManager\"),\r\n        Async               = require(\"utils/Async\"),\r\n        Dialogs             = require(\"widgets/Dialogs\"),\r\n        DefaultDialogs      = require(\"widgets/DefaultDialogs\"),\r\n        Strings             = require(\"strings\"),\r\n        StringUtils         = require(\"utils/StringUtils\"),\r\n        FileUtils           = require(\"file/FileUtils\"),\r\n        FileSystemError     = require(\"filesystem/FileSystemError\");\r\n\r\n    \r\n    /**\r\n     * Guard to spot re-entrancy while syncOpenDocuments() is still in progress\r\n     * @type {boolean}\r\n     */\r\n    var _alreadyChecking = false;\r\n    \r\n    /**\r\n     * If true, we should bail from the syncOpenDocuments() process and then re-run it. See\r\n     * comments in syncOpenDocuments() for how this works.\r\n     * @type {boolean}\r\n     */\r\n    var _restartPending = false;\r\n    \r\n    /**\r\n     * @type {Array.<Document>}\r\n     */\r\n    var toReload;\r\n\r\n    /**\r\n     * @type {Array.<Document>}\r\n     */\r\n    var toClose;\r\n\r\n    /**\r\n     * @type {Array.<{doc: Document, fileTime: number}>}\r\n     */\r\n    var editConflicts;\r\n\r\n    /**\r\n     * @type {Array.<{doc: Document, fileTime: number}>}\r\n     */\r\n    var deleteConflicts;\r\n    \r\n    \r\n    /**\r\n     * Scans all the given Documents for changes on disk, and sorts them into four buckets,\r\n     * populating the corresponding arrays:\r\n     *  toReload        - changed on disk; unchanged within Brackets\r\n     *  toClose         - deleted on disk; unchanged within Brackets\r\n     *  editConflicts   - changed on disk; also dirty in Brackets\r\n     *  deleteConflicts - deleted on disk; also dirty in Brackets\r\n     *\r\n     * @param {!Array.<Document>} docs\r\n     * @return {$.Promise}  Resolved when all scanning done, or rejected immediately if there's any\r\n     *      error while reading file timestamps. Errors are logged but no UI is shown.\r\n     */\r\n    function findExternalChanges(docs) {\r\n\r\n        toReload = [];\r\n        toClose = [];\r\n        editConflicts = [];\r\n        deleteConflicts = [];\r\n    \r\n        function checkDoc(doc) {\r\n            var result = new $.Deferred();\r\n            \r\n            // Check file timestamp / existence\r\n            \r\n            if (doc.isUntitled()) {\r\n                result.resolve();\r\n            } else {\r\n                doc.file.stat(function (err, stat) {\r\n                    if (!err) {\r\n                        // Does file's timestamp differ from last sync time on the Document?\r\n                        var fileTime = stat.mtime.getTime();\r\n                        if (fileTime !== doc.diskTimestamp.getTime()) {\r\n                            // If the user has chosen to keep changes that conflict with the\r\n                            // current state of the file on disk, then do nothing. This means\r\n                            // that even if the user later undoes back to clean, we won't\r\n                            // automatically reload the file on window reactivation. We could\r\n                            // make it do that, but it seems better to be consistent with the\r\n                            // deletion case below, where it seems clear that you don't want\r\n                            // to auto-delete the file on window reactivation just because you\r\n                            // undid back to clean.\r\n                            if (doc.keepChangesTime !== fileTime) {\r\n                                if (doc.isDirty) {\r\n                                    editConflicts.push({doc: doc, fileTime: fileTime});\r\n                                } else {\r\n                                    toReload.push(doc);\r\n                                }\r\n                            }\r\n                        }\r\n                        result.resolve();\r\n                    } else {\r\n                        // File has been deleted externally\r\n                        if (err === FileSystemError.NOT_FOUND) {\r\n                            // If the user has chosen to keep changes previously, and the file\r\n                            // has been deleted, then do nothing. Like the case above, this\r\n                            // means that even if the user later undoes back to clean, we won't\r\n                            // then automatically delete the file on window reactivation.\r\n                            // (We use -1 as the \"mod time\" to indicate that the file didn't\r\n                            // exist, since there's no actual modification time to keep track of\r\n                            // and -1 isn't a valid mod time for a real file.)\r\n                            if (doc.keepChangesTime !== -1) {\r\n                                if (doc.isDirty) {\r\n                                    deleteConflicts.push({doc: doc, fileTime: -1});\r\n                                } else {\r\n                                    toClose.push(doc);\r\n                                }\r\n                            }\r\n                            result.resolve();\r\n                        } else {\r\n                            // Some other error fetching metadata: treat as a real error\r\n                            console.log(\"Error checking modification status of \" + doc.file.fullPath, err);\r\n                            result.reject();\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n\r\n            return result.promise();\r\n        }\r\n        \r\n        // Check all docs in parallel\r\n        // (fail fast b/c we won't continue syncing if there was any error fetching timestamps)\r\n        return Async.doInParallel(docs, checkDoc, true);\r\n    }\r\n    \r\n    /**\r\n     * Scans all the files in the working set that do not have Documents (and thus were not scanned\r\n     * by findExternalChanges()). If any were deleted on disk, removes them from the working set.\r\n     */\r\n    function syncUnopenWorkingSet() {\r\n        // We only care about working set entries that have never been open (have no Document).\r\n        var unopenWorkingSetFiles = MainViewManager.getWorkingSet(MainViewManager.ALL_PANES).filter(function (wsFile) {\r\n            return !DocumentManager.getOpenDocumentForPath(wsFile.fullPath);\r\n        });\r\n        \r\n        function checkWorkingSetFile(file) {\r\n            var result = new $.Deferred();\r\n            \r\n            file.stat(function (err, stat) {\r\n                if (!err) {\r\n                    // File still exists\r\n                    result.resolve();\r\n                } else {\r\n                    // File has been deleted externally\r\n                    if (err === FileSystemError.NOT_FOUND) {\r\n                        DocumentManager.notifyFileDeleted(file);\r\n                        result.resolve();\r\n                    } else {\r\n                        // Some other error fetching metadata: treat as a real error\r\n                        console.log(\"Error checking for deletion of \" + file.fullPath, err);\r\n                        result.reject();\r\n                    }\r\n                }\r\n            });\r\n            return result.promise();\r\n        }\r\n        \r\n        // Check all these files in parallel\r\n        return Async.doInParallel(unopenWorkingSetFiles, checkWorkingSetFile, false);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Reloads the Document's contents from disk, discarding any unsaved changes in the editor.\r\n     *\r\n     * @param {!Document} doc\r\n     * @return {$.Promise} Resolved after editor has been refreshed; rejected if unable to load the\r\n     *      file's new content. Errors are logged but no UI is shown.\r\n     */\r\n    function reloadDoc(doc) {\r\n        \r\n        var promise = FileUtils.readAsText(doc.file);\r\n        \r\n        promise.done(function (text, readTimestamp) {\r\n            doc.refreshText(text, readTimestamp);\r\n        });\r\n        promise.fail(function (error) {\r\n            console.log(\"Error reloading contents of \" + doc.file.fullPath, error);\r\n        });\r\n        return promise;\r\n    }\r\n    \r\n    /**\r\n     * Reloads all the documents in \"toReload\" silently (no prompts). The operations are all run\r\n     * in parallel.\r\n     * @return {$.Promise} Resolved/rejected after all reloads done; will be rejected if any one\r\n     *      file's reload failed. Errors are logged (by reloadDoc()) but no UI is shown.\r\n     */\r\n    function reloadChangedDocs() {\r\n        // Reload each doc in turn, and once all are (async) done, signal that we're done\r\n        return Async.doInParallel(toReload, reloadDoc, false);\r\n    }\r\n    \r\n    /**\r\n     * @param {FileError} error\r\n     * @param {!Document} doc\r\n     * @return {Dialog}\r\n     */\r\n    function showReloadError(error, doc) {\r\n        return Dialogs.showModalDialog(\r\n            DefaultDialogs.DIALOG_ID_ERROR,\r\n            Strings.ERROR_RELOADING_FILE_TITLE,\r\n            StringUtils.format(\r\n                Strings.ERROR_RELOADING_FILE,\r\n                StringUtils.breakableUrl(doc.file.fullPath),\r\n                FileUtils.getFileErrorString(error)\r\n            )\r\n        );\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Closes all the documents in \"toClose\" silently (no prompts). Completes synchronously.\r\n     */\r\n    function closeDeletedDocs() {\r\n        toClose.forEach(function (doc) {\r\n            DocumentManager.notifyFileDeleted(doc.file);\r\n        });\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Walks through all the documents in \"editConflicts\" & \"deleteConflicts\" and prompts the user\r\n     * about each one. Processing is sequential: if the user chooses to reload a document, the next\r\n     * prompt is not shown until after the reload has completed.\r\n     *\r\n     * @param {string} title Title of the dialog.\r\n     * @return {$.Promise} Resolved/rejected after all documents have been prompted and (if\r\n     *      applicable) reloaded (and any resulting error UI has been dismissed). Rejected if any\r\n     *      one reload failed.\r\n     */\r\n    function presentConflicts(title) {\r\n        \r\n        var allConflicts = editConflicts.concat(deleteConflicts);\r\n        \r\n        function presentConflict(docInfo, i) {\r\n            var result = new $.Deferred(),\r\n                promise = result.promise(),\r\n                doc = docInfo.doc,\r\n                fileTime = docInfo.fileTime;\r\n            \r\n            // If window has been re-focused, skip all remaining conflicts so the sync can bail & restart\r\n            if (_restartPending) {\r\n                result.resolve();\r\n                return promise;\r\n            }\r\n            \r\n            var toClose;\r\n            var dialogId;\r\n            var message;\r\n            var buttons;\r\n            \r\n            // Prompt UI varies depending on whether the file on disk was modified vs. deleted\r\n            if (i < editConflicts.length) {\r\n                toClose = false;\r\n                dialogId = DefaultDialogs.DIALOG_ID_EXT_CHANGED;\r\n                message = StringUtils.format(\r\n                    Strings.EXT_MODIFIED_MESSAGE,\r\n                    StringUtils.breakableUrl(\r\n                        ProjectManager.makeProjectRelativeIfPossible(doc.file.fullPath)\r\n                    )\r\n                );\r\n                buttons = [\r\n                    {\r\n                        className: Dialogs.DIALOG_BTN_CLASS_LEFT,\r\n                        id:        Dialogs.DIALOG_BTN_DONTSAVE,\r\n                        text:      Strings.RELOAD_FROM_DISK\r\n                    },\r\n                    {\r\n                        className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\r\n                        id:        Dialogs.DIALOG_BTN_CANCEL,\r\n                        text:      Strings.KEEP_CHANGES_IN_EDITOR\r\n                    }\r\n                ];\r\n                \r\n            } else {\r\n                toClose = true;\r\n                dialogId = DefaultDialogs.DIALOG_ID_EXT_DELETED;\r\n                message = StringUtils.format(\r\n                    Strings.EXT_DELETED_MESSAGE,\r\n                    StringUtils.breakableUrl(\r\n                        ProjectManager.makeProjectRelativeIfPossible(doc.file.fullPath)\r\n                    )\r\n                );\r\n                buttons = [\r\n                    {\r\n                        className: Dialogs.DIALOG_BTN_CLASS_LEFT,\r\n                        id:        Dialogs.DIALOG_BTN_DONTSAVE,\r\n                        text:      Strings.CLOSE_DONT_SAVE\r\n                    },\r\n                    {\r\n                        className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\r\n                        id:        Dialogs.DIALOG_BTN_CANCEL,\r\n                        text:      Strings.KEEP_CHANGES_IN_EDITOR\r\n                    }\r\n                ];\r\n            }\r\n            \r\n            Dialogs.showModalDialog(dialogId, title, message, buttons)\r\n                .done(function (id) {\r\n                    if (id === Dialogs.DIALOG_BTN_DONTSAVE) {\r\n                        if (toClose) {\r\n                            // Discard - close all editors\r\n                            DocumentManager.notifyFileDeleted(doc.file);\r\n                            result.resolve();\r\n                        } else {\r\n                            // Discard - load changes from disk\r\n                            reloadDoc(doc)\r\n                                .done(function () {\r\n                                    result.resolve();\r\n                                })\r\n                                .fail(function (error) {\r\n                                    // Unable to load changed version from disk - show error UI\r\n                                    showReloadError(error, doc)\r\n                                        .done(function () {\r\n                                            // After user dismisses, move on to next conflict prompt\r\n                                            result.reject();\r\n                                        });\r\n                                });\r\n                        }\r\n                        \r\n                    } else {\r\n                        // Cancel - if user doesn't manually save or close, remember that they\r\n                        // chose to keep the changes in the editor and don't prompt again unless the\r\n                        // file changes again\r\n                        // OR programmatically canceled due to _resetPending - we'll skip all\r\n                        // remaining files in the conflicts list (see above)\r\n\r\n                        // If this wasn't programmatically cancelled, remember that the user \r\n                        // has accepted conflicting changes as of this file version.\r\n                        if (!_restartPending) {\r\n                            doc.keepChangesTime = fileTime;\r\n                        }\r\n                            \r\n                        result.resolve();\r\n                    }\r\n                });\r\n            \r\n            return promise;\r\n        }\r\n        \r\n        // Begin walking through the conflicts, one at a time\r\n        return Async.doSequentially(allConflicts, presentConflict, false);\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n     * Check to see whether any open files have been modified by an external app since the last time\r\n     * Brackets synced up with the copy on disk (either by loading or saving the file). For clean\r\n     * files, we silently upate the editor automatically. For files with unsaved changes, we prompt\r\n     * the user.\r\n     *\r\n     * @param {string} title Title to use for document. Default is \"External Changes\".\r\n     */\r\n    function syncOpenDocuments(title) {\r\n        \r\n        title = title || Strings.EXT_MODIFIED_TITLE;\r\n        \r\n        // We can become \"re-entrant\" if the user leaves & then returns to Brackets before we're\r\n        // done -- easy if a prompt dialog is left open. Since the user may have left Brackets to\r\n        // revert some of the disk changes, etc. we want to cancel the current sync and immediately\r\n        // begin a new one. We let the orig sync run until the user-visible dialog phase, then\r\n        // bail; if we're already there we programmatically close the dialog to bail right away.\r\n        if (_alreadyChecking) {\r\n            _restartPending = true;\r\n            \r\n            // Close dialog if it was open. This will 'unblock' presentConflict(), which bails back\r\n            // to us immediately upon seeing _restartPending. We then restart the sync - see below\r\n            Dialogs.cancelModalDialogIfOpen(DefaultDialogs.DIALOG_ID_EXT_CHANGED);\r\n            Dialogs.cancelModalDialogIfOpen(DefaultDialogs.DIALOG_ID_EXT_DELETED);\r\n            \r\n            return;\r\n        }\r\n        \r\n        _alreadyChecking = true;\r\n        \r\n        \r\n        // Syncing proceeds in four phases:\r\n        //  1) Check all open files for external modifications\r\n        //  2) Check any other working set entries (that are not open) for deletion, and remove\r\n        //     from working set if deleted\r\n        //  3) Refresh all Documents that are clean (if file changed on disk)\r\n        //  4) Close all Documents that are clean (if file deleted on disk)\r\n        //  5) Prompt about any Documents that are dirty (if file changed/deleted on disk)\r\n        // Each phase fully completes (asynchronously) before the next one begins.\r\n        \r\n        \r\n        // 1) Check for external modifications\r\n        var allDocs = DocumentManager.getAllOpenDocuments();\r\n        \r\n        findExternalChanges(allDocs)\r\n            .done(function () {\r\n                // 2) Check un-open working set entries for deletion (& \"close\" if needed)\r\n                syncUnopenWorkingSet()\r\n                    .always(function () {\r\n                        // If we were unable to check any un-open files for deletion, silently ignore\r\n                        // (after logging to console). This doesn't have any bearing on syncing truly\r\n                        // open Documents (which we've already successfully checked).\r\n                        \r\n                        // 3) Reload clean docs as needed\r\n                        reloadChangedDocs()\r\n                            .always(function () {\r\n                                // 4) Close clean docs as needed\r\n                                // This phase completes synchronously\r\n                                closeDeletedDocs();\r\n                                \r\n                                // 5) Prompt for dirty editors (conflicts)\r\n                                presentConflicts(title)\r\n                                    .always(function () {\r\n                                        if (_restartPending) {\r\n                                            // Restart the sync if needed\r\n                                            _restartPending = false;\r\n                                            _alreadyChecking = false;\r\n                                            syncOpenDocuments();\r\n                                        } else {\r\n                                            // We're really done!\r\n                                            _alreadyChecking = false;\r\n                                            \r\n                                            // If we showed a dialog, restore focus to editor\r\n                                            if (editConflicts.length > 0 || deleteConflicts.length > 0) {\r\n                                                MainViewManager.focusActivePane();\r\n                                            }\r\n                                            \r\n                                            // (Any errors that ocurred during presentConflicts() have already\r\n                                            // shown UI & been dismissed, so there's no fail() handler here)\r\n                                        }\r\n                                    });\r\n                            });\r\n                            // Note: if any auto-reloads failed, we silently ignore (after logging to console)\r\n                            // and we still continue onto phase 4 and try to process those files anyway.\r\n                            // (We'll retry the auto-reloads next time window is activated... and evenually\r\n                            // we'll also be double checking before each Save).\r\n                    });\r\n            }).fail(function () {\r\n                // Unable to fetch timestamps for some reason - silently ignore (after logging to console)\r\n                // (We'll retry next time window is activated... and evenually we'll also be double\r\n                // checking before each Save).\r\n                \r\n                // We can't go on without knowing which files are dirty, so bail now\r\n                _alreadyChecking = false;\r\n            });\r\n        \r\n    }\r\n    \r\n    \r\n    // Define public API\r\n    exports.syncOpenDocuments = syncOpenDocuments;\r\n});\r\n\n//# sourceURL=/project/FileSyncManager.js"),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n/**\r\n * DocumentManager maintains a list of currently \'open\' Documents. The DocumentManager is responsible \r\n * for coordinating document operations and dispatching certain document events.\r\n *\r\n * Document is the model for a file\'s contents; it dispatches events whenever those contents change.\r\n * To transiently inspect a file\'s content, simply get a Document and call getText() on it. However,\r\n * to be notified of Document changes or to modify a Document, you MUST call addRef() to ensure the\r\n * Document instance \'stays alive\' and is shared by all other who read/modify that file. (\'Open\'\r\n * Documents are all Documents that are \'kept alive\', i.e. have ref count > 0).\r\n *\r\n * To get a Document, call getDocumentForPath(); never new up a Document yourself.\r\n *\r\n * Secretly, a Document may use an Editor instance to act as the model for its internal state. (This\r\n * is unavoidable because CodeMirror does not separate its model from its UI). Documents are not\r\n * modifiable until they have a backing \'master Editor\'. Creation of the backing Editor is owned by\r\n * EditorManager. A Document only gets a backing Editor if it opened in an editor.\r\n *\r\n * A non-modifiable Document may still dispatch change notifications, if the Document was changed\r\n * externally on disk.\r\n *\r\n * Aside from the text content, Document tracks a few pieces of metadata - notably, whether there are\r\n * any unsaved changes.\r\n *\r\n * This module dispatches several events:\r\n *\r\n *    - dirtyFlagChange -- When any Document\'s isDirty flag changes. The 2nd arg to the listener is the\r\n *      Document whose flag changed.\r\n *    - documentSaved -- When a Document\'s changes have been saved. The 2nd arg to the listener is the\r\n *      Document that has been saved.\r\n *    - documentRefreshed -- When a Document\'s contents have been reloaded from disk. The 2nd arg to the\r\n *      listener is the Document that has been refreshed.\r\n *\r\n * NOTE: WorkingSet APIs have been deprecated and have moved to MainViewManager as WorkingSet APIs\r\n *       Some WorkingSet APIs that have been identified as being used by 3rd party extensions will\r\n *       emit deprecation warnings and call the WorkingSet APIS to maintain backwards compatibility\r\n *\r\n *    - currentDocumentChange -- This is being deprecated and is currently only used as a shim to assist \r\n *      the document open process so that the editor will actually open or close the desired document. \r\n *      This will change accordingly once work begins to refactor EditorManager to be a view provider\r\n *      and open documents directly.\r\n *\r\n *    - fileNameChange -- When the name of a file or folder has changed. The 2nd arg is the old name.\r\n *      The 3rd arg is the new name.  Generally, however, file objects have already been changed by the \r\n *      time this event is dispatched so code that relies on matching the filename to a file object \r\n *      will need to compare the newname.\r\n * \r\n *    - pathDeleted -- When a file or folder has been deleted. The 2nd arg is the path that was deleted.\r\n *\r\n * These are jQuery events, so to listen for them you do something like this:\r\n *    $(DocumentManager).on("eventname", handler);\r\n *\r\n * Document objects themselves also dispatch some events - see Document docs for details.\r\n */\r\ndefine(\'document/DocumentManager\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'utils/AppInit\',\'document/Document\',\'utils/DeprecationWarning\',\'view/MainViewManager\',\'view/MainViewFactory\',\'project/ProjectManager\',\'editor/EditorManager\',\'project/FileSyncManager\',\'filesystem/FileSystem\',\'preferences/PreferencesManager\',\'file/FileUtils\',\'document/InMemoryFile\',\'command/CommandManager\',\'command/Commands\',\'utils/Async\',\'utils/PerfUtils\',\'language/LanguageManager\',\'strings\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n    \r\n    var AppInit             = require("utils/AppInit"),\r\n        DocumentModule      = require("document/Document"),\r\n        DeprecationWarning  = require("utils/DeprecationWarning"),\r\n        MainViewManager     = require("view/MainViewManager"),\r\n        MainViewFactory     = require("view/MainViewFactory"),\r\n        ProjectManager      = require("project/ProjectManager"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        FileSyncManager     = require("project/FileSyncManager"),\r\n        FileSystem          = require("filesystem/FileSystem"),\r\n        PreferencesManager  = require("preferences/PreferencesManager"),\r\n        FileUtils           = require("file/FileUtils"),\r\n        InMemoryFile        = require("document/InMemoryFile"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        Commands            = require("command/Commands"),\r\n        Async               = require("utils/Async"),\r\n        PerfUtils           = require("utils/PerfUtils"),\r\n        LanguageManager     = require("language/LanguageManager"),\r\n        Strings             = require("strings");\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Random path prefix for untitled documents\r\n     */\r\n    var _untitledDocumentPath = "/_brackets_" + _.random(10000000, 99999999);\r\n\r\n    /**\r\n     * All documents with refCount > 0. Maps Document.file.id -> Document.\r\n     * @private\r\n     * @type {Object.<string, Document>}\r\n     */\r\n    var _openDocuments = {};\r\n\r\n    /**\r\n     * Returns the existing open Document for the given file, or null if the file is not open (\'open\'\r\n     * means referenced by the UI somewhere). If you will hang onto the Document, you must addRef()\r\n     * it; see {@link getDocumentForPath()} for details.\r\n     * @param {!string} fullPath\r\n     * @return {?Document}\r\n     */\r\n    function getOpenDocumentForPath(fullPath) {\r\n        var id;\r\n        \r\n        // Need to walk all open documents and check for matching path. We can\'t\r\n        // use getFileForPath(fullPath).id since the file it returns won\'t match\r\n        // an Untitled document\'s InMemoryFile.\r\n        for (id in _openDocuments) {\r\n            if (_openDocuments.hasOwnProperty(id)) {\r\n                if (_openDocuments[id].file.fullPath === fullPath) {\r\n                    return _openDocuments[id];\r\n                }\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Returns the Document that is currently open in the editor UI. May be null.\r\n     * @return {?Document}\r\n     */\r\n    function getCurrentDocument() {\r\n        var file = MainViewManager.getCurrentlyViewedFile(MainViewManager.ACTIVE_PANE);\r\n        \r\n        if (file) {\r\n            return getOpenDocumentForPath(file.fullPath);\r\n        }\r\n        \r\n        return null;\r\n    }\r\n\r\n    \r\n    /**\r\n     * Returns a list of items in the working set in UI list order. May be 0-length, but never null.\r\n     * @deprecated Use MainViewManager.getWorkingSet() instead\r\n     * @return {Array.<File>}\r\n     */\r\n    function getWorkingSet() {\r\n        DeprecationWarning.deprecationWarning("Use MainViewManager.getViews() instead of DocumentManager.getWorkingSet()", true);\r\n        return MainViewManager.getWorkingSet(MainViewManager.ALL_PANES)\r\n            .filter(function (file) {\r\n                // Legacy didn\'t allow for files with custom viewers\r\n                return !MainViewFactory.findSuitableFactoryForPath(file.fullPath);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Returns the index of the file matching fullPath in the working set.\r\n     * @deprecated Use MainViewManager.findInWorkingSet() instead\r\n     * @param {!string} fullPath\r\n     * @return {number} index, -1 if not found\r\n     */\r\n    function findInWorkingSet(fullPath) {\r\n        DeprecationWarning.deprecationWarning("Use MainViewManager.findInWorkingSet() instead of DocumentManager.findInWorkingSet()", true);\r\n        return MainViewManager.findInWorkingSet(MainViewManager.ACTIVE_PANE, fullPath);\r\n    }\r\n    \r\n    /**\r\n     * Returns all Documents that are \'open\' in the UI somewhere (for now, this means open in an\r\n     * inline editor and/or a full-size editor). Only these Documents can be modified, and only\r\n     * these Documents are synced with external changes on disk.\r\n     * @return {Array.<Document>}\r\n     */\r\n    function getAllOpenDocuments() {\r\n        var result = [];\r\n        var id;\r\n        for (id in _openDocuments) {\r\n            if (_openDocuments.hasOwnProperty(id)) {\r\n                result.push(_openDocuments[id]);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Adds the given file to the end of the working set list.\r\n     * @deprecated Use MainViewManager.addToWorkingSet() instead \r\n     * @param {!File} file\r\n     * @param {number=} index  Position to add to list (defaults to last); -1 is ignored\r\n     * @param {boolean=} forceRedraw  If true, a working set change notification is always sent\r\n     *    (useful if suppressRedraw was used with removeFromWorkingSet() earlier)\r\n     */\r\n    function addToWorkingSet(file, index, forceRedraw) {\r\n        DeprecationWarning.deprecationWarning("Use MainViewManager.addToWorkingSet() instead of DocumentManager.addToWorkingSet()", true);\r\n        MainViewManager.addToWorkingSet(MainViewManager.ACTIVE_PANE, file, index, forceRedraw);\r\n    }\r\n    \r\n    /**\r\n     * @deprecated Use MainViewManager.addListToWorkingSet() instead \r\n     * Adds the given file list to the end of the working set list.\r\n     * If a file in the list has its own custom viewer, then it \r\n     * is not added into the working set.\r\n     * Does not change which document is currently open in the editor.\r\n     * More efficient than calling addToWorkingSet() (in a loop) for\r\n     * a list of files because there\'s only 1 redraw at the end\r\n     * @param {!Array.<File>} fileList\r\n     */\r\n    function addListToWorkingSet(fileList) {\r\n        DeprecationWarning.deprecationWarning("Use MainViewManager.addListToWorkingSet() instead of DocumentManager.addListToWorkingSet()", true);\r\n        MainViewManager.addListToWorkingSet(MainViewManager.ACTIVE_PANE, fileList);\r\n    }\r\n\r\n    \r\n    /**\r\n     */\r\n    function removeListFromWorkingSet(list) {\r\n        throw new Error("removeListFromWorkingSet() has been deprecated.  Use Command.FILE_CLOSE_LIST instead.");\r\n    }\r\n        \r\n    /**\r\n     * closes all open files\r\n     * @deprecated Use MainViewManager._closeAll() instead\r\n     * Calling this discards any unsaved changes, so the UI should confirm with the user before calling this.\r\n     */\r\n    function closeAll() {\r\n        DeprecationWarning.deprecationWarning("Use MainViewManager._closeAll() instead of DocumentManager.closeAll()", true);\r\n        CommandManager.execute(Commands.FILE_CLOSE_ALL, {PaneId: MainViewManager.ALL_PANES});\r\n    }\r\n\r\n    /**\r\n     * closes the specified file file \r\n     * @deprecated use MainViewManager._close() instead\r\n     * @param {!File} file\r\n     */\r\n    function closeFullEditor(file) {\r\n        DeprecationWarning.deprecationWarning("Use MainViewManager._close() instead of DocumentManager.closeFullEditor()", true);\r\n        CommandManager.execute(Commands.FILE_CLOSE, {File: file});\r\n    }\r\n    \r\n    /**\r\n     * opens the specified document for editing in the currently active pane\r\n     * @deprecated use MainViewManager._edit() instead\r\n     * @param {!Document} document  The Document to make current. \r\n     */\r\n    function setCurrentDocument(doc) {\r\n        DeprecationWarning.deprecationWarning("Use CommandManager.doCommand(Commands.CMD_OPEN) instead of DocumentManager.setCurrentDocument()", true);\r\n        CommandManager.execute(Commands.CMD_OPEN, {fullPath: doc.file.fullPath});\r\n    }\r\n\r\n    \r\n    /**\r\n     * freezes the Working Set MRU list \r\n     * @deprecated use MainViewManager.beginTraversal() instead\r\n     */\r\n    function beginDocumentNavigation() {\r\n        DeprecationWarning.deprecationWarning("Use MainViewManager.beginTraversal() instead of DocumentManager.beginDocumentNavigation()", true);\r\n        MainViewManager.beginTraversal();\r\n    }\r\n    \r\n    /**\r\n     * ends document navigation and moves the current file to the front of the MRU list in the Working Set\r\n     * @deprecated use MainViewManager.endTraversal() instead\r\n     */\r\n    function finalizeDocumentNavigation() {\r\n        DeprecationWarning.deprecationWarning("Use MainViewManager.endTraversal() instead of DocumentManager.finalizeDocumentNavigation()", true);\r\n        MainViewManager.endTraversal();\r\n    }\r\n    \r\n    /**\r\n     * Get the next or previous file in the working set, in MRU order (relative to currentDocument). May\r\n     * return currentDocument itself if working set is length 1.\r\n     * @deprecated use MainViewManager.traverseToNextViewByMRU() instead\r\n     */\r\n    function getNextPrevFile(inc) {\r\n        DeprecationWarning.deprecationWarning("Use MainViewManager.traverseToNextViewByMRU() instead of DocumentManager.getNextPrevFile()", true);\r\n        var result = MainViewManager.traverseToNextViewByMRU(inc);\r\n        if (result) {\r\n            return result.file;\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Cleans up any loose Documents whose only ref is its own master Editor, and that Editor is not\r\n     * rooted in the UI anywhere. This can happen if the Editor is auto-created via Document APIs that\r\n     * trigger _ensureMasterEditor() without making it dirty. E.g. a command invoked on the focused\r\n     * inline editor makes no-op edits or does a read-only operation.\r\n     */\r\n    function _gcDocuments() {\r\n        getAllOpenDocuments().forEach(function (doc) {\r\n            // Is the only ref to this document its own master Editor?\r\n            if (doc._refCount === 1 && doc._masterEditor) {\r\n                // Destroy the Editor if it\'s not being kept alive by the UI\r\n                MainViewManager._destroyEditorIfNotNeeded(doc);\r\n            }\r\n        });\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Gets an existing open Document for the given file, or creates a new one if the Document is\r\n     * not currently open (\'open\' means referenced by the UI somewhere). Always use this method to\r\n     * get Documents; do not call the Document constructor directly. This method is safe to call\r\n     * in parallel.\r\n     *\r\n     * If you are going to hang onto the Document for more than just the duration of a command - e.g.\r\n     * if you are going to display its contents in a piece of UI - then you must addRef() the Document\r\n     * and listen for changes on it. (Note: opening the Document in an Editor automatically manages\r\n     * refs and listeners for that Editor UI).\r\n     * \r\n     * If all you need is the Document\'s getText() value, use the faster getDocumentText() instead.\r\n     *\r\n     * @param {!string} fullPath\r\n     * @return {$.Promise} A promise object that will be resolved with the Document, or rejected\r\n     *      with a FileSystemError if the file is not yet open and can\'t be read from disk.\r\n     */\r\n    function getDocumentForPath(fullPath) {\r\n        var doc = getOpenDocumentForPath(fullPath);\r\n\r\n        if (doc) {\r\n            // use existing document\r\n            return new $.Deferred().resolve(doc).promise();\r\n        } else {\r\n            \r\n            // Should never get here if the fullPath refers to an Untitled document\r\n            if (fullPath.indexOf(_untitledDocumentPath) === 0) {\r\n                console.error("getDocumentForPath called for non-open untitled document: " + fullPath);\r\n                return new $.Deferred().reject().promise();\r\n            }\r\n            \r\n            var file            = FileSystem.getFileForPath(fullPath),\r\n                pendingPromise  = getDocumentForPath._pendingDocumentPromises[file.id];\r\n            \r\n            if (pendingPromise) {\r\n                // wait for the result of a previous request\r\n                return pendingPromise;\r\n            } else {\r\n                var result = new $.Deferred(),\r\n                    promise = result.promise();\r\n                \r\n                // log this document\'s Promise as pending\r\n                getDocumentForPath._pendingDocumentPromises[file.id] = promise;\r\n    \r\n                // create a new document\r\n                var perfTimerName = PerfUtils.markStart("getDocumentForPath:\\t" + fullPath);\r\n    \r\n                result.done(function () {\r\n                    PerfUtils.addMeasurement(perfTimerName);\r\n                }).fail(function () {\r\n                    PerfUtils.finalizeMeasurement(perfTimerName);\r\n                });\r\n    \r\n                FileUtils.readAsText(file)\r\n                    .always(function () {\r\n                        // document is no longer pending\r\n                        delete getDocumentForPath._pendingDocumentPromises[file.id];\r\n                    })\r\n                    .done(function (rawText, readTimestamp) {\r\n                        doc = new DocumentModule.Document(file, readTimestamp, rawText);\r\n                                \r\n                        // This is a good point to clean up any old dangling Documents\r\n                        _gcDocuments();\r\n                        \r\n                        result.resolve(doc);\r\n                    })\r\n                    .fail(function (fileError) {\r\n                        result.reject(fileError);\r\n                    });\r\n                \r\n                return promise;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Document promises that are waiting to be resolved. It is possible for multiple clients\r\n     * to request the same document simultaneously before the initial request has completed.\r\n     * In particular, this happens at app startup where the working set is created and the\r\n     * intial active document is opened in an editor. This is essential to ensure that only\r\n     * one Document exists for any File.\r\n     * @private\r\n     * @type {Object.<string, $.Promise>}\r\n     */\r\n    getDocumentForPath._pendingDocumentPromises = {};\r\n    \r\n    /**\r\n     * Gets the text of a Document (including any unsaved changes), or would-be Document if the\r\n     * file is not actually open. More efficient than getDocumentForPath(). Use when you\'re reading\r\n     * document(s) but don\'t need to hang onto a Document object.\r\n     * \r\n     * If the file is open this is equivalent to calling getOpenDocumentForPath().getText(). If the\r\n     * file is NOT open, this is like calling getDocumentForPath()...getText() but more efficient.\r\n     * Differs from plain FileUtils.readAsText() in two ways: (a) line endings are still normalized\r\n     * as in Document.getText(); (b) unsaved changes are returned if there are any.\r\n     * \r\n     * @param {!File} file The file to get the text for.\r\n     * @param {boolean=} checkLineEndings Whether to return line ending information. Default false (slightly more efficient).\r\n     * @return {$.Promise} \r\n     *     A promise that is resolved with three parameters:\r\n     *          contents - string: the document\'s text\r\n     *          timestamp - Date: the last time the document was changed on disk (might not be the same as the last time it was changed in memory)\r\n     *          lineEndings - string: the original line endings of the file, one of the FileUtils.LINE_ENDINGS_* constants;\r\n     *              will be null if checkLineEndings was false.\r\n     *     or rejected with a filesystem error.\r\n     */\r\n    function getDocumentText(file, checkLineEndings) {\r\n        var result = new $.Deferred(),\r\n            doc = getOpenDocumentForPath(file.fullPath);\r\n        if (doc) {\r\n            result.resolve(doc.getText(), doc.diskTimestamp, checkLineEndings ? doc._lineEndings : null);\r\n        } else {\r\n            file.read(function (err, contents, stat) {\r\n                if (err) {\r\n                    result.reject(err);\r\n                } else {\r\n                    // Normalize line endings the same way Document would, but don\'t actually\r\n                    // new up a Document (which entails a bunch of object churn).\r\n                    var originalLineEndings = checkLineEndings ? FileUtils.sniffLineEndings(contents) : null;\r\n                    contents = DocumentModule.Document.normalizeText(contents);\r\n                    result.resolve(contents, stat.mtime, originalLineEndings);\r\n                }\r\n            });\r\n        }\r\n        return result.promise();\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Creates an untitled document. The associated File has a fullPath that\r\n     * looks like /some-random-string/Untitled-counter.fileExt.\r\n     *\r\n     * @param {number} counter - used in the name of the new Document\'s File\r\n     * @param {string} fileExt - file extension of the new Document\'s File, including "."\r\n     * @return {Document} - a new untitled Document\r\n     */\r\n    function createUntitledDocument(counter, fileExt) {\r\n        var filename = Strings.UNTITLED + "-" + counter + fileExt,\r\n            fullPath = _untitledDocumentPath + "/" + filename,\r\n            now = new Date(),\r\n            file = new InMemoryFile(fullPath, FileSystem);\r\n        \r\n        return new DocumentModule.Document(file, now, "");\r\n    }\r\n    \r\n    /**\r\n     * Reacts to a file being deleted: if there is a Document for this file, causes it to dispatch a\r\n     * "deleted" event; ensures it\'s not the currentDocument; and removes this file from the working\r\n     * set. These actions in turn cause all open editors for this file to close. Discards any unsaved\r\n     * changes - it is expected that the UI has already confirmed with the user before calling.\r\n     *\r\n     * To simply close a main editor when the file hasn\'t been deleted, use closeFullEditor() or FILE_CLOSE.\r\n     *\r\n     * FUTURE: Instead of an explicit notify, we should eventually listen for deletion events on some\r\n     * sort of "project file model," making this just a private event handler.\r\n     *\r\n     * @param {!File} file\r\n     * @param {boolean} skipAutoSelect - if true, don\'t automatically open/select the next document\r\n     */\r\n    function notifyFileDeleted(file, skipAutoSelect) {\r\n        // Notify all editors to close as well\r\n        $(exports).triggerHandler("pathDeleted", file.fullPath);\r\n\r\n        var doc = getOpenDocumentForPath(file.fullPath);\r\n        if (doc) {\r\n            $(doc).triggerHandler("deleted");\r\n        }\r\n        \r\n        // At this point, all those other views SHOULD have released the Doc\r\n        if (doc && doc._refCount > 0) {\r\n            console.warn("Deleted " + file.fullPath + " Document still has " + doc._refCount + " references. Did someone addRef() without listening for \'deleted\'?");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Called after a file or folder has been deleted. This function is responsible\r\n     * for updating underlying model data and notifying all views of the change.\r\n     *\r\n     * @param {string} path The path of the file/folder that has been deleted\r\n     */\r\n    function notifyPathDeleted(path) {\r\n        /* FileSyncManager.syncOpenDocuments() does all the work of closing files\r\n           in the working set and notifying the user of any unsaved changes. */\r\n        FileSyncManager.syncOpenDocuments(Strings.FILE_DELETED_TITLE);\r\n        // Send a "pathDeleted" event. This will trigger the views to update.\r\n        $(exports).triggerHandler("pathDeleted", path);\r\n    }\r\n\r\n    /**\r\n     * Called after a file or folder name has changed. This function is responsible\r\n     * for updating underlying model data and notifying all views of the change.\r\n     *\r\n     * @param {string} oldName The old name of the file/folder\r\n     * @param {string} newName The new name of the file/folder\r\n     * @param {boolean} isFolder True if path is a folder; False if it is a file.\r\n     */\r\n    function notifyPathNameChanged(oldName, newName, isFolder) {\r\n        // Notify all open documents \r\n        _.forEach(_openDocuments, function (doc, id) {\r\n            // TODO: Only notify affected documents? For now _notifyFilePathChange \r\n            // just updates the language if the extension changed, so it\'s fine\r\n            // to call for all open docs.\r\n            doc._notifyFilePathChanged();\r\n        });\r\n        \r\n        // Send a "fileNameChanged" event. This will trigger the views to update.\r\n        $(exports).triggerHandler("fileNameChange", [oldName, newName]);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @private\r\n     * Update document\r\n     */\r\n    function _handleLanguageAdded(event, language) {\r\n        _.forEach(_openDocuments, function (doc, key) {\r\n            // No need to look at the new language if this document has one already\r\n            if (doc.getLanguage().isFallbackLanguage()) {\r\n                doc._updateLanguage();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Update document\r\n     */\r\n    function _handleLanguageModified(event, language) {\r\n        _.forEach(_openDocuments, function (doc, key) {\r\n            var docLanguage = doc.getLanguage();\r\n            // A modified language can affect a document\r\n            // - if its language was modified\r\n            // - if the document doesn\'t have a language yet and its file extension was added to the modified language\r\n            if (docLanguage === language || docLanguage.isFallbackLanguage()) {\r\n                doc._updateLanguage();\r\n            }\r\n        });\r\n    }\r\n    \r\n    // For compatibility\r\n    $(DocumentModule)\r\n        .on("_afterDocumentCreate", function (event, doc) {\r\n            if (_openDocuments[doc.file.id]) {\r\n                console.error("Document for this path already in _openDocuments!");\r\n                return true;\r\n            }\r\n\r\n            _openDocuments[doc.file.id] = doc;\r\n            $(exports).triggerHandler("afterDocumentCreate", doc);\r\n        })\r\n        .on("_beforeDocumentDelete", function (event, doc) {\r\n            if (!_openDocuments[doc.file.id]) {\r\n                console.error("Document with references was not in _openDocuments!");\r\n                return true;\r\n            }\r\n\r\n            $(exports).triggerHandler("beforeDocumentDelete", doc);\r\n            delete _openDocuments[doc.file.id];\r\n        })\r\n        .on("_documentRefreshed", function (event, doc) {\r\n            $(exports).triggerHandler("documentRefreshed", doc);\r\n        })\r\n        .on("_dirtyFlagChange", function (event, doc) {\r\n            $(exports).triggerHandler("dirtyFlagChange", doc);\r\n            if (doc.isDirty) {\r\n                MainViewManager.addToWorkingSet(MainViewManager.ACTIVE_PANE, doc.file);\r\n            }\r\n        })\r\n        .on("_documentSaved", function (event, doc) {\r\n            $(exports).triggerHandler("documentSaved", doc);\r\n        });\r\n    \r\n    /**\r\n     * @private\r\n     * Examine each preference key for migration of the working set files.\r\n     * If the key has a prefix of "files_/", then it is a working set files \r\n     * preference from old preference model.\r\n     *\r\n     * @param {string} key The key of the preference to be examined\r\n     *      for migration of working set files.\r\n     * @return {?string} - the scope to which the preference is to be migrated\r\n     */\r\n    function _checkPreferencePrefix(key) {\r\n        var pathPrefix = "files_";\r\n        if (key.indexOf(pathPrefix) === 0) {\r\n            // Get the project path from the old preference key by stripping "files_".\r\n            var projectPath = key.substr(pathPrefix.length);\r\n            return "user project.files " + projectPath;\r\n        }\r\n        \r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Creates a deprecation warning event handler\r\n     * @param {!string} eventName - the event being deprecated. \r\n     *  The Event Name doesn\'t change just which object dispatches it\r\n     */\r\n    function _deprecateEvent(eventName) {\r\n        DeprecationWarning.deprecateEvent(exports,\r\n                                          MainViewManager,\r\n                                          eventName,\r\n                                          eventName,\r\n                                          "DocumentManager." + eventName,\r\n                                          "MainViewManager." + eventName);\r\n    }\r\n    \r\n    /* \r\n     * Setup an extensionsLoaded handler to register deprecated events.  \r\n     * We do this so these events are added to the end of the event\r\n     * handler chain which gives the system a chance to process them\r\n     * before they are dispatched to extensions.  \r\n     * \r\n     * Extensions that listen to the new MainViewManager working set events \r\n     * are always added to the end so this effectively puts the legacy events \r\n     * at the end of the event list. This prevents extensions from \r\n     * handling the event too soon. (e.g.  workingSetListView needs to \r\n     * process these events before the Extension Highlighter extension)\r\n     */\r\n    AppInit.extensionsLoaded(function () {\r\n        _deprecateEvent("workingSetAdd");\r\n        _deprecateEvent("workingSetAddList");\r\n        _deprecateEvent("workingSetRemove");\r\n        _deprecateEvent("workingSetRemoveList");\r\n        _deprecateEvent("workingSetSort");\r\n    });\r\n    \r\n    PreferencesManager.convertPreferences(module, {"files_": "user"}, true, _checkPreferencePrefix);\r\n\r\n    // Handle file saves that may affect preferences\r\n    $(exports).on("documentSaved", function (e, doc) {\r\n        PreferencesManager.fileChanged(doc.file.fullPath);\r\n    });\r\n    \r\n    $(MainViewManager).on("currentFileChange", function (e, newFile, newPaneId, oldFile, oldPaneId) {\r\n        var newDoc = null,\r\n            oldDoc = null;\r\n\r\n        if (newFile) {\r\n            newDoc = getOpenDocumentForPath(newFile.fullPath);\r\n        }\r\n        \r\n        if (oldFile) {\r\n            oldDoc = getOpenDocumentForPath(oldFile.fullPath);\r\n        }\r\n        \r\n        if (oldDoc) {\r\n            $(oldDoc).off("languageChanged.DocumentManager");\r\n        }\r\n        \r\n        var count = DeprecationWarning.getEventHandlerCount(exports, "currentDocumentChange");\r\n        if (count > 0) {\r\n            DeprecationWarning.deprecationWarning("The Event \'DocumentManager.currentDocumentChange\' has been deprecated.  Please use \'MainViewManager.currentFileChange\' instead.", true);\r\n        }\r\n        \r\n        $(exports).triggerHandler("currentDocumentChange", [newDoc, oldDoc]);\r\n\r\n        if (newDoc) {\r\n            $(newDoc).on("languageChanged.DocumentManager", function (data) {\r\n                $(exports).trigger("currentDocumentLanguageChanged", data);\r\n            });\r\n        }\r\n    \r\n    });\r\n    \r\n    // Deprecated APIs   \r\n    exports.getWorkingSet                  = getWorkingSet;\r\n    exports.findInWorkingSet               = findInWorkingSet;\r\n    exports.addToWorkingSet                = addToWorkingSet;\r\n    exports.addListToWorkingSet            = addListToWorkingSet;\r\n    exports.removeListFromWorkingSet       = removeListFromWorkingSet;\r\n    exports.getCurrentDocument             = getCurrentDocument;\r\n    exports.beginDocumentNavigation        = beginDocumentNavigation;\r\n    exports.finalizeDocumentNavigation     = finalizeDocumentNavigation;\r\n    exports.getNextPrevFile                = getNextPrevFile;\r\n    exports.setCurrentDocument             = setCurrentDocument;\r\n    exports.closeFullEditor                = closeFullEditor;\r\n    exports.closeAll                       = closeAll;\r\n    \r\n    // Define public API\r\n    exports.Document                    = DocumentModule.Document;\r\n    exports.getDocumentForPath          = getDocumentForPath;\r\n    exports.getOpenDocumentForPath      = getOpenDocumentForPath;\r\n    exports.getDocumentText             = getDocumentText;\r\n    exports.createUntitledDocument      = createUntitledDocument;\r\n    exports.getAllOpenDocuments         = getAllOpenDocuments;\r\n    exports.notifyFileDeleted           = notifyFileDeleted;\r\n    exports.notifyPathNameChanged       = notifyPathNameChanged;\r\n    exports.notifyPathDeleted           = notifyPathDeleted;\r\n\r\n    // Performance measurements\r\n    PerfUtils.createPerfMeasurement("DOCUMENT_MANAGER_GET_DOCUMENT_FOR_PATH", "DocumentManager.getDocumentForPath()");\r\n\r\n    // Handle Language change events\r\n    $(LanguageManager).on("languageAdded", _handleLanguageAdded);\r\n    $(LanguageManager).on("languageModified", _handleLanguageModified);\r\n});\r\n\n//# sourceURL=/document/DocumentManager.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n/**\r\n * Responsible for coordinating file selection between views by permitting only one view\r\n * to show the current file selection at a time. Currently, only WorkingSetView and \r\n * ProjectManager can show file selection. In general the WorkingSetView takes higher\r\n * priority until the user selects a file in the ProjectManager.\r\n *\r\n * Events dispatched:\r\n * - documentSelectionFocusChange - indicates a document change has caused the focus to \r\n *   change between the working set and file tree.\r\n *\r\n * - fileViewFocusChange - indicates the selection focus has changed between the working\r\n *   set and the project tree, but the document selection has NOT changed\r\n *\r\n * Current file selection rules in views:\r\n * - select a file in WorkingSetView > select in WorkingSetView\r\n * - add a file to the WorkingSetView > select in WorkingSetView\r\n * - select a file in ProjectManager > select in ProjectManager\r\n * - open a file from places other than the WorkingSetView or ProjectManager > \r\n *       select file in WorkignSetView if its in the working set, otherwise select in ProjectManager\r\n */\r\n\r\ndefine(\'project/FileViewController\',[\'require\',\'exports\',\'module\',\'document/DocumentManager\',\'view/MainViewManager\',\'command/CommandManager\',\'editor/EditorManager\',\'utils/PerfUtils\',\'command/Commands\',\'utils/DeprecationWarning\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    // Load dependent modules\r\n    var DocumentManager     = require("document/DocumentManager"),\r\n        MainViewManager     = require("view/MainViewManager"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        PerfUtils           = require("utils/PerfUtils"),\r\n        Commands            = require("command/Commands"),\r\n        DeprecationWarning  = require("utils/DeprecationWarning");\r\n\r\n    /** \r\n     * Tracks whether a "currentFileChange" notification occured due to a call to \r\n     * openAndSelectDocument.\r\n     * @see FileviewController.openAndSelectDocument\r\n     * @private \r\n     */\r\n    var _curDocChangedDueToMe = false;\r\n    var WORKING_SET_VIEW = "WorkingSetView";\r\n    var PROJECT_MANAGER = "ProjectManager";\r\n\r\n    /**\r\n     * @private\r\n     * @see FileViewController.getFileSelectionFocus()\r\n     */\r\n    var _fileSelectionFocus = PROJECT_MANAGER;\r\n    \r\n    /** \r\n     * Change the doc selection to the working set when ever a new file is added to the working set\r\n     */\r\n    $(MainViewManager).on("workingSetAdd", function (event, addedFile) {\r\n        _fileSelectionFocus = WORKING_SET_VIEW;\r\n        $(exports).triggerHandler("documentSelectionFocusChange");\r\n    });\r\n\r\n    /** \r\n      * Update the file selection focus whenever the contents of the editor area change\r\n      */\r\n    $(MainViewManager).on("currentFileChange", function (event, file, paneId) {\r\n        var perfTimerName;\r\n        if (!_curDocChangedDueToMe) {\r\n            // The the cause of the doc change was not openAndSelectDocument, so pick the best fileSelectionFocus\r\n            perfTimerName = PerfUtils.markStart("FileViewController._oncurrentFileChange():\\t" + (file ? (file.fullPath) : "(no open file)"));\r\n            if (file && MainViewManager.findInWorkingSet(paneId,  file.fullPath) !== -1) {\r\n                _fileSelectionFocus = WORKING_SET_VIEW;\r\n            } else {\r\n                _fileSelectionFocus = PROJECT_MANAGER;\r\n            }\r\n        }\r\n\r\n        $(exports).triggerHandler("documentSelectionFocusChange");\r\n\r\n        if (!_curDocChangedDueToMe) {\r\n            PerfUtils.addMeasurement(perfTimerName);\r\n        }\r\n    });\r\n    \r\n    /** \r\n     * @private\r\n     * @param {string=} paneId - the Pane to activate\r\n     */\r\n    function _activatePane(paneId) {\r\n        if (paneId) {\r\n            MainViewManager.setActivePaneId(paneId);\r\n        } else {\r\n            MainViewManager.focusActivePane();\r\n        }\r\n        // If fullPath corresonds to the current doc being viewed then opening the file won\'t\r\n        // trigger a currentFileChange event, so we need to trigger a documentSelectionFocusChange \r\n        // in this case to signify the selection focus has changed even though the current document has not.\r\n        $(exports).triggerHandler("documentSelectionFocusChange");\r\n    }\r\n\r\n    /**\r\n     * Modifies the selection focus in the project side bar. A file can either be selected\r\n     * in the working set (the open files) or in the file tree, but not both.\r\n     * @param {String} fileSelectionFocus - either PROJECT_MANAGER or WORKING_SET_VIEW\r\n     */\r\n    function setFileViewFocus(fileSelectionFocus) {\r\n        if (fileSelectionFocus !== PROJECT_MANAGER && fileSelectionFocus !== WORKING_SET_VIEW) {\r\n            console.error("Bad parameter passed to FileViewController.setFileViewFocus");\r\n            return;\r\n        }\r\n\r\n        _fileSelectionFocus = fileSelectionFocus;\r\n        $(exports).triggerHandler("fileViewFocusChange");\r\n    }\r\n\r\n    /** \r\n     * Opens a document if it\'s not open and selects the file in the UI corresponding to\r\n     * fileSelectionFocus\r\n     * @param {!fullPath} fullPath - full path of the document to open\r\n     * @param {string} fileSelectionFocus - (WORKING_SET_VIEW || PROJECT_MANAGER)\r\n     * @param {string} paneId - pane in which to open the document\r\n     * @return {$.Promise}\r\n     */\r\n    function openAndSelectDocument(fullPath, fileSelectionFocus, paneId) {\r\n        var result;\r\n\r\n        if (fileSelectionFocus !== PROJECT_MANAGER && fileSelectionFocus !== WORKING_SET_VIEW) {\r\n            console.error("Bad parameter passed to FileViewController.openAndSelectDocument");\r\n            return;\r\n        }\r\n\r\n        // Opening files are asynchronous and we want to know when this function caused a file\r\n        // to open so that _fileSelectionFocus is set appropriatly. _curDocChangedDueToMe is set here\r\n        // and checked in the currentFileChange handler\r\n        _curDocChangedDueToMe = true;\r\n\r\n        _fileSelectionFocus = fileSelectionFocus;\r\n\r\n        paneId = (paneId || MainViewManager.ACTIVE_PANE);\r\n        \r\n        // If fullPath corresonds to the current doc being viewed then opening the file won\'t\r\n        // trigger a currentFileChange event, so we need to trigger a documentSelectionFocusChange \r\n        // in this case to signify the selection focus has changed even though the current document has not.\r\n        var currentPath = MainViewManager.getCurrentlyViewedPath(paneId);\r\n        if (currentPath === fullPath) {\r\n            _activatePane(paneId);\r\n            result = (new $.Deferred()).resolve().promise();\r\n        } else {\r\n            result = CommandManager.execute(Commands.FILE_OPEN, {fullPath: fullPath,\r\n                                                                 paneId: paneId});\r\n        }\r\n        \r\n        // clear after notification is done\r\n        result.always(function () {\r\n            _curDocChangedDueToMe = false;\r\n        });\r\n        \r\n        return result;\r\n    }\r\n\r\n    /** \r\n     * Opens the specified document if it\'s not already open, adds it to the working set,\r\n     * and selects it in the WorkingSetView\r\n     * @param {!fullPath}\r\n     * @param {string=} paneId - Pane in which to add the view.  If omitted, the command default is to use the ACTIVE_PANE \r\n     * @return {!$.Promise}\r\n     */\r\n    function openFileAndAddToWorkingSet(fullPath, paneId) {\r\n        var result = new $.Deferred(),\r\n            promise = CommandManager.execute(Commands.CMD_ADD_TO_WORKINGSET_AND_OPEN, {fullPath: fullPath,\r\n                                                                                  paneId: paneId});\r\n\r\n        // This properly handles sending the right nofications in cases where the document\r\n        // is already the current one. In that case we will want to notify with\r\n        // documentSelectionFocusChange so the views change their selection\r\n        promise.done(function (file) {\r\n            // CMD_ADD_TO_WORKINGSET_AND_OPEN command sets the current document. Update the \r\n            // selection focus only if doc is not null. When double-clicking on an\r\n            // image file, we get a null doc here but we still want to keep _fileSelectionFocus\r\n            // as PROJECT_MANAGER. Regardless of doc is null or not, call _activatePane\r\n            // to trigger documentSelectionFocusChange event.\r\n            result.resolve(file);\r\n        }).fail(function (err) {\r\n            result.reject(err);\r\n        });\r\n\r\n        return result.promise();\r\n    }\r\n    \r\n    /** \r\n     * Opens the specified document if it\'s not already open, adds it to the working set,\r\n     * and selects it in the WorkingSetView\r\n     * @deprecated use FileViewController.openFileAndAddToWorkingSet() instead\r\n     * @param {!fullPath}\r\n     * @return {!$.Promise}\r\n     */\r\n    function addToWorkingSetAndSelect(fullPath) {\r\n        DeprecationWarning.deprecationWarning("Use FileViewController.openFileAndAddToWorkingSet() instead of FileViewController.addToWorkingSetAndSelect().", true);\r\n        var result = new $.Deferred();\r\n        openFileAndAddToWorkingSet(fullPath)\r\n            .done(function (file) {\r\n                var doc;\r\n                \r\n                if (file) {\r\n                    doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\r\n                }\r\n                \r\n                result.resolve(doc);\r\n            })\r\n            .fail(function (err) {\r\n                result.reject(err);\r\n            });\r\n        return result.promise();\r\n    }\r\n    \r\n    \r\n\r\n    /**\r\n     * returns either WORKING_SET_VIEW or PROJECT_MANAGER\r\n     * @return {!String}\r\n     */\r\n    function getFileSelectionFocus() {\r\n        return _fileSelectionFocus;\r\n    }\r\n\r\n\r\n    // Deprecated\r\n    exports.addToWorkingSetAndSelect = addToWorkingSetAndSelect;\r\n\r\n\r\n    // Define public API\r\n    exports.getFileSelectionFocus = getFileSelectionFocus;\r\n    exports.openAndSelectDocument = openAndSelectDocument;\r\n    exports.openFileAndAddToWorkingSet = openFileAndAddToWorkingSet;\r\n    exports.setFileViewFocus = setFileViewFocus;\r\n    exports.WORKING_SET_VIEW = WORKING_SET_VIEW;\r\n    exports.PROJECT_MANAGER = PROJECT_MANAGER;\r\n});\r\n\n//# sourceURL=/project/FileViewController.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets, FileError, window */\r\n\r\n/**\r\n * ProjectManager is the model for the set of currently open project. It is responsible for\r\n * creating and updating the project tree when projects are opened and when changes occur to\r\n * the file tree.\r\n *\r\n * This module dispatches these events:\r\n *    - beforeProjectClose -- before `_projectRoot` changes, but working set files still open\r\n *    - projectClose       -- *just* before `_projectRoot` changes; working set already cleared\r\n *      & project root unwatched\r\n *    - beforeAppClose     -- before Brackets quits entirely\r\n *    - projectOpen        -- after `_projectRoot` changes and the tree is re-rendered\r\n *    - projectRefresh     -- when project tree is re-rendered for a reason other than\r\n *      a project being opened (e.g. from the Refresh command)\r\n *\r\n * These are jQuery events, so to listen for them you do something like this:\r\n *    $(ProjectManager).on("eventname", handler);\r\n */\r\ndefine(\'project/ProjectManager\',[\'require\',\'exports\',\'module\',\'utils/Global\',\'thirdparty/jstree_pre1.0_fix_1/jquery.jstree\',\'thirdparty/lodash\',\'utils/AppInit\',\'preferences/PreferencesDialogs\',\'preferences/PreferencesManager\',\'document/DocumentManager\',\'view/MainViewManager\',\'document/InMemoryFile\',\'command/CommandManager\',\'command/Commands\',\'widgets/Dialogs\',\'widgets/DefaultDialogs\',\'utils/DeprecationWarning\',\'language/LanguageManager\',\'command/Menus\',\'utils/StringUtils\',\'strings\',\'filesystem/FileSystem\',\'project/FileViewController\',\'utils/PerfUtils\',\'utils/ViewUtils\',\'file/FileUtils\',\'filesystem/FileSystemError\',\'i18n!nls/urls\',\'utils/KeyEvent\',\'utils/Async\',\'project/FileSyncManager\',\'editor/EditorManager\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    require("utils/Global");\r\n    \r\n    // Load dependent non-module scripts\r\n    require("thirdparty/jstree_pre1.0_fix_1/jquery.jstree");\r\n\r\n    var _ = require("thirdparty/lodash");\r\n\r\n    // Load dependent modules\r\n    var AppInit             = require("utils/AppInit"),\r\n        PreferencesDialogs  = require("preferences/PreferencesDialogs"),\r\n        PreferencesManager  = require("preferences/PreferencesManager"),\r\n        DocumentManager     = require("document/DocumentManager"),\r\n        MainViewManager     = require("view/MainViewManager"),\r\n        InMemoryFile        = require("document/InMemoryFile"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        Commands            = require("command/Commands"),\r\n        Dialogs             = require("widgets/Dialogs"),\r\n        DefaultDialogs      = require("widgets/DefaultDialogs"),\r\n        DeprecationWarning  = require("utils/DeprecationWarning"),\r\n        LanguageManager     = require("language/LanguageManager"),\r\n        Menus               = require("command/Menus"),\r\n        StringUtils         = require("utils/StringUtils"),\r\n        Strings             = require("strings"),\r\n        FileSystem          = require("filesystem/FileSystem"),\r\n        FileViewController  = require("project/FileViewController"),\r\n        PerfUtils           = require("utils/PerfUtils"),\r\n        ViewUtils           = require("utils/ViewUtils"),\r\n        FileUtils           = require("file/FileUtils"),\r\n        FileSystemError     = require("filesystem/FileSystemError"),\r\n        Urls                = require("i18n!nls/urls"),\r\n        KeyEvent            = require("utils/KeyEvent"),\r\n        Async               = require("utils/Async"),\r\n        FileSyncManager     = require("project/FileSyncManager"),\r\n        EditorManager       = require("editor/EditorManager");\r\n    \r\n    \r\n    // Define the preference to decide how to sort the Project Tree files\r\n    PreferencesManager.definePreference("sortDirectoriesFirst", "boolean", brackets.platform !== "mac");\r\n    \r\n    \r\n    /**\r\n     * @private\r\n     * Forward declaration for the _fileSystemChange and _fileSystemRename functions to make JSLint happy.\r\n     */\r\n    var _fileSystemChange,\r\n        _fileSystemRename;\r\n\r\n    /**\r\n     * @private\r\n     * File tree sorting for mac-specific sorting behavior\r\n     */\r\n    var _sortPrefixDir,\r\n        _sortPrefixFile;\r\n    \r\n    /**\r\n     * @private\r\n     * File and folder names which are not displayed or searched\r\n     * TODO: We should add the rest of the file names that TAR excludes:\r\n     *    http://www.gnu.org/software/tar/manual/html_section/exclude.html\r\n     * TODO: This should be user configurable\r\n     *    https://github.com/adobe/brackets/issues/6781\r\n     * @type {RegExp}\r\n     */\r\n    var _exclusionListRegEx = /\\.pyc$|^\\.git$|^\\.gitmodules$|^\\.svn$|^\\.DS_Store$|^Thumbs\\.db$|^\\.hg$|^CVS$|^\\.hgtags$|^\\.idea$|^\\.c9revisions$|^\\.sass-cache$|^\\.SyncArchive$|^\\.SyncID$|^\\.SyncIgnore$|\\~$/;\r\n\r\n    /**\r\n     * @private\r\n     * Filename to use for project settings files.\r\n     * @type {string}\r\n     */\r\n    var SETTINGS_FILENAME = "." + PreferencesManager.SETTINGS_FILENAME;\r\n\r\n    /**\r\n     * @const\r\n     * @private\r\n     * Error context to show the correct error message\r\n     * @type {int}\r\n     */\r\n    var ERR_TYPE_CREATE = 1,\r\n        ERR_TYPE_CREATE_EXISTS = 2,\r\n        ERR_TYPE_RENAME = 3,\r\n        ERR_TYPE_DELETE = 4,\r\n        ERR_TYPE_LOADING_PROJECT = 5,\r\n        ERR_TYPE_LOADING_PROJECT_NATIVE = 6,\r\n        ERR_TYPE_MAX_FILES = 7,\r\n        ERR_TYPE_OPEN_DIALOG = 8,\r\n        ERR_TYPE_INVALID_FILENAME = 9;\r\n\r\n    /**\r\n     * @private\r\n     * Reference to the tree control container div. Initialized by\r\n     * htmlReady handler\r\n     * @type {jQueryObject}\r\n     */\r\n    var $projectTreeContainer;\r\n    \r\n    /**\r\n     * @private\r\n     * Reference to the tree control\r\n     * @type {jQueryObject}\r\n     */\r\n    var _projectTree = null;\r\n        \r\n    /**\r\n     * @private\r\n     * Reference to previous selected jstree leaf node when ProjectManager had\r\n     * selection focus from FileViewController.\r\n     * @type {DOMElement}\r\n     */\r\n    var _lastSelected = null;\r\n    \r\n    /**\r\n     * @private\r\n     * Internal flag to suppress firing of selectionChanged event.\r\n     * @type {boolean}\r\n     */\r\n    var _suppressSelectionChange = false;\r\n    \r\n    /**\r\n     * @private\r\n     * Reference to the tree control UL element\r\n     * @type {DOMElement}\r\n     */\r\n    var $projectTreeList;\r\n    \r\n    /**\r\n     * @private\r\n     * @see getProjectRoot()\r\n     * @type {Directory}\r\n     */\r\n    var _projectRoot = null;\r\n\r\n    /**\r\n     * @private\r\n     * Encoded URL\r\n     * @see getBaseUrl(), setBaseUrl()\r\n     */\r\n    var _projectBaseUrl = "";\r\n    \r\n    /**\r\n     * @private\r\n     * Used to initialize jstree state\r\n     */\r\n    var _projectInitialLoad = null;\r\n    \r\n    /**\r\n     * @private\r\n     * A string containing all invalid characters for a specific platform.\r\n     * This will be used to construct a regular expression for checking invalid filenames.\r\n     * When a filename with one of these invalid characters are detected, then it is \r\n     * also used to substitute the place holder of the error message.\r\n     */\r\n    var _invalidChars;\r\n\r\n    /**\r\n     * @private\r\n     * RegEx to validate if a filename is not allowed even if the system allows it.\r\n     * This is done to prevent cross-platform issues.\r\n     */\r\n            \r\n    var _illegalFilenamesRegEx = /^(\\.+|com[1-9]|lpt[1-9]|nul|con|prn|aux|)$|\\.+$/i;\r\n    \r\n    var suppressToggleOpen = false;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {?jQuery.Promise.<Array<File>>}\r\n     * A promise that is resolved with an array of all project files. Used by \r\n     * ProjectManager.getAllFiles().\r\n     */\r\n    var _allFilesCachePromise = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     * A flag to remember when user has been warned about too many files, so they\r\n     * are only warned once per project/session.\r\n     */\r\n    var _projectWarnedForTooManyFiles = false;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     * Current sort order for the tree, true if directories are first. This is\r\n     * initialized in _generateSortPrefixes.\r\n     */\r\n    var _dirFirst;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {Number}\r\n     * Tracks the timeoutID for mouseup events.\r\n     */\r\n    var _mouseupTimeoutId = null;\r\n    \r\n    /**\r\n     * @private\r\n     * Generates the prefixes used for sorting the files in the project tree\r\n     * @return {boolean} true if the sort prefixes have changed\r\n     */\r\n    function _generateSortPrefixes() {\r\n        var previousDirFirst  = _dirFirst;\r\n        _dirFirst             = PreferencesManager.get("sortDirectoriesFirst");\r\n        _sortPrefixDir        = _dirFirst ? "a" : "";\r\n        _sortPrefixFile       = _dirFirst ? "b" : "";\r\n        \r\n        return previousDirFirst !== _dirFirst;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     */\r\n    function _hasFileSelectionFocus() {\r\n        return FileViewController.getFileSelectionFocus() === FileViewController.PROJECT_MANAGER;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     */\r\n    function _redraw(selectionChanged, reveal) {\r\n        reveal = (reveal === undefined) ? true : reveal;\r\n        \r\n        // redraw selection\r\n        if ($projectTreeList) {\r\n            if (selectionChanged && !_suppressSelectionChange) {\r\n                $projectTreeList.triggerHandler("selectionChanged", reveal);\r\n            }\r\n\r\n            // reposition the selection "extension"\r\n            $projectTreeContainer.triggerHandler("selectionRedraw");\r\n            \r\n            // in-lieu of resize events, manually trigger contentChanged for every\r\n            // FileViewController focus change. This event triggers scroll shadows\r\n            // on the jstree to update. documentSelectionFocusChange fires when\r\n            // a new file is added and removed (causing a new selection) from the working set\r\n            _projectTree.triggerHandler("contentChanged");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Returns the File or Directory corresponding to the item selected in the file tree, or null\r\n     * if no item is selected in the tree (though the working set may still have a selection; use\r\n     * getSelectedItem() to get the selection regardless of whether it\'s in the tree or working set).\r\n     * @return {?(File|Directory)}\r\n     */\r\n    function _getTreeSelectedItem() {\r\n        var selected = _projectTree.jstree("get_selected");\r\n        if (selected) {\r\n            return selected.data("entry");\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Returns the File or Directory corresponding to the item selected in the sidebar panel, whether in\r\n     * the file tree OR in the working set; or null if no item is selected anywhere in the sidebar.\r\n     * May NOT be identical to the current Document - a folder may be selected in the sidebar, or the sidebar may not\r\n     * have the current document visible in the tree & working set.\r\n     * @return {?(File|Directory)}\r\n     */\r\n    function getSelectedItem() {\r\n        // Prefer file tree selection, else use working set selection\r\n        var selectedEntry = _getTreeSelectedItem();\r\n        if (!selectedEntry) {\r\n            selectedEntry = MainViewManager.getCurrentlyViewedFile();\r\n        }\r\n        return selectedEntry;\r\n    }\r\n\r\n    function _fileViewFocusChange() {\r\n        _redraw(true);\r\n    }\r\n    \r\n    function _documentSelectionFocusChange() {\r\n        var curFullPath = MainViewManager.getCurrentlyViewedPath(MainViewManager.ACTIVE_PANE);\r\n        if (curFullPath && _hasFileSelectionFocus()) {\r\n            var nodeFound = $("#project-files-container li").is(function (index) {\r\n                var $treeNode = $(this),\r\n                    entry = $treeNode.data("entry");\r\n                if (entry && entry.fullPath === curFullPath) {\r\n                    if (!_projectTree.jstree("is_selected", $treeNode)) {\r\n                        if ($treeNode.parents(".jstree-closed").length) {\r\n                            //don\'t auto-expand tree to show file - but remember it if parent is manually expanded later\r\n                            _projectTree.jstree("deselect_all");\r\n                            _lastSelected = $treeNode;\r\n                        } else {\r\n                            //we don\'t want to trigger another selection change event, so manually deselect\r\n                            //and select without sending out notifications\r\n                            _projectTree.jstree("deselect_all");\r\n                            _projectTree.jstree("select_node", $treeNode, false);  // sets _lastSelected\r\n                        }\r\n                    }\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n            \r\n            // file is outside project subtree, or in a folder that\'s never been expanded yet\r\n            if (!nodeFound) {\r\n                _projectTree.jstree("deselect_all");\r\n                _lastSelected = null;\r\n            }\r\n        } else if (_projectTree !== null) {\r\n            _projectTree.jstree("deselect_all");\r\n            _lastSelected = null;\r\n        }\r\n        \r\n        _redraw(true);\r\n    }\r\n\r\n    /**\r\n     * Returns the root folder of the currently loaded project, or null if no project is open (during\r\n     * startup, or running outside of app shell).\r\n     * @return {Directory}\r\n     */\r\n    function getProjectRoot() {\r\n        return _projectRoot;\r\n    }\r\n\r\n    /**\r\n     * Returns the encoded Base URL of the currently loaded project, or empty string if no project\r\n     * is open (during startup, or running outside of app shell).\r\n     * @return {String}\r\n     */\r\n    function getBaseUrl() {\r\n        return _projectBaseUrl;\r\n    }\r\n\r\n    /**\r\n     * Sets the encoded Base URL of the currently loaded project.\r\n     * @param {String}\r\n     */\r\n    function setBaseUrl(projectBaseUrl) {\r\n        var context = { location : { scope: "user",\r\n                                     layer: "project",\r\n                                     layerID: _projectRoot.fullPath} };\r\n        \r\n        _projectBaseUrl = projectBaseUrl;\r\n\r\n        // Ensure trailing slash to be consistent with _projectRoot.fullPath\r\n        // so they\'re interchangable (i.e. easy to convert back and forth)\r\n        if (_projectBaseUrl.length > 0 && _projectBaseUrl[_projectBaseUrl.length - 1] !== "/") {\r\n            _projectBaseUrl += "/";\r\n        }\r\n\r\n        PreferencesManager.setViewState("project.baseUrl", _projectBaseUrl, context);\r\n    }\r\n    \r\n    /**\r\n     * Returns true if absPath lies within the project, false otherwise.\r\n     * Does not support paths containing ".."\r\n     * @param {string|FileSystemEntry} absPathOrEntry\r\n     * @return {boolean}\r\n     */\r\n    function isWithinProject(absPathOrEntry) {\r\n        var absPath = absPathOrEntry.fullPath || absPathOrEntry;\r\n        return (_projectRoot && absPath.indexOf(_projectRoot.fullPath) === 0);\r\n    }\r\n    /**\r\n     * If absPath lies within the project, returns a project-relative path. Else returns absPath\r\n     * unmodified.\r\n     * Does not support paths containing ".."\r\n     * @param {!string} absPath\r\n     * @return {!string}\r\n     */\r\n    function makeProjectRelativeIfPossible(absPath) {\r\n        if (isWithinProject(absPath)) {\r\n            return absPath.slice(_projectRoot.fullPath.length);\r\n        }\r\n        return absPath;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Save ProjectManager project path and tree state.\r\n     */\r\n    function _savePreferences() {\r\n        \r\n        // save the current project\r\n        PreferencesManager.setViewState("projectPath", _projectRoot.fullPath);\r\n\r\n        // save jstree state\r\n        var openNodes = [],\r\n            projectPathLength = _projectRoot.fullPath.length,\r\n            entry,\r\n            fullPath,\r\n            shortPath,\r\n            depth,\r\n            context = { location : { scope: "user",\r\n                                     layer: "project",\r\n                                     layerID: _projectRoot.fullPath } };\r\n\r\n        // Query open nodes by class selector\r\n        $(".jstree-open:visible").each(function (index) {\r\n            entry = $(this).data("entry");\r\n\r\n            if (entry.fullPath) {\r\n                fullPath = entry.fullPath;\r\n\r\n                // Truncate project path prefix (including its last slash) AND remove trailing slash suffix\r\n                // So "/foo/bar/projroot/abc/xyz/" -> "abc/xyz"\r\n                shortPath = fullPath.slice(projectPathLength, -1);\r\n\r\n                // Determine depth of the node by counting path separators.\r\n                // Children at the root have depth of zero\r\n                depth = shortPath.split("/").length - 1;\r\n\r\n                // Map tree depth to list of open nodes\r\n                if (openNodes[depth] === undefined) {\r\n                    openNodes[depth] = [];\r\n                }\r\n\r\n                openNodes[depth].push(fullPath);\r\n            }\r\n        });\r\n\r\n        // Store the open nodes by their full path and persist to storage\r\n        PreferencesManager.setViewState("project.treeState", openNodes, context);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     */\r\n    function _forceSelection(current, target) {\r\n        // select_node will force the target to be revealed. Instead,\r\n        // keep the scroller position stable.\r\n        var savedScrollTop = $projectTreeContainer.get(0).scrollTop;\r\n        \r\n        // suppress selectionChanged event from firing by jstree select_node\r\n        _suppressSelectionChange = true;\r\n        if (current) {\r\n            _projectTree.jstree("deselect_node", current);\r\n        }\r\n        _projectTree.jstree("select_node", target, false);\r\n        _suppressSelectionChange = false;\r\n        \r\n        $projectTreeContainer.get(0).scrollTop = savedScrollTop;\r\n        \r\n        _redraw(true, false);\r\n    }\r\n\r\n    /**\r\n     * Returns false when the event occured without any input present in the li closest to the DOM object\r\n     *\r\n     * @param {event} event to check\r\n     * @return boolean true if an input field is present\r\n     */\r\n    function _isInRename(element) {\r\n        return ($(element).closest("li").find("input").length > 0);\r\n    }\r\n        \r\n    /**\r\n     * @private\r\n     * Reopens a set of nodes in the tree by ID.\r\n     * @param {Array.<Array.<string>>} nodesByDepth An array of arrays of node ids to reopen. The ids within\r\n     *     each sub-array are reopened in parallel, and the sub-arrays are reopened in order, so they should\r\n     *     be sorted by depth within the tree.\r\n     * @param {$.Deferred} resultDeferred A Deferred that will be resolved when all nodes have been fully\r\n     *     reopened.\r\n     */\r\n    function _reopenNodes(nodesByDepth, resultDeferred) {\r\n        if (nodesByDepth.length === 0) {\r\n            // All paths are opened and fully rendered.\r\n            resultDeferred.resolve();\r\n        } else {\r\n            var toOpenPaths = nodesByDepth.shift(),\r\n                toOpenIds   = [],\r\n                node        = null;\r\n\r\n            // use path to lookup ID\r\n            toOpenPaths.forEach(function (value, index) {\r\n                node = _projectInitialLoad.fullPathToIdMap[value];\r\n                \r\n                if (node) {\r\n                    toOpenIds.push(node);\r\n                }\r\n            });\r\n            \r\n            Async.doInParallel(\r\n                toOpenIds,\r\n                function (id) {\r\n                    var result = new $.Deferred();\r\n                    _projectTree.jstree("open_node", "#" + id, function () {\r\n                        result.resolve();\r\n                    }, true);\r\n                    return result.promise();\r\n                },\r\n                false\r\n            ).always(function () {\r\n                _reopenNodes(nodesByDepth, resultDeferred);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * A memoized comparator of DOM nodes for use with jsTree\r\n     * @private\r\n     * @param {Node} First DOM node\r\n     * @param {Node} Second DOM node\r\n     * @return {number} Comparator value\r\n     */\r\n    var _projectTreeSortComparator = _.memoize(function (a, b) {\r\n        var a1 = $(a).data("compareString"),\r\n            b1 = $(b).data("compareString");\r\n        \r\n        return FileUtils.compareFilenames(a1, b1, false);\r\n    }, function (a, b) {\r\n        return $(a).data("compareString") + ":" + $(b).data("compareString");\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * Given an input to jsTree\'s json_data.data setting, display the data in the file tree UI\r\n     * (replacing any existing file tree that was previously displayed). This input could be\r\n     * raw JSON data, or it could be a dataprovider function. See jsTree docs for details:\r\n     * http://www.jstree.com/documentation/json_data\r\n     */\r\n    function _renderTree(treeDataProvider) {\r\n        var result = new $.Deferred();\r\n\r\n        // For #1542, make sure the tree is scrolled to the top before refreshing.\r\n        // If we try to do this later (e.g. after the tree has been refreshed), it\r\n        // doesn\'t seem to work properly.\r\n        $projectTreeContainer.scrollTop(0);\r\n        \r\n        // Instantiate tree widget\r\n        // (jsTree is smart enough to replace the old tree if there\'s already one there)\r\n        $projectTreeContainer.hide()\r\n            .addClass("no-focus");\r\n        _projectTree = $projectTreeContainer\r\n            .jstree({\r\n                plugins : ["ui", "themes", "json_data", "crrm", "sort"],\r\n                ui : { select_limit: 1, select_multiple_modifier: "", select_range_modifier: "" },\r\n                json_data : { data: treeDataProvider, correct_state: false },\r\n                core : { html_titles: true, animation: 0, strings : { loading : Strings.PROJECT_LOADING, new_node : "New node" } },\r\n                themes : { theme: "brackets", url: "styles/jsTreeTheme.css", dots: false, icons: false },\r\n                    //(note: our actual jsTree theme CSS lives in brackets.less; we specify an empty .css\r\n                    // file because jsTree insists on loading one itself)\r\n                sort : _projectTreeSortComparator\r\n            }).bind(\r\n                "before.jstree",\r\n                function (event, data) {\r\n                    if (data.func === "toggle_node") {\r\n                        // jstree will automaticaly select parent node when the parent is closed\r\n                        // and any descendant is selected. Prevent the select_node handler from\r\n                        // immediately toggling open again in this case.\r\n                        suppressToggleOpen = _projectTree.jstree("is_open", data.args[0]);\r\n                    }\r\n                }\r\n            ).bind(\r\n                "select_node.jstree",\r\n                function (event, data) {\r\n                    var entry = data.rslt.obj.data("entry");\r\n                    if (entry) {\r\n                        if (entry.isFile) {\r\n                            var openResult = FileViewController.openAndSelectDocument(entry.fullPath, FileViewController.PROJECT_MANAGER);\r\n                        \r\n                            openResult.done(function () {\r\n                                // update when tree display state changes\r\n                                _redraw(true);\r\n                                _lastSelected = data.rslt.obj;\r\n                            }).fail(function () {\r\n                                if (_lastSelected) {\r\n                                    // revert this new selection and restore previous selection\r\n                                    _forceSelection(data.rslt.obj, _lastSelected);\r\n                                } else {\r\n                                    _projectTree.jstree("deselect_all");\r\n                                    _lastSelected = null;\r\n                                }\r\n                            });\r\n                        } else {\r\n                            FileViewController.setFileViewFocus(FileViewController.PROJECT_MANAGER);\r\n                            // show selection marker on folders\r\n                            _redraw(true);\r\n                            \r\n                            // toggle folder open/closed\r\n                            // suppress if this selection was triggered by clicking the disclousre triangle\r\n                            if (!suppressToggleOpen) {\r\n                                _projectTree.jstree("toggle_node", data.rslt.obj);\r\n                            }\r\n                        }\r\n                    }\r\n                    suppressToggleOpen = false;\r\n                }\r\n            ).bind(\r\n                "reopen.jstree",\r\n                function (event, data) {\r\n                    if (_projectInitialLoad.previous) {\r\n                        // Start reopening nodes that were previously open, starting\r\n                        // with the first recorded depth level. As each level completes,\r\n                        // it will trigger the next level to finish.\r\n                        _reopenNodes(_projectInitialLoad.previous, result);\r\n                        _projectInitialLoad.previous = null;\r\n                    }\r\n                }\r\n            ).bind(\r\n                "scroll.jstree",\r\n                function (e) {\r\n                    // close all dropdowns on scroll\r\n                    Menus.closeAll();\r\n                }\r\n            ).bind(\r\n                "loaded.jstree open_node.jstree close_node.jstree",\r\n                function (event, data) {\r\n                    if (event.type === "open_node") {\r\n                        // select the current document if it becomes visible when this folder is opened\r\n                        var curFile = MainViewManager.getCurrentlyViewedFile();\r\n                        \r\n                        if (_hasFileSelectionFocus() && curFile && data) {\r\n                            var entry = data.rslt.obj.data("entry");\r\n                            \r\n                            if (entry && curFile.fullPath.indexOf(entry.fullPath) === 0) {\r\n                                _forceSelection(data.rslt.obj, _lastSelected);\r\n                            } else {\r\n                                _redraw(true, false);\r\n                            }\r\n                        }\r\n                    } else if (event.type === "close_node") {\r\n                        // always update selection marker position when collapsing a node\r\n                        _redraw(true, false);\r\n                    } else {\r\n                        _redraw(false);\r\n                    }\r\n                    \r\n                    _savePreferences();\r\n                }\r\n            ).bind(\r\n                "mousedown.jstree",\r\n                function (event) {\r\n                    // select tree node on right-click\r\n                    if (event.which === 3 || (event.ctrlKey && event.which === 1 && brackets.platform === "mac")) {\r\n                        var treenode = $(event.target).closest("li");\r\n                        if (treenode) {\r\n                            var saveSuppressToggleOpen = suppressToggleOpen;\r\n                            \r\n                            // don\'t toggle open folders (just select)\r\n                            suppressToggleOpen = true;\r\n                            _projectTree.jstree("deselect_all");\r\n                            _projectTree.jstree("select_node", treenode, false);\r\n                            suppressToggleOpen = saveSuppressToggleOpen;\r\n                        }\r\n                    }\r\n                }\r\n            ).bind("mouseup.jstree", function (event) {\r\n                if (event.button !== 0) { // 0 = Left mouse button\r\n                    return;\r\n                }\r\n\r\n                var $treenode = $(event.target).closest("li"),\r\n                    entry = $treenode.data("entry");\r\n\r\n                // If we are already in a rename, don\'t re-invoke it, just cancel it.\r\n                if (_isInRename($treenode)) {\r\n                    return;\r\n                }\r\n\r\n                // Don\'t do the rename for folders, because clicking on a folder name collapses/expands it.\r\n                if (entry && entry.isFile && $treenode.is($(_projectTree.jstree("get_selected")))) {\r\n                    // wrap this in a setTimeout function so that we can check if it\'s a double click.\r\n                    _mouseupTimeoutId = window.setTimeout(function () {\r\n                        // if we get a double-click, _mouseupTimeoutId will have been set to null by the double-click handler before this runs.\r\n                        if (_mouseupTimeoutId !== null) {\r\n                            CommandManager.execute(Commands.FILE_RENAME);\r\n                        }\r\n                    }, 500);\r\n                }\r\n            });\r\n\r\n        // jstree has a default event handler for dblclick that attempts to clear the\r\n        // global window selection (presumably because it doesn\'t want text within the tree\r\n        // to be selected). This ends up messing up CodeMirror, and we don\'t need this anyway\r\n        // since we\'ve turned off user selection of UI text globally. So we just unbind it,\r\n        // and add our own double-click handler here.\r\n        // Filed this bug against jstree at https://github.com/vakata/jstree/issues/163\r\n        _projectTree.bind("init.jstree", function () {\r\n            // install scroller shadows\r\n            ViewUtils.addScrollerShadow(_projectTree.get(0));\r\n            \r\n            var findEventHandler = function (type, namespace, selector) {\r\n                var events        = $._data(_projectTree[0], "events"),\r\n                    eventsForType = events ? events[type] : null,\r\n                    event         = eventsForType ? _.find(eventsForType, function (e) {\r\n                        return e.namespace === namespace && e.selector === selector;\r\n                    }) : null,\r\n                    eventHandler  = event ? event.handler : null;\r\n                if (!eventHandler) {\r\n                    console.error(type + "." + namespace + " " + selector + " handler not found!");\r\n                }\r\n                return eventHandler;\r\n            };\r\n            var createCustomHandler = function (originalHandler) {\r\n                return function (event) {\r\n                    var $node = $(event.target).parent("li"),\r\n                        methodName;\r\n                    if (event.ctrlKey || event.metaKey) {\r\n                        if (event.altKey) {\r\n                            // collapse subtree\r\n                            // note: expanding using open_all is a bad idea due to poor performance\r\n                            methodName = $node.is(".jstree-open") ? "close_all" : "open_node";\r\n                            _projectTree.jstree(methodName, $node);\r\n                            return;\r\n                        } else {\r\n                            // toggle siblings\r\n                            methodName = $node.is(".jstree-open") ? "close_node" : "open_node";\r\n                            $node.parent().children("li").each(function () {\r\n                                _projectTree.jstree(methodName, $(this));\r\n                            });\r\n                            return;\r\n                        }\r\n                    }\r\n                    // original behaviour\r\n                    originalHandler.apply(this, arguments);\r\n                };\r\n            };\r\n            var originalHrefHandler = findEventHandler("click", "jstree", "a");\r\n            var originalInsHandler = findEventHandler("click", "jstree", "li > ins");\r\n\r\n            _projectTree\r\n                .off("click.jstree", "a")\r\n                .on("click.jstree", "a", createCustomHandler(originalHrefHandler))\r\n                .off("click.jstree", "li > ins")\r\n                .on("click.jstree", "li > ins", createCustomHandler(originalInsHandler))\r\n                .unbind("dblclick.jstree")\r\n                .bind("dblclick.jstree", function (event) {\r\n                    var entry = $(event.target).closest("li").data("entry");\r\n                    if (entry && entry.isFile && !_isInRename(event.target)) {\r\n                        FileViewController.openFileAndAddToWorkingSet(entry.fullPath);\r\n                    }\r\n                    if (_mouseupTimeoutId !== null) {\r\n                        window.clearTimeout(_mouseupTimeoutId);\r\n                        _mouseupTimeoutId = null;\r\n                    }\r\n                    \r\n                });\r\n\r\n            // fire selection changed events for sidebar-selection\r\n            $projectTreeList = $projectTreeContainer.find("ul");\r\n            ViewUtils.sidebarList($projectTreeContainer, "jstree-clicked", "jstree-leaf");\r\n            $projectTreeContainer.show();\r\n        });\r\n\r\n        return Async.withTimeout(result.promise(), 1000);\r\n    }\r\n    \r\n    function _showErrorDialog(errType, isFolder, error, path) {\r\n        var titleType = isFolder ? Strings.DIRECTORY_TITLE : Strings.FILE_TITLE,\r\n            entryType = isFolder ? Strings.DIRECTORY : Strings.FILE,\r\n            title,\r\n            message;\r\n        path = StringUtils.breakableUrl(path);\r\n\r\n        switch (errType) {\r\n        case ERR_TYPE_CREATE:\r\n            title = StringUtils.format(Strings.ERROR_CREATING_FILE_TITLE, titleType);\r\n            message = StringUtils.format(Strings.ERROR_CREATING_FILE, entryType, path, error);\r\n            break;\r\n        case ERR_TYPE_CREATE_EXISTS:\r\n            title = StringUtils.format(Strings.INVALID_FILENAME_TITLE, titleType);\r\n            message = StringUtils.format(Strings.ENTRY_WITH_SAME_NAME_EXISTS, path);\r\n            break;\r\n        case ERR_TYPE_RENAME:\r\n            title = StringUtils.format(Strings.ERROR_RENAMING_FILE_TITLE, titleType);\r\n            message = StringUtils.format(Strings.ERROR_RENAMING_FILE, path, error, entryType);\r\n            break;\r\n        case ERR_TYPE_DELETE:\r\n            title = StringUtils.format(Strings.ERROR_DELETING_FILE_TITLE, titleType);\r\n            message = StringUtils.format(Strings.ERROR_DELETING_FILE, path, error, entryType);\r\n            break;\r\n        case ERR_TYPE_LOADING_PROJECT:\r\n            title = Strings.ERROR_LOADING_PROJECT;\r\n            message = StringUtils.format(Strings.READ_DIRECTORY_ENTRIES_ERROR, path, error);\r\n            break;\r\n        case ERR_TYPE_LOADING_PROJECT_NATIVE:\r\n            title = Strings.ERROR_LOADING_PROJECT;\r\n            message = StringUtils.format(Strings.REQUEST_NATIVE_FILE_SYSTEM_ERROR, path, error);\r\n            break;\r\n        case ERR_TYPE_MAX_FILES:\r\n            title = Strings.ERROR_MAX_FILES_TITLE;\r\n            message = Strings.ERROR_MAX_FILES;\r\n            break;\r\n        case ERR_TYPE_OPEN_DIALOG:\r\n            title = Strings.ERROR_LOADING_PROJECT;\r\n            message = StringUtils.format(Strings.OPEN_DIALOG_ERROR, error);\r\n            break;\r\n        case ERR_TYPE_INVALID_FILENAME:\r\n            title = StringUtils.format(Strings.INVALID_FILENAME_TITLE, isFolder ? Strings.DIRECTORY_NAME : Strings.FILENAME);\r\n            message = StringUtils.format(Strings.INVALID_FILENAME_MESSAGE, isFolder ? Strings.DIRECTORY_NAMES_LEDE : Strings.FILENAMES_LEDE, error);\r\n            break;\r\n        }\r\n\r\n        if (title && message) {\r\n            return Dialogs.showModalDialog(\r\n                DefaultDialogs.DIALOG_ID_ERROR,\r\n                title,\r\n                message\r\n            );\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * See shouldShow\r\n     */\r\n    function _shouldShowName(name) {\r\n        return !name.match(_exclusionListRegEx);\r\n    }\r\n    \r\n    /**\r\n     * Returns false for files and directories that are not commonly useful to display.\r\n     *\r\n     * @param {FileSystemEntry} entry File or directory to filter\r\n     * @return boolean true if the file should be displayed\r\n     */\r\n    function shouldShow(entry) {\r\n        return _shouldShowName(entry.name);\r\n    }\r\n    \r\n    /**\r\n     * Returns true if fileName\'s extension doesn\'t belong to binary (e.g. archived)\r\n     * @deprecated Use LanguageManager.getLanguageForPath(fullPath).isBinary()\r\n     * @param {string} fileName\r\n     * @return {boolean}\r\n     */\r\n    function isBinaryFile(fileName) {\r\n        DeprecationWarning.deprecationWarning("ProjectManager.isBinaryFile() called for " + fileName + ". Use LanguageManager.getLanguageForPath(fileName).isBinary() instead.");\r\n        return LanguageManager.getLanguageForPath(fileName).isBinary();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Generate a string suitable for sorting\r\n     * @param {string} name\r\n     * @param {boolean} isFolder\r\n     * @return {string}\r\n     */\r\n    function _toCompareString(name, isFolder) {\r\n        return (isFolder ? _sortPrefixDir : _sortPrefixFile) + name;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Insert a path in the fullPath-to-DOM ID cache\r\n     * @param {!(FileSystemEntry|string)} entry Entry or full path to add to cache\r\n     */\r\n    function _insertTreeNodeCache(entry, id) {\r\n        var fullPath = entry.fullPath || entry;\r\n        _projectInitialLoad.fullPathToIdMap[fullPath] = id;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Delete a path from the fullPath-to-DOM ID cache\r\n     * @param {!(FileSystemEntry|string)} entry Entry or full path to remove from cache\r\n     */\r\n    function _deleteTreeNodeCache(entry) {\r\n        var fullPath = entry.fullPath || entry;\r\n        delete _projectInitialLoad.fullPathToIdMap[fullPath];\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Create JSON object for a jstree node. Insert mapping from full path to\r\n     * jstree node ID.\r\n     * \r\n     * For more info on jsTree\'s JSON format see: http://www.jstree.com/documentation/json_data\r\n     * @param {!FileSystemEntry} entry\r\n     * @return {data: string, attr: {id: string}, metadata: {entry: FileSystemEntry}, children: Array.<Object>, state: string}\r\n     */\r\n    function _entryToJSON(entry) {\r\n        if (!shouldShow(entry)) {\r\n            return null;\r\n        }\r\n        \r\n        var jsonEntry = {\r\n            data                : entry.name,\r\n            attr                : { id: "node" + _projectInitialLoad.id++ },\r\n            metadata: {\r\n                entry           : entry,\r\n                compareString   : _toCompareString(entry.name, entry.isDirectory)\r\n            }\r\n        };\r\n\r\n        if (entry.isDirectory) {\r\n            jsonEntry.children = [];\r\n            jsonEntry.state = "closed";\r\n            jsonEntry.data = _.escape(jsonEntry.data);\r\n        } else {\r\n            jsonEntry.data = ViewUtils.getFileEntryDisplay(entry);\r\n        }\r\n\r\n        // Map path to ID to initialize loaded and opened states\r\n        _insertTreeNodeCache(entry, jsonEntry.attr.id);\r\n        \r\n        return jsonEntry;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Given an array of file system entries, returns a JSON array representing them in the format\r\n     * required by jsTree. Saves the corresponding Entry object as metadata (which jsTree will store in\r\n     * the DOM via $.data()).\r\n     *\r\n     * Does NOT recursively traverse the file system: folders are marked as expandable but are given no\r\n     * children initially.\r\n     *\r\n     * @param {Array.<FileSystemEntry>} entries  Array of FileSystemEntry entry objects.\r\n     * @return {Array} jsTree node data: array of JSON objects\r\n     */\r\n    function _convertEntriesToJSON(entries) {\r\n        var jsonEntryList = [],\r\n            entry,\r\n            entryI,\r\n            jsonEntry;\r\n\r\n        for (entryI = 0; entryI < entries.length; entryI++) {\r\n            jsonEntryList.push(_entryToJSON(entries[entryI]));\r\n        }\r\n        \r\n        return jsonEntryList;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Called by jsTree when the user has expanded a node that has never been expanded before. We call\r\n     * jsTree back asynchronously with the node\'s immediate children data once the subfolder is done\r\n     * being fetched.\r\n     *\r\n     * @param {jQueryObject} $treeNode  jQ object for the DOM node being expanded\r\n     * @param {function(Array)} jsTreeCallback  jsTree callback to provide children to\r\n     */\r\n    function _treeDataProvider($treeNode, jsTreeCallback) {\r\n        var dirEntry, isProjectRoot = false, deferred = new $.Deferred();\r\n        \r\n        function processEntries(entries) {\r\n            var subtreeJSON = _convertEntriesToJSON(entries),\r\n                wasNodeOpen = false,\r\n                emptyDirectory = (subtreeJSON.length === 0);\r\n            \r\n            if (emptyDirectory) {\r\n                if (!isProjectRoot) {\r\n                    wasNodeOpen = $treeNode.hasClass("jstree-open");\r\n                } else {\r\n                    // project root is a special case, add a placeholder\r\n                    subtreeJSON.push({});\r\n                }\r\n            }\r\n            \r\n            jsTreeCallback(subtreeJSON);\r\n            \r\n            if (!isProjectRoot && emptyDirectory) {\r\n                // If the directory is empty, force it to appear as an open or closed node.\r\n                // This is a workaround for issue #149 where jstree would show this node as a leaf.\r\n                var classToAdd = (wasNodeOpen) ? "jstree-closed" : "jstree-open";\r\n                \r\n                $treeNode.removeClass("jstree-leaf jstree-closed jstree-open")\r\n                    .addClass(classToAdd);\r\n                \r\n                // This is a workaround for a part of issue #2085, where the file creation process\r\n                // depends on the open_node.jstree event being triggered, which doesn\'t happen on\r\n                // empty folders\r\n                if (!wasNodeOpen) {\r\n                    $treeNode.trigger("open_node.jstree");\r\n                }\r\n            }\r\n            \r\n            deferred.resolve();\r\n        }\r\n\r\n        if ($treeNode === -1) {\r\n            // Special case: root of tree\r\n            dirEntry = _projectRoot;\r\n            isProjectRoot = true;\r\n        } else {\r\n            // All other nodes: the Directory is saved as jQ data in the tree (by _convertEntriesToJSON())\r\n            dirEntry = $treeNode.data("entry");\r\n        }\r\n        \r\n        // Fetch dirEntry\'s contents\r\n        dirEntry.getContents(function (err, contents, stats, statsErrs) {\r\n            if (err) {\r\n                _showErrorDialog(ERR_TYPE_LOADING_PROJECT, null, err, dirEntry.fullPath);\r\n                // Reject the render promise so we can move on.\r\n                deferred.reject();\r\n            } else {\r\n                if (statsErrs) {\r\n                    // some but not all entries failed to load, so render what we can\r\n                    console.warn("Error reading a subset of folder " + dirEntry);\r\n                }\r\n                processEntries(contents);\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Forces createNewItem() to complete by removing focus from the rename field which causes\r\n     * the new file to be written to disk\r\n     */\r\n    function forceFinishRename() {\r\n        $(".jstree-rename-input").blur();\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Although Brackets is generally standardized on folder paths with a trailing "/", some APIs here\r\n     * receive project paths without "/" due to legacy preference storage formats, etc.\r\n     * @param {!string} fullPath  Path that may or may not end in "/"\r\n     * @return {!string} Path that ends in "/"\r\n     */\r\n    function _ensureTrailingSlash(fullPath) {\r\n        if (fullPath[fullPath.length - 1] !== "/") {\r\n            return fullPath + "/";\r\n        }\r\n        return fullPath;\r\n    }\r\n    \r\n    /** Returns the full path to the welcome project, which we open on first launch.\r\n     * @private\r\n     * @return {!string} fullPath reference\r\n     */\r\n    function _getWelcomeProjectPath() {\r\n        // Hack for demo: use root\r\n        return \'/\';\r\n\r\n\r\n        var initialPath = FileUtils.getNativeBracketsDirectoryPath(),\r\n            sampleUrl = Urls.GETTING_STARTED;\r\n        if (sampleUrl) {\r\n            // Back up one more folder. The samples folder is assumed to be at the same level as\r\n            // the src folder, and the sampleUrl is relative to the samples folder.\r\n            initialPath = initialPath.substr(0, initialPath.lastIndexOf("/")) + "/samples/" + sampleUrl;\r\n        }\r\n\r\n        return _ensureTrailingSlash(initialPath); // paths above weren\'t canonical\r\n    }\r\n    \r\n    /**\r\n     * Returns true if the given path is the same as one of the welcome projects we\'ve previously opened,\r\n     * or the one for the current build.\r\n     */\r\n    function isWelcomeProjectPath(path) {\r\n        if (path === _getWelcomeProjectPath()) {\r\n            return true;\r\n        }\r\n        var pathNoSlash = FileUtils.stripTrailingSlash(path);  // "welcomeProjects" pref has standardized on no trailing "/"\r\n        var welcomeProjects = PreferencesManager.getViewState("welcomeProjects") || [];\r\n        return welcomeProjects.indexOf(pathNoSlash) !== -1;\r\n    }\r\n    \r\n    /**\r\n     * Adds the path to the list of welcome projects we\'ve ever seen, if not on the list already.\r\n     */\r\n    function addWelcomeProjectPath(path) {\r\n        var pathNoSlash = FileUtils.stripTrailingSlash(path);  // "welcomeProjects" pref has standardized on no trailing "/"\r\n        \r\n        var welcomeProjects = PreferencesManager.getViewState("welcomeProjects") || [];\r\n        if (welcomeProjects.indexOf(pathNoSlash) === -1) {\r\n            welcomeProjects.push(pathNoSlash);\r\n            PreferencesManager.setViewState("welcomeProjects", welcomeProjects);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * If the provided path is to an old welcome project, returns the current one instead.\r\n     */\r\n    function updateWelcomeProjectPath(path) {\r\n        if (isWelcomeProjectPath(path)) {\r\n            return _getWelcomeProjectPath();\r\n        } else {\r\n            return path;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initial project path is stored in prefs, which defaults to the welcome project on\r\n     * first launch.\r\n     */\r\n    function getInitialProjectPath() {\r\n        // Hack for demo: use root /\r\n        return \'/\';\r\n        return updateWelcomeProjectPath(PreferencesManager.getViewState("projectPath"));\r\n    }\r\n    \r\n    function _watchProjectRoot(rootPath) {\r\n        FileSystem.on("change", _fileSystemChange);\r\n        FileSystem.on("rename", _fileSystemRename);\r\n\r\n        FileSystem.watch(FileSystem.getDirectoryForPath(rootPath), _shouldShowName, function (err) {\r\n            if (err === FileSystemError.TOO_MANY_ENTRIES) {\r\n                if (!_projectWarnedForTooManyFiles) {\r\n                    _showErrorDialog(ERR_TYPE_MAX_FILES);\r\n                    _projectWarnedForTooManyFiles = true;\r\n                }\r\n            } else if (err) {\r\n                console.error("Error watching project root: ", rootPath, err);\r\n            }\r\n        });\r\n        \r\n        // Reset allFiles cache\r\n        _allFilesCachePromise = null;\r\n    }\r\n\r\n        \r\n    /**\r\n     * @private\r\n     * Close the file system and remove listeners.\r\n     * @return {$.Promise} A promise that\'s resolved when the root is unwatched. Rejected if\r\n     *     there is no project root or if the unwatch fails.\r\n     */\r\n    function _unwatchProjectRoot() {\r\n        var result = new $.Deferred();\r\n        if (!_projectRoot) {\r\n            result.reject();\r\n        } else {\r\n            FileSystem.off("change", _fileSystemChange);\r\n            FileSystem.off("rename", _fileSystemRename);\r\n\r\n            FileSystem.unwatch(_projectRoot, function (err) {\r\n                if (err) {\r\n                    console.error("Error unwatching project root: ", _projectRoot.fullPath, err);\r\n                    result.reject();\r\n                } else {\r\n                    result.resolve();\r\n                }\r\n            });\r\n            \r\n            // Reset allFiles cache\r\n            _allFilesCachePromise = null;\r\n        }\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Reloads the project preferences.\r\n     */\r\n    function _reloadProjectPreferencesScope() {\r\n        var root = getProjectRoot();\r\n        if (root) {\r\n            // Alias the "project" Scope to the path Scope for the project-level settings file\r\n            PreferencesManager._setProjectSettingsFile(root.fullPath + SETTINGS_FILENAME);\r\n        } else {\r\n            PreferencesManager._setProjectSettingsFile();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Loads the given folder as a project. Does NOT prompt about any unsaved changes - use openProject()\r\n     * instead to check for unsaved changes and (optionally) let the user choose the folder to open.\r\n     *\r\n     * @param {!string} rootPath  Absolute path to the root folder of the project.\r\n     *  A trailing "/" on the path is optional (unlike many Brackets APIs that assume a trailing "/").\r\n     * @param {boolean=} isUpdating  If true, indicates we\'re just updating the tree;\r\n     *  if false, a different project is being loaded.\r\n     * @return {$.Promise} A promise object that will be resolved when the\r\n     *  project is loaded and tree is rendered, or rejected if the project path\r\n     *  fails to load.\r\n     */\r\n    function _loadProject(rootPath, isUpdating) {\r\n        var result = new $.Deferred(),\r\n            startLoad = new $.Deferred(),\r\n            resultRenderTree;\r\n\r\n        forceFinishRename();    // in case we\'re in the middle of renaming a file in the project\r\n        \r\n        // Some legacy code calls this API with a non-canonical path\r\n        rootPath = _ensureTrailingSlash(rootPath);\r\n        \r\n        if (isUpdating) {\r\n            // We\'re just refreshing. Don\'t need to unwatch the project root, so we can start loading immediately.\r\n            startLoad.resolve();\r\n        } else {\r\n            if (_projectRoot && _projectRoot.fullPath === rootPath) {\r\n                return (new $.Deferred()).resolve().promise();\r\n            }\r\n            \r\n            // About to close current project (if any)\r\n            if (_projectRoot) {\r\n                $(exports).triggerHandler("beforeProjectClose", _projectRoot);\r\n            }\r\n            \r\n            // close all the old files\r\n            MainViewManager._closeAll(MainViewManager.ALL_PANES);\r\n    \r\n            _unwatchProjectRoot().always(function () {\r\n                // Finish closing old project (if any)\r\n                if (_projectRoot) {\r\n                    LanguageManager._resetPathLanguageOverrides();\r\n                    PreferencesManager._reloadUserPrefs(_projectRoot);\r\n                    $(exports).triggerHandler("projectClose", _projectRoot);\r\n                }\r\n                \r\n                startLoad.resolve();\r\n            });\r\n        }\r\n        \r\n        startLoad.done(function () {\r\n            var context = { location : { scope: "user",\r\n                                         layer: "project" } };\r\n\r\n            // Clear project path map\r\n            _projectInitialLoad = {\r\n                previous        : [],   /* array of arrays containing full paths to open at each depth of the tree */\r\n                id              : 0,    /* incrementing id */\r\n                fullPathToIdMap : {}    /* mapping of fullPath to tree node id attr */\r\n            };\r\n\r\n            if (!isUpdating) {\r\n                PreferencesManager._stateProjectLayer.setProjectPath(rootPath);\r\n            }\r\n            \r\n            // restore project tree state from last time this project was open\r\n            _projectInitialLoad.previous = PreferencesManager.getViewState("project.treeState", context) || [];\r\n\r\n            // Populate file tree\r\n            if (!isUpdating) {\r\n                _watchProjectRoot(rootPath);\r\n            }\r\n            // Point at a real folder structure on local disk\r\n            var rootEntry = FileSystem.getDirectoryForPath(rootPath);\r\n            rootEntry.exists(function (err, exists) {\r\n                if (exists) {\r\n                    var projectRootChanged = (!_projectRoot || !rootEntry) ||\r\n                        _projectRoot.fullPath !== rootEntry.fullPath;\r\n\r\n                    // Success!\r\n                    var perfTimerName = PerfUtils.markStart("Load Project: " + rootPath);\r\n\r\n                    _projectRoot = rootEntry;\r\n\r\n                    if (projectRootChanged) {\r\n                        _reloadProjectPreferencesScope();\r\n                        PreferencesManager._setCurrentEditingFile(rootPath);\r\n                    }\r\n\r\n                    _projectBaseUrl = PreferencesManager.getViewState("project.baseUrl", context) || "";\r\n                    _allFilesCachePromise = null;  // invalidate getAllFiles() cache as soon as _projectRoot changes\r\n\r\n                    // If this is the most current welcome project, record it. In future launches, we want\r\n                    // to substitute the latest welcome project from the current build instead of using an\r\n                    // outdated one (when loading recent projects or the last opened project).\r\n                    if (rootPath === _getWelcomeProjectPath()) {\r\n                        addWelcomeProjectPath(rootPath);\r\n                    }\r\n\r\n                    // The tree will invoke our "data provider" function to populate the top-level items, then\r\n                    // go idle until a node is expanded - at which time it\'ll call us again to fetch the node\'s\r\n                    // immediate children, and so on.\r\n                    resultRenderTree = _renderTree(_treeDataProvider);\r\n\r\n                    resultRenderTree.always(function () {\r\n                        if (projectRootChanged) {\r\n                            // Allow asynchronous event handlers to finish before resolving result by collecting promises from them\r\n                            var promises = [];\r\n                            $(exports).triggerHandler({ type: "projectOpen", promises: promises }, [_projectRoot]);\r\n                            $.when.apply($, promises).then(result.resolve, result.reject);\r\n                        } else {\r\n                            $(exports).triggerHandler("projectRefresh", _projectRoot);\r\n                            result.resolve();\r\n                        }\r\n                    });\r\n                    resultRenderTree.fail(function () {\r\n                        PerfUtils.finalizeMeasurement(perfTimerName);\r\n                        result.reject();\r\n                    });\r\n                    resultRenderTree.always(function () {\r\n                        PerfUtils.addMeasurement(perfTimerName);\r\n                    });\r\n                } else {\r\n                    _showErrorDialog(ERR_TYPE_LOADING_PROJECT_NATIVE, null, rootPath, err || FileSystemError.NOT_FOUND)\r\n                        .done(function () {\r\n                            // Reset _projectRoot to null so that the following _loadProject call won\'t \r\n                            // run the \'beforeProjectClose\' event a second time on the original project, \r\n                            // which is now partially torn down (see #6574).\r\n                            _projectRoot = null;\r\n\r\n                            // The project folder stored in preference doesn\'t exist, so load the default\r\n                            // project directory.\r\n                            // TODO (issue #267): When Brackets supports having no project directory\r\n                            // defined this code will need to change\r\n                            _loadProject(_getWelcomeProjectPath()).always(function () {\r\n                                // Make sure not to reject the original deferred until the fallback\r\n                                // project is loaded, so we don\'t violate expectations that there is always\r\n                                // a current project before continuing after _loadProject().\r\n                                result.reject();\r\n                            });\r\n                        });\r\n                }\r\n            });\r\n        });\r\n\r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Lookup jQuery node for a given FileSystem Entry\r\n     * @param {!File|Directory|string} entry String or File/Directory entry to find in the tree\r\n     * @return {?jQuery} The jQuery node for this entry or null if not found\r\n     */\r\n    function _getTreeNode(entry) {\r\n        // Special case if the entry matches the project root\r\n        if (entry === getProjectRoot()) {\r\n            return $projectTreeList;\r\n        }\r\n        \r\n        var fullPath = entry.fullPath || entry,\r\n            id = _projectInitialLoad.fullPathToIdMap[fullPath],\r\n            node = null;\r\n        \r\n        if (id) {\r\n            node = $("#" + id);\r\n        }\r\n        \r\n        return node;\r\n    }\r\n    \r\n    /**\r\n     * Finds the tree node corresponding to the given file/folder (rejected if the path lies\r\n     * outside the project, or if it doesn\'t exist).\r\n     *\r\n     * @param {!(File|Directory)} entry File or Directory to find\r\n     * @return {$.Promise} Resolved with jQ obj for the jsTree tree node; or rejected if not found\r\n     */\r\n    function _findTreeNode(entry) {\r\n        var result = new $.Deferred(),\r\n            $renderedNode = _getTreeNode(entry);\r\n        \r\n        // Check if tree node was already rendered\r\n        if ($renderedNode) {\r\n            return result.resolve($renderedNode).promise();\r\n        }\r\n        \r\n        var projRelativePath = makeProjectRelativeIfPossible(entry.fullPath);\r\n\r\n        if (projRelativePath === entry.fullPath) {\r\n            // If path not within project, ignore\r\n            return result.reject().promise();\r\n        } else if (entry === getProjectRoot()) {\r\n            // If path is the project root, return the tree itself\r\n            return result.resolve($projectTreeList).promise();\r\n        }\r\n        \r\n        var treeAPI = $.jstree._reference(_projectTree);\r\n        \r\n        // We\'re going to traverse from root of tree, one segment at a time\r\n        var pathSegments = projRelativePath.split("/");\r\n        if (entry.isDirectory) {\r\n            pathSegments.pop();  // Directory always has a trailing "/"\r\n        }\r\n        \r\n        function findInSubtree($nodes, segmentI) {\r\n            var seg = pathSegments[segmentI];\r\n            var match = _.findIndex($nodes, function (node, i) {\r\n                var entry = $(node).data("entry"),\r\n                    nodeName = entry ? entry.name : null;\r\n                \r\n                return nodeName === seg;\r\n            });\r\n            \r\n            if (match === -1) {\r\n                result.reject();    // path doesn\'t exist\r\n            } else {\r\n                var $node = $nodes.eq(match);\r\n                if (segmentI === pathSegments.length - 1) {\r\n                    result.resolve($node);  // done searching!\r\n                } else {\r\n                    // Search next level down\r\n                    var subChildren = treeAPI._get_children($node);\r\n                    if (subChildren.length > 0) {\r\n                        findInSubtree(subChildren, segmentI + 1);\r\n                    } else {\r\n                        // Subtree not loaded yet: force async load & try again\r\n                        treeAPI.load_node($node, function (data) {\r\n                            subChildren = treeAPI._get_children($node);\r\n                            findInSubtree(subChildren, segmentI + 1);\r\n                        }, function (err) {\r\n                            result.reject();  // includes case where folder is empty\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Begin searching from root\r\n        var topLevelNodes = treeAPI._get_children(-1);  // -1 means top level in jsTree-ese\r\n        findInSubtree(topLevelNodes, 0);\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Internal function to refresh the project\'s file tree, maintaining the\r\n     * current selection. This function is expensive and not concurrency-safe,\r\n     * so most callers should use the synchronized and throttled version below,\r\n     * refreshFileTree.\r\n     * \r\n     * @private\r\n     * @return {$.Promise} A promise object that will be resolved when the\r\n     *  project tree is reloaded, or rejected if the project path\r\n     *  fails to reload. If the previous selected entry is not found, \r\n     *  the promise is still resolved.\r\n     */\r\n    function _refreshFileTreeInternal() {\r\n        var selectedEntry,\r\n            deferred = new $.Deferred();\r\n\r\n        if (_lastSelected) {\r\n            selectedEntry = _lastSelected.data("entry");\r\n        }\r\n        _lastSelected = null;\r\n        \r\n        _loadProject(getProjectRoot().fullPath, true)\r\n            .then(function () {\r\n                if (selectedEntry) {\r\n                    // restore selection, always resolve\r\n                    _findTreeNode(selectedEntry)\r\n                        .done(function ($node) {\r\n                            _forceSelection(null, $node);\r\n                        })\r\n                        .always(deferred.resolve);\r\n                } else {\r\n                    deferred.resolve();\r\n                }\r\n            }, deferred.reject);\r\n\r\n        return deferred.promise();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * @type {?jQuery.Promise} Resolves when the currently running instance of\r\n     *      _refreshFileTreeInternal completes, or null if there is no currently\r\n     *      running instance.\r\n     */\r\n    var _refreshFileTreePromise = null;\r\n    \r\n    /**\r\n     * @type {boolean} If refreshFileTree is called before _refreshFileTreePromise\r\n     *      has resolved then _refreshPending is set, which indicates that \r\n     *      refreshFileTree should be called again once the promise resolves.\r\n     */\r\n    var _refreshPending = false;\r\n    \r\n    /**\r\n     * @const\r\n     * @private\r\n     * @type {number} Minimum delay in milliseconds between calls to refreshFileTree\r\n     */\r\n    var _refreshDelay = 1000;\r\n    \r\n    /**\r\n     * Refresh the project\'s file tree, maintaining the current selection.\r\n     * \r\n     * @return {$.Promise} A promise object that will be resolved when the\r\n     *  project tree is reloaded, or rejected if the project path\r\n     *  fails to reload. If the previous selected entry is not found, \r\n     *  the promise is still resolved.\r\n     */\r\n    function refreshFileTree() {\r\n        if (!_refreshFileTreePromise) {\r\n            var internalRefreshPromise  = _refreshFileTreeInternal(),\r\n                deferred                = new $.Deferred();\r\n\r\n            _refreshFileTreePromise = deferred.promise();\r\n            \r\n            _refreshFileTreePromise.always(function () {\r\n                _refreshFileTreePromise = null;\r\n                \r\n                if (_refreshPending) {\r\n                    _refreshPending = false;\r\n                    refreshFileTree();\r\n                }\r\n            });\r\n\r\n            // Wait at least one second before resolving the promise\r\n            window.setTimeout(function () {\r\n                internalRefreshPromise.then(deferred.resolve, deferred.reject);\r\n            }, _refreshDelay);\r\n        } else {\r\n            _refreshPending = true;\r\n        }\r\n\r\n        return _refreshFileTreePromise;\r\n    }\r\n    \r\n    /**\r\n     * Expands tree nodes to show the given file or folder and selects it. Silently no-ops if the\r\n     * path lies outside the project, or if it doesn\'t exist.\r\n     *\r\n     * @param {!(File|Directory)} entry File or Directory to show\r\n     * @return {$.Promise} Resolved when done; or rejected if not found\r\n     */\r\n    function showInTree(entry) {\r\n        return _findTreeNode(entry)\r\n            .done(function ($node) {\r\n                // jsTree will automatically expand parent nodes to ensure visible\r\n                _projectTree.jstree("select_node", $node, false);\r\n            });\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Open a new project. Currently, Brackets must always have a project open, so\r\n     * this method handles both closing the current project and opening a new project.\r\n     *\r\n     * @param {string=} path Optional absolute path to the root folder of the project.\r\n     *  If path is undefined or null, displays a dialog where the user can choose a\r\n     *  folder to load. If the user cancels the dialog, nothing more happens.\r\n     * @return {$.Promise} A promise object that will be resolved when the\r\n     *  project is loaded and tree is rendered, or rejected if the project path\r\n     *  fails to load.\r\n     */\r\n    function openProject(path) {\r\n\r\n        var result = new $.Deferred();\r\n\r\n        // Confirm any unsaved changes first. We run the command in "prompt-only" mode, meaning it won\'t\r\n        // actually close any documents even on success; we\'ll do that manually after the user also oks\r\n        // the folder-browse dialog.\r\n        CommandManager.execute(Commands.FILE_CLOSE_ALL, { promptOnly: true })\r\n            .done(function () {\r\n                if (path) {\r\n                    // use specified path\r\n                    _loadProject(path, false).then(result.resolve, result.reject);\r\n                } else {\r\n                    // Pop up a folder browse dialog\r\n                    FileSystem.showOpenDialog(false, true, Strings.CHOOSE_FOLDER, _projectRoot.fullPath, null, function (err, files) {\r\n                        if (!err) {\r\n                            // If length == 0, user canceled the dialog; length should never be > 1\r\n                            if (files.length > 0) {\r\n                                // Load the new project into the folder tree\r\n                                _loadProject(files[0]).then(result.resolve, result.reject);\r\n                            } else {\r\n                                result.reject();\r\n                            }\r\n                        } else {\r\n                            _showErrorDialog(ERR_TYPE_OPEN_DIALOG, null, err);\r\n                            result.reject();\r\n                        }\r\n                    });\r\n                }\r\n            })\r\n            .fail(function () {\r\n                result.reject();\r\n            });\r\n\r\n        // if fail, don\'t open new project: user canceled (or we failed to save its unsaved changes)\r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * Invoke project settings dialog.\r\n     * @return {$.Promise}\r\n     */\r\n    function _projectSettings() {\r\n        return PreferencesDialogs.showProjectPreferencesDialog(getBaseUrl()).getPromise();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Check a filename for illegal characters. If any are found, show an error\r\n     * dialog and return false. If no illegal characters are found, return true.\r\n     * Although Mac and Linux allow ?*| characters, we still cannot allow them\r\n     * since these have special meaning for all file systems.\r\n     *\r\n     * @param {string} filename\r\n     * @param {boolean} isFolder\r\n     * @return {boolean} Returns true if no illegal characters are found\r\n     */\r\n    function _checkForValidFilename(filename, isFolder) {\r\n        // Validate file name\r\n        // Checks for valid Windows filenames:\r\n        // See http://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx\r\n        if ((filename.search(new RegExp("[" + _invalidChars + "]+")) !== -1) ||\r\n                filename.match(_illegalFilenamesRegEx)) {\r\n            _showErrorDialog(ERR_TYPE_INVALID_FILENAME, isFolder, _invalidChars);\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Add a new node (existing FileSystemEntry or untitled file) to the project tree\r\n     * \r\n     * @param {?jQueryObject} $target Parent or sibling node\r\n     * @param {?number|string} position Position to insert\r\n     * @param {!Object|Array.<Object>} arr Node data or array of node data\r\n     * @param {!boolean} skipRename\r\n     * @param {!boolean} skipRedraw\r\n     */\r\n    function _createNode($target, position, arr, skipRename, skipRedraw) {\r\n        if (typeof arr === "string") {\r\n            arr = [{ data: arr }];\r\n        } else if (!Array.isArray(arr)) {\r\n            arr = [arr];\r\n        }\r\n        \r\n        position = position || 0;\r\n        \r\n        arr.forEach(function (node) {\r\n            // Convert strings to objects\r\n            if (typeof node === "string") {\r\n                node = {\r\n                    data: node,\r\n                    metadata: { compareString: _sortPrefixFile + node }\r\n                };\r\n            }\r\n            \r\n            if (node) {\r\n                _projectTree.jstree("create", $target, position, node, null, skipRename);\r\n            }\r\n        });\r\n        \r\n        if (!skipRedraw) {\r\n            _redraw(true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a new item in the current project.\r\n     *\r\n     * @param baseDir {string|Directory} Full path of the directory where the item should go.\r\n     *   Defaults to the project root if the entry is not valid or not within the project.\r\n     * @param initialName {string} Initial name for the item\r\n     * @param skipRename {boolean} If true, don\'t allow the user to rename the item\r\n     * @param isFolder {boolean} If true, create a folder instead of a file\r\n     * @return {$.Promise} A promise object that will be resolved with the File\r\n     *  of the created object, or rejected if the user cancelled or entered an illegal\r\n     *  filename.\r\n     */\r\n    function createNewItem(baseDir, initialName, skipRename, isFolder) {\r\n        // We assume the parent directory exists\r\n        var entry               = (typeof baseDir === "string") ? FileSystem.getDirectoryForPath(baseDir) : baseDir,\r\n            baseDirEntry        = isWithinProject(entry) ? entry : getProjectRoot(),\r\n            $baseDirNode        = (baseDir && _getTreeNode(baseDirEntry)) || null,\r\n            position            = "inside",\r\n            escapeKeyPressed    = false,\r\n            result              = new $.Deferred(),\r\n            isRoot              = $baseDirNode === $projectTreeList,\r\n            wasNodeOpen         = isRoot || ($baseDirNode && $baseDirNode.hasClass("jstree-open")) || false,\r\n            newItemData         = {};\r\n        \r\n        // Silently fail if baseDir assumption fails\r\n        if (!$baseDirNode) {\r\n            return result.reject().promise();\r\n        }\r\n        \r\n        // Inject jstree data for sorting\r\n        newItemData.data = initialName;\r\n        newItemData.metadata = { compareString: _toCompareString(initialName, isFolder) };\r\n\r\n        _projectTree.on("create.jstree", function (event, data) {\r\n            $(event.target).off("create.jstree");\r\n\r\n            function errorCleanup() {\r\n                // TODO (issue #115): If an error occurred, we should allow the user to fix the filename.\r\n                // For now we just remove the node so you have to start again.\r\n                var parent = data.inst._get_parent(data.rslt.obj);\r\n                \r\n                _projectTree.jstree("remove", data.rslt.obj);\r\n                \r\n                // Restore tree node state and styling when errors occur.\r\n                // parent returns -1 when at the root\r\n                if (parent && (parent !== -1)) {\r\n                    var methodName = (wasNodeOpen) ? "open_node" : "close_node";\r\n                    var classToAdd = (wasNodeOpen) ? "jstree-open" : "jstree-closed";\r\n\r\n                    // This is a workaround for issue #149 where jstree would show this node as a leaf.\r\n                    _projectTree.jstree(methodName, parent);\r\n                    parent.removeClass("jstree-leaf jstree-closed jstree-open")\r\n                        .addClass(classToAdd);\r\n                }\r\n                \r\n                _redraw(true);\r\n                \r\n                result.reject();\r\n            }\r\n\r\n            if (!escapeKeyPressed) {\r\n                // Validate file name\r\n                if (!_checkForValidFilename(data.rslt.name, isFolder)) {\r\n                    errorCleanup();\r\n                    return;\r\n                }\r\n\r\n                var successCallback = function (entry) {\r\n                    // Remove the temporary leaf node used for the name input\r\n                    _projectTree.jstree("remove", data.rslt.obj);\r\n\r\n                    _projectTree.one("create.jstree", function (event, data) {\r\n                        // Select the new node and resolve\r\n                        _projectTree.jstree("select_node", data.rslt.obj, true);\r\n                        result.resolve(entry);\r\n                    });\r\n\r\n                    // Create a new node\r\n                    _createNode($baseDirNode, null, _entryToJSON(entry), true, true);\r\n                };\r\n                \r\n                var errorCallback = function (error) {\r\n                    if (error === FileSystemError.ALREADY_EXISTS) {\r\n                        _showErrorDialog(ERR_TYPE_CREATE_EXISTS, isFolder, null, data.rslt.name);\r\n                    } else {\r\n                        var errString = error === FileSystemError.NOT_WRITABLE ?\r\n                                         Strings.NO_MODIFICATION_ALLOWED_ERR :\r\n                                         StringUtils.format(Strings.GENERIC_ERROR, error);\r\n\r\n                        _showErrorDialog(ERR_TYPE_CREATE, isFolder, errString, data.rslt.name);\r\n                    }\r\n\r\n                    errorCleanup();\r\n                };\r\n                \r\n                var newItemPath = baseDirEntry.fullPath + data.rslt.name;\r\n                \r\n                FileSystem.resolve(newItemPath, function (err) {\r\n                    if (!err) {\r\n                        // Item already exists, fail with error\r\n                        errorCallback(FileSystemError.ALREADY_EXISTS);\r\n                    } else {\r\n                        if (isFolder) {\r\n                            var directory = FileSystem.getDirectoryForPath(newItemPath);\r\n                            \r\n                            directory.create(function (err) {\r\n                                if (err) {\r\n                                    errorCallback(err);\r\n                                } else {\r\n                                    successCallback(directory);\r\n                                }\r\n                            });\r\n                        } else {\r\n                            // Create an empty file\r\n                            var file = FileSystem.getFileForPath(newItemPath);\r\n                            \r\n                            file.write("", function (err) {\r\n                                if (err) {\r\n                                    errorCallback(err);\r\n                                } else {\r\n                                    successCallback(file);\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                });\r\n                \r\n            } else { //escapeKeyPressed\r\n                errorCleanup();\r\n            }\r\n        });\r\n\r\n        // There is a race condition in jstree if "open_node" and "create" are called in rapid\r\n        // succession and the node was not yet loaded. To avoid it, first open the node and wait\r\n        // for the open_node event before trying to create the new one. See #2085 for more details.\r\n        if (wasNodeOpen) {\r\n            _createNode($baseDirNode, position, newItemData, skipRename);\r\n\r\n            if (!skipRename) {\r\n                var $renameInput = _projectTree.find(".jstree-rename-input");\r\n    \r\n                $renameInput.on("keydown", function (event) {\r\n                    // Listen for escape key on keydown, so we can remove the node in the create.jstree handler above\r\n                    if (event.keyCode === KeyEvent.DOM_VK_ESCAPE) {\r\n    \r\n                        escapeKeyPressed = true;\r\n                    }\r\n                });\r\n    \r\n                ViewUtils.scrollElementIntoView(_projectTree, $renameInput, true);\r\n            }\r\n        } else {\r\n            _projectTree.one("open_node.jstree", function () {\r\n                _createNode($baseDirNode, position, newItemData, skipRename);\r\n            });\r\n    \r\n            // Open the node before creating the new child\r\n            _projectTree.jstree("open_node", $baseDirNode);\r\n        }\r\n        \r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * Rename a file/folder. This will update the project tree data structures\r\n     * and send notifications about the rename.\r\n     *\r\n     * @param {string} oldName Old item name\r\n     * @param {string} newName New item name\r\n     * @param {boolean} isFolder True if item is a folder; False if it is a file.\r\n     * @return {$.Promise} A promise object that will be resolved or rejected when\r\n     *   the rename is finished.\r\n     */\r\n    function renameItem(oldName, newName, isFolder) {\r\n        var result = new $.Deferred();\r\n        \r\n        if (oldName === newName) {\r\n            result.resolve();\r\n            return result.promise();\r\n        }\r\n        \r\n        var entry = isFolder ? FileSystem.getDirectoryForPath(oldName) : FileSystem.getFileForPath(oldName);\r\n        entry.rename(newName, function (err) {\r\n            if (!err) {\r\n                if (MainViewManager.getCurrentlyViewedPath(MainViewManager.ACTIVE_PANE)) {\r\n                    FileViewController.openAndSelectDocument(\r\n                        MainViewManager.getCurrentlyViewedPath(MainViewManager.ACTIVE_PANE),\r\n                        FileViewController.getFileSelectionFocus()\r\n                    );\r\n                }\r\n                \r\n                _redraw(true);\r\n                result.resolve();\r\n            } else {\r\n                // Show an error alert\r\n                var errString = err === FileSystemError.ALREADY_EXISTS ?\r\n                                Strings.FILE_EXISTS_ERR :\r\n                                FileUtils.getFileErrorString(err);\r\n\r\n                _showErrorDialog(ERR_TYPE_RENAME, isFolder, errString, newName);\r\n                result.reject(err);\r\n            }\r\n        });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Initiates a rename of the selected item in the project tree, showing an inline editor\r\n     * for input. Silently no-ops if the entry lies outside the tree or doesn\'t exist.\r\n     * @param {!(File|Directory)} entry File or Directory to rename\r\n     */\r\n    function renameItemInline(entry) {\r\n        // First make sure the item in the tree is visible - jsTree\'s rename API doesn\'t do anything to ensure inline input is visible\r\n        showInTree(entry)\r\n            .done(function ($selected) {\r\n                // Don\'t try to rename again if we are already renaming\r\n                if (_isInRename($selected)) {\r\n                    return;\r\n                }\r\n                \r\n                var isFolder = $selected.hasClass("jstree-open") || $selected.hasClass("jstree-closed");\r\n        \r\n                _projectTree.one("rename.jstree", function (event, data) {\r\n                    var unescapedOldName = _.unescape(data.rslt.old_name),\r\n                        unescapedNewName = _.unescape(data.rslt.new_name),\r\n                        // Make sure the file was actually renamed\r\n                        changed = (unescapedOldName !== unescapedNewName);\r\n                    \r\n                    var _resetOldFilename = function () {\r\n                        _projectTree.jstree("set_text", $selected, ViewUtils.getFileEntryDisplay(entry));\r\n                    };\r\n                    \r\n                    if (!changed || !_checkForValidFilename(unescapedNewName, isFolder)) {\r\n                        // No change or invalid filename. Reset the old name and bail.\r\n                        _resetOldFilename();\r\n                        return;\r\n                    }\r\n                    \r\n                    var oldFullPath = $selected.data("entry").fullPath;\r\n                    // Folder paths have to end with a slash. Use look-head (?=...) to only replace the folder\'s name, not the slash as well\r\n                    \r\n                    var oldNameEndPattern = isFolder ? "(?=\\/$)" : "$";\r\n                    var oldNameRegex = new RegExp(StringUtils.regexEscape(unescapedOldName) + oldNameEndPattern);\r\n                    var newName = oldFullPath.replace(oldNameRegex, unescapedNewName);\r\n                    \r\n                    renameItem(oldFullPath, newName, isFolder)\r\n                        .done(function () {\r\n                            _projectTree.jstree("set_text", $selected, ViewUtils.getFileEntryDisplay(entry));\r\n                            \r\n                            // Update caches: compareString and fullPathToIdMap\r\n                            $selected.data("compareString", _toCompareString(entry.name, isFolder));\r\n                            _deleteTreeNodeCache(oldFullPath);\r\n                            _insertTreeNodeCache(entry, $selected.attr("id"));\r\n                            \r\n                            // If a folder was renamed, re-select it here, since openAndSelectDocument()\r\n                            // changed the selection.\r\n                            if (isFolder) {\r\n                                var oldSuppressToggleOpen = suppressToggleOpen;\r\n                                \r\n                                // Supress the open/close toggle\r\n                                suppressToggleOpen = true;\r\n                                _projectTree.jstree("select_node", $selected, true);\r\n                                suppressToggleOpen = oldSuppressToggleOpen;\r\n                            }\r\n                        })\r\n                        .fail(function (err) {\r\n                            // Error during rename. Reset to the old name and alert the user.\r\n                            _resetOldFilename();\r\n                        })\r\n                        .always(function () {\r\n                            _projectTree.jstree("sort", $selected.parent());\r\n                            _redraw(true);\r\n                        });\r\n                });\r\n                \r\n                // Since html_titles are enabled, we have to reset the text without markup.\r\n                // And we also need to explicitly escape all html-sensitive characters.\r\n                var escapedName = _.escape(entry.name);\r\n                _projectTree.jstree("set_text", $selected, escapedName);\r\n                _projectTree.jstree("rename");\r\n\r\n                var extension = FileUtils.getSmartFileExtension(entry.name);\r\n                if (extension) {\r\n                    var indexOfExtension = escapedName.length - extension.length - 1;\r\n                    if (indexOfExtension > 0) {\r\n                        $selected.children(".jstree-rename-input")[0].setSelectionRange(0, indexOfExtension);\r\n                    }\r\n                }\r\n            });\r\n        // No fail handler: silently no-op if file doesn\'t exist in tree\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Deletes a node from jstree. Does not make assumptions on file existence.\r\n     * @param {FileSystemEntry|Array.<FileSystemEntry>} target Entry or array of entries to delete\r\n     * @param {boolean} skipRedraw\r\n     */\r\n    function _deleteTreeNode(target, skipRedraw) {\r\n        var arr = !Array.isArray(target) ? [target] : target,\r\n            oldSuppressToggleOpen = suppressToggleOpen,\r\n            treeAPI = $.jstree._reference(_projectTree);\r\n        \r\n        suppressToggleOpen = true;\r\n        \r\n        arr.forEach(function (entry) {\r\n            var $treeNode = _getTreeNode(entry),\r\n                parentEntry,\r\n                parentNode,\r\n                siblings,\r\n                parentWasOpen = false;\r\n\r\n            // Save parent node open/closed state for non-root nodes\r\n            if (entry.parentPath) {\r\n                parentEntry = FileSystem.getDirectoryForPath(entry.parentPath);\r\n                parentNode  = (parentEntry !== getProjectRoot()) && _getTreeNode(parentEntry);\r\n\r\n                if (parentNode) {\r\n                    parentWasOpen = parentNode.hasClass("jstree-open");\r\n                }\r\n            }\r\n            \r\n            if ($treeNode) {\r\n                _projectTree.jstree("delete_node", $treeNode);\r\n                _deleteTreeNodeCache(entry);\r\n                \r\n                if (parentNode) {\r\n                    siblings    = treeAPI._get_children(parentNode);\r\n                    \r\n                    // Make sure it didn\'t turn into a leaf node. This happens if\r\n                    // the only file in the directory was deleted\r\n                    if (siblings.length === 0 && parentNode.hasClass("jstree-leaf")) {\r\n                        parentNode.removeClass("jstree-leaf jstree-open jstree-closed");\r\n\r\n                        // Only apply style if parent is a tree node (i.e. not project root)\r\n                        if (parentWasOpen) {\r\n                            parentNode.addClass("jstree-open");\r\n                        } else {\r\n                            parentNode.addClass("jstree-closed");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        \r\n        suppressToggleOpen = oldSuppressToggleOpen;\r\n        \r\n        if (!skipRedraw) {\r\n            _redraw(true);\r\n        }\r\n        \r\n        // Trigger notifications after tree updates are complete\r\n        arr.forEach(function (entry) {\r\n            DocumentManager.notifyPathDeleted(entry.fullPath);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Delete file or directore from project\r\n     * @param {!(File|Directory)} entry File or Directory to delete\r\n     */\r\n    function deleteItem(entry) {\r\n        var result = new $.Deferred();\r\n\r\n        entry.moveToTrash(function (err) {\r\n            if (!err) {\r\n                _deleteTreeNode(entry);\r\n                result.resolve();\r\n            } else {\r\n                _showErrorDialog(ERR_TYPE_DELETE, entry.isDirectory, FileUtils.getFileErrorString(err), entry.fullPath);\r\n    \r\n                result.reject(err);\r\n            }\r\n        });\r\n\r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Returns a promise that resolves with a cached copy of all project files.\r\n     * Used by ProjectManager.getAllFiles(). Ensures that at most one un-cached\r\n     * directory traversal is active at a time, which is useful at project load\r\n     * time when watchers (and hence filesystem-level caching) has not finished\r\n     * starting up. The cache is cleared on every filesystem change event, and\r\n     * also on project load and unload.\r\n     * \r\n     * @private\r\n     * @return {jQuery.Promise.<Array.<File>>}\r\n     */\r\n    function _getAllFilesCache() {\r\n        if (!_allFilesCachePromise) {\r\n            var deferred = new $.Deferred(),\r\n                allFiles = [],\r\n                allFilesVisitor = function (entry) {\r\n                    if (shouldShow(entry)) {\r\n                        if (entry.isFile) {\r\n                            allFiles.push(entry);\r\n                        }\r\n                        return true;\r\n                    }\r\n                    return false;\r\n                };\r\n\r\n            _allFilesCachePromise = deferred.promise();\r\n            \r\n            getProjectRoot().visit(allFilesVisitor, function (err) {\r\n                if (err) {\r\n                    if (err === FileSystemError.TOO_MANY_ENTRIES && !_projectWarnedForTooManyFiles) {\r\n                        _showErrorDialog(ERR_TYPE_MAX_FILES);\r\n                        _projectWarnedForTooManyFiles = true;\r\n                    }\r\n                    deferred.reject(err);\r\n                } else {\r\n                    deferred.resolve(allFiles);\r\n                }\r\n            });\r\n        }\r\n        \r\n        return _allFilesCachePromise;\r\n    }\r\n    \r\n    /**\r\n     * Returns an Array of all files for this project, optionally including\r\n     * files in the working set that are *not* under the project root. Files filtered\r\n     * out by shouldShow().\r\n     *\r\n     * @param {function (File, number):boolean=} filter Optional function to filter\r\n     *          the file list (does not filter directory traversal). API matches Array.filter().\r\n     * @param {boolean=} includeWorkingSet If true, include files in the working set\r\n     *          that are not under the project root (*except* for untitled documents).\r\n     *\r\n     * @return {$.Promise} Promise that is resolved with an Array of File objects.\r\n     */\r\n    function getAllFiles(filter, includeWorkingSet) {\r\n        // The filter and includeWorkingSet params are both optional.\r\n        // Handle the case where filter is omitted but includeWorkingSet is\r\n        // specified.\r\n        if (includeWorkingSet === undefined && typeof (filter) !== "function") {\r\n            includeWorkingSet = filter;\r\n            filter = null;\r\n        }\r\n        \r\n        var filteredFilesDeferred = new $.Deferred();\r\n        \r\n        // First gather all files in project proper\r\n        _getAllFilesCache()\r\n            .done(function (result) {\r\n            // Add working set entries, if requested\r\n                if (includeWorkingSet) {\r\n                    MainViewManager.getWorkingSet(MainViewManager.ALL_PANES).forEach(function (file) {\r\n                        if (result.indexOf(file) === -1 && !(file instanceof InMemoryFile)) {\r\n                            result.push(file);\r\n                        }\r\n                    });\r\n                }\r\n\r\n                // Filter list, if requested\r\n                if (filter) {\r\n                    result = result.filter(filter);\r\n                }\r\n\r\n                // If a done handler attached to the returned filtered files promise\r\n                // throws an exception that isn\'t handled here then it will leave\r\n                // _allFilesCachePromise in an inconsistent state such that no\r\n                // additional done handlers will ever be called!\r\n                try {\r\n                    filteredFilesDeferred.resolve(result);\r\n                } catch (e) {\r\n                    console.warn("Unhandled exception in getAllFiles handler: ", e);\r\n                }\r\n            })\r\n            .fail(function (err) {\r\n                // resolve with empty list\r\n                try {\r\n                    filteredFilesDeferred.resolve([]);\r\n                } catch (e) {\r\n                    console.warn("Unhandled exception in getAllFiles handler: ", e);\r\n                }\r\n            });\r\n        \r\n        return filteredFilesDeferred.promise();\r\n    }\r\n    \r\n    /**\r\n     * Returns a filter for use with getAllFiles() that filters files based on LanguageManager language id\r\n     * @param {!(string|Array.<string>)} languageId a single string of a language id or an array of language ids\r\n     * @return {!function(File):boolean}\r\n     */\r\n    function getLanguageFilter(languageId) {\r\n        return function languageFilter(file) {\r\n            var id = LanguageManager.getLanguageForPath(file.fullPath).getId();\r\n            if (typeof languageId === "string") {\r\n                return (id === languageId);\r\n            } else {\r\n                return (languageId.indexOf(id) !== -1);\r\n            }\r\n        };\r\n    }\r\n        \r\n    /**\r\n     * @private \r\n     * Respond to a FileSystem change event. Note that if renames are initiated\r\n     * externally, they may be reported as a separate removal and addition. In\r\n     * this case, the editor state isn\'t currently preserved.\r\n     * \r\n     * @param {$.Event} event\r\n     * @param {?(File|Directory)} entry File or Directory changed\r\n     * @param {Array.<FileSystemEntry>=} added If entry is a Directory, contains zero or more added children\r\n     * @param {Array.<FileSystemEntry>=} removed If entry is a Directory, contains zero or more removed children\r\n     */\r\n    _fileSystemChange = function (event, entry, added, removed) {\r\n        FileSyncManager.syncOpenDocuments();\r\n        \r\n        // Reset allFiles cache\r\n        _allFilesCachePromise = null;\r\n\r\n        // A whole-sale change event; refresh the entire file tree\r\n        if (!entry) {\r\n            refreshFileTree();\r\n            return;\r\n        }\r\n        \r\n        var $directoryNode = _getTreeNode(entry);\r\n        \r\n        // Ignore change event when: the entry is not a directory, the directory\r\n        // was not yet rendered or the directory is outside the current project\r\n        if (!entry.isDirectory || !$directoryNode || !isWithinProject(entry.fullPath)) {\r\n            return;\r\n        }\r\n        \r\n        // If there is a change event with unknown added and removed sets\r\n        // just refresh the tree.\r\n        // \r\n        // TODO: in the former case we really should just refresh the affected\r\n        // directory instead of refreshing the entire tree.\r\n        if (!added || !removed) {\r\n            refreshFileTree();\r\n            return;\r\n        }\r\n\r\n        var wasOpen = $directoryNode.hasClass("jstree-open"),\r\n            doRedraw = false;\r\n        \r\n        // Directory contents removed\r\n        if (removed.length > 0) {\r\n            // Synchronously remove all tree nodes\r\n            _deleteTreeNode(removed, true);\r\n            doRedraw = true;\r\n        }\r\n\r\n        // Before creating new nodes, make sure it doesn\'t already exist\r\n        var addedJSON = added.filter(function (addedEntry) {\r\n            return !_getTreeNode(addedEntry);\r\n        });\r\n\r\n        // Convert entries to JSON objects for jstree\r\n        addedJSON = addedJSON.map(_entryToJSON);\r\n\r\n        // Directory contents added\r\n        if (addedJSON.length > 0) {\r\n            var isClosed = $directoryNode.hasClass("jstree-closed");\r\n\r\n            // Manually force the directory to open in case it was auto-closed\r\n            // when deleting the files in the removed file set for this event.\r\n            // This starts an async call to load_node/Directory.getContents().\r\n            // We do this to avoid a race condition in jstree create_node where\r\n            // jstree attempts to load empty nodes during the create workflow,\r\n            // resulting in duplicate nodes for the same entry, see\r\n            // https://github.com/adobe/brackets/issues/6474.\r\n            if (wasOpen && isClosed) {\r\n                _projectTree.one("open_node.jstree", function () {\r\n                    _redraw(true);\r\n                });\r\n        \r\n                // Open the node before creating the new child\r\n                _projectTree.jstree("open_node", $directoryNode);\r\n            } else {\r\n                // We can only incrementally create new child nodes when the \r\n                // DOM node for the directory is not currently empty. The reason\r\n                // is due to the fact that jstree treats empty DOM folders as\r\n                // not-loaded. When jstree sees this, it calls the JSON data\r\n                // provider to populate the DOM, always. Creating a node in this\r\n                // state leads to duplicate nodes. Avoid this by calling load_node\r\n                // instead of create_node.\r\n                var treeAPI = $.jstree._reference(_projectTree),\r\n                    directoryNodeOrRoot = (entry === getProjectRoot()) ? -1 : $directoryNode,\r\n                    hasDOMChildren = treeAPI._get_children(directoryNodeOrRoot).length > 0;\r\n                \r\n                if (hasDOMChildren) {\r\n                    // The directory was already loaded and currently has\r\n                    // children, so we can incrementally create all new nodes\r\n                    // in a batch\r\n                    _createNode($directoryNode, null, addedJSON, true, true);\r\n                } else if (!isClosed) {\r\n                    // Call load_node for the directory to add the new entries\r\n                    // for this change event. We only call load_node immediately\r\n                    // in the case where the empty directory DOM node was\r\n                    // already open. If the directory is currently closed,\r\n                    // jstree will call load_node when the user opens the node\r\n                    // interactively\r\n                    _projectTree.jstree("load_node", $directoryNode, function () {}, function () {\r\n                        console.error("Error loading project tree for changed path: " + entry.fullPath);\r\n                    });\r\n                }\r\n                \r\n                doRedraw = true;\r\n            }\r\n        }\r\n        \r\n        if (doRedraw) {\r\n            _redraw(true);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Respond to a FileSystem rename event.\r\n     */\r\n    _fileSystemRename = function (event, oldName, newName) {\r\n        // Tell the document manager about the name change. This will update\r\n        // all of the model information and send notification to all views\r\n        DocumentManager.notifyPathNameChanged(oldName, newName);\r\n    };\r\n    \r\n    \r\n    \r\n    // Initialize variables and listeners that depend on the HTML DOM\r\n    AppInit.htmlReady(function () {\r\n        $projectTreeContainer = $("#project-files-container");\r\n        \r\n        $("#open-files-container").on("contentChanged", function () {\r\n            _redraw(false); // redraw jstree when working set size changes\r\n        });\r\n        \r\n        $(".main-view").click(function (jqEvent) {\r\n            if (jqEvent.target.className !== "jstree-rename-input") {\r\n                forceFinishRename();\r\n            }\r\n        });\r\n        \r\n        $projectTreeContainer.on("contextmenu", function () {\r\n            forceFinishRename();\r\n        });\r\n    });\r\n\r\n    /**\r\n     * @private\r\n     * Examine each preference key for migration of project tree states.\r\n     * If the key has a prefix of "projectTreeState_/", then it is a project tree states\r\n     * preference from old preference model.\r\n     *\r\n     * @param {string} key The key of the preference to be examined\r\n     *      for migration of project tree states.\r\n     * @return {?string} - the scope to which the preference is to be migrated\r\n     */\r\n    function _checkPreferencePrefix(key) {\r\n        var pathPrefix = "projectTreeState_",\r\n            projectPath;\r\n        if (key.indexOf(pathPrefix) === 0) {\r\n            // Get the project path from the old preference key by stripping "projectTreeState_".\r\n            projectPath = key.substr(pathPrefix.length);\r\n            return "user project.treeState " + projectPath;\r\n        }\r\n        \r\n        pathPrefix = "projectBaseUrl_";\r\n        if (key.indexOf(pathPrefix) === 0) {\r\n            // Get the project path from the old preference key by stripping "projectBaseUrl_[Directory "\r\n            // and "]".\r\n            projectPath = key.substr(key.indexOf(" ") + 1);\r\n            projectPath = projectPath.substr(0, projectPath.length - 1);\r\n            return "user project.baseUrl " + projectPath;\r\n        }\r\n\r\n        return null;\r\n    }\r\n    \r\n    // Init default project path to welcome project\r\n    PreferencesManager.stateManager.definePreference("projectPath", "string", _getWelcomeProjectPath());\r\n\r\n    PreferencesManager.convertPreferences(module, {\r\n        "projectPath": "user",\r\n        "projectTreeState_": "user",\r\n        "welcomeProjects": "user",\r\n        "projectBaseUrl_": "user"\r\n    }, true, _checkPreferencePrefix);\r\n    \r\n    // Initialize the sort prefixes and make sure to change them when the sort pref changes\r\n    _generateSortPrefixes();\r\n    PreferencesManager.on("change", "sortDirectoriesFirst", function () {\r\n        if (_generateSortPrefixes()) {\r\n            refreshFileTree();\r\n        }\r\n    });\r\n    \r\n    // Event Handlers\r\n    $(FileViewController).on("documentSelectionFocusChange", _documentSelectionFocusChange);\r\n    $(FileViewController).on("fileViewFocusChange", _fileViewFocusChange);\r\n    $(exports).on("beforeAppClose", _unwatchProjectRoot);\r\n    \r\n    // Commands\r\n    CommandManager.register(Strings.CMD_OPEN_FOLDER,      Commands.FILE_OPEN_FOLDER,      openProject);\r\n    CommandManager.register(Strings.CMD_PROJECT_SETTINGS, Commands.FILE_PROJECT_SETTINGS, _projectSettings);\r\n    CommandManager.register(Strings.CMD_FILE_REFRESH,     Commands.FILE_REFRESH,          refreshFileTree);\r\n    \r\n    // Init invalid characters string \r\n    if (brackets.platform === "mac") {\r\n        _invalidChars = "?*|:";\r\n    } else if (brackets.platform === "linux") {\r\n        _invalidChars = "?*|/";\r\n    } else {\r\n        _invalidChars = "/?*:<>\\\\|\\"";  // invalid characters on Windows\r\n    }\r\n\r\n    // Define public API\r\n    exports.getProjectRoot           = getProjectRoot;\r\n    exports.getBaseUrl               = getBaseUrl;\r\n    exports.setBaseUrl               = setBaseUrl;\r\n    exports.isWithinProject          = isWithinProject;\r\n    exports.makeProjectRelativeIfPossible = makeProjectRelativeIfPossible;\r\n    exports.shouldShow               = shouldShow;\r\n    exports.isBinaryFile             = isBinaryFile;\r\n    exports.openProject              = openProject;\r\n    exports.getSelectedItem          = getSelectedItem;\r\n    exports.getInitialProjectPath    = getInitialProjectPath;\r\n    exports.isWelcomeProjectPath     = isWelcomeProjectPath;\r\n    exports.updateWelcomeProjectPath = updateWelcomeProjectPath;\r\n    exports.createNewItem            = createNewItem;\r\n    exports.renameItemInline         = renameItemInline;\r\n    exports.deleteItem               = deleteItem;\r\n    exports.forceFinishRename        = forceFinishRename;\r\n    exports.showInTree               = showInTree;\r\n    exports.refreshFileTree          = refreshFileTree;\r\n    exports.getAllFiles              = getAllFiles;\r\n    exports.getLanguageFilter        = getLanguageFilter;\r\n});\r\n\n//# sourceURL=/project/ProjectManager.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\ndefine(\'language/HTMLUtils\',[\'require\',\'exports\',\'module\',\'thirdparty/CodeMirror2/lib/codemirror\',\'utils/TokenUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var CodeMirror = require("thirdparty/CodeMirror2/lib/codemirror"),\r\n        TokenUtils = require("utils/TokenUtils");\r\n    \r\n    // Constants\r\n    var TAG_NAME = "tagName",\r\n        CLOSING_TAG = "closingTag",\r\n        ATTR_NAME = "attr.name",\r\n        ATTR_VALUE = "attr.value";\r\n    \r\n    // Regular expression for token types with "tag" prefixed\r\n    var tagPrefixedRegExp = /^tag/;\r\n    \r\n   /**\r\n     * @private\r\n     * Sometimes as attr values are getting typed, if the quotes aren\'t balanced yet\r\n     * some extra \'non attribute value\' text gets included in the token. This attempts\r\n     * to assure the attribute value we grab is always good\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @return { val:{string}, offset:{number}}\r\n     */\r\n    function _extractAttrVal(ctx) {\r\n        var attrValue = ctx.token.string,\r\n            startChar = attrValue.charAt(0),\r\n            endChar = attrValue.charAt(attrValue.length - 1),\r\n            offset = TokenUtils.offsetInToken(ctx),\r\n            foundEqualSign = false;\r\n        \r\n        //If this is a fully quoted value, return the whole\r\n        //thing regardless of position\r\n        if (attrValue.length > 1 &&\r\n                (startChar === "\'" || startChar === \'"\') &&\r\n                endChar === startChar) {\r\n            \r\n            // Find an equal sign before the end quote. If found, \r\n            // then the user may be entering an attribute value right before \r\n            // another attribute and we\'re getting a false balanced string.\r\n            // An example of this case is <link rel" href="foo"> where the \r\n            // cursor is right after the first double quote.\r\n            foundEqualSign = (attrValue.match(/\\=\\s*[\'"]$/) !== null);\r\n            \r\n            if (!foundEqualSign) {\r\n                //strip the quotes and return;\r\n                attrValue = attrValue.substring(1, attrValue.length - 1);\r\n                offset = offset - 1 > attrValue.length ? attrValue.length : offset - 1;\r\n                return {val: attrValue, offset: offset, quoteChar: startChar, hasEndQuote: true};\r\n            }\r\n        }\r\n        \r\n        if (foundEqualSign) {\r\n            var spaceIndex = attrValue.indexOf(" "),\r\n                bracketIndex = attrValue.indexOf(">"),\r\n                upToIndex = (spaceIndex !== -1 && spaceIndex < bracketIndex) ? spaceIndex : bracketIndex;\r\n            attrValue = attrValue.substring(0, (upToIndex > offset) ? upToIndex : offset);\r\n        } else if (offset > 0 && (startChar === "\'" || startChar === \'"\')) {\r\n            //The att value is getting edit in progress. There is possible extra\r\n            //stuff in this token state since the quote isn\'t closed, so we assume\r\n            //the stuff from the quote to the current pos is definitely in the attribute \r\n            //value.\r\n            attrValue = attrValue.substring(0, offset);\r\n        }\r\n        \r\n        //If the attrValue start with a quote, trim that now\r\n        startChar = attrValue.charAt(0);\r\n        if (startChar === "\'" || startChar === \'"\') {\r\n            attrValue = attrValue.substring(1);\r\n            offset--;\r\n        } else {\r\n            startChar = "";\r\n            // Make attr value empty and set offset to zero if it has the ">" \r\n            // which is the closing of the tag.\r\n            if (endChar === ">") {\r\n                attrValue = "";\r\n                offset = 0;\r\n            }\r\n        }\r\n        \r\n        return {val: attrValue, offset: offset, quoteChar: startChar, hasEndQuote: false};\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Gets the tagname from where ever you are in the currect state\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @return {string}\r\n     */\r\n    function _extractTagName(ctx) {\r\n        var mode = ctx.editor.getMode(),\r\n            innerModeData = CodeMirror.innerMode(mode, ctx.token.state);\r\n\r\n        if (ctx.token.type === "tag bracket") {\r\n            return innerModeData.state.tagName;\r\n        }\r\n        \r\n        // If the ctx is inside the tag name of an end tag, innerModeData.state.tagName is\r\n        // undefined. So return token string as the tag name.\r\n        return innerModeData.state.tagName || ctx.token.string;\r\n    }\r\n    \r\n    /**\r\n     * Compiles a list of used attributes for a given tag\r\n     * @param {CodeMirror} editor An instance of a CodeMirror editor\r\n     * @param {ch:{string}, line:{number}} pos A CodeMirror position\r\n     * @return {Array.<string>} A list of the used attributes inside the current tag\r\n     */\r\n    function getTagAttributes(editor, pos) {\r\n        var attrs       = [],\r\n            backwardCtx = TokenUtils.getInitialContext(editor._codeMirror, pos),\r\n            forwardCtx  = $.extend({}, backwardCtx);\r\n        \r\n        if (editor.getModeForSelection() === "html") {\r\n            if (backwardCtx.token && !tagPrefixedRegExp.test(backwardCtx.token.type)) {\r\n                while (TokenUtils.movePrevToken(backwardCtx) && !tagPrefixedRegExp.test(backwardCtx.token.type)) {\r\n                    if (backwardCtx.token.type === "error" && backwardCtx.token.string.indexOf("<") === 0) {\r\n                        break;\r\n                    }\r\n                    if (backwardCtx.token.type === "attribute") {\r\n                        attrs.push(backwardCtx.token.string);\r\n                    }\r\n                }\r\n                \r\n                while (TokenUtils.moveNextToken(forwardCtx) && !tagPrefixedRegExp.test(forwardCtx.token.type)) {\r\n                    if (forwardCtx.token.type === "attribute") {\r\n                        // If the current tag is not closed, codemirror may return the next opening\r\n                        // tag as an attribute. Stop the search loop in that case.\r\n                        if (forwardCtx.token.string.indexOf("<") === 0) {\r\n                            break;\r\n                        }\r\n                        attrs.push(forwardCtx.token.string);\r\n                    } else if (forwardCtx.token.type === "error") {\r\n                        if (forwardCtx.token.string.indexOf("<") === 0 || forwardCtx.token.string.indexOf(">") === 0) {\r\n                            break;\r\n                        }\r\n                        // If we type the first letter of the next attribute, it comes as an error\r\n                        // token. We need to double check for possible invalidated attributes.\r\n                        if (/\\S/.test(forwardCtx.token.string) &&\r\n                                forwardCtx.token.string.indexOf("\\"") === -1 &&\r\n                                forwardCtx.token.string.indexOf("\'") === -1 &&\r\n                                forwardCtx.token.string.indexOf("=") === -1) {\r\n                            attrs.push(forwardCtx.token.string);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        return attrs;\r\n    }\r\n    \r\n    /**\r\n     * Creates a tagInfo object and assures all the values are entered or are empty strings\r\n     * @param {string=} tokenType what is getting edited and should be hinted\r\n     * @param {number=} offset where the cursor is for the part getting hinted\r\n     * @param {string=} tagName The name of the tag\r\n     * @param {string=} attrName The name of the attribute\r\n     * @param {string=} attrValue The value of the attribute\r\n     * @return {{tagName:string,\r\n     *           attr:{name:string, value:string, valueAssigned:boolean, quoteChar:string, hasEndQuote:boolean},\r\n     *           position:{tokenType:string, offset:number}\r\n     *         }}\r\n     *         A tagInfo object with some context about the current tag hint.\r\n     */\r\n    function createTagInfo(tokenType, offset, tagName, attrName, attrValue, valueAssigned, quoteChar, hasEndQuote) {\r\n        return { tagName: tagName || "",\r\n                 attr:\r\n                    { name: attrName || "",\r\n                      value: attrValue || "",\r\n                      valueAssigned: valueAssigned || false,\r\n                      quoteChar: quoteChar || "",\r\n                      hasEndQuote: hasEndQuote || false },\r\n                 position:\r\n                    { tokenType: tokenType || "",\r\n                      offset: offset || 0 } };\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Gets the taginfo starting from the attribute value and moving backwards\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @return {string}\r\n     */\r\n    function _getTagInfoStartingFromAttrValue(ctx) {\r\n        // Assume we in the attr value\r\n        // and validate that by going backwards\r\n        var attrInfo = _extractAttrVal(ctx),\r\n            attrVal = attrInfo.val,\r\n            offset = attrInfo.offset,\r\n            quoteChar = attrInfo.quoteChar,\r\n            hasEndQuote = attrInfo.hasEndQuote,\r\n            strLength = ctx.token.string.length;\r\n        \r\n        if ((ctx.token.type === "string" || ctx.token.type === "error") &&\r\n                ctx.pos.ch === ctx.token.end && strLength > 1) {\r\n            var firstChar = ctx.token.string[0],\r\n                lastChar = ctx.token.string[strLength - 1];\r\n            \r\n            // We get here only when the cursor is immediately on the right of the end quote\r\n            // of an attribute value. So we want to return an empty tag info so that the caller\r\n            // can dismiss the code hint popup if it is still open.\r\n            if (firstChar === lastChar && (firstChar === "\'" || firstChar === "\\"")) {\r\n                return createTagInfo();\r\n            }\r\n        }\r\n        \r\n        //Move to the prev token, and check if it\'s "="\r\n        if (!TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx) || ctx.token.string !== "=") {\r\n            return createTagInfo();\r\n        }\r\n        \r\n        //Move to the prev token, and check if it\'s an attribute\r\n        if (!TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx) || ctx.token.type !== "attribute") {\r\n            return createTagInfo();\r\n        }\r\n        \r\n        var attrName = ctx.token.string;\r\n        var tagName = _extractTagName(ctx);\r\n \r\n        //We\'re good. \r\n        return createTagInfo(ATTR_VALUE, offset, tagName, attrName, attrVal, true, quoteChar, hasEndQuote);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Gets the taginfo starting from the attribute name and moving forwards\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @param {boolean} isPriorAttr indicates whether we\'re getting info for a prior attribute\r\n     * @return {string}\r\n     */\r\n    function _getTagInfoStartingFromAttrName(ctx, isPriorAttr) {\r\n        //Verify We\'re in the attribute name, move forward and try to extract the rest of\r\n        //the info. If the user it typing the attr the rest might not be here\r\n        if (isPriorAttr === false && ctx.token.type !== "attribute") {\r\n            return createTagInfo();\r\n        }\r\n        \r\n        var tagName = _extractTagName(ctx);\r\n        var attrName = ctx.token.string;\r\n        var offset = TokenUtils.offsetInToken(ctx);\r\n        \r\n        if (!TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx) || ctx.token.string !== "=") {\r\n            // If we\'re checking for a prior attribute and the next token we get is a tag or an html comment or\r\n            // an undefined token class, then we\'ve already scanned past our original cursor location. \r\n            // So just return an empty tag info.\r\n            if (isPriorAttr &&\r\n                    (!ctx.token.type ||\r\n                    (ctx.token.type && ctx.token.type !== "attribute" &&\r\n                        ctx.token.type.indexOf("error") === -1 &&\r\n                        ctx.token.string.indexOf("<") !== -1))) {\r\n                return createTagInfo();\r\n            }\r\n            return createTagInfo(ATTR_NAME, offset, tagName, attrName);\r\n        }\r\n        \r\n        if (!TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx)) {\r\n            return createTagInfo(ATTR_NAME, offset, tagName, attrName);\r\n        }\r\n        //this should be the attrvalue\r\n        var attrInfo = _extractAttrVal(ctx),\r\n            attrVal = attrInfo.val,\r\n            quoteChar = attrInfo.quoteChar,\r\n            hasEndQuote = attrInfo.hasEndQuote;\r\n        \r\n        return createTagInfo(ATTR_NAME, offset, tagName, attrName, attrVal, true, quoteChar, hasEndQuote);\r\n    }\r\n    \r\n    /**\r\n     * Figure out if we\'re in a tag, and if we are return info about it\r\n     * An example token stream for this tag is <span id="open-files-disclosure-arrow"></span> : \r\n     *      className:tag       string:"<span"\r\n     *      className:          string:" "\r\n     *      className:attribute string:"id"\r\n     *      className:          string:"="\r\n     *      className:string    string:""open-files-disclosure-arrow""\r\n     *      className:tag       string:"></span>"\r\n     * @param {Editor} editor An instance of a Brackets editor\r\n     * @param {{ch: number, line: number}} constPos  A CM pos (likely from editor.getCursorPos())\r\n     * @return {{tagName:string,\r\n     *           attr:{name:string, value:string, valueAssigned:boolean, quoteChar:string, hasEndQuote:boolean},\r\n     *           position:{tokenType:string, offset:number}\r\n     *         }}\r\n     *         A tagInfo object with some context about the current tag hint.\r\n     */\r\n    function getTagInfo(editor, constPos) {\r\n        // We\'re going to be changing pos a lot, but we don\'t want to mess up\r\n        // the pos the caller passed in so we use extend to make a safe copy of it.	\r\n        var pos = $.extend({}, constPos),\r\n            ctx = TokenUtils.getInitialContext(editor._codeMirror, pos),\r\n            tempCtx = null,\r\n            offset = TokenUtils.offsetInToken(ctx),\r\n            tagInfo,\r\n            tokenType;\r\n        \r\n        // Check if this is inside a style block.\r\n        if (editor.getModeForSelection() !== "html") {\r\n            return createTagInfo();\r\n        }\r\n        \r\n        // Check and see where we are in the tag\r\n        if (ctx.token.string.length > 0 && !/\\S/.test(ctx.token.string)) {\r\n\r\n            // token at (i.e. before) pos is whitespace, so test token at next pos\r\n            //\r\n            // note: getTokenAt() does range checking for ch. If it detects that ch is past\r\n            // EOL, it uses EOL, same token is returned, and the following condition fails,\r\n            // so we don\'t need to worry about testPos being valid.\r\n            var testPos = {ch: ctx.pos.ch + 1, line: ctx.pos.line},\r\n                testToken = editor._codeMirror.getTokenAt(testPos, true);\r\n\r\n            if (testToken.string.length > 0 && /\\S/.test(testToken.string) &&\r\n                    testToken.string.charAt(0) !== ">") {\r\n                // pos has whitespace before it and non-whitespace after it, so use token after\r\n                ctx.token = testToken;\r\n\r\n                // Check whether the token type is one of the types prefixed with "tag"\r\n                // (e.g. "tag", "tag error", "tag brackets")\r\n                if (tagPrefixedRegExp.test(ctx.token.type)) {\r\n                    // Check to see if the cursor is just before a "<" but not in any tag.\r\n                    if (ctx.token.string.charAt(0) === "<") {\r\n                        return createTagInfo();\r\n                    }\r\n                } else if (ctx.token.type === "attribute") {\r\n                    // Check to see if the user is going to add a new attr before an existing one\r\n                    return _getTagInfoStartingFromAttrName(ctx, false);\r\n                } else if (ctx.token.string === "=") {\r\n                    // We\'re between a whitespace and  "=", so return an empty tag info.\r\n                    return createTagInfo();\r\n                }\r\n            } else {\r\n                // We get here if ">" or white spaces after testPos.\r\n                // Check if there is an equal sign after testPos by creating a new ctx\r\n                // with the original pos. We can\'t use the current ctx since we need to \r\n                // use it to scan backwards if we don\'t find an equal sign here.\r\n                // Comment out this block to fix issue #1510.\r\n//                if (testToken.string.length > 0 && testToken.string.charAt(0) !== ">") {\r\n//                    tempCtx = TokenUtils.getInitialContext(editor._codeMirror, pos);\r\n//                    if (TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, tempCtx) && tempCtx.token.string === "=") {\r\n//                        // Return an empty tag info since we\'re between an atribute name and the equal sign.\r\n//                        return createTagInfo();\r\n//                    }\r\n//                }\r\n\r\n                // next, see what\'s before pos\r\n                if (!TokenUtils.movePrevToken(ctx)) {\r\n                    return createTagInfo();\r\n                }\r\n\r\n                if (ctx.token.type === "comment") {\r\n                    return createTagInfo();\r\n                } else if (!tagPrefixedRegExp.test(ctx.token.type) && ctx.token.string !== "=") {\r\n                    // If it wasn\'t the tag name, assume it was an attr value\r\n                    // Also we don\'t handle the "=" here.\r\n                    tagInfo = _getTagInfoStartingFromAttrValue(ctx);\r\n\r\n                    // Check to see if this is the closing of a tag (either the start or end)\r\n                    // or a comment tag.\r\n                    if (ctx.token.type === "comment" ||\r\n                            (tagPrefixedRegExp.test(ctx.token.type) &&\r\n                            (ctx.token.string === ">" || ctx.token.string === "/>" ||\r\n                                ctx.token.string === "</"))) {\r\n                        return createTagInfo();\r\n                    }\r\n                    \r\n                    // If it wasn\'t an attr value, assume it was an empty attr (ie. attr with no value)\r\n                    if (!tagInfo.tagName) {\r\n                        tagInfo = _getTagInfoStartingFromAttrName(ctx, true);\r\n                    }\r\n\r\n                    // We don\'t want to give context for the previous attr\r\n                    // and we want it to look like the user is going to add a new attr\r\n                    if (tagInfo.tagName) {\r\n                        return createTagInfo(ATTR_NAME, 0, tagInfo.tagName);\r\n                    }\r\n                    return createTagInfo();\r\n                }\r\n                \r\n                // We know the tag was here, so the user is adding an attr name\r\n                tokenType = ATTR_NAME;\r\n                offset = 0;\r\n            }\r\n        }\r\n        \r\n        if (tagPrefixedRegExp.test(ctx.token.type)) {\r\n            if (ctx.token.type !== "tag bracket") {\r\n                // Check if the user just typed a white space after "<" that made an existing tag invalid.\r\n                if (TokenUtils.movePrevToken(ctx) && !/\\S/.test(ctx.token.string)) {\r\n                    return createTagInfo();\r\n                }\r\n\r\n                // Check to see if this is a closing tag\r\n                if (ctx.token.type === "tag bracket" && ctx.token.string === "</") {\r\n                    tokenType = CLOSING_TAG;\r\n                }\r\n\r\n                // Restore the original ctx by moving back to next context since we call\r\n                // movePrevToken above to detect "<" or "</".\r\n                TokenUtils.moveNextToken(ctx);\r\n            }\r\n            \r\n            // Check to see if this is the closing of a start tag or a self closing tag\r\n            if (ctx.token.string === ">" || ctx.token.string === "/>") {\r\n                return createTagInfo();\r\n            }\r\n            \r\n            // Make sure the cursor is not after an equal sign or a quote before we report the context as a tag.\r\n            if (ctx.token.string !== "=" && ctx.token.string.match(/^["\']/) === null) {\r\n                if (!tokenType) {\r\n                    tokenType = TAG_NAME;\r\n                    if (ctx.token.type === "tag bracket") {\r\n                        // Check to see if this is a closing tag\r\n                        if (ctx.token.string === "</") {\r\n                            tokenType = CLOSING_TAG;\r\n                            offset -= 2;\r\n                        } else {\r\n                            offset = 0;\r\n                        }\r\n                        // If the cursor is right after the "<" or "</", then \r\n                        // move context to next one so that _extractTagName\r\n                        // call below can get the tag name if there is one.\r\n                        if (offset === 0) {\r\n                            TokenUtils.moveNextToken(ctx);\r\n                        }\r\n                    }\r\n                }\r\n                \r\n                // We\'re actually in the tag, just return that as we have no relevant \r\n                // info about what attr is selected\r\n                return createTagInfo(tokenType, offset, _extractTagName(ctx));\r\n            }\r\n        }\r\n        \r\n        if (ctx.token.string === "=") {\r\n            // We could be between the attr and the value\r\n            // Step back and check\r\n            if (!TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx) || ctx.token.type !== "attribute") {\r\n                return createTagInfo();\r\n            }\r\n            \r\n            // The "=" is added, time to hint for values\r\n            tokenType = ATTR_VALUE;\r\n            offset = 0;\r\n        }\r\n        \r\n        if (ctx.token.type === "attribute") {\r\n            tagInfo = _getTagInfoStartingFromAttrName(ctx, false);\r\n            \r\n            // If we\'re in attr value, then we may need to calculate the correct offset\r\n            // from the beginning of the attribute value. If the cursor position is to \r\n            // the left of attr value, then the offset is negative.\r\n            // e.g. if the cursor is just to the right of the "=" in <a rel= "rtl", then\r\n            // the offset will be -2.\r\n            if (tagInfo.attr.quoteChar) {\r\n                offset = constPos.ch - ctx.pos.ch;\r\n            } else if (tokenType === ATTR_VALUE && (constPos.ch + 1) < ctx.pos.ch) {\r\n                // The cursor may be right before an unquoted attribute or another attribute name.\r\n                // Since we can\'t distinguish between them, we will empty the value so that the \r\n                // caller can just insert a new attribute value.\r\n                tagInfo.attr.value = "";\r\n            }\r\n        } else {\r\n            // if we\'re not at a tag, "=", or attribute name, assume we\'re in the value\r\n            tagInfo = _getTagInfoStartingFromAttrValue(ctx);\r\n        }\r\n        \r\n        if (tokenType && tagInfo.tagName) {\r\n            tagInfo.position.tokenType = tokenType;\r\n            tagInfo.position.offset = offset;\r\n        }\r\n        \r\n        return tagInfo;\r\n    }\r\n    \r\n    \r\n\r\n    /**\r\n     * Returns an Array of info about all blocks whose token mode name matches that passed in,\r\n     * in the given Editor\'s HTML document (assumes the Editor contains HTML text).\r\n     * @param {!Editor} editor - the editor containing the HTML text\r\n     * @param {string} modeName - the mode name of the tokens to look for\r\n     * @return {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, text:string}>}\r\n     */\r\n    function findBlocks(editor, modeName) {\r\n        // Start scanning from beginning of file\r\n        var ctx = TokenUtils.getInitialContext(editor._codeMirror, {line: 0, ch: 0}),\r\n            blocks = [],\r\n            currentBlock = null,\r\n            inBlock = false,\r\n            outerMode = editor._codeMirror.getMode(),\r\n            tokenModeName,\r\n            previousMode;\r\n        \r\n        while (TokenUtils.moveNextToken(ctx, false)) {\r\n            tokenModeName = CodeMirror.innerMode(outerMode, ctx.token.state).mode.name;\r\n            if (inBlock) {\r\n                if (!currentBlock.end) {\r\n                    // Handle empty blocks\r\n                    currentBlock.end = currentBlock.start;\r\n                }\r\n                // Check for end of this block\r\n                if (tokenModeName === previousMode) {\r\n                    // currentBlock.end is already set to pos of the last token by now\r\n                    currentBlock.text = editor.document.getRange(currentBlock.start, currentBlock.end);\r\n                    inBlock = false;\r\n                } else {\r\n                    currentBlock.end = { line: ctx.pos.line, ch: ctx.pos.ch };\r\n                }\r\n            } else {\r\n                // Check for start of a block\r\n                if (tokenModeName === modeName) {\r\n                    currentBlock = {\r\n                        start: { line: ctx.pos.line, ch: ctx.pos.ch }\r\n                    };\r\n                    blocks.push(currentBlock);\r\n                    inBlock = true;\r\n                } else {\r\n                    previousMode = tokenModeName;\r\n                }\r\n                // else, random token: ignore\r\n            }\r\n        }\r\n        \r\n        return blocks;\r\n    }\r\n\r\n    /**\r\n     * Returns an Array of info about all <style> blocks in the given Editor\'s HTML document (assumes\r\n     * the Editor contains HTML text).\r\n     * @param {!Editor} editor\r\n     * @return {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, text:string}>}\r\n     */\r\n    function findStyleBlocks(editor) {\r\n        return findBlocks(editor, "css");\r\n    }\r\n    \r\n    \r\n    // Define public API\r\n    exports.TAG_NAME         = TAG_NAME;\r\n    exports.CLOSING_TAG      = CLOSING_TAG;\r\n    exports.ATTR_NAME        = ATTR_NAME;\r\n    exports.ATTR_VALUE       = ATTR_VALUE;\r\n    \r\n    exports.getTagInfo       = getTagInfo;\r\n    exports.getTagAttributes = getTagAttributes;\r\n    //The createTagInfo is really only for the unit tests so they can make the same structure to \r\n    //compare results with\r\n    exports.createTagInfo   = createTagInfo;\r\n    exports.findStyleBlocks = findStyleBlocks;\r\n    exports.findBlocks      = findBlocks;\r\n});\r\n\n//# sourceURL=/language/HTMLUtils.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, regexp: true */\r\n/*global define, $ */\r\n\r\n/**\r\n * Set of utilities for simple parsing of CSS text.\r\n */\r\ndefine(\'language/CSSUtils\',[\'require\',\'exports\',\'module\',\'thirdparty/CodeMirror2/lib/codemirror\',\'utils/Async\',\'document/DocumentManager\',\'editor/EditorManager\',\'file/FileUtils\',\'language/HTMLUtils\',\'project/ProjectManager\',\'utils/TokenUtils\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var CodeMirror          = require("thirdparty/CodeMirror2/lib/codemirror"),\r\n        Async               = require("utils/Async"),\r\n        DocumentManager     = require("document/DocumentManager"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        FileUtils           = require("file/FileUtils"),\r\n        HTMLUtils           = require("language/HTMLUtils"),\r\n        ProjectManager      = require("project/ProjectManager"),\r\n        TokenUtils          = require("utils/TokenUtils"),\r\n        _                   = require("thirdparty/lodash");\r\n\r\n    // Constants\r\n    var SELECTOR   = "selector",\r\n        PROP_NAME  = "prop.name",\r\n        PROP_VALUE = "prop.value",\r\n        IMPORT_URL = "import.url";\r\n\r\n    var RESERVED_FLOW_NAMES = ["content", "element"],\r\n        INVALID_FLOW_NAMES = ["none", "inherit", "default", "auto", "initial"],\r\n        IGNORED_FLOW_NAMES = RESERVED_FLOW_NAMES.concat(INVALID_FLOW_NAMES);\r\n    \r\n    /**\r\n     * List of all bracket pairs that is keyed by opening brackets, and the inverted list\r\n     * that is keyed by closing brackets.\r\n     * @type {{string: string}}\r\n     */\r\n    var _bracketPairs = { "{": "}",\r\n                          "[": "]",\r\n                          "(": ")" },\r\n        _invertedBracketPairs = _.invert(_bracketPairs);\r\n    \r\n    /**\r\n     * @private\r\n     * Helper function to check whether the given text string has any non whitespace character.\r\n     * @param {!string} text\r\n     * @return {boolean} true if text has any non whitespace character\r\n     */\r\n    function _hasNonWhitespace(text) {\r\n        return (/\\S/.test(text));\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Checks if the current cursor position is inside the property name context\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @return {boolean} true if the context is in property name\r\n     */\r\n    function _isInPropName(ctx) {\r\n        var state,\r\n            lastToken;\r\n        if (!ctx || !ctx.token || !ctx.token.state || ctx.token.type === "comment") {\r\n            return false;\r\n        }\r\n\r\n        state = ctx.token.state.localState || ctx.token.state;\r\n        \r\n        if (!state.context) {\r\n            return false;\r\n        }\r\n        \r\n        lastToken = state.context.type;\r\n        return (lastToken === "{" || lastToken === "rule" || lastToken === "block");\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Checks if the current cursor position is inside the property value context\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @return {boolean} true if the context is in property value\r\n     */\r\n    function _isInPropValue(ctx) {\r\n        \r\n        function isInsideParens(context) {\r\n            if (context.type !== "parens" || !context.prev) {\r\n                return false;\r\n            }\r\n                                                             \r\n            if (context.prev.type === "prop") {\r\n                return true;\r\n            }\r\n            \r\n            return isInsideParens(context.prev);\r\n        }\r\n        \r\n        var state;\r\n        if (!ctx || !ctx.token || !ctx.token.state || ctx.token.type === "comment") {\r\n            return false;\r\n        }\r\n\r\n        state = ctx.token.state.localState || ctx.token.state;\r\n        \r\n        if (!state.context || !state.context.prev) {\r\n            return false;\r\n        }\r\n        return ((state.context.type === "prop" &&\r\n                    (state.context.prev.type === "rule" || state.context.prev.type === "block")) ||\r\n                    isInsideParens(state.context));\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Checks if the current cursor position is inside an at-rule\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @return {boolean} true if the context is in property value\r\n     */\r\n    function _isInAtRule(ctx) {\r\n        var state;\r\n        if (!ctx || !ctx.token || !ctx.token.state) {\r\n            return false;\r\n        }\r\n\r\n        state = ctx.token.state.localState || ctx.token.state;\r\n        \r\n        if (!state.context) {\r\n            return false;\r\n        }\r\n        return (state.context.type === "at");\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Creates a context info object\r\n     * @param {string=} context A constant string \r\n     * @param {number=} offset The offset of the token for a given cursor position\r\n     * @param {string=} name Property name of the context \r\n     * @param {number=} index The index of the property value for a given cursor position\r\n     * @param {Array.<string>=} values An array of property values \r\n     * @param {boolean=} isNewItem If this is true, then the value in index refers to the index at which a new item  \r\n     *     is going to be inserted and should not be used for accessing an existing value in values array. \r\n     * @param {{start: {line: number, ch: number},\r\n     *          end: {line: number, ch: number}}=} range A range object with a start position and an end position\r\n     * @return {{context: string,\r\n     *           offset: number,\r\n     *           name: string,\r\n     *           index: number,\r\n     *           values: Array.<string>,\r\n     *           isNewItem: boolean,\r\n     *           range: {start: {line: number, ch: number},\r\n     *                   end: {line: number, ch: number}}}} A CSS context info object.\r\n     */\r\n    function createInfo(context, offset, name, index, values, isNewItem, range) {\r\n        var ruleInfo = { context: context || "",\r\n                         offset: offset || 0,\r\n                         name: name || "",\r\n                         index: -1,\r\n                         values: [],\r\n                         isNewItem: (isNewItem === true),\r\n                         range: range };\r\n        \r\n        if (context === PROP_VALUE || context === SELECTOR || context === IMPORT_URL) {\r\n            ruleInfo.index = index;\r\n            ruleInfo.values = values;\r\n        }\r\n        \r\n        return ruleInfo;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Scan backwards to check for any prefix if the current context is property name.\r\n     * If the current context is in a prefix (either \'meta\' or \'-\'), then scan forwards \r\n     * to collect the entire property name. Return the name of the property in the CSS \r\n     * context info object if there is one that seems to be valid. Return an empty context\r\n     * info when we find an invalid one.\r\n     *\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} ctx  context\r\n     * @return {{context: string,\r\n     *           offset: number,\r\n     *           name: string,\r\n     *           index: number,\r\n     *           values: Array.<string>,\r\n     *           isNewItem: boolean,\r\n     *           range: {start: {line: number, ch: number},\r\n     *                   end: {line: number, ch: number}}}} A CSS context info object.\r\n     */\r\n    function _getPropNameInfo(ctx) {\r\n        var propName = "",\r\n            offset = TokenUtils.offsetInToken(ctx),\r\n            tokenString = ctx.token.string,\r\n            excludedCharacters = [";", "{", "}"];\r\n        \r\n        if (ctx.token.type === "property" || ctx.token.type === "property error" ||\r\n                ctx.token.type === "tag") {\r\n            propName = tokenString;\r\n            if (TokenUtils.movePrevToken(ctx) && _hasNonWhitespace(ctx.token.string) &&\r\n                    excludedCharacters.indexOf(ctx.token.string) === -1) {\r\n                propName = ctx.token.string + tokenString;\r\n                offset += ctx.token.string.length;\r\n            }\r\n        } else if (ctx.token.type === "meta" || tokenString === "-") {\r\n            propName = tokenString;\r\n            if (TokenUtils.moveNextToken(ctx) &&\r\n                    (ctx.token.type === "property" || ctx.token.type === "property error" ||\r\n                    ctx.token.type === "tag")) {\r\n                propName += ctx.token.string;\r\n            }\r\n        } else if (_hasNonWhitespace(tokenString) && excludedCharacters.indexOf(tokenString) === -1) {\r\n            // We\'re not inside the property name context.\r\n            return createInfo();\r\n        } else {\r\n            var testPos = {ch: ctx.pos.ch + 1, line: ctx.pos.line},\r\n                testToken = ctx.editor.getTokenAt(testPos, true);\r\n\r\n            if (testToken.type === "property" || testToken.type === "property error" ||\r\n                    testToken.type === "tag") {\r\n                propName = testToken.string;\r\n                offset = 0;\r\n            } else if (testToken.type === "meta" || testToken.string === "-") {\r\n                ctx.pos = testPos;\r\n                ctx.token = testToken;\r\n                return _getPropNameInfo(ctx);\r\n            }\r\n        }\r\n\r\n        // If we\'re in the property name context but not in an existing property name, \r\n        // then reset offset to zero.\r\n        if (propName === "") {\r\n            offset = 0;\r\n        }\r\n\r\n        return createInfo(PROP_NAME, offset, propName);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Scans backwards from the current context and returns the name of the property if there is \r\n     * a valid one. \r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @return {string} the property name of the current rule.\r\n     */\r\n    function _getPropNameStartingFromPropValue(ctx) {\r\n        var ctxClone = $.extend({}, ctx),\r\n            propName = "";\r\n        do {\r\n            // If we\'re no longer in the property value before seeing a colon, then we don\'t\r\n            // have a valid property name. Just return an empty string.\r\n            if (ctxClone.token.string !== ":" && !_isInPropValue(ctxClone)) {\r\n                return "";\r\n            }\r\n        } while (ctxClone.token.string !== ":" && TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctxClone));\r\n        \r\n        if (ctxClone.token.string === ":" && TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctxClone) &&\r\n                (ctxClone.token.type === "property" || ctxClone.token.type === "property error")) {\r\n            propName = ctxClone.token.string;\r\n            if (TokenUtils.movePrevToken(ctxClone) && ctxClone.token.type === "meta") {\r\n                propName = ctxClone.token.string + propName;\r\n            }\r\n        }\r\n        \r\n        return propName;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Gets all of the space/comma seperated tokens before the the current cursor position.\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @return {?Array.<string>} An array of all the space/comma seperated tokens before the\r\n     *    current cursor position\r\n     */\r\n    function _getPrecedingPropValues(ctx) {\r\n        var lastValue = "",\r\n            curValue,\r\n            propValues = [];\r\n        while (ctx.token.string !== ":" && TokenUtils.movePrevToken(ctx)) {\r\n            if (ctx.token.string === ":" || !_isInPropValue(ctx)) {\r\n                break;\r\n            }\r\n\r\n            curValue = ctx.token.string;\r\n            if (lastValue !== "") {\r\n                curValue += lastValue;\r\n            }\r\n\r\n            if ((ctx.token.string.length > 0 && !ctx.token.string.match(/\\S/)) ||\r\n                    ctx.token.string === ",") {\r\n                lastValue = curValue;\r\n            } else {\r\n                lastValue = "";\r\n                if (propValues.length === 0 || curValue.match(/,\\s*$/)) {\r\n                    // stack is empty, or current value ends with a comma\r\n                    // (and optional whitespace), so push it on the stack\r\n                    propValues.push(curValue);\r\n                } else {\r\n                    // current value does not end with a comma (and optional ws) so prepend\r\n                    // to last stack item (e.g. "rgba(50" get broken into 2 tokens)\r\n                    propValues[propValues.length - 1] = curValue + propValues[propValues.length - 1];\r\n                }\r\n            }\r\n        }\r\n        if (propValues.length > 0) {\r\n            propValues.reverse();\r\n        }\r\n        \r\n        return propValues;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Gets all of the space/comma seperated tokens after the the current cursor position.\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @param {string} currentValue The token string at the current cursor position\r\n     * @return {?Array.<string>} An array of all the space/comma seperated tokens after the\r\n     *    current cursor position\r\n     */\r\n    function _getSucceedingPropValues(ctx, currentValue) {\r\n        var lastValue = currentValue,\r\n            curValue,\r\n            propValues = [];\r\n        \r\n        while (ctx.token.string !== ";" && ctx.token.string !== "}" && TokenUtils.moveNextToken(ctx)) {\r\n            if (ctx.token.string === ";" || ctx.token.string === "}") {\r\n                break;\r\n            }\r\n            if (!_isInPropValue(ctx)) {\r\n                lastValue = "";\r\n                break;\r\n            }\r\n            \r\n            if (lastValue === "") {\r\n                lastValue = ctx.token.string.trim();\r\n            } else if (lastValue.length > 0) {\r\n                if (ctx.token.string.length > 0 && !ctx.token.string.match(/\\S/)) {\r\n                    lastValue += ctx.token.string;\r\n                    propValues.push(lastValue);\r\n                    lastValue = "";\r\n                } else if (ctx.token.string === ",") {\r\n                    lastValue += ctx.token.string;\r\n                } else if (lastValue && lastValue.match(/,$/)) {\r\n                    propValues.push(lastValue);\r\n                    if (ctx.token.string.length > 0) {\r\n                        lastValue = ctx.token.string;\r\n                    } else {\r\n                        lastValue = "";\r\n                    }\r\n                } else {\r\n                    // e.g. "rgba(50" gets broken into 2 tokens\r\n                    lastValue += ctx.token.string;\r\n                }\r\n            }\r\n        }\r\n        if (lastValue.length > 0) {\r\n            propValues.push(lastValue);\r\n        }\r\n\r\n        return propValues;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Return a range object with a start position and an end position after\r\n     * skipping any whitespaces and all separators used before and after a\r\n     * valid property value.\r\n     *\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} startCtx context\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} endCtx context\r\n     * @return {{start: {line: number, ch: number},\r\n     *           end: {line: number, ch: number}}} A range object.\r\n     */\r\n    function _getRangeForPropValue(startCtx, endCtx) {\r\n        var range = { "start": {},\r\n                      "end": {} };\r\n        \r\n        // Skip the ":" and any leading whitespace\r\n        while (TokenUtils.moveNextToken(startCtx)) {\r\n            if (_hasNonWhitespace(startCtx.token.string)) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // Skip the trailing whitespace and property separators.\r\n        while (endCtx.token.string === ";" || endCtx.token.string === "}" ||\r\n                !_hasNonWhitespace(endCtx.token.string)) {\r\n            TokenUtils.movePrevToken(endCtx);\r\n        }\r\n        \r\n        range.start = _.clone(startCtx.pos);\r\n        range.start.ch = startCtx.token.start;\r\n        \r\n        range.end = _.clone(endCtx.pos);\r\n        range.end.ch = endCtx.token.end;\r\n        \r\n        return range;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Returns a context info object for the current CSS style rule\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @param {!Editor} editor\r\n     * @return {{context: string,\r\n     *           offset: number,\r\n     *           name: string,\r\n     *           index: number,\r\n     *           values: Array.<string>,\r\n     *           isNewItem: boolean,\r\n     *           range: {start: {line: number, ch: number},\r\n     *                   end: {line: number, ch: number}}}} A CSS context info object.\r\n     */\r\n    function _getRuleInfoStartingFromPropValue(ctx, editor) {\r\n        var propNamePos = $.extend({}, ctx.pos),\r\n            backwardPos = $.extend({}, ctx.pos),\r\n            forwardPos  = $.extend({}, ctx.pos),\r\n            propNameCtx = TokenUtils.getInitialContext(editor._codeMirror, propNamePos),\r\n            backwardCtx,\r\n            forwardCtx,\r\n            lastValue = "",\r\n            propValues = [],\r\n            index = -1,\r\n            offset = TokenUtils.offsetInToken(ctx),\r\n            canAddNewOne = false,\r\n            testPos = {ch: ctx.pos.ch + 1, line: ctx.pos.line},\r\n            testToken = editor._codeMirror.getTokenAt(testPos, true),\r\n            propName,\r\n            range;\r\n        \r\n        // Get property name first. If we don\'t have a valid property name, then \r\n        // return a default rule info.\r\n        propName = _getPropNameStartingFromPropValue(propNameCtx);\r\n        if (!propName) {\r\n            return createInfo();\r\n        }\r\n        \r\n        // Scan backward to collect all preceding property values\r\n        backwardCtx = TokenUtils.getInitialContext(editor._codeMirror, backwardPos);\r\n        propValues = _getPrecedingPropValues(backwardCtx);\r\n\r\n        lastValue = "";\r\n        if (ctx.token.string === ":") {\r\n            index = 0;\r\n            canAddNewOne = true;\r\n        } else {\r\n            index = propValues.length - 1;\r\n            if (ctx.token.string === ",") {\r\n                propValues[index] += ctx.token.string;\r\n                index++;\r\n                canAddNewOne = true;\r\n            } else {\r\n                index = (index < 0) ? 0 : index + 1;\r\n                if (ctx.token.string.match(/\\S/)) {\r\n                    lastValue = ctx.token.string;\r\n                } else {\r\n                    // Last token is all whitespace\r\n                    canAddNewOne = true;\r\n                    if (index > 0) {\r\n                        // Append all spaces before the cursor to the previous value in values array\r\n                        propValues[index - 1] += ctx.token.string.substr(0, offset);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (canAddNewOne) {\r\n            offset = 0;\r\n\r\n            // If pos is at EOL, then there\'s implied whitespace (newline).\r\n            if (editor.document.getLine(ctx.pos.line).length > ctx.pos.ch  &&\r\n                    (testToken.string.length === 0 || testToken.string.match(/\\S/))) {\r\n                canAddNewOne = false;\r\n            }\r\n        }\r\n        \r\n        // Scan forward to collect all succeeding property values and append to all propValues.\r\n        forwardCtx = TokenUtils.getInitialContext(editor._codeMirror, forwardPos);\r\n        propValues = propValues.concat(_getSucceedingPropValues(forwardCtx, lastValue));\r\n        \r\n        if (propValues.length) {\r\n            range = _getRangeForPropValue(backwardCtx, forwardCtx);\r\n        } else {\r\n            // No property value, so just return the cursor pos as range\r\n            range = { "start": _.clone(ctx.pos),\r\n                      "end": _.clone(ctx.pos) };\r\n        }\r\n        \r\n        // If current index is more than the propValues size, then the cursor is \r\n        // at the end of the existing property values and is ready for adding another one.\r\n        if (index === propValues.length) {\r\n            canAddNewOne = true;\r\n        }\r\n        \r\n        return createInfo(PROP_VALUE, offset, propName, index, propValues, canAddNewOne, range);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Returns a context info object for the current CSS import rule\r\n     * @param {editor:{CodeMirror}, pos:{ch:{string}, line:{number}}, token:{object}} context\r\n     * @param {!Editor} editor\r\n     * @return {{context: string,\r\n     *           offset: number,\r\n     *           name: string,\r\n     *           index: number,\r\n     *           values: Array.<string>,\r\n     *           isNewItem: boolean,\r\n     *           range: {start: {line: number, ch: number},\r\n     *                   end: {line: number, ch: number}}}} A CSS context info object.\r\n     */\r\n    function _getImportUrlInfo(ctx, editor) {\r\n        var propNamePos = $.extend({}, ctx.pos),\r\n            backwardPos = $.extend({}, ctx.pos),\r\n            forwardPos  = $.extend({}, ctx.pos),\r\n            backwardCtx,\r\n            forwardCtx,\r\n            index = 0,\r\n            propValues = [],\r\n            offset = TokenUtils.offsetInToken(ctx),\r\n            testPos = {ch: ctx.pos.ch + 1, line: ctx.pos.line},\r\n            testToken = editor._codeMirror.getTokenAt(testPos, true);\r\n\r\n        // Currently only support url. May be null if starting to type\r\n        if (ctx.token.type && ctx.token.type !== "string") {\r\n            return createInfo();\r\n        }\r\n\r\n        // Move backward to @import and collect data as we go. We return propValues\r\n        // array, but we can only have 1 value, so put all data in first item\r\n        backwardCtx = TokenUtils.getInitialContext(editor._codeMirror, backwardPos);\r\n        propValues[0] = backwardCtx.token.string;\r\n\r\n        while (TokenUtils.movePrevToken(backwardCtx)) {\r\n            if (backwardCtx.token.type === "def" && backwardCtx.token.string === "@import") {\r\n                break;\r\n            }\r\n            \r\n            if (backwardCtx.token.type && backwardCtx.token.type !== "tag" && backwardCtx.token.string !== "url") {\r\n                // Previous token may be white-space\r\n                // Otherwise, previous token may only be "url("\r\n                break;\r\n            }\r\n            \r\n            propValues[0] = backwardCtx.token.string + propValues[0];\r\n            offset += backwardCtx.token.string.length;\r\n        }\r\n        \r\n        if (backwardCtx.token.type !== "def" || backwardCtx.token.string !== "@import") {\r\n            // Not in url\r\n            return createInfo();\r\n        }\r\n\r\n        // Get value after cursor up until closing paren or newline\r\n        forwardCtx = TokenUtils.getInitialContext(editor._codeMirror, forwardPos);\r\n        do {\r\n            if (!TokenUtils.moveNextToken(forwardCtx)) {\r\n                if (forwardCtx.token.string === "(") {\r\n                    break;\r\n                } else {\r\n                    return createInfo();\r\n                }\r\n            }\r\n            propValues[0] += forwardCtx.token.string;\r\n        } while (forwardCtx.token.string !== ")" && forwardCtx.token.string !== "");\r\n        \r\n        return createInfo(IMPORT_URL, offset, "", index, propValues, false);\r\n    }\r\n\r\n    /**\r\n     * Returns a context info object for the given cursor position\r\n     * @param {!Editor} editor\r\n     * @param {{ch: number, line: number}} constPos  A CM pos (likely from editor.getCursorPos())\r\n     * @return {{context: string,\r\n     *           offset: number,\r\n     *           name: string,\r\n     *           index: number,\r\n     *           values: Array.<string>,\r\n     *           isNewItem: boolean,\r\n     *           range: {start: {line: number, ch: number},\r\n     *                   end: {line: number, ch: number}}}} A CSS context info object.\r\n     */\r\n    function getInfoAtPos(editor, constPos) {\r\n        // We\'re going to be changing pos a lot, but we don\'t want to mess up\r\n        // the pos the caller passed in so we use extend to make a safe copy of it.	\r\n        var pos = $.extend({}, constPos),\r\n            ctx = TokenUtils.getInitialContext(editor._codeMirror, pos),\r\n            offset = TokenUtils.offsetInToken(ctx),\r\n            propName = "",\r\n            mode = editor.getModeForSelection();\r\n        \r\n        // Check if this is inside a style block or in a css/less document.\r\n        if (mode !== "css" && mode !== "text/x-scss" && mode !== "text/x-less") {\r\n            return createInfo();\r\n        }\r\n\r\n        if (_isInPropName(ctx)) {\r\n            return _getPropNameInfo(ctx, editor);\r\n        }\r\n        \r\n        if (_isInPropValue(ctx)) {\r\n            return _getRuleInfoStartingFromPropValue(ctx, editor);\r\n        }\r\n\r\n        if (_isInAtRule(ctx)) {\r\n            return _getImportUrlInfo(ctx, editor);\r\n        }\r\n        \r\n        return createInfo();\r\n    }\r\n    \r\n    /**\r\n     * Return a string that shows the literal parent hierarchy of the selector\r\n     * in info.\r\n     *\r\n     * @param {!SelectorInfo} info\r\n     * @param {boolean=} useGroup true to append selectorGroup instead of selector\r\n     * @return {string} the literal parent hierarchy of the selector\r\n     */\r\n    function getCompleteSelectors(info, useGroup) {\r\n        if (info.parentSelectors) {\r\n            // Show parents with / separators.\r\n            var completeSelectors = info.parentSelectors + " / ";\r\n            if (useGroup && info.selectorGroup) {\r\n                completeSelectors += info.selectorGroup;\r\n            } else {\r\n                completeSelectors += info.selector;\r\n            }\r\n            return completeSelectors;\r\n        } else if (useGroup && info.selectorGroup) {\r\n            return info.selectorGroup;\r\n        }\r\n        \r\n        return info.selector;\r\n    }\r\n    \r\n    /**\r\n     * @typedef {{selector: !string,\r\n     *            ruleStartLine: number,\r\n     *            ruleStartChar: number,\r\n     *            selectorStartLine: number,\r\n     *            selectorStartChar: number,\r\n     *            selectorEndLine: number,\r\n     *            selectorEndChar: number,\r\n     *            selectorGroupStartLine: number,\r\n     *            selectorGroupStartChar: number,\r\n     *            selectorGroup: ?string,\r\n     *            declListStartLine: number,\r\n     *            declListStartChar: number,\r\n     *            declListEndLine: number,\r\n     *            declListEndChar: number,\r\n     *            level: number,\r\n     *            parentSelectors: ?string}} SelectorInfo \r\n     */\r\n    \r\n    /**\r\n     * Extracts all CSS selectors from the given text\r\n     * Returns an array of SelectorInfo. Each SelectorInfo is an object with the following properties:\r\n         selector:                 the text of the selector (note: comma separated selector groups like \r\n                                   "h1, h2" are broken into separate selectors)\r\n         ruleStartLine:            line in the text where the rule (including preceding comment) appears\r\n         ruleStartChar:            column in the line where the rule (including preceding comment) starts\r\n         selectorStartLine:        line in the text where the selector appears\r\n         selectorStartChar:        column in the line where the selector starts\r\n         selectorEndLine:          line where the selector ends\r\n         selectorEndChar:          column where the selector ends\r\n         selectorGroupStartLine:   line where the comma-separated selector group (e.g. .foo, .bar, .baz)\r\n                                   starts that this selector (e.g. .baz) is part of. Particularly relevant for\r\n                                   groups that are on multiple lines.\r\n         selectorGroupStartChar:   column in line where the selector group starts.\r\n         selectorGroup:            the entire selector group containing this selector, or undefined if there \r\n                                   is only one selector in the rule.\r\n         declListStartLine:        line where the declaration list for the rule starts\r\n         declListStartChar:        column in line where the declaration list for the rule starts\r\n         declListEndLine:          line where the declaration list for the rule ends\r\n         declListEndChar:          column in the line where the declaration list for the rule ends\r\n         level:                    the level of the current selector including any containing @media block in the \r\n                                   nesting level count. Use this property with caution since it is primarily for internal\r\n                                   parsing use. For example, two sibling selectors may have different levels if one\r\n                                   of them is nested inside an @media block and it should not be used for sibling info.\r\n         parentSelectors:          all ancestor selectors separated with \'/\' if the current selector is a nested one \r\n     * @param {!string} text CSS text to extract from\r\n     * @param {?string} documentMode language mode of the document that text belongs to, default to css if undefined.\r\n     * @return {Array.<SelectorInfo>} Array with objects specifying selectors.\r\n     */\r\n    function extractAllSelectors(text, documentMode) {\r\n        var state, lines, lineCount,\r\n            token, style, stream, line,\r\n            selectors              = [],\r\n            mode                   = CodeMirror.getMode({indentUnit: 2}, documentMode || "css"),\r\n            currentSelector        = "",\r\n            currentLevel           = 0,\r\n            ruleStartChar          = -1,\r\n            ruleStartLine          = -1,\r\n            selectorStartChar      = -1,\r\n            selectorStartLine      = -1,\r\n            selectorGroupStartLine = -1,\r\n            selectorGroupStartChar = -1,\r\n            declListStartLine      = -1,\r\n            declListStartChar      = -1,\r\n            escapePattern          = new RegExp("\\\\\\\\[^\\\\\\\\]+", "g"),\r\n            validationPattern      = new RegExp("\\\\\\\\([a-f0-9]{6}|[a-f0-9]{4}(\\\\s|\\\\\\\\|$)|[a-f0-9]{2}(\\\\s|\\\\\\\\|$)|.)", "i"),\r\n            _parseRuleList;\r\n        \r\n        // implement _firstToken()/_nextToken() methods to\r\n        // provide a single stream of tokens\r\n        \r\n        function _hasStream() {\r\n            while (stream.eol()) {\r\n                line++;\r\n                if (line >= lineCount) {\r\n                    return false;\r\n                }\r\n                if (_hasNonWhitespace(currentSelector)) {\r\n                    // If we are in a current selector and starting a newline,\r\n                    // make sure there is whitespace in the selector\r\n                    currentSelector += " ";\r\n                }\r\n                stream = new CodeMirror.StringStream(lines[line]);\r\n            }\r\n            return true;\r\n        }\r\n        \r\n        function _firstToken() {\r\n            state = CodeMirror.startState(mode);\r\n            lines = CodeMirror.splitLines(text);\r\n            lineCount = lines.length;\r\n            if (lineCount === 0) {\r\n                return false;\r\n            }\r\n            line = 0;\r\n            stream = new CodeMirror.StringStream(lines[line]);\r\n            if (!_hasStream()) {\r\n                return false;\r\n            }\r\n            style = mode.token(stream, state);\r\n            token = stream.current();\r\n            return true;\r\n        }\r\n        \r\n        function _nextToken() {\r\n            // advance the stream past this token\r\n            stream.start = stream.pos;\r\n            if (!_hasStream()) {\r\n                return false;\r\n            }\r\n            style = mode.token(stream, state);\r\n            token = stream.current();\r\n            return true;\r\n        }\r\n        \r\n        function _firstTokenSkippingWhitespace() {\r\n            if (!_firstToken()) {\r\n                return false;\r\n            }\r\n            while (!_hasNonWhitespace(token)) {\r\n                if (!_nextToken()) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        \r\n        function _nextTokenSkippingWhitespace() {\r\n            if (!_nextToken()) {\r\n                return false;\r\n            }\r\n            while (!_hasNonWhitespace(token)) {\r\n                if (!_nextToken()) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function _isStartComment() {\r\n            // Also check for line comments used in LESS and SASS.\r\n            return (/^\\/[\\/\\*]/.test(token));\r\n        }\r\n        \r\n        function _parseComment() {\r\n            // If it is a line comment, then do nothing and just return. Unlike block\r\n            // comment, a line comment is just one single token and the caller always  \r\n            // has to find the next token by skipping the current token. So leaving \r\n            // it for the caller to skip the current token.\r\n            if (/^\\/\\//.test(token)) {\r\n                return;\r\n            }\r\n            while (!/\\*\\/$/.test(token)) {\r\n                if (!_nextToken()) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        \r\n        function _nextTokenSkippingComments() {\r\n            if (!_nextToken()) {\r\n                return false;\r\n            }\r\n            while (_isStartComment()) {\r\n                _parseComment();\r\n                if (!_nextToken()) {\r\n                    return false;\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        function _skipToClosingBracket(startChar) {\r\n            var skippedText = "",\r\n                unmatchedBraces = 0;\r\n            if (!startChar) {\r\n                startChar = "{";\r\n            }\r\n            while (true) {\r\n                if (token.indexOf(startChar) !== -1 && token.indexOf(_bracketPairs[startChar]) === -1) {\r\n                    // Found an opening bracket but not the matching closing bracket in the same token\r\n                    unmatchedBraces++;\r\n                } else if (token === _bracketPairs[startChar]) {\r\n                    unmatchedBraces--;\r\n                    if (unmatchedBraces <= 0) {\r\n                        skippedText += token;\r\n                        return skippedText;\r\n                    }\r\n                }\r\n                skippedText += token;\r\n                \r\n                if (!_nextTokenSkippingComments()) {\r\n                    return skippedText; // eof\r\n                }\r\n            }\r\n        }\r\n\r\n        function _maybeProperty() {\r\n            return (/^-(moz|ms|o|webkit)-$/.test(token) ||\r\n                    (state.state !== "top" && state.state !== "block" &&\r\n                    // Has a semicolon as in "rgb(0,0,0);", but not one of those after a LESS \r\n                    // mixin parameter variable as in ".size(@width; @height)"\r\n                    stream.string.indexOf(";") !== -1 && !/\\([^)]+;/.test(stream.string)));\r\n        }\r\n\r\n        function _skipProperty() {\r\n            var prevToken = "";\r\n            while (token !== ";") {\r\n                // Skip tokens until the closing brace if we find an interpolated variable.\r\n                if (/#\\{$/.test(token) || (token === "{" && /[#@]$/.test(prevToken))) {\r\n                    _skipToClosingBracket("{");\r\n                    if (token === "}") {\r\n                        _nextToken();   // Skip the closing brace\r\n                    }\r\n                    if (token === ";") {\r\n                        break;\r\n                    }\r\n                }\r\n                // If there is a \'{\' or \'}\' before the \';\',\r\n                // then stop skipping.\r\n                if (token === "{" || token === "}") {\r\n                    return false;   // can\'t tell if the entire property is skipped\r\n                }\r\n                prevToken = token;\r\n                if (!_nextTokenSkippingComments()) {\r\n                    break;\r\n                }\r\n            }\r\n            return true;    // skip the entire property\r\n        }\r\n        \r\n        function _getParentSelectors() {\r\n            var j;\r\n            for (j = selectors.length - 1; j >= 0; j--) {\r\n                if (selectors[j].declListEndLine === -1 && selectors[j].level < currentLevel) {\r\n                    return getCompleteSelectors(selectors[j], true);\r\n                }\r\n            }\r\n            return "";\r\n        }\r\n        \r\n        function _parseSelector(start, level) {\r\n            \r\n            currentSelector = "";\r\n            selectorStartChar = start;\r\n            selectorStartLine = line;\r\n            \r\n            // Everything until the next \',\' or \'{\' is part of the current selector\r\n            while ((token !== "," && token !== "{") ||\r\n                    (token === "{" && /[#@]$/.test(currentSelector)) ||\r\n                    (token === "," && !_hasNonWhitespace(currentSelector))) {\r\n                if (token === "{") {\r\n                    // Append the interpolated variable to selector\r\n                    currentSelector += _skipToClosingBracket("{");\r\n                    _nextToken();  // skip the closing brace\r\n                } else if (token === "}" &&\r\n                        (!currentSelector || /:\\s*\\S/.test(currentSelector) || !/#\\{.+/.test(currentSelector))) {\r\n                    // Either empty currentSelector or currentSelector is a CSS property\r\n                    // but not a selector that is in the form of #{$class}\r\n                    return false;\r\n                }\r\n                // Clear currentSelector if we\'re in a property, but make sure we don\'t treat\r\n                // the semicolors inside a parameter as a property separators.\r\n                if ((token === ";" && state.state !== "parens") ||\r\n                        // Make sure that something like `> li > a {` is not identified as a property\r\n                        (state.state === "prop" && !/\\{/.test(stream.string))) {\r\n                    currentSelector = "";\r\n                } else if (token === "(") {\r\n                    // Collect everything inside the parentheses as a whole chunk so that\r\n                    // commas inside the parentheses won\'t be identified as selector separators\r\n                    // by while loop.\r\n                    if (_hasNonWhitespace(currentSelector)) {\r\n                        currentSelector += _skipToClosingBracket("(");\r\n                    } else {\r\n                        // Nothing in currentSelector yet. Skip to the closing parenthesis\r\n                        // without collecting the selector since a selector cannot start with \r\n                        // an opening parenthesis.\r\n                        _skipToClosingBracket("(");\r\n                    }\r\n                } else if (_hasNonWhitespace(token) || _hasNonWhitespace(currentSelector)) {\r\n                    currentSelector += token;\r\n                }\r\n                if (!_nextTokenSkippingComments()) {\r\n                    return false; // eof\r\n                }\r\n            }\r\n            \r\n            if (!currentSelector) {\r\n                return false;\r\n            }\r\n            \r\n            // Unicode character replacement as defined in http://www.w3.org/TR/CSS21/syndata.html#characters\r\n            if (/\\\\/.test(currentSelector)) {\r\n                // Double replace in case of pattern overlapping (regex improvement?)\r\n                currentSelector = currentSelector.replace(escapePattern, function (escapedToken) {\r\n                    return escapedToken.replace(validationPattern, function (unicodeChar) {\r\n                        unicodeChar = unicodeChar.substr(1);\r\n                        if (unicodeChar.length === 1) {\r\n                            return unicodeChar;\r\n                        } else {\r\n                            if (parseInt(unicodeChar, 16) < 0x10FFFF) {\r\n                                return String.fromCharCode(parseInt(unicodeChar, 16));\r\n                            } else { return String.fromCharCode(0xFFFD); }\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            \r\n            currentSelector = currentSelector.trim();\r\n            var startChar = (selectorGroupStartLine === -1) ? selectorStartChar : selectorStartChar + 1;\r\n            var selectorStart = (stream.string.indexOf(currentSelector, selectorStartChar) !== -1) ? stream.string.indexOf(currentSelector, selectorStartChar - currentSelector.length) : startChar;\r\n\r\n            if (currentSelector !== "") {\r\n                if (currentLevel < level) {\r\n                    currentLevel++;\r\n                }\r\n                if (ruleStartLine === -1) {\r\n                    ruleStartLine = line;\r\n                    ruleStartChar = stream.start - currentSelector.length;\r\n                }\r\n                var parentSelectors = _getParentSelectors();\r\n                selectors.push({selector: currentSelector,\r\n                                ruleStartLine: ruleStartLine,\r\n                                ruleStartChar: ruleStartChar,\r\n                                selectorStartLine: selectorStartLine,\r\n                                selectorStartChar: selectorStart,\r\n                                declListEndLine: -1,\r\n                                selectorEndLine: line,\r\n                                selectorEndChar: selectorStart + currentSelector.length,\r\n                                selectorGroupStartLine: selectorGroupStartLine,\r\n                                selectorGroupStartChar: selectorGroupStartChar,\r\n                                level: currentLevel,\r\n                                parentSelectors: parentSelectors\r\n                               });\r\n                currentSelector = "";\r\n            }\r\n            selectorStartChar = -1;\r\n\r\n            return true;\r\n        }\r\n        \r\n        function _parseSelectorList(level) {\r\n            selectorGroupStartLine = (stream.string.indexOf(",") !== -1) ? line : -1;\r\n            selectorGroupStartChar = stream.start;\r\n\r\n            if (!_parseSelector(stream.start, level)) {\r\n                return false;\r\n            }\r\n\r\n            while (token === ",") {\r\n                if (!_nextTokenSkippingComments()) {\r\n                    return false; // eof\r\n                }\r\n                if (!_parseSelector(stream.start, level)) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            return true;\r\n        }\r\n\r\n        function _parseDeclarationList(level) {\r\n\r\n            var j;\r\n            declListStartLine = Math.min(line, lineCount - 1);\r\n            declListStartChar = stream.start;\r\n            \r\n            // Extract the entire selector group we just saw.\r\n            var selectorGroup, sgLine;\r\n            if (selectorGroupStartLine !== -1) {\r\n                selectorGroup = "";\r\n                for (sgLine = selectorGroupStartLine; sgLine <= declListStartLine; sgLine++) {\r\n                    var startChar = 0, endChar = lines[sgLine].length;\r\n                    if (sgLine === selectorGroupStartLine) {\r\n                        startChar = selectorGroupStartChar;\r\n                    } else {\r\n                        selectorGroup += " "; // replace the newline with a single space\r\n                    }\r\n                    if (sgLine === declListStartLine) {\r\n                        endChar = declListStartChar;\r\n                    }\r\n                    selectorGroup += lines[sgLine].substring(startChar, endChar).trim();\r\n                }\r\n                selectorGroup = selectorGroup.trim();\r\n            }\r\n\r\n            // assign this declaration list position and selector group to every selector on the stack\r\n            // that doesn\'t have a declaration list start and end line\r\n            for (j = selectors.length - 1; j >= 0; j--) {\r\n                if (selectors[j].level === level) {\r\n                    if (selectors[j].declListEndLine !== -1) {\r\n                        break;\r\n                    } else {\r\n                        selectors[j].declListStartLine = declListStartLine;\r\n                        selectors[j].declListStartChar = declListStartChar;\r\n                        if (selectorGroup) {\r\n                            selectors[j].selectorGroup = selectorGroup;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            \r\n            var nested = true;\r\n            do {\r\n                // Since we\'re now in a declaration list, that means we also finished\r\n                // parsing the whole selector group. Therefore, reset selectorGroupStartLine\r\n                // so that next time we parse a selector we know it\'s a new group\r\n                selectorGroupStartLine = -1;\r\n                selectorGroupStartChar = -1;\r\n                ruleStartLine = -1;\r\n                ruleStartChar = -1;\r\n\r\n                if (!nested) {\r\n                    if (currentLevel > 0 && currentLevel === level) {\r\n                        currentLevel--;\r\n                        // Skip past \'}\'\r\n                        if (token === "}") {\r\n                            _nextTokenSkippingWhitespace();\r\n                        }\r\n                    }\r\n                }\r\n                // Skip past \'{\' before parsing nested rule list.\r\n                if (token === "{") {\r\n                    _nextTokenSkippingWhitespace();\r\n                }\r\n                nested = _parseRuleList(undefined, currentLevel + 1);\r\n            \r\n                // assign this declaration list position to every selector on the stack\r\n                // that doesn\'t have a declaration list end line\r\n                for (j = selectors.length - 1; j >= 0; j--) {\r\n                    if (selectors[j].level < currentLevel) {\r\n                        break;\r\n                    }\r\n                    if (selectors[j].declListEndLine === -1) {\r\n                        selectors[j].declListEndLine = line;\r\n                        selectors[j].declListEndChar = stream.pos - 1; // stream.pos actually points to the char after the }\r\n                    }\r\n                }\r\n            } while (currentLevel > 0 && currentLevel === level);\r\n        }\r\n        \r\n        function includeCommentInNextRule() {\r\n            if (ruleStartChar !== -1) {\r\n                return false;       // already included\r\n            }\r\n            if (stream.start > 0 && lines[line].substr(0, stream.start).indexOf("}") !== -1) {\r\n                return false;       // on same line as \'}\', so it\'s for previous rule\r\n            }\r\n            return true;\r\n        }\r\n        \r\n        function _isStartAtRule() {\r\n            // Exclude @mixin from at-rule so that we can parse it like a normal rule list\r\n            return (/^@/.test(token) && !/^@mixin/i.test(token) && token !== "@");\r\n        }\r\n        \r\n        function _followedByPseudoSelector() {\r\n            return (/\\}:(enabled|disabled|checked|indeterminate|link|visited|hover|active|focus|target|lang|root|nth-|first-|last-|only-|empty|not)/.test(stream.string));\r\n        }\r\n                    \r\n        function _isVariableInterpolatedProperty() {\r\n            return (/[@#]\\{\\S+\\}(\\s*:|.*;)/.test(stream.string) && !_followedByPseudoSelector());\r\n        }\r\n        \r\n        function _parseAtRule(level) {\r\n\r\n            // reset these fields to ignore comments preceding @rules\r\n            ruleStartLine = -1;\r\n            ruleStartChar = -1;\r\n            selectorStartLine = -1;\r\n            selectorStartChar = -1;\r\n            selectorGroupStartLine = -1;\r\n            selectorGroupStartChar = -1;\r\n            \r\n            if (/@media/i.test(token)) {\r\n                // @media rule holds a rule list\r\n                \r\n                // Skip everything until the opening \'{\'\r\n                while (token !== "{") {\r\n                    if (!_nextTokenSkippingComments()) {\r\n                        return; // eof\r\n                    }\r\n                }\r\n\r\n                // skip past \'{\', to next non-ws token\r\n                if (!_nextTokenSkippingWhitespace()) {\r\n                    return; // eof\r\n                }\r\n\r\n                if (currentLevel <= level) {\r\n                    currentLevel++;\r\n                }\r\n\r\n                // Parse rules until we see \'}\'\r\n                // Treat media rule as one nested level by \r\n                // calling _parseRuleList with next level.\r\n                _parseRuleList("}", currentLevel + 1);\r\n\r\n                if (currentLevel > 0) {\r\n                    currentLevel--;\r\n                }\r\n\r\n            } else {\r\n                // This code handles @rules in this format:\r\n                //   @rule ... ;\r\n                // Or any less variable that starts with @var ... ;\r\n                // Skip everything until the next \';\'\r\n                while (token !== ";") {\r\n                    // This code handle @rules that use this format:\r\n                    //    @rule ... { ... }\r\n                    // such as @page, @keyframes (also -webkit-keyframes, etc.), and @font-face.\r\n                    // Skip everything including nested braces until the next matching \'}\'\r\n                    if (token === "{") {\r\n                        _skipToClosingBracket("{");\r\n                        return;\r\n                    }\r\n                    if (!_nextTokenSkippingComments()) {\r\n                        return; // eof\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // parse a style rule\r\n        function _parseRule(level) {\r\n            if (!_parseSelectorList(level)) {\r\n                return false;\r\n            }\r\n            \r\n            _parseDeclarationList(level);\r\n            return true;\r\n        }\r\n        \r\n        _parseRuleList = function (escapeToken, level) {\r\n            while ((!escapeToken) || token !== escapeToken) {\r\n                if (_isVariableInterpolatedProperty()) {\r\n                    if (!_skipProperty()) {\r\n                        // We found a "{" or "}" while skipping a property. Return false to handle the \r\n                        // opening or closing of a block properly.\r\n                        return false;\r\n                    }\r\n                } else if (_isStartAtRule()) {\r\n                    // @rule\r\n                    _parseAtRule(level);\r\n                } else if (_isStartComment()) {\r\n                    // comment - make this part of style rule\r\n                    if (includeCommentInNextRule()) {\r\n                        ruleStartChar = stream.start;\r\n                        ruleStartLine = line;\r\n                    }\r\n                    _parseComment();\r\n                } else if (_maybeProperty()) {\r\n                    // Skip the property.\r\n                    if (!_skipProperty()) {\r\n                        // We found a "{" or "}" while skipping a property. Return false to handle the \r\n                        // opening or closing of a block properly.\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    // Otherwise, it\'s style rule\r\n                    if (!_parseRule(level === undefined ? 0 : level) && level > 0) {\r\n                        return false;\r\n                    }\r\n                    if (level > 0) {\r\n                        return true;\r\n                    }\r\n                    // Clear ruleStartChar and ruleStartLine in case we have a comment \r\n                    // at the end of previous rule in level 0.\r\n                    ruleStartChar = -1;\r\n                    ruleStartLine = -1;\r\n                }\r\n                \r\n                if (!_nextTokenSkippingWhitespace()) {\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            return true;\r\n        };\r\n        \r\n        // Do parsing\r\n\r\n        if (_firstTokenSkippingWhitespace()) {\r\n\r\n            // Style sheet is a rule list\r\n            _parseRuleList();\r\n        }\r\n\r\n        return selectors;\r\n    }\r\n    \r\n    /*\r\n     * This code can be used to create an "independent" HTML document that can be passed to jQuery\r\n     * calls. Allows using jQuery\'s CSS selector engine without actually putting anything in the browser\'s DOM\r\n     *\r\n    var _htmlDoctype = document.implementation.createDocumentType(\'html\',\r\n        \'-//W3C//DTD XHTML 1.0 Strict//EN\',\r\n        \'http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\'\r\n    );\r\n    var _htmlDocument = document.implementation.createDocument(\'http://www.w3.org/1999/xhtml\', \'html\', _htmlDoctype);\r\n\r\n    function checkIfSelectorSelectsHTML(selector, theHTML) {\r\n        $(\'html\', _htmlDocument).html(theHTML);\r\n        return ($(selector, _htmlDocument).length > 0);\r\n    }\r\n    */\r\n    \r\n    /**\r\n     * Helper function to remove whitespaces before and after a selector\r\n     * Returns trimmed selector if it is not an at-rule, or null if it starts with @.\r\n     *\r\n     * @param {string} selector\r\n     * @return {string}\r\n     */\r\n    function _stripAtRules(selector) {\r\n        selector = selector.trim();\r\n        if (selector.indexOf("@") === 0) {\r\n            return "";\r\n        }\r\n        return selector;\r\n    }\r\n\r\n    /**\r\n     * Converts the given selector array into the actual CSS selectors similar to \r\n     * those generated by a CSS preprocessor.\r\n     *\r\n     * @param {Array.<string>} selectorArray\r\n     * @return {string} \r\n     */\r\n    function _getSelectorInFinalCSSForm(selectorArray) {\r\n        var finalSelectorArray = [""],\r\n            parentSelectorArray = [],\r\n            group = [];\r\n        _.forEach(selectorArray, function (selector) {\r\n            selector = _stripAtRules(selector);\r\n            group = selector.split(",");\r\n            parentSelectorArray = [];\r\n            _.forEach(group, function (cs) {\r\n                var ampersandIndex = cs.indexOf("&");\r\n                _.forEach(finalSelectorArray, function (ps) {\r\n                    if (ampersandIndex === -1) {\r\n                        cs = _stripAtRules(cs);\r\n                        if (ps.length && cs.length) {\r\n                            ps += " ";\r\n                        }\r\n                        ps += cs;\r\n                    } else {\r\n                        // Replace all instances of & with regexp\r\n                        ps = _stripAtRules(cs.replace(/&/g, ps));\r\n                    }\r\n                    parentSelectorArray.push(ps);\r\n                });\r\n            });\r\n            finalSelectorArray = parentSelectorArray;\r\n        });\r\n        return finalSelectorArray.join(", ");\r\n    }\r\n\r\n    /**\r\n     * Finds all instances of the specified selector in "text".\r\n     * Returns an Array of Objects with start and end properties.\r\n     *\r\n     * For now, we only support simple selectors. This function will need to change\r\n     * dramatically to support full selectors.\r\n     *\r\n     * FUTURE: (JRB) It would be nice to eventually use the browser/jquery to do the selector evaluation.\r\n     * One way to do this would be to take the user\'s HTML, add a special attribute to every tag with a UID,\r\n     * and then construct a DOM (using the commented out code above). Then, give this DOM and the selector to \r\n     * jquery and ask what matches. If the node that the user\'s cursor is in comes back from jquery, then \r\n     * we know the selector applies.\r\n     *\r\n     * @param {!string} text CSS text to search\r\n     * @param {!string} selector selector to search for\r\n     * @param {!string} mode language mode of the document that text belongs to\r\n     * @return {Array.<{selectorGroupStartLine:number, declListEndLine:number, selector:string}>}\r\n     *      Array of objects containing the start and end line numbers (0-based, inclusive range) for each\r\n     *      matched selector.\r\n     */\r\n    function _findAllMatchingSelectorsInText(text, selector, mode) {\r\n        var allSelectors = extractAllSelectors(text, mode);\r\n        var result = [];\r\n        var i;\r\n        \r\n        // For now, we only match the rightmost simple selector, and ignore\r\n        // attribute selectors and pseudo selectors\r\n        var classOrIdSelector = selector[0] === "." || selector[0] === "#";\r\n        var prefix = "";\r\n        \r\n        // Escape initial "." in selector, if present.\r\n        if (selector[0] === ".") {\r\n            selector = "\\\\" + selector;\r\n        }\r\n        \r\n        if (!classOrIdSelector) {\r\n            // Tag selectors must have nothing, whitespace, or a combinator before it.\r\n            selector = "(^|[\\\\s>+~])" + selector;\r\n        }\r\n        \r\n        var re = new RegExp(selector + "(\\\\[[^\\\\]]*\\\\]|:{1,2}[\\\\w-()]+|\\\\.[\\\\w-]+|#[\\\\w-]+)*\\\\s*$", classOrIdSelector ? "" : "i");\r\n        allSelectors.forEach(function (entry) {\r\n            var actualSelector = entry.selector;\r\n            if (entry.selector.indexOf("&") !== -1 && entry.parentSelectors) {\r\n                var selectorArray = entry.parentSelectors.split(" / ");\r\n                selectorArray.push(entry.selector);\r\n                actualSelector = _getSelectorInFinalCSSForm(selectorArray);\r\n            }\r\n            if (actualSelector.search(re) !== -1) {\r\n                result.push(entry);\r\n            } else if (!classOrIdSelector) {\r\n                // Special case for tag selectors - match "*" as the rightmost character\r\n                if (/\\*\\s*$/.test(actualSelector)) {\r\n                    result.push(entry);\r\n                }\r\n            }\r\n        });\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Converts the results of _findAllMatchingSelectorsInText() into a simpler bag of data and\r\n     * appends those new objects to the given \'resultSelectors\' Array.\r\n     * @param {Array.<{document:Document, lineStart:number, lineEnd:number}>} resultSelectors\r\n     * @param {Array.<SelectorInfo>} selectorsToAdd\r\n     * @param {!Document} sourceDoc\r\n     * @param {!number} lineOffset Amount to offset all line number info by. Used if the first line\r\n     *          of the parsed CSS text is not the first line of the sourceDoc.\r\n     */\r\n    function _addSelectorsToResults(resultSelectors, selectorsToAdd, sourceDoc, lineOffset) {\r\n        selectorsToAdd.forEach(function (selectorInfo) {\r\n            resultSelectors.push({\r\n                name: getCompleteSelectors(selectorInfo),\r\n                document: sourceDoc,\r\n                lineStart: selectorInfo.ruleStartLine + lineOffset,\r\n                lineEnd: selectorInfo.declListEndLine + lineOffset,\r\n                selectorGroup: selectorInfo.selectorGroup\r\n            });\r\n        });\r\n    }\r\n    \r\n    /** Finds matching selectors in CSS files; adds them to \'resultSelectors\' */\r\n    function _findMatchingRulesInCSSFiles(selector, resultSelectors) {\r\n        var result          = new $.Deferred();\r\n        \r\n        // Load one CSS file and search its contents\r\n        function _loadFileAndScan(fullPath, selector) {\r\n            var oneFileResult = new $.Deferred();\r\n            \r\n            DocumentManager.getDocumentForPath(fullPath)\r\n                .done(function (doc) {\r\n                    // Find all matching rules for the given CSS file\'s content, and add them to the\r\n                    // overall search result\r\n                    var oneCSSFileMatches = _findAllMatchingSelectorsInText(doc.getText(), selector, doc.getLanguage().getMode());\r\n                    _addSelectorsToResults(resultSelectors, oneCSSFileMatches, doc, 0);\r\n                    \r\n                    oneFileResult.resolve();\r\n                })\r\n                .fail(function (error) {\r\n                    oneFileResult.reject(error);\r\n                });\r\n        \r\n            return oneFileResult.promise();\r\n        }\r\n        \r\n        ProjectManager.getAllFiles(ProjectManager.getLanguageFilter(["css", "less", "scss"]))\r\n            .done(function (cssFiles) {\r\n                // Load index of all CSS files; then process each CSS file in turn (see above)\r\n                Async.doInParallel(cssFiles, function (fileInfo, number) {\r\n                    return _loadFileAndScan(fileInfo.fullPath, selector);\r\n                })\r\n                    .then(result.resolve, result.reject);\r\n            });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /** Finds matching selectors in the <style> block of a single HTML file; adds them to \'resultSelectors\' */\r\n    function _findMatchingRulesInStyleBlocks(htmlDocument, selector, resultSelectors) {\r\n        // HTMLUtils requires a real CodeMirror instance; make sure we can give it the right Editor\r\n        var htmlEditor = EditorManager.getCurrentFullEditor();\r\n        if (htmlEditor.document !== htmlDocument) {\r\n            console.error("Cannot search for <style> blocks in HTML file other than current editor");\r\n            return;\r\n        }\r\n        \r\n        // Find all <style> blocks in the HTML file\r\n        var styleBlocks = HTMLUtils.findStyleBlocks(htmlEditor);\r\n        \r\n        styleBlocks.forEach(function (styleBlockInfo) {\r\n            // Search this one <style> block\'s content, appending results to \'resultSelectors\'\r\n            var oneStyleBlockMatches = _findAllMatchingSelectorsInText(styleBlockInfo.text, selector);\r\n            _addSelectorsToResults(resultSelectors, oneStyleBlockMatches, htmlDocument, styleBlockInfo.start.line);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Return all rules matching the specified selector.\r\n     * For now, we only look at the rightmost simple selector. For example, searching for ".foo" will\r\n     * match these rules:\r\n     *  .foo {}\r\n     *  div .foo {}\r\n     *  div.foo {}\r\n     *  div .foo[bar="42"] {}\r\n     *  div .foo:hovered {}\r\n     *  div .foo::first-child\r\n     * but will *not* match these rules:\r\n     *  .foobar {}\r\n     *  .foo .bar {}\r\n     *  div .foo .bar {}\r\n     *  .foo.bar {}\r\n     *\r\n     * @param {!string} selector The selector to match. This can be a tag selector, class selector or id selector\r\n     * @param {?Document} htmlDocument An HTML file for context (so we can search <style> blocks)\r\n     * @return {$.Promise} that will be resolved with an Array of objects containing the\r\n     *      source document, start line, and end line (0-based, inclusive range) for each matching declaration list.\r\n     *      Does not addRef() the documents returned in the array.\r\n     */\r\n    function findMatchingRules(selector, htmlDocument) {\r\n        var result          = new $.Deferred(),\r\n            resultSelectors = [];\r\n        \r\n        // Synchronously search for matches in <style> blocks\r\n        if (htmlDocument) {\r\n            _findMatchingRulesInStyleBlocks(htmlDocument, selector, resultSelectors);\r\n        }\r\n        \r\n        // Asynchronously search for matches in all the project\'s CSS files\r\n        // (results are appended together in same \'resultSelectors\' array)\r\n        _findMatchingRulesInCSSFiles(selector, resultSelectors)\r\n            .done(function () {\r\n                result.resolve(resultSelectors);\r\n            })\r\n            .fail(function (error) {\r\n                result.reject(error);\r\n            });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Returns the selector(s) of the rule at the specified document pos, or "" if the position is \r\n     * is not within a style rule.\r\n     *\r\n     * @param {!Editor} editor Editor to search\r\n     * @param {!{line: number, ch: number}} pos Position to search\r\n     * @return {string} Selector(s) for the rule at the specified position, or "" if the position\r\n     *          is not within a style rule. If the rule has multiple selectors, a comma-separated\r\n     *          selector string is returned.\r\n     */\r\n    function findSelectorAtDocumentPos(editor, pos) {\r\n        var cm = editor._codeMirror;\r\n        var ctx = TokenUtils.getInitialContext(cm, $.extend({}, pos));\r\n        var selector = "", inSelector = false, foundChars = false;\r\n        var isPreprocessorDoc = FileUtils.isCSSPreprocessorFile(editor.document.file.fullPath);\r\n        var selectorArray = [];\r\n\r\n        function _skipToOpeningBracket(ctx, startChar) {\r\n            var unmatchedBraces = 0;\r\n            if (!startChar) {\r\n                startChar = "}";\r\n            }\r\n            while (true) {\r\n                if (startChar === ctx.token.string) {\r\n                    unmatchedBraces++;\r\n                } else if (ctx.token.string.match(_invertedBracketPairs[startChar])) {\r\n                    unmatchedBraces--;\r\n                    if (unmatchedBraces <= 0) {\r\n                        return;\r\n                    }\r\n                }\r\n                \r\n                if (!TokenUtils.movePrevToken(ctx)) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Parse a selector. Assumes ctx is pointing at the opening\r\n        // { that is after the selector name.\r\n        function _parseSelector(ctx) {\r\n            var selector = "";\r\n            \r\n            // Skip over {\r\n            TokenUtils.movePrevToken(ctx);\r\n            \r\n            while (true) {\r\n                if (ctx.token.type !== "comment") {\r\n                    // Stop once we\'ve reached a {, }, or ;\r\n                    if (/[\\{\\}\\;]/.test(ctx.token.string)) {\r\n                        break;\r\n                    }\r\n                    \r\n                    // Stop once we\'ve reached a <style ...> tag\r\n                    if (ctx.token.string === "style" && ctx.token.type === "tag") {\r\n                        // Remove everything up to end-of-tag from selector\r\n                        var eotIndex = selector.indexOf(">");\r\n                        if (eotIndex !== -1) {\r\n                            selector = selector.substring(eotIndex + 1);\r\n                        }\r\n                        break;\r\n                    }\r\n                    \r\n                    selector = ctx.token.string + selector;\r\n                }\r\n                if (!TokenUtils.movePrevToken(ctx)) {\r\n                    break;\r\n                }\r\n            }\r\n            \r\n            return selector;\r\n        }\r\n\r\n        var skipPrevSibling = false;\r\n        \r\n        // If the cursor is inside a non-whitespace token with "block" or "top" state, then it is inside a \r\n        // selector. The only exception is when it is immediately after the \'{\'.\r\n        if (isPreprocessorDoc && _hasNonWhitespace(ctx.token.string) && ctx.token.string !== "{" &&\r\n                (ctx.token.state.state === "block" || ctx.token.state.state === "top")) {\r\n            foundChars = true;\r\n        }\r\n        \r\n        // scan backwards to see if the cursor is in a rule\r\n        while (true) {\r\n            if (ctx.token.type !== "comment") {\r\n                if (ctx.token.string === "}") {\r\n                    if (isPreprocessorDoc) {\r\n                        if (ctx.token.state.state === "top") {\r\n                            break;\r\n                        }\r\n                        skipPrevSibling = true;\r\n                        // Skip past the entire preceding block until the matching "{"\r\n                        _skipToOpeningBracket(ctx, "}");\r\n                    } else {\r\n                        break;\r\n                    }\r\n                } else if (ctx.token.string === "{") {\r\n                    selector = _parseSelector(ctx);\r\n                    if (isPreprocessorDoc) {\r\n                        if (!skipPrevSibling && !/^\\s*@/.test(selector)) {\r\n                            selectorArray.unshift(selector);\r\n                        }\r\n                        if (skipPrevSibling) {\r\n                            skipPrevSibling = false;\r\n                        }\r\n                    } else {\r\n                        break;\r\n                    }\r\n                } else {\r\n                    if (!isPreprocessorDoc && _hasNonWhitespace(ctx.token.string)) {\r\n                        foundChars = true;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            if (ctx.token.string !== "{" && ctx.token.string !== "}" && !TokenUtils.movePrevToken(ctx)) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        selector = _stripAtRules(selector);\r\n        \r\n        // Reset the context to original scan position\r\n        ctx = TokenUtils.getInitialContext(cm, $.extend({}, pos));\r\n        \r\n        // special case - we aren\'t in a selector and haven\'t found any chars,\r\n        // look at the next immediate token to see if it is non-whitespace. \r\n        // For preprocessor documents we need to move the cursor to next non-whitespace\r\n        // token so that we can collect the current selector if the cursor is inside it.\r\n        if ((!selector && !foundChars && !isPreprocessorDoc) ||\r\n                (isPreprocessorDoc && (ctx.token.string === "" || /\\s+/.test(ctx.token.string)))) {\r\n            if (TokenUtils.moveNextToken(ctx) && ctx.token.type !== "comment" && _hasNonWhitespace(ctx.token.string)) {\r\n                foundChars = true;\r\n                ctx = TokenUtils.getInitialContext(cm, $.extend({}, pos));\r\n            }\r\n        }\r\n        \r\n        // At this point if we haven\'t found a selector, but have seen chars when\r\n        // scanning, assume we are in the middle of a selector. For a preprocessor \r\n        // document we also need to collect the current selector if the cursor is \r\n        // is within the selector or whitespaces immediately before or after it.\r\n        if ((!selector || isPreprocessorDoc) && foundChars) {\r\n            // scan forward to see if the cursor is in a selector\r\n            while (true) {\r\n                if (ctx.token.type !== "comment") {\r\n                    if (ctx.token.string === "{") {\r\n                        selector = _parseSelector(ctx);\r\n                        if (isPreprocessorDoc && !/^\\s*@/.test(selector)) {\r\n                            selectorArray.push(selector);\r\n                        }\r\n                        break;\r\n                    } else if (ctx.token.string === "}" || ctx.token.string === ";") {\r\n                        break;\r\n                    }\r\n                }\r\n                if (!TokenUtils.moveNextToken(ctx)) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (isPreprocessorDoc) {\r\n            return _getSelectorInFinalCSSForm(selectorArray);\r\n        }\r\n        \r\n        return _stripAtRules(selector);\r\n    }\r\n    \r\n    /**\r\n     * removes CSS comments from the content \r\n     * @param {!string} content to reduce\r\n     * @return {string} reduced content \r\n     */\r\n    function _removeComments(content) {\r\n        return content.replace(/\\/\\*(?:(?!\\*\\/)[\\s\\S])*\\*\\//g, "");\r\n    }\r\n    \r\n    /**\r\n     * removes strings from the content \r\n     * @param {!string} content to reduce\r\n     * @return {string} reduced content \r\n     */\r\n    function _removeStrings(content) {\r\n        return content.replace(/[^\\\\]\\"(.*)[^\\\\]\\"|[^\\\\]\\\'(.*)[^\\\\]\\\'+/g, "");\r\n    }\r\n    \r\n    /**\r\n     * Reduces the style sheet by removing comments and strings \r\n     * so that the content can be parsed using a regular expression\r\n     * @param {!string} content to reduce\r\n     * @return {string} reduced content \r\n     */\r\n    function reduceStyleSheetForRegExParsing(content) {\r\n        return _removeStrings(_removeComments(content));\r\n    }\r\n    \r\n    /**\r\n     * Extracts all named flow instances\r\n     * @param {!string} text to extract from\r\n     * @return {Array.<string>} array of unique flow names found in the content (empty if none)\r\n     */\r\n    function extractAllNamedFlows(text) {\r\n        var namedFlowRegEx = /(?:flow\\-(into|from)\\:\\s*)([\\w\\-]+)(?:\\s*;)/gi,\r\n            result = [],\r\n            names = {},\r\n            thisMatch;\r\n        \r\n        // Reduce the content so that matches \r\n        // inside strings and comments are ignored \r\n        text = reduceStyleSheetForRegExParsing(text);\r\n\r\n        // Find the first match\r\n        thisMatch = namedFlowRegEx.exec(text);\r\n        \r\n        // Iterate over the matches and add them to result\r\n        while (thisMatch) {\r\n            var thisName = thisMatch[2];\r\n            \r\n            if (IGNORED_FLOW_NAMES.indexOf(thisName) === -1 && !names.hasOwnProperty(thisName)) {\r\n                names[thisName] = result.push(thisName);\r\n            }\r\n            thisMatch = namedFlowRegEx.exec(text);\r\n        }\r\n        \r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Adds a new rule to the end of the given document, and returns the range of the added rule\r\n     * and the position of the cursor on the indented blank line within it. Note that the range will\r\n     * not include all the inserted text (we insert extra newlines before and after the rule).\r\n     * @param {Document} doc The document to insert the rule into.\r\n     * @param {string} selector The selector to use for the given rule.\r\n     * @param {boolean} useTabChar Whether to indent with a tab.\r\n     * @param {number} indentUnit If useTabChar is false, how many spaces to indent with.\r\n     * @return {{range: {from: {line: number, ch: number}, to: {line: number, ch: number}}, pos: {line: number, ch: number}}}\r\n     *     The range of the inserted rule and the location where the cursor should be placed.\r\n     */\r\n    function addRuleToDocument(doc, selector, useTabChar, indentUnit) {\r\n        var newRule = "\\n" + selector + " {\\n",\r\n            blankLineOffset;\r\n        if (useTabChar) {\r\n            newRule += "\\t";\r\n            blankLineOffset = 1;\r\n        } else {\r\n            var i;\r\n            for (i = 0; i < indentUnit; i++) {\r\n                newRule += " ";\r\n            }\r\n            blankLineOffset = indentUnit;\r\n        }\r\n        newRule += "\\n}\\n";\r\n        \r\n        var docLines = doc.getText().split("\\n"),\r\n            lastDocLine = docLines.length - 1,\r\n            lastDocChar = docLines[docLines.length - 1].length;\r\n        doc.replaceRange(newRule, {line: lastDocLine, ch: lastDocChar});\r\n        return {\r\n            range: {\r\n                from: {line: lastDocLine + 1, ch: 0},\r\n                to: {line: lastDocLine + 3, ch: 1}\r\n            },\r\n            pos: {line: lastDocLine + 2, ch: blankLineOffset}\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * \r\n     * In the given rule array (as returned by `findMatchingRules()`), if multiple rules in a row \r\n     * refer to the same rule (because there were multiple matching selectors), eliminate the redundant \r\n     * rules. Also, always use the selector group if available instead of the original matching selector.\r\n     */\r\n    function consolidateRules(rules) {\r\n        var newRules = [], lastRule;\r\n        rules.forEach(function (rule) {\r\n            if (rule.selectorGroup) {\r\n                rule.name = rule.selectorGroup;\r\n            }\r\n            // Push the entry unless it refers to the same rule as the previous entry.\r\n            if (!(lastRule &&\r\n                     rule.document === lastRule.document &&\r\n                     rule.lineStart === lastRule.lineStart &&\r\n                     rule.lineEnd === lastRule.lineEnd &&\r\n                     rule.selectorGroup === lastRule.selectorGroup)) {\r\n                newRules.push(rule);\r\n            }\r\n            lastRule = rule;\r\n        });\r\n        return newRules;\r\n    }\r\n    \r\n    /**\r\n     * Given a TextRange, extracts the selector(s) for the rule in the range and returns it.\r\n     * Assumes the range only contains one rule; if there\'s more than one, it will return the\r\n     * selector(s) for the first rule.\r\n     * @param {TextRange} range The range to extract the selector(s) from.\r\n     * @return {string} The selector(s) for the rule in the range.\r\n     */\r\n    function getRangeSelectors(range) {\r\n        // There\'s currently no immediate way to access a given line in a Document, because it\'s just\r\n        // stored as a string. Eventually, we should have Documents cache the lines in the document\r\n        // as well, or make them use CodeMirror documents which do the same thing.\r\n        var i, startIndex = 0, endIndex, text = range.document.getText();\r\n        for (i = 0; i < range.startLine; i++) {\r\n            startIndex = text.indexOf("\\n", startIndex) + 1;\r\n        }\r\n        endIndex = startIndex;\r\n        // Go one line past the end line. We\'ll extract text up to but not including the last newline.\r\n        for (i = range.startLine + 1; i <= range.endLine + 1; i++) {\r\n            endIndex = text.indexOf("\\n", endIndex) + 1;\r\n        }\r\n        var allSelectors = extractAllSelectors(text.substring(startIndex, endIndex));\r\n        \r\n        // There should only be one rule in the range, and if there are multiple selectors for\r\n        // the first rule, they\'ll all be recorded in the "selectorGroup" for the first selector,\r\n        // so we only need to look at the first one.\r\n        return (allSelectors.length ? allSelectors[0].selectorGroup || allSelectors[0].selector : "");\r\n    }\r\n        \r\n    exports._findAllMatchingSelectorsInText = _findAllMatchingSelectorsInText; // For testing only\r\n    exports.findMatchingRules = findMatchingRules;\r\n    exports.extractAllSelectors = extractAllSelectors;\r\n    exports.extractAllNamedFlows = extractAllNamedFlows;\r\n    exports.findSelectorAtDocumentPos = findSelectorAtDocumentPos;\r\n    exports.reduceStyleSheetForRegExParsing = reduceStyleSheetForRegExParsing;\r\n    exports.addRuleToDocument = addRuleToDocument;\r\n    exports.consolidateRules = consolidateRules;\r\n    exports.getRangeSelectors = getRangeSelectors;\r\n    exports.getCompleteSelectors = getCompleteSelectors;\r\n\r\n    exports.SELECTOR = SELECTOR;\r\n    exports.PROP_NAME = PROP_NAME;\r\n    exports.PROP_VALUE = PROP_VALUE;\r\n    exports.IMPORT_URL = IMPORT_URL;\r\n    \r\n    exports.getInfoAtPos = getInfoAtPos;\r\n\r\n    // The createInfo is really only for the unit tests so they can make the same  \r\n    // structure to compare results with.\r\n    exports.createInfo = createInfo;\r\n});\r\n\n//# sourceURL=/language/CSSUtils.js'),eval(' /*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, brackets */\r\n\r\ndefine(\'utils/DropdownEventHandler\',[\'require\',\'exports\',\'module\',\'command/KeyBindingManager\',\'utils/KeyEvent\',\'widgets/PopUpManager\',\'utils/ViewUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n   \r\n    var KeyBindingManager = require("command/KeyBindingManager"),\r\n        KeyEvent          = require("utils/KeyEvent"),\r\n        PopUpManager      = require("widgets/PopUpManager"),\r\n        ViewUtils         = require("utils/ViewUtils");\r\n    \r\n    /**\r\n     * Object to handle events for a dropdown list.\r\n     *\r\n     * DropdownEventHandler handles these events:\r\n     *\r\n     * Mouse:\r\n     * - click       - execute selection callback and dismiss list\r\n     * - mouseover   - highlight item\r\n     * - mouseleave  - remove mouse highlighting\r\n     *\r\n     * Keyboard:\r\n     * - Enter       - execute selection callback and dismiss list\r\n     * - Esc         - dismiss list\r\n     * - Up/Down     - change selection\r\n     * - PageUp/Down - change selection\r\n     * \r\n     * Items whose <a> has the .disabled class do not respond to selection.\r\n     *\r\n     * @constructor\r\n     * @param {jQueryObject} $list  associated list object\r\n     * @param {Function} selectionCallback  function called when list item is selected.\r\n     */\r\n    function DropdownEventHandler($list, selectionCallback, closeCallback) {\r\n        \r\n        this.$list = $list;\r\n        this.$items = $list.find("li");\r\n        this.selectionCallback = selectionCallback;\r\n        this.closeCallback = closeCallback;\r\n        this.scrolling = false;\r\n        \r\n        /**\r\n         * @private\r\n         * The selected position in the list; otherwise -1.\r\n         * @type {number}\r\n         */\r\n        this._selectedIndex = -1;\r\n    }\r\n\r\n    /**\r\n     * Public open method\r\n     */\r\n    DropdownEventHandler.prototype.open = function () {\r\n        var self = this;\r\n\r\n        /**\r\n         * Convert keydown events into hint list navigation actions.\r\n         *\r\n         * @param {KeyboardEvent} event\r\n         * @return {boolean} true if key was handled, otherwise false.\r\n         */\r\n        function _keydownHook(event) {\r\n            var keyCode;\r\n    \r\n            // (page) up, (page) down, enter and tab key are handled by the list\r\n            if (event.type === "keydown") {\r\n                keyCode = event.keyCode;\r\n    \r\n                if (keyCode === KeyEvent.DOM_VK_UP) {\r\n                    // Move up one, wrapping at edges (if nothing selected, select the last item)\r\n                    self._tryToSelect(self._selectedIndex === -1 ? -1 : self._selectedIndex - 1, -1);\r\n                } else if (keyCode === KeyEvent.DOM_VK_DOWN) {\r\n                    // Move down one, wrapping at edges (if nothing selected, select the first item)\r\n                    self._tryToSelect(self._selectedIndex === -1 ? 0 : self._selectedIndex + 1, +1);\r\n                } else if (keyCode === KeyEvent.DOM_VK_PAGE_UP) {\r\n                    // Move up roughly one \'page\', stopping at edges (not wrapping) (if nothing selected, selects the first item)\r\n                    self._tryToSelect((self._selectedIndex || 0) - self._itemsPerPage(), -1, true);\r\n                } else if (keyCode === KeyEvent.DOM_VK_PAGE_DOWN) {\r\n                    // Move down roughly one \'page\', stopping at edges (not wrapping) (if nothing selected, selects the item one page down from the top)\r\n                    self._tryToSelect((self._selectedIndex || 0) + self._itemsPerPage(), +1, true);\r\n                    \r\n                } else if (keyCode === KeyEvent.DOM_VK_HOME) {\r\n                    self._tryToSelect(0, +1);\r\n                } else if (keyCode === KeyEvent.DOM_VK_END) {\r\n                    self._tryToSelect(self.$items.length - 1, -1);\r\n                    \r\n                } else if (self._selectedIndex !== -1 &&\r\n                        (keyCode === KeyEvent.DOM_VK_RETURN)) {\r\n    \r\n                    // Trigger a click handler to commmit the selected item\r\n                    self._selectionHandler();\r\n                } else {\r\n                    // Let the event bubble.\r\n                    return false;\r\n                }\r\n                \r\n                event.stopImmediatePropagation();\r\n                event.preventDefault();\r\n                return true;\r\n            }\r\n            \r\n            // If we didn\'t handle it, let other global keydown hooks handle it.\r\n            return false;\r\n        }\r\n\r\n        /**\r\n         * PopUpManager callback\r\n         */\r\n        function closeCallback() {\r\n            KeyBindingManager.removeGlobalKeydownHook(_keydownHook);\r\n            self._cleanup();\r\n        }\r\n        \r\n        KeyBindingManager.addGlobalKeydownHook(_keydownHook);\r\n        \r\n        if (this.$list) {\r\n            this._registerMouseEvents();\r\n            PopUpManager.addPopUp(this.$list, closeCallback, true);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Public close method\r\n     */\r\n    DropdownEventHandler.prototype.close = function () {\r\n        if (this.$list) {\r\n            PopUpManager.removePopUp(this.$list);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Cleanup\r\n     */\r\n    DropdownEventHandler.prototype._cleanup = function () {\r\n        if (this.$list) {\r\n            this.$list.off(".dropdownEventHandler");\r\n        }\r\n        if (this.closeCallback) {\r\n            this.closeCallback();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Try to select item at the given index. If it\'s disabled or a divider, keep trying by incrementing\r\n     * index by \'direction\' each time (wrapping around if needed).\r\n     * @param {number} index  If out of bounds, index either wraps around to remain in range (e.g. -1 yields\r\n     *                      last item, length+1 yields 2nd item) or if noWrap set, clips instead (e.g. -1 yields\r\n     *                      first item, length+1 yields last item).\r\n     * @param {number} direction  Either +1 or -1\r\n     * @param {boolean=} noWrap  Clip out of range index values instead of wrapping. Default false (wrap).\r\n     */\r\n    DropdownEventHandler.prototype._tryToSelect = function (index, direction, noWrap) {\r\n        // Fix up \'index\' if out of bounds (>= len or < 0)\r\n        var len = this.$items.length;\r\n        if (noWrap) {\r\n            // Clip to stay in range (and set direction so we don\'t wrap in the recursion case either)\r\n            if (index < 0) {\r\n                index = 0;\r\n                direction = +1;\r\n            } else if (index >= len) {\r\n                index = len - 1;\r\n                direction = -1;\r\n            }\r\n        } else {\r\n            // Wrap around to keep index in bounds\r\n            index %= len;\r\n            if (index < 0) {\r\n                index += len;\r\n            }\r\n        }\r\n        \r\n        var $item = this.$items.eq(index);\r\n        if ($item.hasClass("divider") || $item.find("a.disabled").length) {\r\n            // Desired item is ineligible for selection: try next one\r\n            this._tryToSelect(index + direction, direction, noWrap);\r\n        } else {\r\n            this._setSelectedIndex(index, true);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @return {number} The number of items per scroll page.\r\n     */\r\n    DropdownEventHandler.prototype._itemsPerPage = function () {\r\n        var itemsPerPage = 1,\r\n            itemHeight;\r\n\r\n        if (this.$items.length !== 0) {\r\n            itemHeight = $(this.$items[0]).height();\r\n            if (itemHeight) {\r\n                // round down to integer value\r\n                itemsPerPage = Math.floor(this.$list.height() / itemHeight);\r\n                itemsPerPage = Math.max(1, Math.min(itemsPerPage, this.$items.length));\r\n            }\r\n        }\r\n\r\n        return itemsPerPage;\r\n    };\r\n    \r\n    /**\r\n     * Call selectionCallback with selected index\r\n     */\r\n    DropdownEventHandler.prototype._selectionHandler = function () {\r\n\r\n        if (this._selectedIndex === -1) {\r\n            return;\r\n        }\r\n        \r\n        var $link = this.$items.eq(this._selectedIndex).find("a");\r\n        this._clickHandler($link);\r\n    };\r\n    \r\n    /**\r\n     * Call selectionCallback with selected item\r\n     *\r\n     * @param {jQueryObject} $item\r\n     */\r\n    DropdownEventHandler.prototype._clickHandler = function ($link) {\r\n\r\n        if (!this.selectionCallback || !this.$list || !$link) {\r\n            return;\r\n        }\r\n        if ($link.hasClass("disabled")) {\r\n            return;\r\n        }\r\n        \r\n        this.selectionCallback($link);\r\n        PopUpManager.removePopUp(this.$list);\r\n    };\r\n    \r\n    /**\r\n     * Select the item in the hint list at the specified index, or remove the\r\n     * selection if index < 0.\r\n     *\r\n     * @private\r\n     * @param {number} index\r\n     */\r\n    DropdownEventHandler.prototype._setSelectedIndex = function (index, scrollIntoView) {\r\n        \r\n        // Range check\r\n        index = Math.max(-1, Math.min(index, this.$items.length - 1));\r\n        \r\n        // Clear old highlight\r\n        if (this._selectedIndex !== -1) {\r\n            this.$items.eq(this._selectedIndex).find("a").removeClass("selected");\r\n        }\r\n\r\n        this._selectedIndex = index;\r\n\r\n        // Highlight the new selected item, if necessary\r\n        if (this._selectedIndex !== -1) {\r\n            var $item = this.$items.eq(this._selectedIndex);\r\n\r\n            $item.find("a").addClass("selected");\r\n            if (scrollIntoView) {\r\n                this.scrolling = true;\r\n                ViewUtils.scrollElementIntoView(this.$list, $item, false);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Register mouse event handlers\r\n     */\r\n    DropdownEventHandler.prototype._registerMouseEvents = function () {\r\n        var self = this;\r\n        \r\n        this.$list\r\n            .on("click.dropdownEventHandler", "a", function () {\r\n                self._clickHandler($(this));\r\n            })\r\n            .on("mouseover.dropdownEventHandler", "a", function (e) {\r\n                // Don\'t select item under mouse cursor when scrolling.\r\n                if (self.scrolling) {\r\n                    self.scrolling = false;\r\n                    return;\r\n                }\r\n                \r\n                var $link = $(e.currentTarget),\r\n                    $item = $link.closest("li"),\r\n                    viewOffset = self.$list.offset(),\r\n                    elementOffset = $item.offset();\r\n\r\n                // Only set selected if enabled & in view\r\n                // (dividers are already screened out since they don\'t have an "a" tag in them)\r\n                if (!$link.hasClass("disabled")) {\r\n                    if (elementOffset.top < viewOffset.top + self.$list.height() && viewOffset.top <= elementOffset.top) {\r\n                        self._setSelectedIndex(self.$items.index($item), false);\r\n                    }\r\n                }\r\n            });\r\n    };\r\n    \r\n    /**\r\n     * Re-register mouse event handlers\r\n     * @param {!jQueryObject} $list  newly updated list object\r\n     */\r\n    DropdownEventHandler.prototype.reRegisterMouseHandlers = function ($list) {\r\n        if (this.$list) {\r\n            this.$list.off(".dropdownEventHandler");\r\n            \r\n            this.$list = $list;\r\n            this.$items = $list.find("li");\r\n            \r\n            this._registerMouseEvents();\r\n        }\r\n    };\r\n\r\n    // Export public API\r\n    exports.DropdownEventHandler    = DropdownEventHandler;\r\n});\r\n\n//# sourceURL=/utils/DropdownEventHandler.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\n/**\r\n * Button that opens a dropdown list when clicked. More akin to a popup menu than a combobox. Compared to a\r\n * simple <select> element:\r\n *  - There\'s no "selected" state\r\n *  - The button\'s label is not automatically changed when an item in the list is clicked\r\n *  - Its width is not the max of all the dropdown items\' labels\r\n *  - The button & dropdown\'s appearance can be customized far more\r\n * Events\r\n *  - listRendered -- This event is dispatched after the entire list is rendered so that custom event handlers can be\r\n *                    set up for any custom UI in the list.\r\n * \r\n * TODO: merge DropdownEventHandler into this? Are there any other widgets that might want to use it separately?\r\n *\r\n */\r\ndefine(\'widgets/DropdownButton\',[\'require\',\'exports\',\'module\',\'utils/DropdownEventHandler\',\'view/WorkspaceManager\',\'command/Menus\',\'utils/ViewUtils\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    // Load dependent modules\r\n    var DropdownEventHandler    = require("utils/DropdownEventHandler").DropdownEventHandler,\r\n        WorkspaceManager        = require("view/WorkspaceManager"),\r\n        Menus                   = require("command/Menus"),\r\n        ViewUtils               = require("utils/ViewUtils"),\r\n        _                       = require("thirdparty/lodash");\r\n\r\n    /**\r\n     * Creates a single dropdown-button instance. The DOM node is created but not attached to\r\n     * the document anywhere - clients should append this.$button to the appropriate location.\r\n     * \r\n     * DropdownButton dispatches the following events:\r\n     *  - "select" - when an option in the dropdown is clicked. Passed item object and index.\r\n     * \r\n     * @param {!string} label  Label to display on the button\r\n     * @param {!Array.<*>} items  Items in the dropdown list. It generally doesn\'t matter what type/value the\r\n     *          items have, except that any item === "---" will be treated as a divider. Such items are not\r\n     *          clickable and itemRenderer() will not be called for them.\r\n     * @param {?function(*, number):!string|{html:string, enabled:boolean} itemRenderer  Optional function to\r\n     *          convert a single item to HTML (see itemRenderer() docs below). If not provided, items are\r\n     *          assumed to be plain text strings.\r\n     */\r\n    function DropdownButton(label, items, itemRenderer) {\r\n        this.items = items;\r\n        \r\n        this.itemRenderer = itemRenderer || this.itemRenderer;\r\n        \r\n        this._onClick        = this._onClick.bind(this);\r\n        this.closeDropdown   = this.closeDropdown.bind(this);\r\n        this._onClickOutside = this._onClickOutside.bind(this);\r\n        \r\n        this.$button = $("<button class=\'btn btn-dropdown\'/>")\r\n            .text(label)\r\n            .on("click", this._onClick);\r\n    }\r\n    \r\n    /**\r\n     * Items in dropdown list - may be changed any time dropdown isn\'t open\r\n     * @type {!Array.<*>}\r\n     */\r\n    DropdownButton.prototype.items = null;\r\n    \r\n    /**\r\n     * The clickable button. Available as soon as the DropdownButton is constructed.\r\n     * @type {!jQueryObject}\r\n     */\r\n    DropdownButton.prototype.$button = null;\r\n    \r\n    /**\r\n     * The dropdown element. Only non-null while open.\r\n     * @type {?jQueryObject}\r\n     */\r\n    DropdownButton.prototype.$dropdown = null;\r\n    \r\n    /**\r\n     * Extra CSS class(es) to apply to $dropdown\r\n     * @type {?string}\r\n     */\r\n    DropdownButton.prototype.dropdownExtraClasses = null;\r\n    \r\n    /**\r\n     * @private\r\n     * Where to restore focus when dropdown closed\r\n     * @type {?HTMLElement}\r\n     */\r\n    DropdownButton.prototype._lastFocus = null;\r\n    \r\n    /**\r\n     * @private\r\n     * Helper object for dropdown. Only non-null while open.\r\n     * @type {?DropdownEventHandler}\r\n     */\r\n    DropdownButton.prototype._dropdownEventHandler = null;\r\n    \r\n    \r\n    /**\r\n     * @private\r\n     * Handle clicking button\r\n     */\r\n    DropdownButton.prototype._onClick = function (event) {\r\n        if (!this.$button.hasClass("disabled")) {\r\n            this.toggleDropdown();\r\n        }\r\n        // Indicate click was handled (e.g. to shield from MultiRangeInlineEditor._onClick())\r\n        event.stopPropagation();\r\n    };\r\n    \r\n    /**\r\n     * Update the button label.\r\n     * @param {string} label \r\n     */\r\n    DropdownButton.prototype.setButtonLabel = function (label) {\r\n        if (!this.$button) {\r\n            return;\r\n        }\r\n        $(this.$button).text(label);\r\n    };\r\n    \r\n    /**\r\n     * Called for each item when rendering the dropdown.\r\n     * @param {*} item from items array\r\n     * @param {number} index in items array\r\n     * @return {!string|{html:string, enabled:boolean}} Formatted & escaped HTML, either as a simple string\r\n     *      or as the \'html\' field in an object that also conveys enabled state. Disabled items inherit gray\r\n     *      text color and cannot be selected.\r\n     */\r\n    DropdownButton.prototype.itemRenderer = function (item, index) {\r\n        return _.escape(String(item));\r\n    };\r\n    \r\n    /**\r\n     * Converts the list of item objects into HTML list items in format required by DropdownEventHandler\r\n     * @param {!jQueryObject} parent The dropdown element\r\n     * @return {!jQueryObject} The dropdown element with the rendered list items appended.\r\n     */\r\n    DropdownButton.prototype._renderList = function (parent) {\r\n        if (!parent) {\r\n            return null;\r\n        }\r\n        \r\n        var html = "";\r\n        this.items.forEach(function (item, i) {\r\n            if (item === "---") {\r\n                html += "<li class=\'divider\'></li>";\r\n            } else {\r\n                var rendered = this.itemRenderer(item, i),\r\n                    itemHtml = rendered.html || rendered,\r\n                    disabledClass = (rendered.html && !rendered.enabled) ? "disabled" : "";\r\n                \r\n                html += "<li><a class=\'stylesheet-link " + disabledClass + "\' data-index=\'" + i + "\'>";\r\n                html += itemHtml;\r\n                html += "</a></li>";\r\n            }\r\n        }.bind(this));\r\n        \r\n        parent.append(html);\r\n        \r\n        // Also trigger listRendered handler so that custom event handlers can be\r\n        // set up for any custom UI in the list.\r\n        $(this).triggerHandler("listRendered", [parent]);\r\n        \r\n        // Also need to re-register mouse event handlers with the updated list.\r\n        if (this._dropdownEventHandler) {\r\n            this._dropdownEventHandler.reRegisterMouseHandlers(parent);\r\n        }\r\n        \r\n        return parent;\r\n    };\r\n    \r\n    /**\r\n     * Refresh the dropdown list by removing and re-creating all list items.\r\n     * Call this after deleting/adding any item in the dropdown list.\r\n     */\r\n    DropdownButton.prototype.refresh = function () {\r\n        if (!this.$dropdown) {\r\n            return;\r\n        }\r\n        \r\n        // Remove all list items and then re-create them from this.items.\r\n        $("li", this.$dropdown).remove();\r\n        this._renderList(this.$dropdown);\r\n    };\r\n    \r\n    /**\r\n     * Check/Uncheck the list item of the given index.\r\n     * @param {number} index The index of the list item to be checked or unchecked\r\n     * @param {boolean} checked True if the list item is to be checked, false to get check\r\n     *    mark removed.\r\n     */\r\n    DropdownButton.prototype.setChecked = function (index, checked) {\r\n        if (!this.$dropdown) {\r\n            return;\r\n        }\r\n        \r\n        var listItems = $("li", this.$dropdown),\r\n            count     = listItems.length;\r\n\r\n        if (index > -1 && index < count) {\r\n            $("a", listItems[index]).toggleClass("checked", checked);\r\n        }\r\n    };\r\n        \r\n    /** Pops open the dropdown if currently closed. Does nothing if items.length == 0 */\r\n    DropdownButton.prototype.showDropdown = function () {\r\n        // Act like a plain old button if no items to show\r\n        if (!this.items.length) {\r\n            return;\r\n        }\r\n        \r\n        if (this.$dropdown) {\r\n            return;\r\n        }\r\n        \r\n        Menus.closeAll();\r\n        \r\n        var $dropdown = $("<ul class=\'dropdown-menu dropdownbutton-popup\' tabindex=\'-1\'>")\r\n            .addClass(this.dropdownExtraClasses)  // (no-op if unspecified)\r\n            .css("min-width", this.$button.outerWidth());  // do this before the clipping calcs below\r\n        \r\n        this.$dropdown = $dropdown;\r\n        this._renderList(this.$dropdown)\r\n            .appendTo($("body"))\r\n            .data("attached-to", this.$button[0]);  // keep ModalBar open while dropdown focused\r\n\r\n        // Calculate position of dropdown\r\n        var toggleOffset = this.$button.offset(),\r\n            posLeft      = toggleOffset.left,\r\n            posTop       = toggleOffset.top + this.$button.outerHeight(),\r\n            elementRect  = {\r\n                top:     posTop,\r\n                left:    posLeft,\r\n                height:  $dropdown.height(),\r\n                width:   $dropdown.width()\r\n            },\r\n            clip = ViewUtils.getElementClipSize($(window), elementRect);\r\n\r\n        if (clip.bottom > 0) {\r\n            // Bottom is clipped, so move entire menu above button\r\n            posTop = Math.max(0, toggleOffset.top - $dropdown.height() - 4);\r\n        }\r\n\r\n        if (clip.right > 0) {\r\n            // Right is clipped, so adjust left to fit menu in editor\r\n            posLeft = Math.max(0, posLeft - clip.right);\r\n        }\r\n\r\n        $dropdown.css({\r\n            left: posLeft,\r\n            top: posTop\r\n        });\r\n\r\n        // Attach event handlers\r\n        this._dropdownEventHandler = new DropdownEventHandler($dropdown, this._onSelect.bind(this), this._onDropdownClose.bind(this));\r\n        this._dropdownEventHandler.open();\r\n\r\n        window.document.body.addEventListener("mousedown", this._onClickOutside, true);\r\n        $(WorkspaceManager).on("workspaceUpdateLayout", this.closeDropdown);\r\n        \r\n        // Manage focus\r\n        this._lastFocus = window.document.activeElement;\r\n        $dropdown.focus();\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Clean up event handlers after dropdown closed & dispose old dropdown DOM. Called regardless of how the dropdown\r\n     * was closed.\r\n     */\r\n    DropdownButton.prototype._onDropdownClose = function () {\r\n        window.document.body.removeEventListener("mousedown", this._onClickOutside, true);\r\n        $(WorkspaceManager).off("workspaceUpdateLayout", this.closeDropdown);\r\n        \r\n        // Restore focus to old pos, unless "select" handler changed it\r\n        if (window.document.activeElement === this.$dropdown[0]) {\r\n            this._lastFocus.focus();\r\n        }\r\n\r\n        this._dropdownEventHandler = null;\r\n        this.$dropdown = null;  // already remvoed from DOM automatically by PopUpManager\r\n    };\r\n    \r\n    /** Closes the dropdown if currently open */\r\n    DropdownButton.prototype.closeDropdown = function () {\r\n        if (this._dropdownEventHandler) {\r\n            this._dropdownEventHandler.close();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Clicking outside the dropdown closes it\r\n     */\r\n    DropdownButton.prototype._onClickOutside = function (event) {\r\n        var $container = $(event.target).closest(".dropdownbutton-popup");\r\n\r\n        // If click is outside dropdown list or dropdown button, then close dropdown list\r\n        if (!$(event.target).is(this.$button) &&\r\n                ($container.length === 0 || $container[0] !== this.$dropdown[0])) {\r\n            this.closeDropdown();\r\n            event.stopPropagation();\r\n            event.preventDefault();\r\n        }\r\n    };\r\n    \r\n    /** Opens the dropdown if closed; closes it if open */\r\n    DropdownButton.prototype.toggleDropdown = function () {\r\n        if (this.$dropdown) {\r\n            this.closeDropdown();\r\n        } else {\r\n            this.showDropdown();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Callback from DropdownEventHandler when item in dropdown list is selected (via mouse or keyboard)\r\n     * @param {!jQueryObject} $link  The `a` element selected\r\n     */\r\n    DropdownButton.prototype._onSelect = function ($link) {\r\n        var itemIndex = Number($link.data("index"));\r\n        $(this).triggerHandler("select", [this.items[itemIndex], itemIndex]);\r\n    };\r\n    \r\n    \r\n    exports.DropdownButton = DropdownButton;\r\n});\r\n\n//# sourceURL=/widgets/DropdownButton.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n// FUTURE: Merge part (or all) of this class with InlineTextEditor\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\n/**\r\n * An inline editor for displaying and editing multiple text ranges. Each range corresponds to a \r\n * contiguous set of lines in a file. \r\n * \r\n * In the current implementation, only one range is visible at a time. A list on the right side\r\n * of the editor allows the user to select which range is visible. \r\n *\r\n * This module does not dispatch any events.\r\n */\r\ndefine(\'editor/MultiRangeInlineEditor\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'document/TextRange\',\'editor/InlineTextEditor\',\'editor/EditorManager\',\'command/Commands\',\'strings\',\'command/CommandManager\',\'utils/PerfUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n    \r\n    // Load dependent modules\r\n    var TextRange           = require("document/TextRange").TextRange,\r\n        InlineTextEditor    = require("editor/InlineTextEditor").InlineTextEditor,\r\n        EditorManager       = require("editor/EditorManager"),\r\n        Commands            = require("command/Commands"),\r\n        Strings             = require("strings"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        PerfUtils           = require("utils/PerfUtils");\r\n    \r\n    var _prevMatchCmd, _nextMatchCmd;\r\n\r\n    /**\r\n     * Remove trailing "px" from a style size value.\r\n     * @param {!JQuery} $target Element in DOM\r\n     * @param {!string} styleName Style name to query\r\n     * @return {number} Style value converted from string to number, removing "px" units\r\n     */\r\n    function _parseStyleSize($target, styleName) {\r\n        return parseInt($target.css(styleName), 10);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Stores one search result: its source file, line range, etc. plus the DOM node representing it\r\n     * in the results list.\r\n     * @constructor\r\n     */\r\n    function SearchResultItem(rangeResult) {\r\n        this.name = rangeResult.name;\r\n        this.textRange = new TextRange(rangeResult.document, rangeResult.lineStart, rangeResult.lineEnd);\r\n        // this.$listItem is assigned in load()\r\n    }\r\n    SearchResultItem.prototype.name = null;\r\n    SearchResultItem.prototype.textRange = null;\r\n    SearchResultItem.prototype.$listItem = null;\r\n    \r\n    function _updateRangeLabel(listItem, range, labelCB) {\r\n        if (labelCB) {\r\n            range.name = labelCB(range.textRange);\r\n        }\r\n        var text = _.escape(range.name) + " <span class=\'related-file\'>— " + _.escape(range.textRange.document.file.name) + " : " + (range.textRange.startLine + 1) + "</span>";\r\n        listItem.html(text);\r\n        listItem.attr("title", listItem.text());\r\n    }\r\n    \r\n    /**\r\n     * @constructor\r\n     * @param {Array.<{name:String,document:Document,lineStart:number,lineEnd:number}>} ranges The text ranges to display.\r\n     * @param {function(): $.Promise} messageCB An optional callback that returns a promise that will be resolved with a message to show\r\n     *      when no matches are available.\r\n     * @param {function(range): string} labelCB An optional callback that returns an updated label string for the given range. Called\r\n     *      when we detect that the content of one of the ranges has changed.\r\n     * @extends {InlineTextEditor}\r\n     */\r\n    function MultiRangeInlineEditor(ranges, messageCB, labelCB) {\r\n        InlineTextEditor.call(this);\r\n        \r\n        // Store the results to show in the range list. This creates TextRanges bound to the Document,\r\n        // which will stay up to date automatically (but we must be sure to detach them later)\r\n        this._ranges = ranges.map(function (rangeResult) {\r\n            return new SearchResultItem(rangeResult);\r\n        });\r\n        this._messageCB = messageCB;\r\n        this._labelCB = labelCB;\r\n        \r\n        this._selectedRangeIndex = -1;\r\n    }\r\n    MultiRangeInlineEditor.prototype = Object.create(InlineTextEditor.prototype);\r\n    MultiRangeInlineEditor.prototype.constructor = MultiRangeInlineEditor;\r\n    MultiRangeInlineEditor.prototype.parentClass = InlineTextEditor.prototype;\r\n    \r\n    MultiRangeInlineEditor.prototype.$messageDiv = null;\r\n    MultiRangeInlineEditor.prototype.$relatedContainer = null;\r\n    MultiRangeInlineEditor.prototype.$related = null;\r\n    MultiRangeInlineEditor.prototype.$selectedMarker = null;\r\n    MultiRangeInlineEditor.prototype.$rangeList = null;\r\n    \r\n    /**\r\n     * List of search results\r\n     * @type {Array.<SearchResultItem>}\r\n     */\r\n    MultiRangeInlineEditor.prototype._ranges = null;\r\n    MultiRangeInlineEditor.prototype._selectedRangeIndex = null;\r\n    MultiRangeInlineEditor.prototype._messageCB = null;\r\n    MultiRangeInlineEditor.prototype._labelCB = null;\r\n    \r\n    /**\r\n     * @private\r\n     * Add a new range to the range list UI.\r\n     * @param {SearchResultItem} range The range to add.\r\n     * @param {number=} index Where to add the range in the list. Defaults to the end.\r\n     */\r\n    MultiRangeInlineEditor.prototype._createListItem = function (range, index) {\r\n        var self = this,\r\n            $rangeItem = $("<li/>"),\r\n            $rangeListChildren = this.$rangeList.children();\r\n        \r\n        if (index === undefined || index === $rangeListChildren.length) {\r\n            $rangeItem.appendTo(this.$rangeList);\r\n        } else {\r\n            $rangeItem.insertBefore($rangeListChildren.get(index));\r\n        }\r\n        \r\n        _updateRangeLabel($rangeItem, range);\r\n        $rangeItem.mousedown(function () {\r\n            self.setSelectedIndex(self._ranges.indexOf(range));\r\n        });\r\n\r\n        range.$listItem = $rangeItem;\r\n        \r\n        // Update list item as TextRange changes\r\n        $(range.textRange).on("change", function () {\r\n            _updateRangeLabel($rangeItem, range);\r\n        }).on("contentChange", function () {\r\n            _updateRangeLabel($rangeItem, range, self._labelCB);\r\n        });\r\n        \r\n        // If TextRange lost sync, remove it from the list (and close the widget if no other ranges are left)\r\n        $(range.textRange).on("lostSync", function () {\r\n            self._removeRange(range);\r\n        });\r\n    };\r\n\r\n    /** \r\n     * @override\r\n     * @param {!Editor} hostEditor  Outer Editor instance that inline editor will sit within.\r\n     * \r\n     */\r\n    MultiRangeInlineEditor.prototype.load = function (hostEditor) {\r\n        MultiRangeInlineEditor.prototype.parentClass.load.apply(this, arguments);\r\n        \r\n        // Create the message area\r\n        this.$messageDiv = $("<div/>")\r\n            .addClass("inline-editor-message");\r\n        \r\n        // Prevent touch scroll events from bubbling up to the parent editor.\r\n        this.$editorHolder.on("mousewheel.MultiRangeInlineEditor", function (e) {\r\n            e.stopPropagation();\r\n        });\r\n\r\n        // Outer container for border-left and scrolling\r\n        this.$relatedContainer = $("<div/>").addClass("related-container");\r\n        \r\n        // List "selection" highlight\r\n        this.$selectedMarker = $("<div/>").appendTo(this.$relatedContainer).addClass("selection");\r\n\r\n        // Inner container\r\n        this.$related = $("<div/>").appendTo(this.$relatedContainer).addClass("related");\r\n        \r\n        // Range list\r\n        this.$rangeList = $("<ul/>").appendTo(this.$related);\r\n        \r\n        // create range list & add listeners for range textrange changes\r\n        var rangeItemText;\r\n        this._ranges.forEach(this._createListItem, this);\r\n        \r\n        if (this._ranges.length > 1) {      // attach to main container\r\n            this.$wrapper.before(this.$relatedContainer);\r\n        }\r\n                \r\n        if (this._ranges.length) {\r\n            // select the first range\r\n            this.setSelectedIndex(0);\r\n        } else {\r\n            // force the message div to show\r\n            this.setSelectedIndex(-1);\r\n        }\r\n        \r\n        // Listen for clicks directly on us, so we can set focus back to the editor\r\n        var clickHandler = this._onClick.bind(this);\r\n        this.$htmlContent.on("click.MultiRangeInlineEditor", clickHandler);\r\n        // Also handle mouseup in case the user drags a little bit\r\n        this.$htmlContent.on("mouseup.MultiRangeInlineEditor", clickHandler);\r\n        \r\n        // Update the rule list navigation menu items when we gain/lose focus.\r\n        this.$htmlContent\r\n            .on("focusin.MultiRangeInlineEditor", this._updateCommands.bind(this))\r\n            .on("focusout.MultiRangeInlineEditor", this._updateCommands.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Updates the enablement for the rule list navigation commands.\r\n     */\r\n    MultiRangeInlineEditor.prototype._updateCommands = function () {\r\n        var enabled = (this.hasFocus() && this._ranges.length > 1);\r\n        _prevMatchCmd.setEnabled(enabled && this._selectedRangeIndex > 0);\r\n        _nextMatchCmd.setEnabled(enabled && this._selectedRangeIndex !== -1 && this._selectedRangeIndex < this._ranges.length - 1);\r\n    };\r\n    \r\n    /**\r\n     * @override\r\n     */\r\n    MultiRangeInlineEditor.prototype.onAdded = function () {\r\n        var self = this;\r\n        \r\n        // Before setting the inline widget height, force a height on the\r\n        // floating related-container in order for CodeMirror to layout and\r\n        // compute scrollbars\r\n        this.$relatedContainer.height(this.$related.height());\r\n\r\n        // Set the initial position of the selected marker now that we\'re laid out.\r\n        this._updateSelectedMarker(false);\r\n\r\n        // Call super\r\n        MultiRangeInlineEditor.prototype.parentClass.onAdded.apply(this, arguments);\r\n\r\n        // Editor must be at least as tall as the related list\r\n        this._updateEditorMinHeight();\r\n        \r\n        // Set the initial inline widget height\r\n        this.sizeInlineWidgetToContents(true, false);\r\n        \r\n        this._updateCommands();\r\n    };\r\n\r\n    /**\r\n     * Specify the range that is shown in the editor.\r\n     *\r\n     * @param {!number} index The index of the range to select, or -1 to deselect all.\r\n     * @param {boolean} force Whether to re-select the item even if we think it\'s already selected\r\n     *     (used if the range list has changed).\r\n     */\r\n    MultiRangeInlineEditor.prototype.setSelectedIndex = function (index, force) {\r\n        var newIndex = Math.min(Math.max(-1, index), this._ranges.length - 1),\r\n            self = this;\r\n        \r\n        if (!force && newIndex !== -1 && newIndex === this._selectedRangeIndex) {\r\n            return;\r\n        }\r\n\r\n        // Remove selected class(es)\r\n        var $previousItem = (this._selectedRangeIndex >= 0) ? this._ranges[this._selectedRangeIndex].$listItem : null;\r\n        if ($previousItem) {\r\n            $previousItem.removeClass("selected");\r\n        }\r\n        \r\n        // Clear our listeners on the previous editor since it\'ll be destroyed in setInlineContent().\r\n        if (this.editor) {\r\n            $(this.editor).off(".MultiRangeInlineEditor");\r\n        }\r\n\r\n        this._selectedRangeIndex = newIndex;\r\n        \r\n        if (newIndex === -1) {\r\n            // show the message div\r\n            this.setInlineContent(null);\r\n            if (this._messageCB) {\r\n                this._messageCB().done(function (msg) {\r\n                    self.$messageDiv.html(msg);\r\n                });\r\n            } else {\r\n                this.$messageDiv.text(Strings.INLINE_EDITOR_NO_MATCHES);\r\n            }\r\n            this.$htmlContent.append(this.$messageDiv);\r\n            this.sizeInlineWidgetToContents(true, false);\r\n        } else {\r\n            this.$messageDiv.remove();\r\n            \r\n            var range = this._getSelectedRange();\r\n            range.$listItem.addClass("selected");\r\n    \r\n            // Add new editor\r\n            this.setInlineContent(range.textRange.document, range.textRange.startLine, range.textRange.endLine);\r\n            this.editor.focus();\r\n    \r\n            this._updateEditorMinHeight();\r\n            this.editor.refresh();\r\n            \r\n            // Ensure the cursor position is visible in the host editor as the user is arrowing around.\r\n            $(this.editor).on("cursorActivity.MultiRangeInlineEditor", this._ensureCursorVisible.bind(this));\r\n            \r\n            // ensureVisibility is set to false because we don\'t want to scroll the main editor when the user selects a view\r\n            this.sizeInlineWidgetToContents(true, false);\r\n    \r\n            this._updateSelectedMarker(true);\r\n        }\r\n        \r\n        this._updateCommands();\r\n    };\r\n    \r\n    /**\r\n     * Ensures that the editor\'s min-height is set so it never gets shorter than the rule list.\r\n     * This is necessary to make sure the editor\'s horizontal scrollbar stays at the bottom of the\r\n     * widget.\r\n     */\r\n    MultiRangeInlineEditor.prototype._updateEditorMinHeight = function () {\r\n        if (!this.editor) {\r\n            return;\r\n        }\r\n        \r\n        // Set the scroller\'s min-height to the natural height of the rule list, so the editor\r\n        // always stays at least as tall as the rule list.\r\n        var ruleListNaturalHeight = this.$related.outerHeight(),\r\n            headerHeight = $(".inline-editor-header", this.$htmlContent).outerHeight();\r\n\r\n        // If the widget isn\'t fully loaded yet, bail--we\'ll get called again in onAdded().\r\n        if (!ruleListNaturalHeight || !headerHeight) {\r\n            return;\r\n        }\r\n        \r\n        // We have to set this on the scroller instead of the wrapper because:\r\n        // * we want the wrapper\'s actual height to remain "auto"\r\n        // * if we set a min-height on the wrapper, the scroller\'s height: 100% doesn\'t\r\n        //   respect it (height: 100% doesn\'t seem to work properly with min-height on the parent)\r\n        $(this.editor.getScrollerElement())\r\n            .css("min-height", (ruleListNaturalHeight - headerHeight) + "px");\r\n    };\r\n\r\n    MultiRangeInlineEditor.prototype._removeRange = function (range) {\r\n        // If this is the last range, just close the whole widget\r\n        if (this._ranges.length <= 1) {\r\n            this.close();\r\n            return;\r\n        }\r\n\r\n        // Now we know there is at least one other range -> found out which one this is\r\n        var index = this._ranges.indexOf(range);\r\n        \r\n        // If the range to be removed is the selected one, first switch to another one\r\n        if (index === this._selectedRangeIndex) {\r\n            // If possible, select the one below, else select the one above\r\n            if (index + 1 < this._ranges.length) {\r\n                this.setSelectedIndex(index + 1);\r\n            } else {\r\n                this.setSelectedIndex(index - 1);\r\n            }\r\n        }\r\n\r\n        // Now we can remove this range\r\n        range.$listItem.remove();\r\n        range.textRange.dispose();\r\n        this._ranges.splice(index, 1);\r\n\r\n        // If the selected range is below, we need to update the index\r\n        if (index < this._selectedRangeIndex) {\r\n            this._selectedRangeIndex--;\r\n            this._updateSelectedMarker(true);\r\n        }\r\n        \r\n        if (this._ranges.length === 1) {\r\n            this.$relatedContainer.remove();\r\n            \r\n            // Refresh the height of the inline editor since we remove\r\n            // the entire selector list.\r\n            if (this.editor) {\r\n                this.editor.refresh();\r\n            }\r\n        }\r\n        \r\n        this._updateCommands();\r\n    };\r\n    \r\n    /**\r\n     * Adds a new range to the inline editor and selects it. The range will be inserted\r\n     * immediately below the last range for the same document, or at the end of the list\r\n     * if there are no other ranges for that document.\r\n     * @param {string} name The label for the new range.\r\n     * @param {Document} doc The document the range is in.\r\n     * @param {number} lineStart The starting line of the range, 0-based, inclusive.\r\n     * @param {number} lineEnd The ending line of the range, 0-based, inclusive.\r\n     */\r\n    MultiRangeInlineEditor.prototype.addAndSelectRange = function (name, doc, lineStart, lineEnd) {\r\n        var newRange = new SearchResultItem({\r\n                name: name,\r\n                document: doc,\r\n                lineStart: lineStart,\r\n                lineEnd: lineEnd\r\n            }),\r\n            i;\r\n        \r\n        // Insert the new range after the last range from the same doc, or at the\r\n        // end of the list.\r\n        for (i = this._ranges.length - 1; i >= 0; i--) {\r\n            if (this._ranges[i].textRange.document === doc) {\r\n                break;\r\n            }\r\n        }\r\n        if (i === -1) {\r\n            i = this._ranges.length;\r\n        } else {\r\n            i++;\r\n        }\r\n        this._ranges.splice(i, 0, newRange);\r\n        \r\n        // Add the new range to the UI and select it. This should load the associated range\r\n        // into the editor.\r\n        this._createListItem(newRange, i);\r\n        this.setSelectedIndex(i, true);\r\n\r\n        // Ensure that the rule list becomes visible if it wasn\'t already and we have\r\n        // more than one rule.\r\n        if (this._ranges.length > 1 && !this.$relatedContainer.parent().length) {\r\n            this.$wrapper.before(this.$relatedContainer);\r\n        }\r\n\r\n        this._updateCommands();\r\n    };\r\n\r\n    MultiRangeInlineEditor.prototype._updateSelectedMarker = function (animate) {\r\n        if (this._selectedRangeIndex < 0) {\r\n            return new $.Deferred().resolve().promise();\r\n        }\r\n        \r\n        var result = new $.Deferred(),\r\n            $rangeItem = this._ranges[this._selectedRangeIndex].$listItem;\r\n        \r\n        // scroll the selection to the rangeItem, use setTimeout to wait for DOM updates\r\n        var self = this;\r\n        window.setTimeout(function () {\r\n            var containerHeight = self.$relatedContainer.height(),\r\n                itemTop = $rangeItem.position().top,\r\n                scrollTop = self.$relatedContainer.scrollTop();\r\n            \r\n            self.$selectedMarker\r\n                .toggleClass("animate", animate)\r\n                .css("top", itemTop)\r\n                .height($rangeItem.outerHeight());\r\n            \r\n            if (containerHeight <= 0) {\r\n                return;\r\n            }\r\n            \r\n            var paddingTop = _parseStyleSize($rangeItem.parent(), "paddingTop");\r\n            \r\n            if ((itemTop - paddingTop) < scrollTop) {\r\n                self.$relatedContainer.scrollTop(itemTop - paddingTop);\r\n            } else {\r\n                var itemBottom = itemTop + $rangeItem.height() + _parseStyleSize($rangeItem.parent(), "paddingBottom");\r\n                \r\n                if (itemBottom > (scrollTop + containerHeight)) {\r\n                    self.$relatedContainer.scrollTop(itemBottom - containerHeight);\r\n                }\r\n            }\r\n            \r\n            result.resolve();\r\n        }, 0);\r\n        \r\n        return result.promise();\r\n    };\r\n\r\n    /**\r\n     * Called any time inline is closed, whether manually (via closeThisInline()) or automatically\r\n     */\r\n    MultiRangeInlineEditor.prototype.onClosed = function () {\r\n        // Superclass onClosed() destroys editor\r\n        MultiRangeInlineEditor.prototype.parentClass.onClosed.apply(this, arguments);\r\n\r\n        // de-ref all the Documents in the search results\r\n        this._ranges.forEach(function (searchResult) {\r\n            searchResult.textRange.dispose();\r\n        });\r\n\r\n        // Remove event handlers\r\n        this.$htmlContent.off(".MultiRangeInlineEditor");\r\n        this.$editorHolder.off(".MultiRangeInlineEditor");\r\n    };\r\n    \r\n    /**\r\n     * Prevent clicks in the dead areas of the inlineWidget from changing the focus and insertion point in the editor.\r\n     * This is done by detecting clicks in the inlineWidget that are not inside the editor or the range list and\r\n     * restoring focus and the insertion point.\r\n     */\r\n    MultiRangeInlineEditor.prototype._onClick = function (event) {\r\n        if (!this.editor) {\r\n            return;\r\n        }\r\n        \r\n        var childEditor = this.editor,\r\n            editorRoot = childEditor.getRootElement(),\r\n            editorPos = $(editorRoot).offset();\r\n        \r\n        function containsClick($parent) {\r\n            return $parent.find(event.target) > 0 || $parent[0] === event.target;\r\n        }\r\n        \r\n        // Ignore clicks in editor and clicks on filename link\r\n        // Check clicks on filename link in the context of the current inline widget.\r\n        if (!containsClick($(editorRoot)) && !containsClick($(".filename", this.$htmlContent))) {\r\n            childEditor.focus();\r\n            // Only set the cursor if the click isn\'t in the range list.\r\n            if (!containsClick(this.$relatedContainer)) {\r\n                if (event.pageY < editorPos.top) {\r\n                    childEditor.setCursorPos(0, 0);\r\n                } else if (event.pageY > editorPos.top + $(editorRoot).height()) {\r\n                    var lastLine = childEditor.getLastVisibleLine();\r\n                    childEditor.setCursorPos(lastLine, childEditor.document.getLine(lastLine).length);\r\n                }\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Based on the position of the cursor in the inline editor, determine whether we need to change the\r\n     * vertical scroll position of the host editor to ensure that the cursor is visible.\r\n     */\r\n    MultiRangeInlineEditor.prototype._ensureCursorVisible = function () {\r\n        if (!this.editor) {\r\n            return;\r\n        }\r\n        \r\n        if ($.contains(this.editor.getRootElement(), window.document.activeElement)) {\r\n            var hostScrollPos = this.hostEditor.getScrollPos(),\r\n                cursorCoords = this.editor._codeMirror.cursorCoords();\r\n            \r\n            // Vertically, we want to set the scroll position relative to the overall host editor, not\r\n            // the lineSpace of the widget itself. We don\'t want to modify the horizontal scroll position.\r\n            var scrollerTop = this.hostEditor.getVirtualScrollAreaTop();\r\n            this.hostEditor._codeMirror.scrollIntoView({\r\n                left: hostScrollPos.x,\r\n                top: cursorCoords.top - scrollerTop,\r\n                right: hostScrollPos.x,\r\n                bottom: cursorCoords.bottom - scrollerTop\r\n            });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Overwrite InlineTextEditor\'s _onLostContent to do nothing if the document\'s file is deleted\r\n     * (deletes are handled via TextRange\'s lostSync).\r\n     */\r\n    MultiRangeInlineEditor.prototype._onLostContent = function (event, cause) {\r\n        // Ignore when the editor\'s content got lost due to a deleted file\r\n        if (cause && cause.type === "deleted") { return; }\r\n        // Else yield to the parent\'s implementation\r\n        return MultiRangeInlineEditor.prototype.parentClass._onLostContent.apply(this, arguments);\r\n    };\r\n\r\n    /**\r\n     * @return {Array.<SearchResultItem>}\r\n     */\r\n    MultiRangeInlineEditor.prototype._getRanges = function () {\r\n        return this._ranges;\r\n    };\r\n\r\n    /**\r\n     * @return {!SearchResultItem}\r\n     */\r\n    MultiRangeInlineEditor.prototype._getSelectedRange = function () {\r\n        return this._selectedRangeIndex >= 0 ? this._ranges[this._selectedRangeIndex] : null;\r\n    };\r\n\r\n    /**\r\n     * Display the next range in the range list\r\n     */\r\n    MultiRangeInlineEditor.prototype._selectNextRange = function () {\r\n        if (this._selectedRangeIndex < this._ranges.length - 1) {\r\n            this.setSelectedIndex(this._selectedRangeIndex + 1);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     *  Display the previous range in the range list\r\n     */\r\n    MultiRangeInlineEditor.prototype._selectPreviousRange = function () {\r\n        if (this._selectedRangeIndex > 0) {\r\n            this.setSelectedIndex(this._selectedRangeIndex - 1);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Sizes the inline widget height to be the maximum between the range list height and the editor height\r\n     * @override \r\n     * @param {boolean} force the editor to resize\r\n     * @param {boolean} ensureVisibility makes the parent editor scroll to display the inline editor. Default true.\r\n     */\r\n    MultiRangeInlineEditor.prototype.sizeInlineWidgetToContents = function (force, ensureVisibility) {\r\n        // Size the code mirror editors height to the editor content\r\n        // We use "call" rather than "apply" here since ensureVisibility was an argument added just for this override.\r\n        MultiRangeInlineEditor.prototype.parentClass.sizeInlineWidgetToContents.call(this, force);\r\n        \r\n        // Size the widget height to the max between the editor/message content and the related ranges list\r\n        var widgetHeight = Math.max(this.$related.height(),\r\n                                    this.$header.outerHeight() +\r\n                                        (this._selectedRangeIndex === -1 ? this.$messageDiv.outerHeight() : this.$editorHolder.height()));\r\n\r\n        if (widgetHeight) {\r\n            this.hostEditor.setInlineWidgetHeight(this, widgetHeight, ensureVisibility);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Called when the editor containing the inline is made visible. Updates UI based on\r\n     * state that might have changed while the editor was hidden.\r\n     */\r\n    MultiRangeInlineEditor.prototype.onParentShown = function () {\r\n        MultiRangeInlineEditor.prototype.parentClass.onParentShown.apply(this, arguments);\r\n        this._updateSelectedMarker(false);\r\n    };\r\n    \r\n    /**\r\n     * Refreshes the height of the inline editor and all child editors.\r\n     * @override\r\n     */\r\n    MultiRangeInlineEditor.prototype.refresh = function () {\r\n        MultiRangeInlineEditor.prototype.parentClass.refresh.apply(this, arguments);\r\n        this.sizeInlineWidgetToContents(true);\r\n        if (this.editor) {\r\n            this.editor.refresh();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the currently focused MultiRangeInlineEditor.\r\n     * @return {MultiRangeInlineEditor}\r\n     */\r\n    function getFocusedMultiRangeInlineEditor() {\r\n        var focusedWidget = EditorManager.getFocusedInlineWidget();\r\n        if (focusedWidget instanceof MultiRangeInlineEditor) {\r\n            return focusedWidget;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Previous Range command handler\r\n     */\r\n    function _previousRange() {\r\n        var focusedMultiRangeInlineEditor = getFocusedMultiRangeInlineEditor();\r\n        if (focusedMultiRangeInlineEditor) {\r\n            focusedMultiRangeInlineEditor._selectPreviousRange();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Next Range command handler\r\n     */\r\n    function _nextRange() {\r\n        var focusedMultiRangeInlineEditor = getFocusedMultiRangeInlineEditor();\r\n        if (focusedMultiRangeInlineEditor) {\r\n            focusedMultiRangeInlineEditor._selectNextRange();\r\n        }\r\n    }\r\n    \r\n    _prevMatchCmd = CommandManager.register(Strings.CMD_QUICK_EDIT_PREV_MATCH, Commands.QUICK_EDIT_PREV_MATCH, _previousRange);\r\n    _prevMatchCmd.setEnabled(false);\r\n    _nextMatchCmd = CommandManager.register(Strings.CMD_QUICK_EDIT_NEXT_MATCH, Commands.QUICK_EDIT_NEXT_MATCH, _nextRange);\r\n    _nextMatchCmd.setEnabled(false);\r\n\r\n    exports.MultiRangeInlineEditor = MultiRangeInlineEditor;\r\n    exports.getFocusedMultiRangeInlineEditor = getFocusedMultiRangeInlineEditor;\r\n});\r\n\n//# sourceURL=/editor/MultiRangeInlineEditor.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint regexp: true, vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, Mustache */\r\n\r\ndefine(\'editor/CSSInlineEditor\',[\'require\',\'exports\',\'module\',\'language/CSSUtils\',\'widgets/DropdownButton\',\'command/CommandManager\',\'command/Commands\',\'document/DocumentManager\',\'editor/EditorManager\',\'editor/Editor\',\'project/ProjectManager\',\'language/HTMLUtils\',\'editor/MultiRangeInlineEditor\',\'strings\',\'utils/ViewUtils\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    // Load dependent modules\r\n    var CSSUtils                = require("language/CSSUtils"),\r\n        DropdownButton          = require("widgets/DropdownButton").DropdownButton,\r\n        CommandManager          = require("command/CommandManager"),\r\n        Commands                = require("command/Commands"),\r\n        DocumentManager         = require("document/DocumentManager"),\r\n        EditorManager           = require("editor/EditorManager"),\r\n        Editor                  = require("editor/Editor").Editor,\r\n        ProjectManager          = require("project/ProjectManager"),\r\n        HTMLUtils               = require("language/HTMLUtils"),\r\n        MultiRangeInlineEditor  = require("editor/MultiRangeInlineEditor"),\r\n        Strings                 = require("strings"),\r\n        ViewUtils               = require("utils/ViewUtils"),\r\n        _                       = require("thirdparty/lodash");\r\n    \r\n    var _newRuleCmd,\r\n        _newRuleHandlers = [];\r\n\r\n    function _getCSSFilesInProject() {\r\n        return ProjectManager.getAllFiles(ProjectManager.getLanguageFilter(["css", "less", "scss"]));\r\n    }\r\n    \r\n    /**\r\n     * Given a position in an HTML editor, returns the relevant selector for the attribute/tag\r\n     * surrounding that position, or "" if none is found.\r\n     * @param {!Editor} editor\r\n     * @param {!{line:Number, ch:Number}} pos\r\n     * @return {selectorName: {string}, reason: {string}}\r\n     * @private\r\n     */\r\n    function _getSelectorName(editor, pos) {\r\n        var tagInfo = HTMLUtils.getTagInfo(editor, pos),\r\n            selectorName = "",\r\n            reason;\r\n        \r\n        if (tagInfo.position.tokenType === HTMLUtils.TAG_NAME || tagInfo.position.tokenType === HTMLUtils.CLOSING_TAG) {\r\n            // Type selector\r\n            selectorName = tagInfo.tagName;\r\n        } else if (tagInfo.position.tokenType === HTMLUtils.ATTR_NAME ||\r\n                   tagInfo.position.tokenType === HTMLUtils.ATTR_VALUE) {\r\n            if (tagInfo.attr.name === "class") {\r\n                // Class selector. We only look for the class name\r\n                // that includes the insertion point. For example, if\r\n                // the attribute is: \r\n                //   class="error-dialog modal hide"\r\n                // and the insertion point is inside "modal", we want ".modal"\r\n                var attributeValue = tagInfo.attr.value;\r\n                if (/\\S/.test(attributeValue)) {\r\n                    var startIndex = attributeValue.substr(0, tagInfo.position.offset).lastIndexOf(" ");\r\n                    var endIndex = attributeValue.indexOf(" ", tagInfo.position.offset);\r\n                    selectorName = "." +\r\n                        attributeValue.substring(\r\n                            startIndex === -1 ? 0 : startIndex + 1,\r\n                            endIndex === -1 ? attributeValue.length : endIndex\r\n                        );\r\n\r\n                    // If the insertion point is surrounded by space between two classnames, selectorName is "."\r\n                    if (selectorName === ".") {\r\n                        selectorName = "";\r\n                        reason = Strings.ERROR_CSSQUICKEDIT_BETWEENCLASSES;\r\n                    }\r\n                } else {\r\n                    reason = Strings.ERROR_CSSQUICKEDIT_CLASSNOTFOUND;\r\n                }\r\n            } else if (tagInfo.attr.name === "id") {\r\n                // ID selector\r\n                var trimmedVal = tagInfo.attr.value.trim();\r\n                if (trimmedVal) {\r\n                    selectorName = "#" + trimmedVal;\r\n                } else {\r\n                    reason = Strings.ERROR_CSSQUICKEDIT_IDNOTFOUND;\r\n                }\r\n            } else {\r\n                reason = Strings.ERROR_CSSQUICKEDIT_UNSUPPORTEDATTR;\r\n            }\r\n        }\r\n        \r\n        return {\r\n            selectorName: selectorName,\r\n            reason:       reason\r\n        };\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Add a new rule for the given selector to the given stylesheet, then add the rule to the\r\n     * given inline editor.\r\n     * @param {string} selectorName The selector to create a rule for.\r\n     * @param {MultiRangeInlineEditor} inlineEditor The inline editor to display the new rule in.\r\n     * @param {string} path The path to the stylesheet file.\r\n     */\r\n    function _addRule(selectorName, inlineEditor, path) {\r\n        DocumentManager.getDocumentForPath(path).done(function (styleDoc) {\r\n            var newRuleInfo = CSSUtils.addRuleToDocument(styleDoc, selectorName, Editor.getUseTabChar(path), Editor.getSpaceUnits(path));\r\n            inlineEditor.addAndSelectRange(selectorName, styleDoc, newRuleInfo.range.from.line, newRuleInfo.range.to.line);\r\n            inlineEditor.editor.setCursorPos(newRuleInfo.pos.line, newRuleInfo.pos.ch);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Handle the "new rule" menu item by dispatching it to the handler for the focused inline editor.\r\n     */\r\n    function _handleNewRule() {\r\n        var inlineEditor = MultiRangeInlineEditor.getFocusedMultiRangeInlineEditor();\r\n        if (inlineEditor) {\r\n            var handlerInfo = _.find(_newRuleHandlers, function (entry) {\r\n                return entry.inlineEditor === inlineEditor;\r\n            });\r\n            if (handlerInfo) {\r\n                handlerInfo.handler();\r\n            }\r\n        }\r\n    }\r\n    \r\n    /** Item renderer for stylesheet-picker dropdown */\r\n    function _stylesheetListRenderer(item) {\r\n        var html = "<span class=\'stylesheet-name\'>" + _.escape(item.name);\r\n        if (item.subDirStr.length) {\r\n            html += "<span class=\'stylesheet-dir\'> — " + _.escape(item.subDirStr) + "</span>";\r\n        }\r\n        html += "</span>";\r\n        return html;\r\n    }\r\n    \r\n    /**\r\n     * This function is registered with EditManager as an inline editor provider. It creates a CSSInlineEditor\r\n     * when cursor is on an HTML tag name, class attribute, or id attribute, find associated\r\n     * CSS rules and show (one/all of them) in an inline editor.\r\n     *\r\n     * @param {!Editor} editor\r\n     * @param {!{line:Number, ch:Number}} pos\r\n     * @return {?$.Promise} synchronously resolved with an InlineWidget; or error\r\n     *         {string} if pos is in tag but not in tag name, class attr, or id attr; or null if the\r\n     *         selection isn\'t even close to a context where we could provide anything.\r\n     */\r\n    function htmlToCSSProvider(hostEditor, pos) {\r\n\r\n        // Only provide a CSS editor when cursor is in HTML content\r\n        if (hostEditor.getLanguageForSelection().getId() !== "html") {\r\n            return null;\r\n        }\r\n        \r\n        // Only provide CSS editor if the selection is within a single line\r\n        var sel = hostEditor.getSelection();\r\n        if (sel.start.line !== sel.end.line) {\r\n            return null;\r\n        }\r\n        \r\n        // Always use the selection start for determining selector name. The pos\r\n        // parameter is usually the selection end.\r\n        var selectorResult = _getSelectorName(hostEditor, sel.start);\r\n        if (selectorResult.selectorName === "") {\r\n            return selectorResult.reason || null;\r\n        }\r\n        \r\n        var selectorName = selectorResult.selectorName;\r\n\r\n        var result = new $.Deferred(),\r\n            cssInlineEditor,\r\n            cssFileInfos = [],\r\n            newRuleButton;\r\n\r\n        /**\r\n         * @private\r\n         * Callback when item from dropdown list is selected\r\n         */\r\n        function _onDropdownSelect(event, fileInfo) {\r\n            _addRule(selectorName, cssInlineEditor, fileInfo.fullPath);\r\n        }\r\n        \r\n        /**\r\n         * @private\r\n         * Checks to see if there are any stylesheets in the project, and returns the appropriate\r\n         * "no rules"/"no stylesheets" message accordingly.\r\n         * @return {$.Promise} a promise that is resolved with the message to show. Never rejected.\r\n         */\r\n        function _getNoRulesMsg() {\r\n            var result = new $.Deferred();\r\n            _getCSSFilesInProject().done(function (fileInfos) {\r\n                result.resolve(fileInfos.length ? Strings.CSS_QUICK_EDIT_NO_MATCHES : Strings.CSS_QUICK_EDIT_NO_STYLESHEETS);\r\n            });\r\n            return result;\r\n        }\r\n        \r\n        /**\r\n         * @private\r\n         * Update the enablement of associated menu commands.\r\n         */\r\n        function _updateCommands() {\r\n            _newRuleCmd.setEnabled(cssInlineEditor.hasFocus() && !newRuleButton.$button.hasClass("disabled"));\r\n        }\r\n        \r\n        /**\r\n         * @private\r\n         * Create a new rule on click.\r\n         */\r\n        function _handleNewRuleClick(e) {\r\n            if (!newRuleButton.$button.hasClass("disabled")) {\r\n                if (cssFileInfos.length === 1) {\r\n                    // Just go ahead and create the rule.\r\n                    _addRule(selectorName, cssInlineEditor, cssFileInfos[0].fullPath);\r\n                } else {\r\n                    // Although not attached to button click in \'dropdown mode\', this handler can still be\r\n                    // invoked via the command shortcut. Just toggle dropdown open/closed in that case.\r\n                    newRuleButton.toggleDropdown();\r\n                }\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * @private\r\n         * Sort fileInfo objects by name then sub-directory\r\n         */\r\n        function _sortFileInfos(a, b) {\r\n            var nameComparison = a.name.localeCompare(b.name);\r\n            if (nameComparison !== 0) {\r\n                return nameComparison;\r\n            }\r\n            return a.subDirStr.localeCompare(b.subDirStr);\r\n        }\r\n        \r\n        /**\r\n         * @private\r\n         * Prepare file list for display\r\n         */\r\n        function _prepFileList(fileInfos) {\r\n            var i, j, firstDupeIndex,\r\n                displayPaths = [],\r\n                dupeList = [];\r\n            \r\n            // Add subdir field to each entry\r\n            fileInfos.forEach(function (fileInfo) {\r\n                fileInfo.subDirStr = "";\r\n            });\r\n\r\n            // Add directory path to files with the same name so they can be\r\n            // distinguished in list. Start with list sorted by name.\r\n            fileInfos.sort(_sortFileInfos);\r\n\r\n            // For identical names, add a subdir\r\n            for (i = 1; i < fileInfos.length; i++) {\r\n                if (_sortFileInfos(fileInfos[i - 1], fileInfos[i]) === 0) {\r\n                    // Duplicates found\r\n                    firstDupeIndex = i - 1;\r\n                    dupeList.push(fileInfos[i - 1]);\r\n                    dupeList.push(fileInfos[i]);\r\n\r\n                    // Lookahead for more dupes\r\n                    while (++i < fileInfos.length &&\r\n                            _sortFileInfos(dupeList[0], fileInfos[i]) === 0) {\r\n                        dupeList.push(fileInfos[i]);\r\n                    }\r\n\r\n                    // Get minimum subdir to make each unique\r\n                    displayPaths = ViewUtils.getDirNamesForDuplicateFiles(dupeList);\r\n\r\n                    // Add a subdir to each dupe entry\r\n                    for (j = 0; j < displayPaths.length; j++) {\r\n                        fileInfos[firstDupeIndex + j].subDirStr = displayPaths[j];\r\n                    }\r\n\r\n                    // Release memory\r\n                    dupeList = [];\r\n                }\r\n            }\r\n            \r\n            // Sort by name again, so paths are sorted\r\n            fileInfos.sort(_sortFileInfos);\r\n\r\n            return fileInfos;\r\n        }\r\n        \r\n        function _onHostEditorScroll() {\r\n            newRuleButton.closeDropdown();\r\n        }\r\n        \r\n        CSSUtils.findMatchingRules(selectorName, hostEditor.document)\r\n            .done(function (rules) {\r\n                var inlineEditorDeferred = new $.Deferred();\r\n                cssInlineEditor = new MultiRangeInlineEditor.MultiRangeInlineEditor(CSSUtils.consolidateRules(rules),\r\n                                                                                    _getNoRulesMsg, CSSUtils.getRangeSelectors);\r\n                cssInlineEditor.load(hostEditor);\r\n                cssInlineEditor.$htmlContent\r\n                    .on("focusin", _updateCommands)\r\n                    .on("focusout", _updateCommands);\r\n                $(cssInlineEditor).on("add", function () {\r\n                    inlineEditorDeferred.resolve();\r\n                });\r\n                $(cssInlineEditor).on("close", function () {\r\n                    newRuleButton.closeDropdown();\r\n                    $(hostEditor).off("scroll", _onHostEditorScroll);\r\n                });\r\n\r\n                var $header = $(".inline-editor-header", cssInlineEditor.$htmlContent);\r\n                newRuleButton = new DropdownButton(Strings.BUTTON_NEW_RULE, [], _stylesheetListRenderer); // actual item list populated later, below\r\n                newRuleButton.$button.addClass("disabled");  // disabled until list is known\r\n                newRuleButton.$button.addClass("btn-mini stylesheet-button");\r\n                $header.append(newRuleButton.$button);\r\n                _newRuleHandlers.push({inlineEditor: cssInlineEditor, handler: _handleNewRuleClick});\r\n                \r\n                $(hostEditor).on("scroll", _onHostEditorScroll);\r\n                \r\n                result.resolve(cssInlineEditor);\r\n                \r\n\r\n                // Now that dialog has been built, collect list of stylesheets\r\n                var stylesheetsPromise = _getCSSFilesInProject();\r\n                \r\n                // After both the stylesheets are loaded and the inline editor has been added to the DOM,\r\n                // update the UI accordingly. (Those can happen in either order, so we need to wait for both.)\r\n                // Note that the stylesheetsPromise needs to be passed first in order for the fileInfos to be\r\n                // properly passed to the handler, since $.when() passes the results in order of the argument\r\n                // list.\r\n                $.when(stylesheetsPromise, inlineEditorDeferred.promise())\r\n                    .done(function (fileInfos) {\r\n                        cssFileInfos = _prepFileList(fileInfos);\r\n                        \r\n                        // "New Rule" button is disabled by default and gets enabled\r\n                        // here if there are any stylesheets in project\r\n                        if (cssFileInfos.length > 0) {\r\n                            newRuleButton.$button.removeClass("disabled");\r\n                            if (!rules.length) {\r\n                                // Force focus to the button so the user can create a new rule from the keyboard.\r\n                                newRuleButton.$button.focus();\r\n                            }\r\n                            \r\n                            if (cssFileInfos.length === 1) {\r\n                                // Make it look & feel like a plain button in this case\r\n                                newRuleButton.$button.removeClass("btn-dropdown");\r\n                                newRuleButton.$button.on("click", _handleNewRuleClick);\r\n                            } else {\r\n                                // Fill out remaining dropdown attributes otherwise\r\n                                newRuleButton.items = cssFileInfos;\r\n                                $(newRuleButton).on("select", _onDropdownSelect);\r\n                            }\r\n                        }\r\n                        \r\n                        _updateCommands();\r\n                    });\r\n            })\r\n            .fail(function () {\r\n                console.log("Error in findMatchingRules()");\r\n                result.reject();\r\n            });\r\n        \r\n        return result.promise();\r\n    }\r\n\r\n    EditorManager.registerInlineEditProvider(htmlToCSSProvider);\r\n    \r\n    _newRuleCmd = CommandManager.register(Strings.CMD_CSS_QUICK_EDIT_NEW_RULE, Commands.CSS_QUICK_EDIT_NEW_RULE, _handleNewRule);\r\n    _newRuleCmd.setEnabled(false);\r\n});\r\n\n//# sourceURL=/editor/CSSInlineEditor.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\n/**\r\n * Defines a ChangedDocumentTracker class to monitor changes to files in the current project.\r\n */\r\ndefine(\'document/ChangedDocumentTracker\',[\'require\',\'exports\',\'module\',\'document/DocumentManager\',\'project/ProjectManager\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var DocumentManager = require("document/DocumentManager"),\r\n        ProjectManager  = require("project/ProjectManager");\r\n    \r\n    /**\r\n     * Tracks "change" events on opened Documents. Used to monitor changes\r\n     * to documents in-memory and update caches. Assumes all documents have\r\n     * changed when the Brackets window loses and regains focus. Does not\r\n     * read timestamps of files on disk. Clients may optionally track file\r\n     * timestamps on disk independently.\r\n     * @constructor\r\n     */\r\n    function ChangedDocumentTracker() {\r\n        var self = this;\r\n        \r\n        this._changedPaths = {};\r\n        this._windowFocus = true;\r\n        this._addListener = this._addListener.bind(this);\r\n        this._removeListener = this._removeListener.bind(this);\r\n        this._onChange = this._onChange.bind(this);\r\n        this._onWindowFocus = this._onWindowFocus.bind(this);\r\n\r\n        $(DocumentManager).on("afterDocumentCreate", function (event, doc) {\r\n            // Only track documents in the current project\r\n            if (ProjectManager.isWithinProject(doc.file.fullPath)) {\r\n                self._addListener(doc);\r\n            }\r\n        });\r\n\r\n        $(DocumentManager).on("beforeDocumentDelete", function (event, doc) {\r\n            // In case a document somehow remains loaded after its project\r\n            // has been closed, unconditionally attempt to remove the listener.\r\n            self._removeListener(doc);\r\n        });\r\n\r\n        $(window).focus(this._onWindowFocus);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Assumes all files are changed when the window loses and regains focus.\r\n     */\r\n    ChangedDocumentTracker.prototype._addListener = function (doc) {\r\n        $(doc).on("change", this._onChange);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     */\r\n    ChangedDocumentTracker.prototype._removeListener = function (doc) {\r\n        $(doc).off("change", this._onChange);\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Assumes all files are changed when the window loses and regains focus.\r\n     */\r\n    ChangedDocumentTracker.prototype._onWindowFocus = function (event, doc) {\r\n        this._windowFocus = true;\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Tracks changed documents.\r\n     */\r\n    ChangedDocumentTracker.prototype._onChange = function (event, doc) {\r\n        // if it was already changed, and the client hasn\'t reset the tracker,\r\n        // then leave it changed.\r\n        this._changedPaths[doc.file.fullPath] = true;\r\n    };\r\n    \r\n    /**\r\n     * Empty the set of dirty paths. Begin tracking new dirty documents. \r\n     */\r\n    ChangedDocumentTracker.prototype.reset = function () {\r\n        this._changedPaths = {};\r\n        this._windowFocus = false;\r\n    };\r\n    \r\n    /**\r\n     * Check if a file path is dirty.\r\n     * @param {!string} file path\r\n     * @return {!boolean} Returns true if the file was dirtied since the last reset.\r\n     */\r\n    ChangedDocumentTracker.prototype.isPathChanged = function (path) {\r\n        return this._windowFocus || this._changedPaths[path];\r\n    };\r\n    \r\n    /**\r\n     * Get the set of changed paths since the last reset.\r\n     * @return {Array.<string>} Changed file paths\r\n     */\r\n    ChangedDocumentTracker.prototype.getChangedPaths = function () {\r\n        return $.makeArray(this._changedPaths);\r\n    };\r\n\r\n    module.exports = ChangedDocumentTracker;\r\n});\n//# sourceURL=/document/ChangedDocumentTracker.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets */\r\n\r\n/**\r\n * Set of utilities for simple parsing of JS text.\r\n */\r\ndefine(\'language/JSUtils\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'thirdparty/CodeMirror2/lib/codemirror\',\'utils/Async\',\'document/DocumentManager\',\'document/ChangedDocumentTracker\',\'filesystem/FileSystem\',\'file/FileUtils\',\'utils/PerfUtils\',\'project/ProjectManager\',\'utils/StringUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n    \r\n    // Load brackets modules\r\n    var CodeMirror              = require("thirdparty/CodeMirror2/lib/codemirror"),\r\n        Async                   = require("utils/Async"),\r\n        DocumentManager         = require("document/DocumentManager"),\r\n        ChangedDocumentTracker  = require("document/ChangedDocumentTracker"),\r\n        FileSystem              = require("filesystem/FileSystem"),\r\n        FileUtils               = require("file/FileUtils"),\r\n        PerfUtils               = require("utils/PerfUtils"),\r\n        ProjectManager          = require("project/ProjectManager"),\r\n        StringUtils             = require("utils/StringUtils");\r\n\r\n    /**\r\n     * Tracks dirty documents between invocations of findMatchingFunctions.\r\n     * @type {ChangedDocumentTracker}\r\n     */\r\n    var _changedDocumentTracker = new ChangedDocumentTracker();\r\n    \r\n    /**\r\n     * Function matching regular expression. Recognizes the forms:\r\n     * "function functionName()", "functionName = function()", and\r\n     * "functionName: function()".\r\n     *\r\n     * Note: JavaScript identifier matching is not strictly to spec. This\r\n     * RegExp matches any sequence of characters that is not whitespace.\r\n     * @type {RegExp}\r\n     */\r\n    var _functionRegExp = /(function\\s+([$_A-Za-z\\u007F-\\uFFFF][$_A-Za-z0-9\\u007F-\\uFFFF]*)\\s*(\\([^)]*\\)))|(([$_A-Za-z\\u007F-\\uFFFF][$_A-Za-z0-9\\u007F-\\uFFFF]*)\\s*[:=]\\s*function\\s*(\\([^)]*\\)))/g;\r\n    \r\n    /**\r\n     * @private\r\n     * Return an object mapping function name to offset info for all functions in the specified text.\r\n     * Offset info is an array, since multiple functions of the same name can exist.\r\n     * @param {!string} text Document text\r\n     * @return {Object.<string, Array.<{offsetStart: number, offsetEnd: number}>}\r\n     */\r\n    function _findAllFunctionsInText(text) {\r\n        var results = {},\r\n            functionName,\r\n            match;\r\n        \r\n        PerfUtils.markStart(PerfUtils.JSUTILS_REGEXP);\r\n        \r\n        while ((match = _functionRegExp.exec(text)) !== null) {\r\n            functionName = (match[2] || match[5]).trim();\r\n            \r\n            if (!Array.isArray(results[functionName])) {\r\n                results[functionName] = [];\r\n            }\r\n            \r\n            results[functionName].push({offsetStart: match.index});\r\n        }\r\n        \r\n        PerfUtils.addMeasurement(PerfUtils.JSUTILS_REGEXP);\r\n        \r\n        return results;\r\n    }\r\n    \r\n    // Given the start offset of a function definition (before the opening brace), find\r\n    // the end offset for the function (the closing "}"). Returns the position one past the\r\n    // close brace. Properly ignores braces inside comments, strings, and regexp literals.\r\n    function _getFunctionEndOffset(text, offsetStart) {\r\n        var mode = CodeMirror.getMode({}, "javascript");\r\n        var state = CodeMirror.startState(mode), stream, style, token;\r\n        var curOffset = offsetStart, length = text.length, blockCount = 0, lineStart;\r\n        var foundStartBrace = false;\r\n        \r\n        // Get a stream for the next line, and update curOffset and lineStart to point to the \r\n        // beginning of that next line. Returns false if we\'re at the end of the text.\r\n        function nextLine() {\r\n            if (stream) {\r\n                curOffset++; // account for \\n\r\n                if (curOffset >= length) {\r\n                    return false;\r\n                }\r\n            }\r\n            lineStart = curOffset;\r\n            var lineEnd = text.indexOf("\\n", lineStart);\r\n            if (lineEnd === -1) {\r\n                lineEnd = length;\r\n            }\r\n            stream = new CodeMirror.StringStream(text.slice(curOffset, lineEnd));\r\n            return true;\r\n        }\r\n        \r\n        // Get the next token, updating the style and token to refer to the current\r\n        // token, and updating the curOffset to point to the end of the token (relative\r\n        // to the start of the original text).\r\n        function nextToken() {\r\n            if (curOffset >= length) {\r\n                return false;\r\n            }\r\n            if (stream) {\r\n                // Set the start of the next token to the current stream position.\r\n                stream.start = stream.pos;\r\n            }\r\n            while (!stream || stream.eol()) {\r\n                if (!nextLine()) {\r\n                    return false;\r\n                }\r\n            }\r\n            style = mode.token(stream, state);\r\n            token = stream.current();\r\n            curOffset = lineStart + stream.pos;\r\n            return true;\r\n        }\r\n\r\n        while (nextToken()) {\r\n            if (style !== "comment" && style !== "regexp" && style !== "string") {\r\n                if (token === "{") {\r\n                    foundStartBrace = true;\r\n                    blockCount++;\r\n                } else if (token === "}") {\r\n                    blockCount--;\r\n                }\r\n            }\r\n\r\n            // blockCount starts at 0, so we don\'t want to check if it hits 0\r\n            // again until we\'ve actually gone past the start of the function body.\r\n            if (foundStartBrace && blockCount <= 0) {\r\n                return curOffset;\r\n            }\r\n        }\r\n        \r\n        // Shouldn\'t get here, but if we do, return the end of the text as the offset.\r\n        return length;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Computes function offsetEnd, lineStart and lineEnd. Appends a result record to rangeResults.\r\n     * @param {!Document} doc\r\n     * @param {!string} functionName\r\n     * @param {!Array.<{offsetStart: number, offsetEnd: number}>} functions\r\n     * @param {!Array.<{document: Document, name: string, lineStart: number, lineEnd: number}>} rangeResults\r\n     */\r\n    function _computeOffsets(doc, functionName, functions, rangeResults) {\r\n        var text    = doc.getText(),\r\n            lines   = StringUtils.getLines(text);\r\n        \r\n        functions.forEach(function (funcEntry) {\r\n            if (!funcEntry.offsetEnd) {\r\n                PerfUtils.markStart(PerfUtils.JSUTILS_END_OFFSET);\r\n                \r\n                funcEntry.offsetEnd = _getFunctionEndOffset(text, funcEntry.offsetStart);\r\n                funcEntry.lineStart = StringUtils.offsetToLineNum(lines, funcEntry.offsetStart);\r\n                funcEntry.lineEnd   = StringUtils.offsetToLineNum(lines, funcEntry.offsetEnd);\r\n                \r\n                PerfUtils.addMeasurement(PerfUtils.JSUTILS_END_OFFSET);\r\n            }\r\n            \r\n            rangeResults.push({\r\n                document:   doc,\r\n                name:       functionName,\r\n                lineStart:  funcEntry.lineStart,\r\n                lineEnd:    funcEntry.lineEnd\r\n            });\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Read a file and build a function list. Result is cached in fileInfo.\r\n     * @param {!FileInfo} fileInfo File to parse\r\n     * @param {!$.Deferred} result Deferred to resolve with all functions found and the document\r\n     */\r\n    function _readFile(fileInfo, result) {\r\n        DocumentManager.getDocumentForPath(fileInfo.fullPath)\r\n            .done(function (doc) {\r\n                var allFunctions = _findAllFunctionsInText(doc.getText());\r\n                \r\n                // Cache the result in the fileInfo object\r\n                fileInfo.JSUtils = {};\r\n                fileInfo.JSUtils.functions = allFunctions;\r\n                fileInfo.JSUtils.timestamp = doc.diskTimestamp;\r\n                \r\n                result.resolve({doc: doc, functions: allFunctions});\r\n            })\r\n            .fail(function (error) {\r\n                result.reject(error);\r\n            });\r\n    }\r\n    \r\n    /**\r\n     * Determines if the document function cache is up to date. \r\n     * @param {FileInfo} fileInfo\r\n     * @return {$.Promise} A promise resolved with true with true when a function cache is available for the document. Resolves\r\n     *   with false when there is no cache or the cache is stale.\r\n     */\r\n    function _shouldGetFromCache(fileInfo) {\r\n        var result = new $.Deferred(),\r\n            isChanged = _changedDocumentTracker.isPathChanged(fileInfo.fullPath);\r\n        \r\n        if (isChanged && fileInfo.JSUtils) {\r\n            // See if it\'s dirty and in the working set first\r\n            var doc = DocumentManager.getOpenDocumentForPath(fileInfo.fullPath);\r\n            \r\n            if (doc && doc.isDirty) {\r\n                result.resolve(false);\r\n            } else {\r\n                // If a cache exists, check the timestamp on disk\r\n                var file = FileSystem.getFileForPath(fileInfo.fullPath);\r\n                \r\n                file.stat(function (err, stat) {\r\n                    if (!err) {\r\n                        result.resolve(fileInfo.JSUtils.timestamp.getTime() === stat.mtime.getTime());\r\n                    } else {\r\n                        result.reject(err);\r\n                    }\r\n                });\r\n            }\r\n        } else {\r\n            // Use the cache if the file did not change and the cache exists\r\n            result.resolve(!isChanged && fileInfo.JSUtils);\r\n        }\r\n\r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Compute lineStart and lineEnd for each matched function\r\n     * @param {!Array.<{doc: Document, fileInfo: FileInfo, functions: Array.<offsetStart: number, offsetEnd: number>}>} docEntries\r\n     * @param {!string} functionName\r\n     * @param {!Array.<document: Document, name: string, lineStart: number, lineEnd: number>} rangeResults\r\n     * @return {$.Promise} A promise resolved with an array of document ranges to populate a MultiRangeInlineEditor.\r\n     */\r\n    function _getOffsetsForFunction(docEntries, functionName) {\r\n        // Filter for documents that contain the named function\r\n        var result              = new $.Deferred(),\r\n            matchedDocuments    = [],\r\n            rangeResults        = [];\r\n        \r\n        docEntries.forEach(function (docEntry) {\r\n            // Need to call _.has here since docEntry.functions could have an\r\n            // entry for "hasOwnProperty", which results in an error if trying\r\n            // to invoke docEntry.functions.hasOwnProperty().\r\n            if (_.has(docEntry.functions, functionName)) {\r\n                var functionsInDocument = docEntry.functions[functionName];\r\n                matchedDocuments.push({doc: docEntry.doc, fileInfo: docEntry.fileInfo, functions: functionsInDocument});\r\n            }\r\n        });\r\n        \r\n        Async.doInParallel(matchedDocuments, function (docEntry) {\r\n            var doc         = docEntry.doc,\r\n                oneResult   = new $.Deferred();\r\n            \r\n            // doc will be undefined if we hit the cache\r\n            if (!doc) {\r\n                DocumentManager.getDocumentForPath(docEntry.fileInfo.fullPath)\r\n                    .done(function (fetchedDoc) {\r\n                        _computeOffsets(fetchedDoc, functionName, docEntry.functions, rangeResults);\r\n                    })\r\n                    .always(function () {\r\n                        oneResult.resolve();\r\n                    });\r\n            } else {\r\n                _computeOffsets(doc, functionName, docEntry.functions, rangeResults);\r\n                oneResult.resolve();\r\n            }\r\n            \r\n            return oneResult.promise();\r\n        }).done(function () {\r\n            result.resolve(rangeResults);\r\n        });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Resolves with a record containing the Document or FileInfo and an Array of all\r\n     * function names with offsets for the specified file. Results may be cached.\r\n     * @param {FileInfo} fileInfo\r\n     * @return {$.Promise} A promise resolved with a document info object that\r\n     *   contains a map of all function names from the document and each function\'s start offset. \r\n     */\r\n    function _getFunctionsForFile(fileInfo) {\r\n        var result = new $.Deferred();\r\n            \r\n        _shouldGetFromCache(fileInfo)\r\n            .done(function (useCache) {\r\n                if (useCache) {\r\n                    // Return cached data. doc property is undefined since we hit the cache.\r\n                    // _getOffsets() will fetch the Document if necessary.\r\n                    result.resolve({/*doc: undefined,*/fileInfo: fileInfo, functions: fileInfo.JSUtils.functions});\r\n                } else {\r\n                    _readFile(fileInfo, result);\r\n                }\r\n            }).fail(function (err) {\r\n                result.reject(err);\r\n            });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Get all functions for each FileInfo.\r\n     * @param {Array.<FileInfo>} fileInfos\r\n     * @return {$.Promise} A promise resolved with an array of document info objects that each\r\n     *   contain a map of all function names from the document and each function\'s start offset.\r\n     */\r\n    function _getFunctionsInFiles(fileInfos) {\r\n        var result          = new $.Deferred(),\r\n            docEntries      = [];\r\n        \r\n        PerfUtils.markStart(PerfUtils.JSUTILS_GET_ALL_FUNCTIONS);\r\n        \r\n        Async.doInParallel(fileInfos, function (fileInfo) {\r\n            var oneResult = new $.Deferred();\r\n            \r\n            _getFunctionsForFile(fileInfo)\r\n                .done(function (docInfo) {\r\n                    docEntries.push(docInfo);\r\n                })\r\n                .always(function (error) {\r\n                    // If one file fails, continue to search\r\n                    oneResult.resolve();\r\n                });\r\n            \r\n            return oneResult.promise();\r\n        }).always(function () {\r\n            // Reset ChangedDocumentTracker now that the cache is up to date.\r\n            _changedDocumentTracker.reset();\r\n            \r\n            PerfUtils.addMeasurement(PerfUtils.JSUTILS_GET_ALL_FUNCTIONS);\r\n            result.resolve(docEntries);\r\n        });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Return all functions that have the specified name, searching across all the given files.\r\n     *\r\n     * @param {!String} functionName The name to match.\r\n     * @param {!Array.<File>} fileInfos The array of files to search.\r\n     * @param {boolean=} keepAllFiles If true, don\'t ignore non-javascript files.\r\n     * @return {$.Promise} that will be resolved with an Array of objects containing the\r\n     *      source document, start line, and end line (0-based, inclusive range) for each matching function list.\r\n     *      Does not addRef() the documents returned in the array.\r\n     */\r\n    function findMatchingFunctions(functionName, fileInfos, keepAllFiles) {\r\n        var result          = new $.Deferred(),\r\n            jsFiles         = [],\r\n            docEntries      = [];\r\n        \r\n        if (!keepAllFiles) {\r\n            // Filter fileInfos for .js files\r\n            jsFiles = fileInfos.filter(function (fileInfo) {\r\n                return FileUtils.getFileExtension(fileInfo.fullPath).toLowerCase() === "js";\r\n            });\r\n        } else {\r\n            jsFiles = fileInfos;\r\n        }\r\n        \r\n        // RegExp search (or cache lookup) for all functions in the project\r\n        _getFunctionsInFiles(jsFiles).done(function (docEntries) {\r\n            // Compute offsets for all matched functions\r\n            _getOffsetsForFunction(docEntries, functionName).done(function (rangeResults) {\r\n                result.resolve(rangeResults);\r\n            });\r\n        });\r\n        \r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * Finds all instances of the specified searchName in "text".\r\n     * Returns an Array of Objects with start and end properties.\r\n     *\r\n     * @param text {!String} JS text to search\r\n     * @param searchName {!String} function name to search for\r\n     * @return {Array.<{offset:number, functionName:string}>}\r\n     *      Array of objects containing the start offset for each matched function name.\r\n     */\r\n    function findAllMatchingFunctionsInText(text, searchName) {\r\n        var allFunctions = _findAllFunctionsInText(text);\r\n        var result = [];\r\n        var lines = text.split("\\n");\r\n        \r\n        _.forEach(allFunctions, function (functions, functionName) {\r\n            if (functionName === searchName || searchName === "*") {\r\n                functions.forEach(function (funcEntry) {\r\n                    var endOffset = _getFunctionEndOffset(text, funcEntry.offsetStart);\r\n                    result.push({\r\n                        name: functionName,\r\n                        lineStart: StringUtils.offsetToLineNum(lines, funcEntry.offsetStart),\r\n                        lineEnd: StringUtils.offsetToLineNum(lines, endOffset)\r\n                    });\r\n                });\r\n            }\r\n        });\r\n         \r\n        return result;\r\n    }\r\n    \r\n    PerfUtils.createPerfMeasurement("JSUTILS_GET_ALL_FUNCTIONS", "Parallel file search across project");\r\n    PerfUtils.createPerfMeasurement("JSUTILS_REGEXP", "RegExp search for all functions");\r\n    PerfUtils.createPerfMeasurement("JSUTILS_END_OFFSET", "Find end offset for a single matched function");\r\n\r\n    exports.findAllMatchingFunctionsInText = findAllMatchingFunctionsInText;\r\n    exports._getFunctionEndOffset = _getFunctionEndOffset; // For testing only\r\n    exports.findMatchingFunctions = findMatchingFunctions;\r\n});\r\n\n//# sourceURL=/language/JSUtils.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, regexp: true */\r\n/*global define, $, brackets, window */\r\n\r\n/**\r\n * Initializes the default brackets menu items.\r\n */\r\ndefine(\'command/DefaultMenus\',[\'require\',\'exports\',\'module\',\'utils/AppInit\',\'command/Commands\',\'command/Menus\',\'editor/EditorManager\',\'command/Menus\',\'strings\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var AppInit         = require("utils/AppInit"),\r\n        Commands        = require("command/Commands"),\r\n        ContextMenu     = require("command/Menus"),\r\n        EditorManager   = require("editor/EditorManager"),\r\n        Menus           = require("command/Menus"),\r\n        Strings         = require("strings");\r\n    \r\n    AppInit.htmlReady(function () {\r\n        /*\r\n         * File menu\r\n         */\r\n        var menu;\r\n        menu = Menus.addMenu(Strings.FILE_MENU, Menus.AppMenuBar.FILE_MENU);\r\n        menu.addMenuItem(Commands.FILE_NEW_UNTITLED);\r\n        menu.addMenuItem(Commands.FILE_OPEN);\r\n        menu.addMenuItem(Commands.FILE_OPEN_FOLDER);\r\n        menu.addMenuItem(Commands.FILE_CLOSE);\r\n        menu.addMenuItem(Commands.FILE_CLOSE_ALL);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.FILE_SAVE);\r\n        menu.addMenuItem(Commands.FILE_SAVE_ALL);\r\n        menu.addMenuItem(Commands.FILE_SAVE_AS);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.FILE_LIVE_FILE_PREVIEW);\r\n        menu.addMenuItem(Commands.FILE_PROJECT_SETTINGS);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.FILE_EXTENSION_MANAGER);\r\n        \r\n        // suppress redundant quit menu item on mac\r\n        if (brackets.platform !== "mac" || !brackets.nativeMenus) {\r\n            menu.addMenuDivider();\r\n            menu.addMenuItem(Commands.FILE_QUIT);\r\n        }\r\n        \r\n        /*\r\n         * Edit  menu\r\n         */\r\n        menu = Menus.addMenu(Strings.EDIT_MENU, Menus.AppMenuBar.EDIT_MENU);\r\n        menu.addMenuItem(Commands.EDIT_UNDO);\r\n        menu.addMenuItem(Commands.EDIT_REDO);\r\n        menu.addMenuDivider();\r\n        if (brackets.nativeMenus) {\r\n            // Native-only - can\'t programmatically trigger clipboard actions from JS menus\r\n            menu.addMenuItem(Commands.EDIT_CUT);\r\n            menu.addMenuItem(Commands.EDIT_COPY);\r\n            menu.addMenuItem(Commands.EDIT_PASTE);\r\n            menu.addMenuDivider();\r\n        }\r\n        menu.addMenuItem(Commands.EDIT_SELECT_ALL);\r\n        menu.addMenuItem(Commands.EDIT_SELECT_LINE);\r\n        menu.addMenuItem(Commands.EDIT_SPLIT_SEL_INTO_LINES);\r\n        menu.addMenuItem(Commands.EDIT_ADD_CUR_TO_PREV_LINE);\r\n        menu.addMenuItem(Commands.EDIT_ADD_CUR_TO_NEXT_LINE);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.EDIT_INDENT);\r\n        menu.addMenuItem(Commands.EDIT_UNINDENT);\r\n        menu.addMenuItem(Commands.EDIT_DUPLICATE);\r\n        menu.addMenuItem(Commands.EDIT_DELETE_LINES);\r\n        menu.addMenuItem(Commands.EDIT_LINE_UP);\r\n        menu.addMenuItem(Commands.EDIT_LINE_DOWN);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.EDIT_LINE_COMMENT);\r\n        menu.addMenuItem(Commands.EDIT_BLOCK_COMMENT);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.SHOW_CODE_HINTS);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.TOGGLE_CLOSE_BRACKETS);\r\n        \r\n        /*\r\n         * Find menu\r\n         */\r\n        menu = Menus.addMenu(Strings.FIND_MENU, Menus.AppMenuBar.FIND_MENU);\r\n        menu.addMenuItem(Commands.CMD_FIND);\r\n        menu.addMenuItem(Commands.CMD_FIND_NEXT);\r\n        menu.addMenuItem(Commands.CMD_FIND_PREVIOUS);\r\n        menu.addMenuItem(Commands.CMD_FIND_ALL_AND_SELECT);\r\n        menu.addMenuItem(Commands.CMD_ADD_NEXT_MATCH);\r\n        menu.addMenuItem(Commands.CMD_SKIP_CURRENT_MATCH);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.CMD_FIND_IN_FILES);\r\n        menu.addMenuItem(Commands.CMD_FIND_IN_SELECTED);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.CMD_REPLACE);\r\n        menu.addMenuItem(Commands.CMD_REPLACE_IN_FILES);\r\n        menu.addMenuItem(Commands.CMD_REPLACE_IN_SELECTED);\r\n        \r\n        /*\r\n         * View menu\r\n         */\r\n        menu = Menus.addMenu(Strings.VIEW_MENU, Menus.AppMenuBar.VIEW_MENU);\r\n        menu.addMenuItem(Commands.CMD_THEMES_OPEN_SETTINGS);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.VIEW_HIDE_SIDEBAR);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.VIEW_INCREASE_FONT_SIZE);\r\n        menu.addMenuItem(Commands.VIEW_DECREASE_FONT_SIZE);\r\n        menu.addMenuItem(Commands.VIEW_RESTORE_FONT_SIZE);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.TOGGLE_ACTIVE_LINE);\r\n        menu.addMenuItem(Commands.TOGGLE_LINE_NUMBERS);\r\n        menu.addMenuItem(Commands.TOGGLE_WORD_WRAP);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.FILE_LIVE_HIGHLIGHT);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.VIEW_TOGGLE_INSPECTION);\r\n        \r\n        /*\r\n         * Navigate menu\r\n         */\r\n        menu = Menus.addMenu(Strings.NAVIGATE_MENU, Menus.AppMenuBar.NAVIGATE_MENU);\r\n        menu.addMenuItem(Commands.NAVIGATE_QUICK_OPEN);\r\n        menu.addMenuItem(Commands.NAVIGATE_GOTO_LINE);\r\n        menu.addMenuItem(Commands.NAVIGATE_GOTO_DEFINITION);\r\n        menu.addMenuItem(Commands.NAVIGATE_JUMPTO_DEFINITION);\r\n        menu.addMenuItem(Commands.NAVIGATE_GOTO_FIRST_PROBLEM);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.NAVIGATE_NEXT_DOC);\r\n        menu.addMenuItem(Commands.NAVIGATE_PREV_DOC);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.NAVIGATE_SHOW_IN_FILE_TREE);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.TOGGLE_QUICK_EDIT);\r\n        menu.addMenuItem(Commands.QUICK_EDIT_PREV_MATCH);\r\n        menu.addMenuItem(Commands.QUICK_EDIT_NEXT_MATCH);\r\n        menu.addMenuItem(Commands.CSS_QUICK_EDIT_NEW_RULE);\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.TOGGLE_QUICK_DOCS);\r\n        \r\n        /*\r\n         * Help menu\r\n         */\r\n        menu = Menus.addMenu(Strings.HELP_MENU, Menus.AppMenuBar.HELP_MENU);\r\n        menu.addMenuItem(Commands.HELP_CHECK_FOR_UPDATE);\r\n\r\n        menu.addMenuDivider();\r\n        if (brackets.config.how_to_use_url) {\r\n            menu.addMenuItem(Commands.HELP_HOW_TO_USE_BRACKETS);\r\n        }\r\n        if (brackets.config.support_url) {\r\n            menu.addMenuItem(Commands.HELP_SUPPORT);\r\n        }\r\n        if (brackets.config.suggest_feature_url) {\r\n            menu.addMenuItem(Commands.HELP_SUGGEST);\r\n        }\r\n        if (brackets.config.release_notes_url) {\r\n            menu.addMenuItem(Commands.HELP_RELEASE_NOTES);\r\n        }\r\n        if (brackets.config.get_involved_url) {\r\n            menu.addMenuItem(Commands.HELP_GET_INVOLVED);\r\n        }\r\n\r\n        menu.addMenuDivider();\r\n        menu.addMenuItem(Commands.HELP_SHOW_EXT_FOLDER);\r\n\r\n\r\n        var hasAboutItem = (brackets.platform !== "mac" || !brackets.nativeMenus);\r\n        \r\n        // Add final divider only if we have a homepage URL or twitter URL or about item\r\n        if (hasAboutItem || brackets.config.homepage_url || brackets.config.twitter_url) {\r\n            menu.addMenuDivider();\r\n        }\r\n        \r\n        if (brackets.config.homepage_url) {\r\n            menu.addMenuItem(Commands.HELP_HOMEPAGE);\r\n        }\r\n        \r\n        if (brackets.config.twitter_url) {\r\n            menu.addMenuItem(Commands.HELP_TWITTER);\r\n        }\r\n        // supress redundant about menu item in mac shell\r\n        if (hasAboutItem) {\r\n            menu.addMenuItem(Commands.HELP_ABOUT);\r\n        }\r\n        \r\n        /*\r\n         * WorkingSet context and gear menus\r\n         * NOTE: Unlike most context menus defined here, these menus cannot\r\n         *       be setup to listen to click or context menu events when \r\n         *       this module intializes because the DOM nodes for these are \r\n         *       created by pane views which are created at runtime. \r\n         *       All other context menus have DOM elements to attach to\r\n         *       out of index.html\r\n         */\r\n\r\n        var workingset_cmenu = Menus.registerContextMenu(Menus.ContextMenuIds.WORKING_SET_CONTEXT_MENU);\r\n        workingset_cmenu.addMenuItem(Commands.FILE_SAVE);\r\n        workingset_cmenu.addMenuItem(Commands.FILE_SAVE_AS);\r\n        workingset_cmenu.addMenuItem(Commands.FILE_RENAME);\r\n        workingset_cmenu.addMenuItem(Commands.NAVIGATE_SHOW_IN_FILE_TREE);\r\n        workingset_cmenu.addMenuItem(Commands.NAVIGATE_SHOW_IN_OS);\r\n        workingset_cmenu.addMenuDivider();\r\n        workingset_cmenu.addMenuItem(Commands.CMD_FIND_IN_SUBTREE);\r\n        workingset_cmenu.addMenuItem(Commands.CMD_REPLACE_IN_SUBTREE);\r\n        workingset_cmenu.addMenuDivider();\r\n        workingset_cmenu.addMenuItem(Commands.FILE_CLOSE);\r\n        \r\n        var workingset_configuration_menu = Menus.registerContextMenu(Menus.ContextMenuIds.WORKING_SET_CONFIG_MENU);\r\n        workingset_configuration_menu.addMenuItem(Commands.CMD_WORKINGSET_SORT_BY_ADDED);\r\n        workingset_configuration_menu.addMenuItem(Commands.CMD_WORKINGSET_SORT_BY_NAME);\r\n        workingset_configuration_menu.addMenuItem(Commands.CMD_WORKINGSET_SORT_BY_TYPE);\r\n        workingset_configuration_menu.addMenuDivider();\r\n        workingset_configuration_menu.addMenuItem(Commands.CMD_WORKING_SORT_TOGGLE_AUTO);\r\n        \r\n        \r\n        /*\r\n         * Context Menus\r\n         */\r\n        var project_cmenu = Menus.registerContextMenu(Menus.ContextMenuIds.PROJECT_MENU);\r\n        project_cmenu.addMenuItem(Commands.FILE_NEW);\r\n        project_cmenu.addMenuItem(Commands.FILE_NEW_FOLDER);\r\n        project_cmenu.addMenuItem(Commands.FILE_RENAME);\r\n        project_cmenu.addMenuItem(Commands.FILE_DELETE);\r\n        project_cmenu.addMenuItem(Commands.NAVIGATE_SHOW_IN_OS);\r\n        project_cmenu.addMenuDivider();\r\n        project_cmenu.addMenuItem(Commands.CMD_FIND_IN_SUBTREE);\r\n        project_cmenu.addMenuItem(Commands.CMD_REPLACE_IN_SUBTREE);\r\n        project_cmenu.addMenuDivider();\r\n        project_cmenu.addMenuItem(Commands.FILE_REFRESH);\r\n        \r\n        var editor_cmenu = Menus.registerContextMenu(Menus.ContextMenuIds.EDITOR_MENU);\r\n        // editor_cmenu.addMenuItem(Commands.NAVIGATE_JUMPTO_DEFINITION);\r\n        editor_cmenu.addMenuItem(Commands.TOGGLE_QUICK_EDIT);\r\n        editor_cmenu.addMenuItem(Commands.TOGGLE_QUICK_DOCS);\r\n        editor_cmenu.addMenuItem(Commands.EDIT_SELECT_ALL);\r\n\r\n        var inline_editor_cmenu = Menus.registerContextMenu(Menus.ContextMenuIds.INLINE_EDITOR_MENU);\r\n        inline_editor_cmenu.addMenuItem(Commands.TOGGLE_QUICK_EDIT);\r\n        inline_editor_cmenu.addMenuItem(Commands.EDIT_SELECT_ALL);\r\n        inline_editor_cmenu.addMenuDivider();\r\n        inline_editor_cmenu.addMenuItem(Commands.QUICK_EDIT_PREV_MATCH);\r\n        inline_editor_cmenu.addMenuItem(Commands.QUICK_EDIT_NEXT_MATCH);\r\n        \r\n        /**\r\n         * Context menu for code editors (both full-size and inline)\r\n         * Auto selects the word the user clicks if the click does not occur over\r\n         * an existing selection\r\n         */\r\n        $("#editor-holder").on("contextmenu", function (e) {\r\n            if ($(e.target).parents(".CodeMirror-gutter").length !== 0) {\r\n                return;\r\n            }\r\n            \r\n            // Note: on mousedown before this event, CodeMirror automatically checks mouse pos, and\r\n            // if not clicking on a selection moves the cursor to click location. When triggered\r\n            // from keyboard, no pre-processing occurs and the cursor/selection is left as is.\r\n            \r\n            var editor = EditorManager.getFocusedEditor(),\r\n                inlineWidget = EditorManager.getFocusedInlineWidget();\r\n            \r\n            if (editor) {\r\n                // If there\'s just an insertion point select the word token at the cursor pos so\r\n                // it\'s more clear what the context menu applies to.\r\n                if (!editor.hasSelection()) {\r\n                    editor.selectWordAt(editor.getCursorPos());\r\n                    \r\n                    // Prevent menu from overlapping text by moving it down a little\r\n                    // Temporarily backout this change for now to help mitigate issue #1111,\r\n                    // which only happens if mouse is not over context menu. Better fix\r\n                    // requires change to bootstrap, which is too risky for now.\r\n                    //e.pageY += 6;\r\n                }\r\n                \r\n                // Inline text editors have a different context menu (safe to assume it\'s not some other\r\n                // type of inline widget since we already know an Editor has focus)\r\n                if (inlineWidget) {\r\n                    inline_editor_cmenu.open(e);\r\n                } else {\r\n                    editor_cmenu.open(e);\r\n                }\r\n            }\r\n        });\r\n\r\n        /**\r\n         * Context menu for folder tree \r\n         */\r\n        $("#project-files-container").on("contextmenu", function (e) {\r\n            project_cmenu.open(e);\r\n        });\r\n\r\n\r\n        // Prevent the browser context menu since Brackets creates a custom context menu\r\n        $(window).contextmenu(function (e) {\r\n            e.preventDefault();\r\n        });\r\n        \r\n        /*\r\n         * General menu event processing\r\n         */\r\n        // Prevent clicks on top level menus and menu items from taking focus\r\n        $(window.document).on("mousedown", ".dropdown", function (e) {\r\n            e.preventDefault();\r\n        });\r\n\r\n        // Switch menus when the mouse enters an adjacent menu\r\n        // Only open the menu if another one has already been opened\r\n        // by clicking\r\n        $(window.document).on("mouseenter", "#titlebar .dropdown", function (e) {\r\n            var open = $(this).siblings(".open");\r\n            if (open.length > 0) {\r\n                open.removeClass("open");\r\n                $(this).addClass("open");\r\n            }\r\n        });\r\n    });\r\n});\r\n\n//# sourceURL=/command/DefaultMenus.js'),eval('define(\'text!htmlContent/working-set.html\',[],function () { return \'<div id="{{id}}">\\r\\n    <div class="working-set-header"><span class="working-set-header-title">{{WORKING_FILES}}</span>\\r\\n        <div class="working-set-option-btn btn-alt-quiet"></div>\\r\\n    </div>\\r\\n    <div class="open-files-container">\\r\\n        <!-- This will contain runtime-generated <li>\\\'s for each file in the working set -->\\r\\n        <ul>\\r\\n        </ul>\\r\\n    </div>\\r\\n<div>\';});\n\n//# sourceURL=/text!htmlContent/working-set.html'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, brackets, Mustache  */\r\n\r\n/**\r\n * WorkingSetView generates the UI for the list of the files user is editing based on the model provided by EditorManager.\r\n * The UI allows the user to see what files are open/dirty and allows them to close files and specify the current editor.\r\n *\r\n */\r\ndefine(\'project/WorkingSetView\',[\'require\',\'exports\',\'module\',\'document/DocumentManager\',\'view/MainViewManager\',\'command/CommandManager\',\'command/Commands\',\'command/Menus\',\'command/DefaultMenus\',\'project/FileViewController\',\'utils/ViewUtils\',\'text!htmlContent/working-set.html\',\'strings\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    // Load dependent modules\r\n    var DocumentManager       = require("document/DocumentManager"),\r\n        MainViewManager       = require("view/MainViewManager"),\r\n        CommandManager        = require("command/CommandManager"),\r\n        Commands              = require("command/Commands"),\r\n        Menus                 = require("command/Menus"),\r\n        DefaultMenus          = require("command/DefaultMenus"),\r\n        FileViewController    = require("project/FileViewController"),\r\n        ViewUtils             = require("utils/ViewUtils"),\r\n        paneListTemplate      = require("text!htmlContent/working-set.html"),\r\n        Strings               = require("strings"),\r\n        _                     = require("thirdparty/lodash");\r\n    \r\n    \r\n    /**\r\n     * Currently open views\r\n     * @private\r\n     * @type {Array.WorkingSetView}\r\n     * \r\n     */\r\n    var _views = [];\r\n    \r\n    /**\r\n     * Context Menu\r\n     * @private\r\n     * @type {Menu}\r\n     * \r\n     */\r\n    var _workingset_cmenu;\r\n    \r\n    /**\r\n     * Context Menu\r\n     * @private\r\n     * @type {Menu}\r\n     * \r\n     */\r\n    var _workingset_configuration_menu;\r\n    \r\n    /**\r\n     * Constants for event.which values\r\n     * @enum {number}\r\n     */\r\n    var LEFT_BUTTON = 1,\r\n        MIDDLE_BUTTON = 2;\r\n    \r\n    /** \r\n     * Each list item in the working set stores a references to the related document in the list item\'s data.  \r\n     *  Use `listItem.data(_FILE_KEY)` to get the document reference\r\n     * @type {string}\r\n     * @private\r\n     */\r\n    var _FILE_KEY = "file";\r\n\r\n    /* \r\n     * Determines if context menus are registered\r\n     * @private\r\n     * @return {boolean} true if the menus are registered, false if not\r\n     */\r\n    function _areContextMenusRegistered() {\r\n        return _workingset_cmenu && _workingset_configuration_menu;\r\n    }\r\n    \r\n    /* \r\n     * Registers context menus\r\n     * @private\r\n     */\r\n    function _registerContextMenus() {\r\n        if (!_areContextMenusRegistered()) {\r\n            _workingset_cmenu = Menus.getContextMenu(Menus.ContextMenuIds.WORKING_SET_CONTEXT_MENU);\r\n            _workingset_configuration_menu = Menus.getContextMenu(Menus.ContextMenuIds.WORKING_SET_CONFIG_MENU);\r\n        }\r\n    }\r\n    \r\n    /** \r\n     * Updates the appearance of the list element based on the parameters provided.\r\n     * @private\r\n     * @param {!HTMLLIElement} listElement\r\n     * @param {?File} selectedFile\r\n     */\r\n    function _updateListItemSelection(listItem, selectedFile) {\r\n        var shouldBeSelected = (selectedFile && $(listItem).data(_FILE_KEY).fullPath === selectedFile.fullPath);\r\n        \r\n        ViewUtils.toggleClass($(listItem), "selected", shouldBeSelected);\r\n    }\r\n\r\n    /** \r\n     * Determines if a file is dirty\r\n     * @private\r\n     * @param {!File} file - file to test\r\n     * @return {boolean} true if the file is dirty, false otherwise\r\n     */\r\n    function _isOpenAndDirty(file) {\r\n        // working set item might never have been opened; if so, then it\'s definitely not dirty\r\n        var docIfOpen = DocumentManager.getOpenDocumentForPath(file.fullPath);\r\n        return (docIfOpen && docIfOpen.isDirty);\r\n    }\r\n    \r\n    /* \r\n     * WorkingSetView constructor\r\n     * @constructor\r\n     * @param {!jQuery} $container - owning container\r\n     * @param {!string} paneId - paneId of this view pertains to\r\n     */\r\n    function WorkingSetView($container, paneId) {\r\n        var id = "working-set-list-" + paneId;\r\n        \r\n        this.$header = null;\r\n        this.$openFilesList = null;\r\n        this.$container = $container;\r\n        this.$el = $container.append(Mustache.render(paneListTemplate, _.extend({id: id}, Strings))).find("#" + id);\r\n        this.suppressSortRedraw = false;\r\n        this.paneId = paneId;\r\n        \r\n        this.updateOptionsButton();\r\n        this.init();\r\n    }\r\n\r\n    /*\r\n     * updates the visibility state of the gear button\r\n     */\r\n    WorkingSetView.prototype.updateOptionsButton = function () {\r\n        var visible = (MainViewManager.getActivePaneId() === this.paneId);\r\n        this.$el.find(".working-set-option-btn").toggle(visible);\r\n    };\r\n    \r\n    /*\r\n     * paneLayoutChange event listener\r\n     * @private\r\n     */\r\n    WorkingSetView.prototype._handlePaneLayoutChange = function () {\r\n        var $titleEl = this.$el.find(".working-set-header-title"),\r\n            title = Strings.WORKING_FILES;\r\n        \r\n        if (MainViewManager.getPaneCount() > 1) {\r\n            title = MainViewManager.getPaneTitle(this.paneId);\r\n        }\r\n        \r\n        $titleEl.text(title);\r\n        this.updateOptionsButton();\r\n    };\r\n\r\n    /**\r\n     * Finds the listItem item assocated with the file. Returns null if not found.\r\n     * @private\r\n     * @param {!File} file\r\n     * @return {HTMLLIItem} returns the DOM element of the item. null if one could not be found\r\n     */\r\n    WorkingSetView.prototype._findListItemFromFile = function (file) {\r\n        var result = null;\r\n\r\n        if (file) {\r\n            var items = this.$openFilesContainer.find("ul").children();\r\n            items.each(function () {\r\n                var $listItem = $(this);\r\n                if ($listItem.data(_FILE_KEY).fullPath === file.fullPath) {\r\n                    result = $listItem;\r\n                    return false; // breaks each\r\n                }\r\n            });\r\n        }\r\n\r\n        return result;\r\n    };\r\n\r\n    /*\r\n     * creates a name that is namespaced to this pane\r\n     * @param {!string} name - name of the event to create.\r\n     * use an empty string to get just the event name to turn off all events in the namespace\r\n     * @private\r\n     */\r\n    WorkingSetView.prototype._makeEventName = function (name) {\r\n        return name + ".paneList" + this.paneId;\r\n    };\r\n    \r\n\r\n    /**\r\n     * Scrolls the selected file into view\r\n     * @private\r\n     */\r\n    WorkingSetView.prototype._scrollSelectedFileIntoView = function () {\r\n        if (FileViewController.getFileSelectionFocus() !== FileViewController.WORKING_SET_VIEW) {\r\n            return;\r\n        }\r\n\r\n        var file = MainViewManager.getCurrentlyViewedFile(this.paneId);\r\n\r\n        var $selectedFile = this._findListItemFromFile(file);\r\n        if (!$selectedFile) {\r\n            return;\r\n        }\r\n\r\n        ViewUtils.scrollElementIntoView(this.$openFilesContainer, $selectedFile, false);\r\n    };\r\n\r\n    /**\r\n     * Redraw selection when list size changes or DocumentManager currentDocument changes.\r\n     * @private\r\n     */\r\n    WorkingSetView.prototype._fireSelectionChanged = function () {\r\n        this._scrollSelectedFileIntoView();\r\n\r\n        if (FileViewController.getFileSelectionFocus() === FileViewController.WORKING_SET_VIEW && this.$el.hasClass("active")) {\r\n            this.$openFilesList.trigger("selectionChanged");\r\n        } else {\r\n            this.$openFilesList.trigger("selectionHide");\r\n        }\r\n        // in-lieu of resize events, manually trigger contentChanged to update scroll shadows\r\n        this.$openFilesContainer.triggerHandler("contentChanged");\r\n    };\r\n\r\n    /**\r\n     * adds the style \'vertical-scroll\' if a vertical scroll bar is present\r\n     * @private\r\n     */\r\n    WorkingSetView.prototype._adjustForScrollbars = function () {\r\n        if (this.$openFilesContainer[0].scrollHeight > this.$openFilesContainer[0].clientHeight) {\r\n            if (!this.$openFilesContainer.hasClass("vertical-scroll")) {\r\n                this.$openFilesContainer.addClass("vertical-scroll");\r\n            }\r\n        } else {\r\n            this.$openFilesContainer.removeClass("vertical-scroll");\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Adds directory names to elements representing passed files in working tree\r\n     * @private\r\n     * @param {Array.<File>} filesList - list of Files with the same filename\r\n     */\r\n    WorkingSetView.prototype._addDirectoryNamesToWorkingTreeFiles = function (filesList) {\r\n        // filesList must have at least two files in it for this to make sense\r\n        if (filesList.length <= 1) {\r\n            return;\r\n        }\r\n\r\n        var displayPaths = ViewUtils.getDirNamesForDuplicateFiles(filesList);\r\n\r\n        // Go through open files and add directories to appropriate entries\r\n        this.$openFilesContainer.find("ul > li").each(function () {\r\n            var $li = $(this);\r\n            var io = filesList.indexOf($li.data(_FILE_KEY));\r\n            if (io !== -1) {\r\n                var dirSplit = displayPaths[io].split("/");\r\n                if (dirSplit.length > 3) {\r\n                    displayPaths[io] = dirSplit[0] + "/\\u2026/" + dirSplit[dirSplit.length - 1];\r\n                }\r\n\r\n                var $dir = $("<span class=\'directory\'/>").html(" &mdash; " + displayPaths[io]);\r\n                $li.children("a").append($dir);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Looks for files with the same name in the working set\r\n     * and adds a parent directory name to them\r\n     * @private\r\n     */\r\n    WorkingSetView.prototype._checkForDuplicatesInWorkingTree = function () {\r\n        var self = this,\r\n            map = {},\r\n            fileList = MainViewManager.getWorkingSet(this.paneId);\r\n\r\n        // We need to always clear current directories as files could be removed from working tree.\r\n        this.$openFilesContainer.find("ul > li > a > span.directory").remove();\r\n\r\n        // Go through files and fill map with arrays of files.\r\n        fileList.forEach(function (file) {\r\n            // Use the same function that is used to create html for file.\r\n            var displayHtml = ViewUtils.getFileEntryDisplay(file);\r\n\r\n            if (!map[displayHtml]) {\r\n                map[displayHtml] = [];\r\n            }\r\n            map[displayHtml].push(file);\r\n        });\r\n\r\n        // Go through the map and solve the arrays with length over 1. Ignore the rest.\r\n        _.forEach(map, function (value) {\r\n            if (value.length > 1) {\r\n                self._addDirectoryNamesToWorkingTreeFiles(value);\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Shows/Hides open files list based on working set content.\r\n     * @private\r\n     */\r\n    WorkingSetView.prototype._redraw = function () {\r\n        var fileList = MainViewManager.getWorkingSet(this.paneId),\r\n            paneId = MainViewManager.getActivePaneId();\r\n        \r\n        if (paneId === this.paneId) {\r\n            this.$el.addClass("active");\r\n        } else {\r\n            this.$el.removeClass("active");\r\n        }\r\n        \r\n        if (!fileList || fileList.length === 0) {\r\n            this.$openFilesContainer.hide();\r\n            this.$workingSetListViewHeader.hide();\r\n        } else {\r\n            this.$openFilesContainer.show();\r\n            this.$workingSetListViewHeader.show();\r\n            this._checkForDuplicatesInWorkingTree();\r\n        }\r\n        this._adjustForScrollbars();\r\n        this._fireSelectionChanged();\r\n        this.updateOptionsButton();\r\n    };\r\n    \r\n    /**\r\n     * activePaneChange event handler\r\n     * @private\r\n     */\r\n    WorkingSetView.prototype._handleActivePaneChange = function () {\r\n        this._redraw();\r\n    };\r\n    \r\n    /**\r\n     * Starts the drag and drop working set view reorder.\r\n     * @private\r\n     * @param {!Event} event - jQuery event\r\n     * @param {!HTMLLIElement} $listItem - jQuery element\r\n     * @param {?bool} fromClose - true if reorder was called from the close icon\r\n     */\r\n    WorkingSetView.prototype._reorderListItem = function (event, $listItem, fromClose) {\r\n        var self            = this,\r\n            $prevListItem   = $listItem.prev(),\r\n            $nextListItem   = $listItem.next(),\r\n            selected        = $listItem.hasClass("selected"),\r\n            prevSelected    = $prevListItem.hasClass("selected"),\r\n            nextSelected    = $nextListItem.hasClass("selected"),\r\n            index           = MainViewManager.findInWorkingSet(self.paneId, $listItem.data(_FILE_KEY).fullPath),\r\n            height          = $listItem.height(),\r\n            startPageY      = event.pageY,\r\n            listItemTop     = startPageY - $listItem.offset().top,\r\n            listItemBottom  = $listItem.offset().top + height - startPageY,\r\n            offsetTop       = this.$openFilesContainer.offset().top,\r\n            scrollElement   = this.$openFilesContainer.get(0),\r\n            containerHeight = scrollElement.clientHeight,\r\n            maxScroll       = scrollElement.scrollHeight - containerHeight,\r\n            hasScroll       = scrollElement.scrollHeight > containerHeight,\r\n            hasBottomShadow = scrollElement.scrollHeight > scrollElement.scrollTop + containerHeight,\r\n            addBottomShadow = false,\r\n            interval        = false,\r\n            moved           = false;\r\n        \r\n        // Don\'t redraw the working set for the next events\r\n        self.suppressSortRedraw = true;\r\n        \r\n        function drag(e) {\r\n            var top = e.pageY - startPageY;\r\n            \r\n            // Drag if the item is not the first and moving it up or\r\n            // if the item is not the last and moving down\r\n            if (($prevListItem.length && top < 0) || ($nextListItem.length && top > 0)) {\r\n                // Reorder the list once the item is halfway to the new position\r\n                if (Math.abs(top) > height / 2) {\r\n                    // If moving up, place the previows item after the moving item\r\n                    if (top < 0) {\r\n                        $prevListItem.insertAfter($listItem);\r\n                        startPageY -= height;\r\n                        top = top + height;\r\n                        MainViewManager._swapWorkingSetListIndexes(self.paneId, index, --index);\r\n                    // If moving down, place the next item before the moving item\r\n                    } else {\r\n                        $nextListItem.insertBefore($listItem);\r\n                        startPageY += height;\r\n                        top = top - height;\r\n                        MainViewManager._swapWorkingSetListIndexes(self.paneId, index, ++index);\r\n                    }\r\n                    \r\n                    // Update the selection when the previows or next element were selected\r\n                    if (!selected && ((top > 0 && prevSelected) || (top < 0 && nextSelected))) {\r\n                        self._fireSelectionChanged();\r\n                    }\r\n                    \r\n                    // Update the previows and next items\r\n                    $prevListItem = $listItem.prev();\r\n                    $nextListItem = $listItem.next();\r\n                    prevSelected  = $prevListItem.hasClass("selected");\r\n                    nextSelected  = $nextListItem.hasClass("selected");\r\n\r\n                    // If the last item of the list was selected and the previows was moved to its location, then\r\n                    // the it will show a bottom shadow even if it shouldnt because of the way the scrollHeight is \r\n                    // handle with relative position. This will remove that shadow and add it on drop. \r\n                    if (!addBottomShadow && !hasBottomShadow && !$nextListItem.length && prevSelected) {\r\n                        ViewUtils.removeScrollerShadow(self.$openFilesContainer[0], null);\r\n                        ViewUtils.addScrollerShadow(self.$openFilesContainer[0], null, false);\r\n                        addBottomShadow = true;\r\n                    }\r\n                }\r\n            // Set the top to 0 as the event probably didnt fired at the exact start/end of the list \r\n            } else {\r\n                top = 0;\r\n            }\r\n            \r\n            // Move the item\r\n            $listItem.css("top", top + "px");\r\n            \r\n            // Update the selection position\r\n            if (selected) {\r\n                self._fireSelectionChanged();\r\n            }\r\n            \r\n            // Once the movement is greater than 3 pixels, it is assumed that the user wantes to reorder files and not open\r\n            if (!moved && Math.abs(top) > 3) {\r\n                Menus.closeAll();\r\n                moved = true;\r\n                \r\n                // Don\'t redraw the working set for the next events\r\n                self.suppressSortRedraw = true;\r\n            }\r\n        }\r\n        \r\n        function endScroll() {\r\n            window.clearInterval(interval);\r\n            interval = false;\r\n        }\r\n        \r\n        function scroll(e) {\r\n            var dir = 0;\r\n            // Mouse over the first visible pixels and moving up\r\n            if (e.pageY - listItemTop < offsetTop + 7) {\r\n                dir = -1;\r\n            // Mouse over the last visible pixels and moving down\r\n            } else if (e.pageY + listItemBottom > offsetTop + containerHeight - 7) {\r\n                dir = 1;\r\n            }\r\n            \r\n            if (dir && !interval) {\r\n                // Scroll view if the mouse is over the first or last pixels of the container\r\n                interval = window.setInterval(function () {\r\n                    var scrollTop = self.$openFilesContainer.scrollTop();\r\n                    // End scroll if there isn\'t more to scroll\r\n                    if ((dir === -1 && scrollTop <= 0) || (dir === 1 && scrollTop >= maxScroll)) {\r\n                        endScroll();\r\n                    // Scroll and drag list item\r\n                    } else {\r\n                        self.$openFilesContainer.scrollTop(scrollTop + 7 * dir);\r\n                        startPageY -= 7 * dir;\r\n                        drag(e);\r\n                    }\r\n                }, 100);\r\n            } else if (!dir && interval) {\r\n                endScroll();\r\n            }\r\n        }\r\n        \r\n        function drop() {\r\n            // Enable Mousewheel\r\n            window.onmousewheel = window.document.onmousewheel = null;\r\n            \r\n            // Removes the styles, placing the item in the chosen place\r\n            $listItem.removeAttr("style");\r\n            \r\n            // End the scrolling if needed\r\n            if (interval) {\r\n                window.clearInterval(interval);\r\n            }\r\n            \r\n            // If item wasn\'t dragged, treat as a click\r\n            if (!moved) {\r\n                // Click on close icon, or middle click anywhere - close the item without selecting it first\r\n                if (fromClose || event.which === MIDDLE_BUTTON) {\r\n                    CommandManager.execute(Commands.FILE_CLOSE, {file: $listItem.data(_FILE_KEY),\r\n                                                                 paneId: self.paneId});\r\n                } else {\r\n                    // Normal right and left click - select the item\r\n                    FileViewController.openAndSelectDocument($listItem.data(_FILE_KEY).fullPath,\r\n                                                             FileViewController.WORKING_SET_VIEW,\r\n                                                             self.paneId);\r\n                }\r\n            \r\n            } else {\r\n                // Update the file selection\r\n                if (selected) {\r\n                    self._fireSelectionChanged();\r\n                    ViewUtils.scrollElementIntoView(self.$openFilesContainer, $listItem, false);\r\n                }\r\n                \r\n                // Restore the shadow\r\n                if (addBottomShadow) {\r\n                    ViewUtils.addScrollerShadow(self.$openFilesContainer[0], null, true);\r\n                }\r\n            }\r\n            // The drag is done, so set back to the default\r\n            self.suppressSortRedraw = false;\r\n        }\r\n        \r\n        \r\n        // Only drag with the left mouse button, and control key is not down\r\n        // on Mac, end the drop in other cases\r\n        if (event.which !== LEFT_BUTTON || (event.ctrlKey && brackets.platform === "mac")) {\r\n            drop();\r\n            return;\r\n        }\r\n        \r\n        // Disable Mousewheel while dragging\r\n        window.onmousewheel = window.document.onmousewheel = function (e) {\r\n            e.preventDefault();\r\n        };\r\n        \r\n        // Style the element\r\n        $listItem.css("position", "relative").css("z-index", 1);\r\n        \r\n        var $holder = $(window);\r\n        \r\n        // Event Handlers\r\n        $holder.on(self._makeEventName("mousemove"), function (e) {\r\n            if (hasScroll) {\r\n                scroll(e);\r\n            }\r\n            drag(e);\r\n        });\r\n        $holder.on(self._makeEventName("mouseup"), function (e) {\r\n            $holder.off(self._makeEventName(""));\r\n            drop();\r\n        });\r\n    };\r\n    \r\n    /** \r\n     * Updates the appearance of the list element based on the parameters provided\r\n     * @private\r\n     * @param {!HTMLLIElement} listElement\r\n     * @param {bool} isDirty \r\n     * @param {bool} canClose\r\n     */\r\n    WorkingSetView.prototype._updateFileStatusIcon = function (listElement, isDirty, canClose) {\r\n        var self = this,\r\n            $fileStatusIcon = listElement.find(".file-status-icon"),\r\n            showIcon = isDirty || canClose;\r\n\r\n        // remove icon if its not needed\r\n        if (!showIcon && $fileStatusIcon.length !== 0) {\r\n            $fileStatusIcon.remove();\r\n            $fileStatusIcon = null;\r\n            \r\n        // create icon if its needed and doesn\'t exist\r\n        } else if (showIcon && $fileStatusIcon.length === 0) {\r\n            \r\n            $fileStatusIcon = $("<div class=\'file-status-icon\'></div>")\r\n                .prependTo(listElement)\r\n                .mousedown(function (e) {\r\n                    // Try to drag if that is what is wanted if not it will be the equivalent to File > Close;\r\n                    // it doesn\'t merely remove a file from the working set\r\n                    self._reorderListItem(e, $(this).parent(), true);\r\n                    \r\n                    // stopPropagation of mousedown for fileStatusIcon so the parent <LI> item, which\r\n                    // selects documents on mousedown, doesn\'t select the document in the case \r\n                    // when the click is on fileStatusIcon\r\n                    e.stopPropagation();\r\n                });\r\n        }\r\n\r\n        // Set icon\'s class\r\n        if ($fileStatusIcon) {\r\n            ViewUtils.toggleClass($fileStatusIcon, "dirty", isDirty);\r\n            ViewUtils.toggleClass($fileStatusIcon, "can-close", canClose);\r\n        }\r\n    };\r\n    \r\n    /** \r\n     * Builds the UI for a new list item and inserts in into the end of the list\r\n     * @private\r\n     * @param {File} file\r\n     * @return {HTMLLIElement} newListItem\r\n     */\r\n    WorkingSetView.prototype._createNewListItem = function (file) {\r\n        var self = this,\r\n            selectedFile = MainViewManager.getCurrentlyViewedFile(this.paneId);\r\n\r\n        // Create new list item with a link\r\n        var $link = $("<a href=\'#\'></a>").html(ViewUtils.getFileEntryDisplay(file));\r\n        var $newItem = $("<li></li>")\r\n            .append($link)\r\n            .data(_FILE_KEY, file);\r\n\r\n        this.$openFilesContainer.find("ul").append($newItem);\r\n        \r\n        // Update the listItem\'s apperance\r\n        this._updateFileStatusIcon($newItem, _isOpenAndDirty(file), false);\r\n        _updateListItemSelection($newItem, selectedFile);\r\n\r\n        $newItem.mousedown(function (e) {\r\n            self._reorderListItem(e, $(this));\r\n            e.preventDefault();\r\n        });\r\n        \r\n        $newItem.hover(\r\n            function () {\r\n                self._updateFileStatusIcon($(this), _isOpenAndDirty(file), true);\r\n            },\r\n            function () {\r\n                self._updateFileStatusIcon($(this), _isOpenAndDirty(file), false);\r\n            }\r\n        );\r\n    };\r\n    \r\n    /** \r\n     * Deletes all the list items in the view and rebuilds them from the working set model\r\n     * @private\r\n     */\r\n    WorkingSetView.prototype._rebuildViewList = function (forceRedraw) {\r\n        var self = this,\r\n            fileList = MainViewManager.getWorkingSet(this.paneId);\r\n\r\n        this.$openFilesContainer.find("ul").empty();\r\n        \r\n        fileList.forEach(function (file) {\r\n            self._createNewListItem(file);\r\n        });\r\n\r\n        if (forceRedraw) {\r\n            self._redraw();\r\n        }\r\n    };\r\n\r\n    /** \r\n     * Updates the pane view\'s selection marker and scrolls the item into view\r\n     * @private\r\n     */\r\n    WorkingSetView.prototype._updateListSelection = function () {\r\n        var file = MainViewManager.getCurrentlyViewedFile(this.paneId);\r\n            \r\n        // Iterate through working set list and update the selection on each\r\n        var items = this.$openFilesContainer.find("ul").children().each(function () {\r\n            _updateListItemSelection(this, file);\r\n        });\r\n\r\n        // Make sure selection is in view\r\n        this._scrollSelectedFileIntoView();\r\n        this._fireSelectionChanged();\r\n    };\r\n\r\n    /** \r\n     * workingSetAdd event handler\r\n     * @private\r\n     * @param {jQuery.Event} e - event object\r\n     * @param {!File} fileAdded - the file that was added\r\n     * @param {!number} index - index where the file was added\r\n     * @param {!string} paneId - the id of the pane the item that was to\r\n     */\r\n    WorkingSetView.prototype._handleFileAdded = function (e, fileAdded, index, paneId) {\r\n        if (paneId === this.paneId) {\r\n            this._rebuildViewList(true);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * workingSetAddList event handler\r\n     * @private\r\n     * @param {jQuery.Event} e - event object\r\n     * @param {!Array.<File>} files - the files that were added\r\n     * @param {!string} paneId - the id of the pane the item that was to\r\n     */\r\n    WorkingSetView.prototype._handleFileListAdded = function (e, files, paneId) {\r\n        if (paneId === this.paneId) {\r\n            this._rebuildViewList(true);\r\n        }\r\n    };\r\n\r\n    /** \r\n     * workingSetRemove event handler\r\n     * @private \r\n     * @param {jQuery.Event} e - event object\r\n     * @param {!File} file - the file that was removed\r\n     * @param {?boolean} suppressRedraw If true, suppress redraw\r\n     * @param {!string} paneId - the id of the pane the item that was to\r\n     */\r\n    WorkingSetView.prototype._handleFileRemoved = function (e, file, suppressRedraw, paneId) {\r\n        if (paneId === this.paneId && !suppressRedraw) {\r\n            var $listItem = this._findListItemFromFile(file);\r\n            if ($listItem) {\r\n                // Make the next file in the list show the close icon, \r\n                // without having to move the mouse, if there is a next file.\r\n                var $nextListItem = $listItem.next();\r\n                if ($nextListItem && $nextListItem.length > 0) {\r\n                    var canClose = ($listItem.find(".can-close").length === 1);\r\n                    var isDirty = _isOpenAndDirty($nextListItem.data(_FILE_KEY));\r\n                    this._updateFileStatusIcon($nextListItem, isDirty, canClose);\r\n                }\r\n                $listItem.remove();\r\n            }\r\n            \r\n            this._redraw();\r\n        }\r\n    };\r\n\r\n    /** \r\n     * workingSetRemoveList event handler\r\n     * @private\r\n     * @param {jQuery.Event} e - event object\r\n     * @param {!Array.<File>} files - the files that were removed\r\n     * @param {!string} paneId - the id of the pane the item that was to\r\n     */\r\n    WorkingSetView.prototype._handleRemoveList = function (e, files, paneId) {\r\n        var self = this;\r\n        if (paneId === this.paneId) {\r\n            files.forEach(function (file) {\r\n                var $listItem = self._findListItemFromFile(file);\r\n                if ($listItem) {\r\n                    $listItem.remove();\r\n                }\r\n            });\r\n\r\n            this._redraw();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * workingSetSort event handler\r\n     * @private\r\n     * @param {jQuery.Event} e - event object\r\n     * @param {!string} paneId - the id of the pane to sort\r\n     */\r\n    WorkingSetView.prototype._handleWorkingSetSort = function (e, paneId) {\r\n        if (!this.suppressSortRedraw && paneId === this.paneId) {\r\n            this._rebuildViewList(true);\r\n        }\r\n    };\r\n\r\n    /** \r\n     * dirtyFlagChange event handler\r\n     * @private\r\n     * @param {jQuery.Event} e - event object\r\n     * @param {Document} doc - document whose dirty state has changed\r\n     */\r\n    WorkingSetView.prototype._handleDirtyFlagChanged = function (e, doc) {\r\n        var listItem = this._findListItemFromFile(doc.file);\r\n        if (listItem) {\r\n            var canClose = $(listItem).find(".can-close").length === 1;\r\n            this._updateFileStatusIcon(listItem, doc.isDirty, canClose);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * workingSetUpdate event handler\r\n     * @private\r\n     * @param {jQuery.Event} e - event object\r\n     * @param {!string} paneId - the id of the pane to update\r\n     */\r\n    WorkingSetView.prototype._handleWorkingSetUpdate = function (e, paneId) {\r\n        if (this.paneId === paneId) {\r\n            this._rebuildViewList(true);\r\n        }\r\n    };\r\n    \r\n\r\n    /** \r\n     * Initializes the WorkingSetView object\r\n     */\r\n    WorkingSetView.prototype.init = function () {\r\n        // Init DOM element\r\n        var self = this;\r\n        \r\n        this.$openFilesContainer = this.$el.find(".open-files-container");\r\n        this.$workingSetListViewHeader = this.$el.find(".working-set-header");\r\n        this.$gearMenu = this.$el.find(".working-set-option-btn");\r\n        \r\n        this.$openFilesList = this.$el.find("ul");\r\n        \r\n        // Register listeners\r\n        $(MainViewManager).on(this._makeEventName("workingSetAdd"), _.bind(this._handleFileAdded, this));\r\n        $(MainViewManager).on(this._makeEventName("workingSetAddList"), _.bind(this._handleFileListAdded, this));\r\n        $(MainViewManager).on(this._makeEventName("workingSetRemove"), _.bind(this._handleFileRemoved, this));\r\n        $(MainViewManager).on(this._makeEventName("workingSetRemoveList"), _.bind(this._handleRemoveList, this));\r\n        $(MainViewManager).on(this._makeEventName("workingSetSort"), _.bind(this._handleWorkingSetSort, this));\r\n        $(MainViewManager).on(this._makeEventName("activePaneChange"), _.bind(this._handleActivePaneChange, this));\r\n        $(MainViewManager).on(this._makeEventName("paneLayoutChange"), _.bind(this._handlePaneLayoutChange, this));\r\n        $(MainViewManager).on(this._makeEventName("workingSetUpdate"), _.bind(this._handleWorkingSetUpdate, this));\r\n\r\n        $(DocumentManager).on(this._makeEventName("dirtyFlagChange"), _.bind(this._handleDirtyFlagChanged, this));\r\n\r\n        $(FileViewController).on(this._makeEventName("documentSelectionFocusChange") + " " + this._makeEventName("fileViewFocusChange"), _.bind(this._updateListSelection, this));\r\n        \r\n        // Show scroller shadows when open-files-container scrolls\r\n        ViewUtils.addScrollerShadow(this.$openFilesContainer[0], null, true);\r\n        ViewUtils.sidebarList(this.$openFilesContainer);\r\n        \r\n        // Disable horizontal scrolling until WebKit bug #99379 is fixed\r\n        this.$openFilesContainer.css("overflow-x", "hidden");\r\n\r\n        this.installMenuHandlers();\r\n        \r\n        this._redraw();\r\n    };\r\n\r\n\r\n    /** \r\n     * Installs the gear and context menu handlers\r\n     */\r\n    WorkingSetView.prototype.installMenuHandlers = function () {\r\n        var self = this;\r\n        \r\n        this.$openFilesContainer.on("contextmenu", function (e) {\r\n            _registerContextMenus();\r\n            _workingset_cmenu.open(e);\r\n        });\r\n\r\n        this.$gearMenu.on("click", function (e) {\r\n            var buttonOffset,\r\n                buttonHeight;\r\n\r\n            e.stopPropagation();\r\n\r\n            MainViewManager.setActivePaneId(self.paneId);\r\n            _registerContextMenus();\r\n            \r\n            if (_workingset_configuration_menu.isOpen()) {\r\n                _workingset_configuration_menu.close();\r\n            } else {\r\n                buttonOffset = $(this).offset();\r\n                buttonHeight = $(this).outerHeight();\r\n                _workingset_configuration_menu.open({\r\n                    pageX: buttonOffset.left,\r\n                    pageY: buttonOffset.top + buttonHeight\r\n                });\r\n            }\r\n        });\r\n            \r\n    };\r\n    \r\n    /** \r\n     * Destroys the WorkingSetView DOM element and removes all event handlers\r\n     */\r\n    WorkingSetView.prototype.destroy = function () {\r\n        this.$el.remove();\r\n        $(MainViewManager).off(this._makeEventName(""));\r\n        $(DocumentManager).off(this._makeEventName(""));\r\n        $(FileViewController).off(this._makeEventName(""));\r\n    };\r\n    \r\n    /**\r\n     * paneDestroy event handler\r\n     */\r\n    $(MainViewManager).on("paneDestroy", function (e, paneId) {\r\n        var index = _.findIndex(_views, function (workingSetListView) {\r\n            return workingSetListView.paneId === paneId;\r\n        });\r\n        \r\n        if (index >= 0) {\r\n            var views = _views.splice(index, 1);\r\n            _.forEach(views, function (view) {\r\n                view.destroy();\r\n            });\r\n        }\r\n    });\r\n    \r\n    /** \r\n     * Creates a new WorkingSetView object for the specified pane\r\n     * @param {!jQuery} $container - the WorkingSetView\'s DOM parent node\r\n     * @param {!string} paneId - the id of the pane the view is being created for\r\n     */\r\n    function createWorkingSetViewForPane($container, paneId) {\r\n        // make sure the pane doesn\'t already have a view\r\n        var index = _.findIndex(_views, function (workingSetListView) {\r\n            return workingSetListView.paneId === paneId;\r\n        });\r\n\r\n        // if there wasn\'t already a view for the pane then create a new one\r\n        if (index === -1) {\r\n            _views.push(new WorkingSetView($container, paneId));\r\n        }\r\n    }\r\n\r\n    /** \r\n     * Refreshes all Pane View List Views\r\n     */\r\n    function refresh() {\r\n        _.forEach(_views, function (workingSetListView) {\r\n            workingSetListView._redraw();\r\n        });\r\n    }\r\n    \r\n    /** \r\n     * Synchronizes the selection indicator for all views\r\n     */\r\n    function syncSelectionIndicator() {\r\n        _.forEach(_views, function (workingSetListView) {\r\n            workingSetListView.$openFilesContainer.triggerHandler("scroll");\r\n        });\r\n    }\r\n    \r\n    \r\n    // Public API\r\n    exports.createWorkingSetViewForPane   = createWorkingSetViewForPane;\r\n    exports.refresh                       = refresh;\r\n    exports.syncSelectionIndicator         = syncSelectionIndicator;\r\n});\r\n\n//# sourceURL=/project/WorkingSetView.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\n/**\r\n * Manages the workingSetList sort methods.\r\n */\r\ndefine(\'project/WorkingSetSort\',[\'require\',\'exports\',\'module\',\'command/Commands\',\'command/CommandManager\',\'view/MainViewManager\',\'preferences/PreferencesManager\',\'file/FileUtils\',\'utils/AppInit\',\'strings\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var Commands                = require("command/Commands"),\r\n        CommandManager          = require("command/CommandManager"),\r\n        MainViewManager         = require("view/MainViewManager"),\r\n        PreferencesManager      = require("preferences/PreferencesManager"),\r\n        FileUtils               = require("file/FileUtils"),\r\n        AppInit                 = require("utils/AppInit"),\r\n        Strings                 = require("strings"),\r\n        _                       = require("thirdparty/lodash");\r\n    \r\n    /**\r\n     * List of sorting method objects\r\n     * @private\r\n     * @type {Array.<Sort>}\r\n     */\r\n    var _sorts = [];\r\n    \r\n    /**\r\n     * Denotes the current sort method object\r\n     * @private\r\n     * @type {Sort}\r\n     */\r\n    var _currentSort = null;\r\n    \r\n    /**\r\n     * Denotes if automatic sorting is enabled or not\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    var _automaticSort = false;\r\n    \r\n\r\n    /** \r\n     * Maps Legacy sort method names  to new sort method names\r\n     * @private\r\n     * @type {object.<string: string>} oldname: newname\r\n     */\r\n    var _sortPrefConversionMap = {\r\n        "view.sortWorkingSetByAdded" : "cmd.sortWorkingSetByAdded",\r\n        "view.sortWorkingSetByName"  : "cmd.sortWorkingSetByName",\r\n        "view.sortWorkingSetByType"  : "cmd.sortWorkingSetByType"\r\n    };\r\n    \r\n    /**\r\n     * Events which the sort command will listen for to trigger a sort\r\n     * @constant {string} \r\n     * @private\r\n     */\r\n    var _SORT_EVENT_NAMES = "workingSetAdd workingSetAddList";\r\n    \r\n    /**\r\n     * Preference name\r\n     * @constant {string} \r\n     * @private\r\n     */\r\n    var _WORKING_SET_SORT_PREF = "workingSetSortMethod";\r\n\r\n    /**\r\n     * Legacy preference name\r\n     * @constant {string} \r\n     * @private\r\n     */\r\n    var _LEGACY_SORT_PREF = "currentSort";\r\n    \r\n    /**\r\n     * Retrieves a Sort object by id\r\n     * @param {(string|Command)} command A command ID or a command object.\r\n     * @return {?Sort}\r\n     */\r\n    function get(command) {\r\n        var commandID;\r\n        if (!command) {\r\n            console.error("Attempting to get a Sort method with a missing required parameter: command");\r\n            return;\r\n        }\r\n        \r\n        if (typeof command === "string") {\r\n            commandID = command;\r\n        } else {\r\n            commandID = command.getID();\r\n        }\r\n        return _sorts[commandID];\r\n    }\r\n    \r\n    /**\r\n     * Converts the old brackets working set sort preference into the modern paneview sort preference\r\n     * @private\r\n     * @param {!string} sortMethod - sort preference to convert\r\n     * @return {?string} new sort preference string or undefined if an sortMethod is not found\r\n     */\r\n    function _convertSortPref(sortMethod) {\r\n        if (!sortMethod) {\r\n            return null;\r\n        }\r\n        \r\n        if (_sortPrefConversionMap.hasOwnProperty(sortMethod)) {\r\n            sortMethod = _sortPrefConversionMap[sortMethod];\r\n            PreferencesManager.setViewState(_WORKING_SET_SORT_PREF, sortMethod);\r\n        } else {\r\n            sortMethod = null;\r\n        }\r\n        \r\n        return sortMethod;\r\n    }\r\n    \r\n    /**\r\n     * @return {boolean} Enabled state of Automatic Sort.\r\n     */\r\n    function getAutomatic() {\r\n        return _automaticSort;\r\n    }\r\n    \r\n    /**\r\n     * Removes the sort listeners.\r\n     * @private\r\n     */\r\n    function _removeListeners() {\r\n        $(MainViewManager).off(".sort");\r\n    }\r\n    \r\n    /**\r\n     * Enables/Disables Automatic Sort depending on the value.\r\n     * @param {boolean} enable True to enable, false to disable.\r\n     */\r\n    function setAutomatic(enable) {\r\n        _automaticSort = enable;\r\n        PreferencesManager.setViewState("automaticSort", _automaticSort);\r\n        CommandManager.get(Commands.CMD_WORKING_SORT_TOGGLE_AUTO).setChecked(_automaticSort);\r\n        _currentSort.setChecked(_automaticSort);\r\n        \r\n        if (_automaticSort) {\r\n            _currentSort.sort();\r\n        } else {\r\n            _removeListeners();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Adds the current sort MainViewManager listeners.\r\n     * @private\r\n     */\r\n    function _addListeners() {\r\n        if (_automaticSort && _currentSort && _currentSort.getEvents()) {\r\n            $(MainViewManager)\r\n                .on(_currentSort.getEvents(), function () {\r\n                    _currentSort.sort();\r\n                })\r\n                .on("_workingSetDisableAutoSort.sort", function () {\r\n                    setAutomatic(false);\r\n                });\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Sets the current sort method and checks it on the context menu.\r\n     * @private\r\n     * @param {Sort} newSort\r\n     */\r\n    function _setCurrentSort(newSort) {\r\n        var command;\r\n        if (_currentSort !== newSort) {\r\n            if (_currentSort !== null) {\r\n                _currentSort.setChecked(false);\r\n            }\r\n            if (_automaticSort) {\r\n                newSort.setChecked(true);\r\n            }\r\n            \r\n            CommandManager.get(Commands.CMD_WORKING_SORT_TOGGLE_AUTO).setEnabled(!!newSort.getEvents());\r\n            PreferencesManager.setViewState(_WORKING_SET_SORT_PREF, newSort.getCommandID());\r\n            _currentSort = newSort;\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @constructor\r\n     * @param {string} commandID A valid command identifier.\r\n     * @param {function(File, File): number} compareFn A valid sort\r\n     *      function (see register for a longer explanation).\r\n     * @param {string} events Space-separated WorkingSetSort possible events\r\n     *      ending with ".sort".\r\n     */\r\n    function Sort(commandID, compareFn, events, automaticFn) {\r\n        this._commandID = commandID;\r\n        this._compareFn = compareFn;\r\n        this._events    = events;\r\n    }\r\n    \r\n    /**\r\n     * The Command ID\r\n     * @return {string}\r\n     */\r\n    Sort.prototype.getCommandID = function () {\r\n        return this._commandID;\r\n    };\r\n    \r\n    /**\r\n     * The compare function\r\n     * @return {function(File, File): number}\r\n     */\r\n    Sort.prototype.getCompareFn = function () {\r\n        return this._compareFn;\r\n    };\r\n    \r\n    /**\r\n     * Gets the event that this sort object is listening to\r\n     * @return {string}\r\n     */\r\n    Sort.prototype.getEvents = function () {\r\n        return this._events;\r\n    };\r\n    \r\n    /**\r\n     * Checks/Unchecks the command which will show a check in the menu\r\n     * @param {boolean} value\r\n     */\r\n    Sort.prototype.setChecked = function (value) {\r\n        var command = CommandManager.get(this._commandID);\r\n        if (command) {\r\n            command.setChecked(value);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Performs the sort and makes it the current sort method.\r\n     */\r\n    Sort.prototype.execute = function () {\r\n        _setCurrentSort(this);\r\n        this.sort();\r\n    };\r\n    \r\n    /**\r\n     * Only performs the working set sort if this is the current sort.\r\n     */\r\n    Sort.prototype.sort = function () {\r\n        if (_currentSort === this) {\r\n            _removeListeners();\r\n            MainViewManager._sortWorkingSet(MainViewManager.ALL_PANES, this._compareFn);\r\n            _addListeners();\r\n        }\r\n    };\r\n    \r\n    \r\n    /**\r\n     * Registers a working set sort method.\r\n     * @param {(string|Command)} command A command ID or a command object\r\n     * @param {function(File, File): number} compareFn The function that\r\n     *      will be used inside JavaScript\'s sort function. The return a value\r\n     *      should be >0 (sort a to a lower index than b), =0 (leaves a and b\r\n     *      unchanged with respect to each other) or <0 (sort b to a lower index\r\n     *      than a) and must always returns the same value when given a specific\r\n     *      pair of elements a and b as its two arguments. Documentation at:\r\n     *      https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/sort\r\n     * @param {?string} events One or more space-separated event types that\r\n     *      DocumentManger uses. Each event passed will trigger the automatic\r\n     *      sort. If no events are passed, the automatic sort will be disabled\r\n     *      for that sort method.\r\n     * @return {?Sort}\r\n     */\r\n    function register(command, compareFn, events) {\r\n        var commandID = "";\r\n        \r\n        if (!command || !compareFn) {\r\n            console.log("Attempting to register a Sort method with a missing required parameter: command or compare function");\r\n            return;\r\n        }\r\n        if (typeof command === "string") {\r\n            commandID = command;\r\n        } else {\r\n            commandID = command.getID();\r\n        }\r\n        \r\n        if (_sorts[commandID]) {\r\n            console.log("Attempting to register an already-registered Sort method: " + command);\r\n            return;\r\n        }\r\n        \r\n        // Adds ".sort" to the end of each event to make them specific for the automatic sort.\r\n        if (events) {\r\n            events = events.split(" ");\r\n            events.forEach(function (event, index) {\r\n                events[index] = events[index].trim() + ".sort";\r\n            });\r\n            events = events.join(" ");\r\n        }\r\n        \r\n        var sort = new Sort(commandID, compareFn, events);\r\n        _sorts[commandID] = sort;\r\n        return sort;\r\n    }\r\n    \r\n    \r\n    /** \r\n     * Command Handler for CMD_WORKING_SORT_TOGGLE_AUTO\r\n     * @private\r\n     */\r\n    function _handleToggleAutoSort() {\r\n        setAutomatic(!getAutomatic());\r\n    }\r\n    \r\n    /** \r\n     * Command Handler for CMD_WORKINGSET_SORT_BY_* \r\n     * @private\r\n     * @param {!string} commandId identifies the sort method to use \r\n     */\r\n    function _handleSort(commandId) {\r\n        get(commandId).execute();\r\n    }\r\n    \r\n    /**\r\n     * Register Sort Methods \r\n     */\r\n    register(\r\n        Commands.CMD_WORKINGSET_SORT_BY_ADDED,\r\n        function (paneId, file1, file2) {\r\n            var index1 = MainViewManager.findInWorkingSetByAddedOrder(paneId, file1.fullPath),\r\n                index2 = MainViewManager.findInWorkingSetByAddedOrder(paneId, file2.fullPath);\r\n            \r\n            return index1 - index2;\r\n        },\r\n        _SORT_EVENT_NAMES\r\n    );\r\n    register(\r\n        Commands.CMD_WORKINGSET_SORT_BY_NAME,\r\n        function (paneId, file1, file2) {\r\n            return FileUtils.compareFilenames(file1.name, file2.name, false);\r\n        },\r\n        _SORT_EVENT_NAMES\r\n    );\r\n    register(\r\n        Commands.CMD_WORKINGSET_SORT_BY_TYPE,\r\n        function (paneId, file1, file2) {\r\n            return FileUtils.compareFilenames(file1.name, file2.name, true);\r\n        },\r\n        _SORT_EVENT_NAMES\r\n    );\r\n    \r\n    \r\n    /**\r\n     * Register Command Handlers\r\n     */\r\n    CommandManager.register(Strings.CMD_WORKINGSET_SORT_BY_ADDED, Commands.CMD_WORKINGSET_SORT_BY_ADDED, _.partial(_handleSort, Commands.CMD_WORKINGSET_SORT_BY_ADDED));\r\n    CommandManager.register(Strings.CMD_WORKINGSET_SORT_BY_NAME,  Commands.CMD_WORKINGSET_SORT_BY_NAME,  _.partial(_handleSort, Commands.CMD_WORKINGSET_SORT_BY_NAME));\r\n    CommandManager.register(Strings.CMD_WORKINGSET_SORT_BY_TYPE,  Commands.CMD_WORKINGSET_SORT_BY_TYPE,  _.partial(_handleSort, Commands.CMD_WORKINGSET_SORT_BY_TYPE));\r\n    CommandManager.register(Strings.CMD_WORKING_SORT_TOGGLE_AUTO,   Commands.CMD_WORKING_SORT_TOGGLE_AUTO,    _handleToggleAutoSort);\r\n    \r\n    \r\n    /**\r\n     * Initialize default values for sorting preferences\r\n     */\r\n    PreferencesManager.stateManager.definePreference("automaticSort", "boolean", false);\r\n    PreferencesManager.convertPreferences(module, {_LEGACY_SORT_PREF: "user", "automaticSort": "user"}, true);\r\n    \r\n    /** \r\n     * Define a default sort method that\'s empty so that we\r\n     *   just convert and use the legacy sort method \r\n     */\r\n    PreferencesManager.stateManager.definePreference(_WORKING_SET_SORT_PREF, "string", "");\r\n    \r\n    /*\r\n     * initializes global sort method from preference settings or the default \r\n     */\r\n    function initSortMethod() {\r\n        var sortMethod = PreferencesManager.getViewState(_WORKING_SET_SORT_PREF);\r\n        \r\n        if (!sortMethod) {\r\n            sortMethod = _convertSortPref(PreferencesManager.getViewState(_LEGACY_SORT_PREF));\r\n        }\r\n\r\n        if (!sortMethod) {\r\n            sortMethod = Commands.CMD_WORKINGSET_SORT_BY_ADDED;\r\n        }\r\n        return sortMethod;\r\n    }\r\n    \r\n    /**\r\n     * Initialize items dependent on extensions/workingSetList\r\n     */\r\n    AppInit.appReady(function () {\r\n        var sortMethod = initSortMethod(),\r\n            curSort    = get(sortMethod),\r\n            autoSort = PreferencesManager.getViewState("automaticSort");\r\n        \r\n        if (curSort) {\r\n            _setCurrentSort(curSort);\r\n        }\r\n        if (autoSort) {\r\n            setAutomatic(autoSort);\r\n        }\r\n        if (curSort && autoSort) {\r\n            curSort.sort();\r\n        }\r\n    });\r\n    \r\n    // Public API\r\n    exports.register        = register;\r\n    exports.get             = get;\r\n    exports.getAutomatic    = getAutomatic;\r\n    exports.setAutomatic    = setAutomatic;\r\n});\r\n\n//# sourceURL=/project/WorkingSetSort.js'),eval(' /*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, brackets */\r\n\r\ndefine(\'utils/DragAndDrop\',[\'require\',\'exports\',\'module\',\'utils/Async\',\'command/CommandManager\',\'command/Commands\',\'widgets/Dialogs\',\'widgets/DefaultDialogs\',\'view/MainViewManager\',\'view/MainViewFactory\',\'language/LanguageManager\',\'filesystem/FileSystem\',\'editor/EditorManager\',\'file/FileUtils\',\'project/ProjectManager\',\'strings\',\'utils/StringUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n   \r\n    var Async           = require("utils/Async"),\r\n        CommandManager  = require("command/CommandManager"),\r\n        Commands        = require("command/Commands"),\r\n        Dialogs         = require("widgets/Dialogs"),\r\n        DefaultDialogs  = require("widgets/DefaultDialogs"),\r\n        MainViewManager = require("view/MainViewManager"),\r\n        MainViewFactory = require("view/MainViewFactory"),\r\n        LanguageManager = require("language/LanguageManager"),\r\n        FileSystem      = require("filesystem/FileSystem"),\r\n        EditorManager   = require("editor/EditorManager"),\r\n        FileUtils       = require("file/FileUtils"),\r\n        ProjectManager  = require("project/ProjectManager"),\r\n        Strings         = require("strings"),\r\n        StringUtils     = require("utils/StringUtils");\r\n    \r\n    /**\r\n     * Return an array of files excluding all files without a registered viewer. \r\n     *\r\n     * @param {Array.<string>} paths - filenames to filter before opening.\r\n     * @return {Array.<string>} paths which can actually be opened (may be empty)\r\n     */\r\n    function filterFilesToOpen(paths) {\r\n        // Filter out file in which we have no registered viewer\r\n        var filteredFiles = paths.filter(function (fullPath) {\r\n            return !LanguageManager.getLanguageForPath(fullPath).isBinary() ||\r\n                MainViewFactory.findSuitableFactoryForPath(fullPath);\r\n        });\r\n        \r\n        return filteredFiles;\r\n    }\r\n    \r\n    /**\r\n     * Returns true if the drag and drop items contains valid drop objects.\r\n     * @param {Array.<DataTransferItem>} items Array of items being dragged\r\n     * @return {boolean} True if one or more items can be dropped.\r\n     */\r\n    function isValidDrop(items) {\r\n        var i, len = items.length;\r\n        \r\n        for (i = 0; i < len; i++) {\r\n            if (items[i].kind === "file") {\r\n                var entry = items[i].webkitGetAsEntry();\r\n                \r\n                if (entry.isFile) {\r\n                    // If any files are being dropped, this is a valid drop\r\n                    return true;\r\n                } else if (len === 1) {\r\n                    // If exactly one folder is being dropped, this is a valid drop\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // No valid entries found\r\n        return false;\r\n    }\r\n    \r\n    /**\r\n     * Open dropped files\r\n     * @param {Array.<string>} files Array of files dropped on the application.\r\n     * @return {Promise} Promise that is resolved if all files are opened, or rejected\r\n     *     if there was an error. \r\n     */\r\n    function openDroppedFiles(files) {\r\n        var errorFiles = [],\r\n            filteredFiles = filterFilesToOpen(files);\r\n        \r\n        return Async.doInParallel(filteredFiles, function (path, idx) {\r\n            var result = new $.Deferred();\r\n            \r\n            // Only open files.\r\n            FileSystem.resolve(path, function (err, item) {\r\n                if (!err && item.isFile) {\r\n                    // If the file is already open, and this isn\'t the last\r\n                    // file in the list, return. If this *is* the last file,\r\n                    // always open it so it gets selected.\r\n                    if (idx < filteredFiles.length - 1) {\r\n                        if (MainViewManager.findInWorkingSet(MainViewManager.ALL_PANES, path) !== -1) {\r\n                            result.resolve();\r\n                            return;\r\n                        }\r\n                    }\r\n                    \r\n                    CommandManager.execute(Commands.CMD_ADD_TO_WORKINGSET_AND_OPEN,\r\n                                           {fullPath: path, silent: true})\r\n                        .done(function () {\r\n                            result.resolve();\r\n                        })\r\n                        .fail(function () {\r\n                            errorFiles.push(path);\r\n                            result.reject();\r\n                        });\r\n                } else if (!err && item.isDirectory && filteredFiles.length === 1) {\r\n                    // One folder was dropped, open it.\r\n                    ProjectManager.openProject(path)\r\n                        .done(function () {\r\n                            result.resolve();\r\n                        })\r\n                        .fail(function () {\r\n                            // User was already notified of the error.\r\n                            result.reject();\r\n                        });\r\n                } else {\r\n                    errorFiles.push(path);\r\n                    result.reject();\r\n                }\r\n            });\r\n            \r\n            return result.promise();\r\n        }, false)\r\n            .fail(function () {\r\n                if (errorFiles.length > 0) {\r\n                    var message = Strings.ERROR_OPENING_FILES;\r\n                    \r\n                    message += "<ul class=\'dialog-list\'>";\r\n                    errorFiles.forEach(function (file) {\r\n                        message += "<li><span class=\'dialog-filename\'>" +\r\n                            StringUtils.breakableUrl(ProjectManager.makeProjectRelativeIfPossible(file)) +\r\n                            "</span></li>";\r\n                    });\r\n                    message += "</ul>";\r\n                    \r\n                    Dialogs.showModalDialog(\r\n                        DefaultDialogs.DIALOG_ID_ERROR,\r\n                        Strings.ERROR_OPENING_FILE_TITLE,\r\n                        message\r\n                    );\r\n                }\r\n            });\r\n    }\r\n    \r\n    CommandManager.register(Strings.CMD_OPEN_DROPPED_FILES, Commands.FILE_OPEN_DROPPED_FILES, openDroppedFiles);\r\n\r\n    // Export public API\r\n    exports.isValidDrop         = isValidDrop;\r\n    exports.openDroppedFiles    = openDroppedFiles;\r\n    exports.filterFilesToOpen   = filterFilesToOpen;\r\n});\n//# sourceURL=/utils/DragAndDrop.js'),eval('define(\'text!LiveDevelopment/Inspector/Inspector.json\',[],function () { return \'{\\r\\n    "version": { "major": "1", "minor": "0" },\\r\\n    "domains": [{\\r\\n        "domain": "Inspector",\\r\\n        "hidden": true,\\r\\n        "types": [],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables inspector domain notifications."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables inspector domain notifications."\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "evaluateForTestInFrontend",\\r\\n                "parameters": [\\r\\n                    { "name": "testCallId", "type": "integer" },\\r\\n                    { "name": "script", "type": "string" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "inspect",\\r\\n                "parameters": [\\r\\n                    { "name": "object", "$ref": "Runtime.RemoteObject" },\\r\\n                    { "name": "hints", "type": "object" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "detached",\\r\\n                "description": "Fired when remote debugging connection is about to be terminated. Contains detach reason.",\\r\\n                "parameters": [\\r\\n                    { "name": "reason", "type": "string", "description": "The reason why connection has been terminated." }\\r\\n                ]\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Memory",\\r\\n        "hidden": true,\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "NodeCount",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "nodeName", "type": "string" },\\r\\n                    { "name": "count", "type": "integer" }\\r\\n                ],\\r\\n                "description": "Number of nodes with given name."\\r\\n            },\\r\\n            {\\r\\n                "id": "ListenerCount",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "type", "type": "string" },\\r\\n                    { "name": "count", "type": "integer" }\\r\\n                ],\\r\\n                "description": "Number of JS event listeners by event type."\\r\\n            },\\r\\n            {\\r\\n                "id": "StringStatistics",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "dom", "type": "integer" },\\r\\n                    { "name": "js", "type": "integer" },\\r\\n                    { "name": "shared", "type": "integer" }\\r\\n                ],\\r\\n                "description": "Character data statistics for the page."\\r\\n            },\\r\\n            {\\r\\n                "id": "DOMGroup",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "size", "type": "integer" },\\r\\n                    { "name": "title", "type": "string" },\\r\\n                    { "name": "documentURI", "type": "string", "optional": true },\\r\\n                    { "name": "nodeCount", "type": "array", "items": { "$ref": "NodeCount" }},\\r\\n                    { "name": "listenerCount", "type": "array", "items": { "$ref": "ListenerCount" }}\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "MemoryBlock",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "size", "type": "number", "optional": true, "description": "Size of the block in bytes if available" },\\r\\n                    { "name": "name", "type": "string", "description": "Unique name used to identify the component that allocated this block" },\\r\\n                    { "name": "children", "type": "array", "optional": true, "items": { "$ref": "MemoryBlock" }}\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "HeapSnapshotChunk",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "strings", "type": "array", "items": { "type": "string" }, "description": "An array of strings that were found since last update." },\\r\\n                    { "name": "nodes", "type": "array", "items": { "type": "integer" }, "description": "An array of nodes that were found since last update." },\\r\\n                    { "name": "edges", "type": "array", "items": { "type": "integer" }, "description": "An array of edges that were found since last update." },\\r\\n                    { "name": "baseToRealNodeId", "type": "array", "items": { "type": "integer" }, "description": "An array of integers for nodeId remapping. Even nodeId has to be mapped to the following odd nodeId." }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "getDOMNodeCount",\\r\\n                "returns": [\\r\\n                    { "name": "domGroups", "type": "array", "items": { "$ref": "DOMGroup" }},\\r\\n                    { "name": "strings", "$ref": "StringStatistics" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "getDOMCounters",\\r\\n                "returns": [\\r\\n                    { "name": "documents", "type": "integer" },\\r\\n                    { "name": "nodes", "type": "integer" },\\r\\n                    { "name": "jsEventListeners", "type": "integer" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "getProcessMemoryDistribution",\\r\\n                "parameters": [\\r\\n                    { "name": "reportGraph", "type": "boolean", "optional": true, "description": "Whether native memory graph should be reported in addition to aggregated statistics." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "distribution", "$ref": "MemoryBlock", "description": "An object describing all memory allocated by the process"}\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "addNativeSnapshotChunk",\\r\\n                "parameters": [\\r\\n                    { "name": "chunk", "$ref": "HeapSnapshotChunk", "description": "A chunk of the serialized the snapshot." }\\r\\n                ]\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Page",\\r\\n        "description": "Actions and events related to the inspected page belong to the page domain.",\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "ResourceType",\\r\\n                "type": "string",\\r\\n                "enum": ["Document", "Stylesheet", "Image", "Font", "Script", "XHR", "WebSocket", "Other"],\\r\\n                "description": "Resource type as it was perceived by the rendering engine."\\r\\n            },\\r\\n            {\\r\\n                "id": "Frame",\\r\\n                "type": "object",\\r\\n                "description": "Information about the Frame on the page.",\\r\\n                "properties": [\\r\\n                    { "name": "id", "type": "string", "description": "Frame unique identifier." },\\r\\n                    { "name": "parentId", "type": "string", "optional": true, "description": "Parent frame identifier." },\\r\\n                    { "name": "loaderId", "$ref": "Network.LoaderId", "description": "Identifier of the loader associated with this frame." },\\r\\n                    { "name": "name", "type": "string", "optional": true, "description": "Frame\\\'s name as specified in the tag." },\\r\\n                    { "name": "url", "type": "string", "description": "Frame document\\\'s URL." },\\r\\n                    { "name": "securityOrigin", "type": "string", "optional": true, "description": "Frame document\\\'s security origin." },\\r\\n                    { "name": "mimeType", "type": "string", "description": "Frame document\\\'s mimeType as determined by the browser." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "id": "FrameResourceTree",\\r\\n                "type": "object",\\r\\n                "description": "Information about the Frame hierarchy along with their cached resources.",\\r\\n                "properties": [\\r\\n                    { "name": "frame", "$ref": "Frame", "description": "Frame information for this tree item." },\\r\\n                    { "name": "childFrames", "type": "array", "optional": true, "items": { "$ref": "FrameResourceTree" }, "description": "Child frames." },\\r\\n                    { "name": "resources", "type": "array",\\r\\n                        "items": {\\r\\n                            "type": "object",\\r\\n                            "properties": [\\r\\n                                { "name": "url", "type": "string", "description": "Resource URL." },\\r\\n                                { "name": "type", "$ref": "ResourceType", "description": "Type of this resource." },\\r\\n                                { "name": "mimeType", "type": "string", "description": "Resource mimeType as determined by the browser." },\\r\\n                                { "name": "failed", "type": "boolean", "optional": true, "description": "True if the resource failed to load." },\\r\\n                                { "name": "canceled", "type": "boolean", "optional": true, "description": "True if the resource was canceled during loading." }\\r\\n                            ]\\r\\n                        },\\r\\n                        "description": "Information about frame resources."\\r\\n                    }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "id": "SearchMatch",\\r\\n                "type": "object",\\r\\n                "description": "Search match for resource.",\\r\\n                "properties": [\\r\\n                    { "name": "lineNumber", "type": "number", "description": "Line number in resource content." },\\r\\n                    { "name": "lineContent", "type": "string", "description": "Line with match content." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "id": "SearchResult",\\r\\n                "type": "object",\\r\\n                "description": "Search result for resource.",\\r\\n                "properties": [\\r\\n                    { "name": "url", "type": "string", "description": "Resource URL." },\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Resource frame id." },\\r\\n                    { "name": "matchesCount", "type": "number", "description": "Number of matches in the resource content." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "id": "Cookie",\\r\\n                "type": "object",\\r\\n                "description": "Cookie object",\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "Cookie name." },\\r\\n                    { "name": "value", "type": "string", "description": "Cookie value." },\\r\\n                    { "name": "domain", "type": "string", "description": "Cookie domain." },\\r\\n                    { "name": "path", "type": "string", "description": "Cookie path." },\\r\\n                    { "name": "expires", "type": "number", "description": "Cookie expires." },\\r\\n                    { "name": "size", "type": "integer", "description": "Cookie size." },\\r\\n                    { "name": "httpOnly", "type": "boolean", "description": "True if cookie is http-only." },\\r\\n                    { "name": "secure", "type": "boolean", "description": "True if cookie is secure." },\\r\\n                    { "name": "session", "type": "boolean", "description": "True in case of session cookie." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "id": "ScriptIdentifier",\\r\\n                "type": "string",\\r\\n                "description": "Unique script identifier.",\\r\\n                "hidden": true\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables page domain notifications."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables page domain notifications."\\r\\n            },\\r\\n            {\\r\\n                "name": "addScriptToEvaluateOnLoad",\\r\\n                "parameters": [\\r\\n                    { "name": "scriptSource", "type": "string" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "identifier", "$ref": "ScriptIdentifier", "description": "Identifier of the added script." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "removeScriptToEvaluateOnLoad",\\r\\n                "parameters": [\\r\\n                    { "name": "identifier", "$ref": "ScriptIdentifier" }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "reload",\\r\\n                "parameters": [\\r\\n                    { "name": "ignoreCache", "type": "boolean", "optional": true, "description": "If true, browser cache is ignored (as if the user pressed Shift+refresh)." },\\r\\n                    { "name": "scriptToEvaluateOnLoad", "type": "string", "optional": true, "description": "If set, the script will be injected into all frames of the inspected page after reload." },\\r\\n                    { "name": "scriptPreprocessor", "type": "string", "optional": true, "description": "Script body that should evaluate to function that will preprocess all the scripts before their compilation.", "hidden": true }\\r\\n                ],\\r\\n                "description": "Reloads given page optionally ignoring the cache."\\r\\n            },\\r\\n            {\\r\\n                "name": "navigate",\\r\\n                "parameters": [\\r\\n                    { "name": "url", "type": "string", "description": "URL to navigate the page to." }\\r\\n                ],\\r\\n                "description": "Navigates current page to the given URL."\\r\\n            },\\r\\n            {\\r\\n                "name": "getCookies",\\r\\n                "returns": [\\r\\n                    { "name": "cookies", "type": "array", "items": { "$ref": "Cookie"}, "description": "Array of cookie objects." },\\r\\n                    { "name": "cookiesString", "type": "string", "description": "document.cookie string representation of the cookies." }\\r\\n                ],\\r\\n                "description": "Returns all browser cookies. Depending on the backend support, will either return detailed cookie information in the <code>cookie</code> field or string cookie representation using <code>cookieString</code>.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "deleteCookie",\\r\\n                "parameters": [\\r\\n                    { "name": "cookieName", "type": "string", "description": "Name of the cookie to remove." },\\r\\n                    { "name": "url", "type": "string", "description": "URL to match cooke domain and path." }\\r\\n                ],\\r\\n                "description": "Deletes browser cookie with given name, domain and path.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "getResourceTree",\\r\\n                "description": "Returns present frame / resource tree structure.",\\r\\n                "returns": [\\r\\n                    { "name": "frameTree", "$ref": "FrameResourceTree", "description": "Present frame / resource tree structure." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "getResourceContent",\\r\\n                "description": "Returns content of the given resource.",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Frame id to get resource for." },\\r\\n                    { "name": "url", "type": "string", "description": "URL of the resource to get content for." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "content", "type": "string", "description": "Resource content." },\\r\\n                    { "name": "base64Encoded", "type": "boolean", "description": "True, if content was served as base64." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "searchInResource",\\r\\n                "description": "Searches for given string in resource content.",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Frame id for resource to search in." },\\r\\n                    { "name": "url", "type": "string", "description": "URL of the resource to search in." },\\r\\n                    { "name": "query", "type": "string", "description": "String to search for."  },\\r\\n                    { "name": "caseSensitive", "type": "boolean", "optional": true, "description": "If true, search is case sensitive." },\\r\\n                    { "name": "isRegex", "type": "boolean", "optional": true, "description": "If true, treats string parameter as regex." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "array", "items": { "$ref": "SearchMatch" }, "description": "List of search matches." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "searchInResources",\\r\\n                "description": "Searches for given string in frame / resource tree structure.",\\r\\n                "parameters": [\\r\\n                    { "name": "text", "type": "string", "description": "String to search for."  },\\r\\n                    { "name": "caseSensitive", "type": "boolean", "optional": true, "description": "If true, search is case sensitive." },\\r\\n                    { "name": "isRegex", "type": "boolean", "optional": true, "description": "If true, treats string parameter as regex." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "array", "items": { "$ref": "SearchResult" }, "description": "List of search results." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "setDocumentContent",\\r\\n                "description": "Sets given markup as the document\\\'s HTML.",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Frame id to set HTML for." },\\r\\n                    { "name": "html", "type": "string", "description": "HTML content to set."  }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "canOverrideDeviceMetrics",\\r\\n                "description": "Checks whether <code>setDeviceMetricsOverride</code> can be invoked.",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean", "description": "If true, <code>setDeviceMetricsOverride</code> can safely be invoked on the agent." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "setDeviceMetricsOverride",\\r\\n                "description": "Overrides the values of device screen dimensions (window.screen.width, window.screen.height, window.innerWidth, window.innerHeight, and \\\\"device-width\\\\"/\\\\"device-height\\\\"-related CSS media query results) and the font scale factor.",\\r\\n                "parameters": [\\r\\n                    { "name": "width", "type": "integer", "description": "Overriding width value in pixels (minimum 0, maximum 10000000). 0 disables the override." },\\r\\n                    { "name": "height", "type": "integer", "description": "Overriding height value in pixels (minimum 0, maximum 10000000). 0 disables the override." },\\r\\n                    { "name": "fontScaleFactor", "type": "number", "description": "Overriding font scale factor value (must be positive). 1 disables the override." },\\r\\n                    { "name": "fitWindow", "type": "boolean", "description": "Whether a view that exceeds the available browser window area should be scaled down to fit." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "setShowPaintRects",\\r\\n                "description": "Requests that backend shows paint rectangles",\\r\\n                "parameters": [\\r\\n                    { "name": "result", "type": "boolean", "description": "True for showing paint rectangles" }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "canShowDebugBorders",\\r\\n                "description": "Tells if backend supports debug borders on layers",\\r\\n                "returns": [\\r\\n                    { "name": "show", "type": "boolean", "description": "True if the debug borders can be shown" }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "setShowDebugBorders",\\r\\n                "description": "Requests that backend shows debug borders on layers",\\r\\n                "parameters": [\\r\\n                    { "name": "show", "type": "boolean", "description": "True for showing debug borders" }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "canShowFPSCounter",\\r\\n                "description": "Tells if backend supports a FPS counter display",\\r\\n                "returns": [\\r\\n                    { "name": "show", "type": "boolean", "description": "True if the FPS count can be shown" }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "setShowFPSCounter",\\r\\n                "description": "Requests that backend shows the FPS counter",\\r\\n                "parameters": [\\r\\n                    { "name": "show", "type": "boolean", "description": "True for showing the FPS counter" }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "canContinuouslyPaint",\\r\\n                "description": "Tells if backend supports continuous painting",\\r\\n                "returns": [\\r\\n                    { "name": "value", "type": "boolean", "description": "True if continuous painting is available" }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "setContinuousPaintingEnabled",\\r\\n                "description": "Requests that backend enables continuous painting",\\r\\n                "parameters": [\\r\\n                    { "name": "enabled", "type": "boolean", "description": "True for enabling cointinuous painting" }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "getScriptExecutionStatus",\\r\\n                "description": "Determines if scripts can be executed in the page.",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "string", "enum": ["allowed", "disabled", "forbidden"], "description": "Script execution status: \\\\"allowed\\\\" if scripts can be executed, \\\\"disabled\\\\" if script execution has been disabled through page settings, \\\\"forbidden\\\\" if script execution for the given page is not possible for other reasons." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "setScriptExecutionDisabled",\\r\\n                "description": "Switches script execution in the page.",\\r\\n                "parameters": [\\r\\n                    { "name": "value", "type": "boolean", "description": "Whether script execution should be disabled in the page." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "setGeolocationOverride",\\r\\n                "description": "Overrides the Geolocation Position or Error.",\\r\\n                "parameters": [\\r\\n                    { "name": "latitude", "type": "number", "optional": true, "description": "Mock longitude"},\\r\\n                    { "name": "longitude", "type": "number", "optional": true, "description": "Mock latitude"},\\r\\n                    { "name": "accuracy", "type": "number", "optional": true, "description": "Mock accuracy"}\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "clearGeolocationOverride",\\r\\n                "description": "Clears the overriden Geolocation Position and Error.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "canOverrideGeolocation",\\r\\n                "description": "Checks if Geolocation can be overridden.",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean", "description": "True if browser can ovrride Geolocation." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "setDeviceOrientationOverride",\\r\\n                "description": "Overrides the Device Orientation.",\\r\\n                "parameters": [\\r\\n                    { "name": "alpha", "type": "number", "description": "Mock alpha"},\\r\\n                    { "name": "beta", "type": "number", "description": "Mock beta"},\\r\\n                    { "name": "gamma", "type": "number", "description": "Mock gamma"}\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "clearDeviceOrientationOverride",\\r\\n                "description": "Clears the overridden Device Orientation.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "canOverrideDeviceOrientation",\\r\\n                "description": "Check the backend if Web Inspector can override the device orientation.",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean", "description": "If true, <code>setDeviceOrientationOverride</code> can safely be invoked on the agent." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "setTouchEmulationEnabled",\\r\\n                "parameters": [\\r\\n                    { "name": "enabled", "type": "boolean", "description": "Whether the touch event emulation should be enabled." }\\r\\n                ],\\r\\n                "description": "Toggles mouse event-based touch event emulation.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "setEmulatedMedia",\\r\\n                "parameters": [\\r\\n                    { "name": "media", "type": "string", "description": "Media type to emulate. Empty string disables the override." }\\r\\n                ],\\r\\n                "description": "Emulates the given media for CSS media queries.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "getCompositingBordersVisible",\\r\\n                "description": "Indicates the visibility of compositing borders.",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean", "description": "If true, compositing borders are visible." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "setCompositingBordersVisible",\\r\\n                "description": "Controls the visibility of compositing borders.",\\r\\n                "parameters": [\\r\\n                    { "name": "visible", "type": "boolean", "description": "True for showing compositing borders." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "captureScreenshot",\\r\\n                "description": "Capture page screenshot.",\\r\\n                "returns": [\\r\\n                    { "name": "data", "type": "string", "description": "Base64-encoded image data (PNG)." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "handleJavaScriptDialog",\\r\\n                "description": "Accepts or dismisses a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload).",\\r\\n                "parameters": [\\r\\n                    { "name": "accept", "type": "boolean", "description": "Whether to accept or dismiss the dialog." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "domContentEventFired",\\r\\n                "parameters": [\\r\\n                    { "name": "timestamp", "type": "number" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "loadEventFired",\\r\\n                "parameters": [\\r\\n                    { "name": "timestamp", "type": "number" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "frameNavigated",\\r\\n                "description": "Fired once navigation of the frame has completed. Frame is now associated with the new loader.",\\r\\n                "parameters": [\\r\\n                    { "name": "frame", "$ref": "Frame", "description": "Frame object." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "frameDetached",\\r\\n                "description": "Fired when frame has been detached from its parent.",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Id of the frame that has been detached." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "frameStartedLoading",\\r\\n                "description": "Fired when frame has started loading.",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Id of the frame that has started loading." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "frameStoppedLoading",\\r\\n                "description": "Fired when frame has stopped loading.",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Id of the frame that has stopped loading." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "frameScheduledNavigation",\\r\\n                "description": "Fired when frame schedules a potential navigation.",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Id of the frame that has scheduled a navigation." },\\r\\n                    { "name": "delay", "type": "number", "description": "Delay (in seconds) until the navigation is scheduled to begin. The navigation is not guaranteed to start." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "frameClearedScheduledNavigation",\\r\\n                "description": "Fired when frame no longer has a scheduled navigation.",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Id of the frame that has cleared its scheduled navigation." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "javascriptDialogOpening",\\r\\n                "description": "Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) is about to open.",\\r\\n                "parameters": [\\r\\n                    { "name": "message", "type": "string", "description": "Message that will be displayed by the dialog." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "javascriptDialogClosed",\\r\\n                "description": "Fired when a JavaScript initiated dialog (alert, confirm, prompt, or onbeforeunload) has been closed.",\\r\\n                "hidden": true\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Runtime",\\r\\n        "description": "Runtime domain exposes JavaScript runtime by means of remote evaluation and mirror objects. Evaluation results are returned as mirror object that expose object type, string representation and unique identifier that can be used for further object reference. Original objects are maintained in memory unless they are either explicitly released or are released along with the other objects in their object group.",\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "RemoteObjectId",\\r\\n                "type": "string",\\r\\n                "description": "Unique object identifier."\\r\\n            },\\r\\n            {\\r\\n                "id": "RemoteObject",\\r\\n                "type": "object",\\r\\n                "description": "Mirror object referencing original JavaScript object.",\\r\\n                "properties": [\\r\\n                    { "name": "type", "type": "string", "enum": ["object", "function", "undefined", "string", "number", "boolean"], "description": "Object type." },\\r\\n                    { "name": "subtype", "type": "string", "optional": true, "enum": ["array", "null", "node", "regexp", "date"], "description": "Object subtype hint. Specified for <code>object</code> type values only." },\\r\\n                    { "name": "className", "type": "string", "optional": true, "description": "Object class (constructor) name. Specified for <code>object</code> type values only." },\\r\\n                    { "name": "value", "type": "any", "optional": true, "description": "Remote object value (in case of primitive values or JSON values if it was requested)." },\\r\\n                    { "name": "description", "type": "string", "optional": true, "description": "String representation of the object." },\\r\\n                    { "name": "objectId", "$ref": "RemoteObjectId", "optional": true, "description": "Unique object identifier (for non-primitive values)." },\\r\\n                    { "name": "preview", "$ref": "ObjectPreview", "optional": true, "description": "Preview containsing abbreviated property values.", "hidden": true }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "ObjectPreview",\\r\\n                "type": "object",\\r\\n                "hidden": true,\\r\\n                "description": "Object containing abbreviated remote object value.",\\r\\n                "properties": [\\r\\n                    { "name": "lossless", "type": "boolean", "description": "Determines whether preview is lossless (contains all information of the original object)." },\\r\\n                    { "name": "overflow", "type": "boolean", "description": "True iff some of the properties of the original did not fit." },\\r\\n                    { "name": "properties", "type": "array", "items": { "$ref": "PropertyPreview" }, "description": "List of the properties." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "PropertyPreview",\\r\\n                "type": "object",\\r\\n                "hidden": true,\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "Property name." },\\r\\n\\t                { "name": "type", "type": "string", "enum": ["object", "function", "undefined", "string", "number", "boolean"], "description": "Object type." },\\r\\n\\t                { "name": "value", "type": "string", "optional": true, "description": "User-friendly property value string." },\\r\\n\\t                { "name": "subtype", "type": "string", "optional": true, "enum": ["array", "null", "node", "regexp", "date"], "description": "Object subtype hint. Specified for <code>object</code> type values only." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "PropertyDescriptor",\\r\\n                "type": "object",\\r\\n                "description": "Object property descriptor.",\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "Property name." },\\r\\n                    { "name": "value", "$ref": "RemoteObject", "optional": true, "description": "The value associated with the property." },\\r\\n                    { "name": "writable", "type": "boolean", "optional": true, "description": "True if the value associated with the property may be changed (data descriptors only)." },\\r\\n                    { "name": "get", "$ref": "RemoteObject", "optional": true, "description": "A function which serves as a getter for the property, or <code>undefined</code> if there is no getter (accessor descriptors only)." },\\r\\n                    { "name": "set", "$ref": "RemoteObject", "optional": true, "description": "A function which serves as a setter for the property, or <code>undefined</code> if there is no setter (accessor descriptors only)." },\\r\\n                    { "name": "configurable", "type": "boolean", "description": "True if the type of this property descriptor may be changed and if the property may be deleted from the corresponding object." },\\r\\n                    { "name": "enumerable", "type": "boolean", "description": "True if this property shows up during enumeration of the properties on the corresponding object." },\\r\\n                    { "name": "wasThrown", "type": "boolean", "optional": true, "description": "True if the result was thrown during the evaluation." },\\r\\n                    { "name": "isOwn", "optional": true, "type": "boolean", "description": "True if the property is owned for the object." }\\r\\n\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "InternalPropertyDescriptor",\\r\\n                "type": "object",\\r\\n                "description": "Object internal property descriptor. This property isn\\\'t normally visible in JavaScript code.",\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "Conventional property name." },\\r\\n                    { "name": "value", "$ref": "RemoteObject", "optional": true, "description": "The value associated with the property." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "CallArgument",\\r\\n                "type": "object",\\r\\n                "description": "Represents function call argument. Either remote object id <code>objectId</code> or primitive <code>value</code> or neither of (for undefined) them should be specified.",\\r\\n                "properties": [\\r\\n                    { "name": "value", "type": "any", "optional": true, "description": "Primitive value." },\\r\\n                    { "name": "objectId", "$ref": "RemoteObjectId", "optional": true, "description": "Remote object handle." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "ExecutionContextId",\\r\\n                "type": "integer",\\r\\n                "description": "Id of an execution context.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "id": "ExecutionContextDescription",\\r\\n                "type": "object",\\r\\n                "description": "Description of an isolated world.",\\r\\n                "properties": [\\r\\n                    { "name": "id", "$ref": "ExecutionContextId", "description": "Unique id of the execution context. It can be used to specify in which execution context script evaluation should be performed." },\\r\\n                    { "name": "isPageContext", "type": "boolean", "description": "True if this is a context where inpspected web page scripts run. False if it is a content script isolated context." },\\r\\n                    { "name": "name", "type": "string", "description": "Human readable name describing given context." },\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Id of the owning frame." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            }\\r\\n\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "evaluate",\\r\\n                "parameters": [\\r\\n                    { "name": "expression", "type": "string", "description": "Expression to evaluate." },\\r\\n                    { "name": "objectGroup", "type": "string", "optional": true, "description": "Symbolic group name that can be used to release multiple objects." },\\r\\n                    { "name": "includeCommandLineAPI", "type": "boolean", "optional": true, "description": "Determines whether Command Line API should be available during the evaluation.", "hidden": true },\\r\\n                    { "name": "doNotPauseOnExceptionsAndMuteConsole", "type": "boolean", "optional": true, "description": "Specifies whether evaluation should stop on exceptions and mute console. Overrides setPauseOnException state.", "hidden": true },\\r\\n                    { "name": "contextId", "$ref": "Runtime.ExecutionContextId", "optional": true, "description": "Specifies in which isolated context to perform evaluation. Each content script lives in an isolated context and this parameter may be used to specify one of those contexts. If the parameter is omitted or 0 the evaluation will be performed in the context of the inspected page.", "hidden": true },\\r\\n                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object that should be sent by value." },\\r\\n                    { "name": "generatePreview", "type": "boolean", "optional": true, "hidden": true, "description": "Whether preview should be generated for the result." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "result", "$ref": "RemoteObject", "description": "Evaluation result." },\\r\\n                    { "name": "wasThrown", "type": "boolean", "optional": true, "description": "True if the result was thrown during the evaluation." }\\r\\n                ],\\r\\n                "description": "Evaluates expression on global object."\\r\\n            },\\r\\n            {\\r\\n                "name": "callFunctionOn",\\r\\n                "parameters": [\\r\\n                    { "name": "objectId", "$ref": "RemoteObjectId", "description": "Identifier of the object to call function on." },\\r\\n                    { "name": "functionDeclaration", "type": "string", "description": "Declaration of the function to call." },\\r\\n                    { "name": "arguments", "type": "array", "items": { "$ref": "CallArgument", "description": "Call argument." }, "optional": true, "description": "Call arguments. All call arguments must belong to the same JavaScript world as the target object." },\\r\\n                    { "name": "doNotPauseOnExceptionsAndMuteConsole", "type": "boolean", "optional": true, "description": "Specifies whether function call should stop on exceptions and mute console. Overrides setPauseOnException state.", "hidden": true },\\r\\n                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object which should be sent by value." },\\r\\n                    { "name": "generatePreview", "type": "boolean", "optional": true, "hidden": true, "description": "Whether preview should be generated for the result." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "result", "$ref": "RemoteObject", "description": "Call result." },\\r\\n                    { "name": "wasThrown", "type": "boolean", "optional": true, "description": "True if the result was thrown during the evaluation." }\\r\\n                ],\\r\\n                "description": "Calls function with given declaration on the given object. Object group of the result is inherited from the target object."\\r\\n            },\\r\\n            {\\r\\n                "name": "getProperties",\\r\\n                "parameters": [\\r\\n                    { "name": "objectId", "$ref": "RemoteObjectId", "description": "Identifier of the object to return properties for." },\\r\\n                    { "name": "ownProperties", "optional": true, "type": "boolean", "description": "If true, returns properties belonging only to the element itself, not to its prototype chain." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "array", "items": { "$ref": "PropertyDescriptor"}, "description": "Object properties." },\\r\\n                    { "name": "internalProperties", "optional": true, "type": "array", "items": { "$ref": "InternalPropertyDescriptor"}, "description": "Internal object properties." }\\r\\n                ],\\r\\n                "description": "Returns properties of a given object. Object group of the result is inherited from the target object."\\r\\n            },\\r\\n            {\\r\\n                "name": "releaseObject",\\r\\n                "parameters": [\\r\\n                    { "name": "objectId", "$ref": "RemoteObjectId", "description": "Identifier of the object to release." }\\r\\n                ],\\r\\n                "description": "Releases remote object with given id."\\r\\n            },\\r\\n            {\\r\\n                "name": "releaseObjectGroup",\\r\\n                "parameters": [\\r\\n                    { "name": "objectGroup", "type": "string", "description": "Symbolic object group name." }\\r\\n                ],\\r\\n                "description": "Releases all remote objects that belong to a given group."\\r\\n            },\\r\\n            {\\r\\n                "name": "run",\\r\\n                "hidden": true,\\r\\n                "description": "Tells inspected instance(worker or page) that it can run in case it was started paused."\\r\\n            },\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "hidden": true,\\r\\n                "description": "Enables reporting of execution contexts creation by means of <code>executionContextCreated</code> event. When the reporting gets enabled the event will be sent immediately for each existing execution context."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "hidden": true,\\r\\n                "description": "Disables reporting of execution contexts creation."\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "executionContextCreated",\\r\\n                "parameters": [\\r\\n                    { "name": "context", "$ref": "ExecutionContextDescription", "description": "A newly created execution contex." }\\r\\n                ],\\r\\n                "hidden": true,\\r\\n                "description": "Issued when new execution context is created."\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Console",\\r\\n        "description": "Console domain defines methods and events for interaction with the JavaScript console. Console collects messages created by means of the <a href=\\\'http://getfirebug.com/wiki/index.php/Console_API\\\'>JavaScript Console API</a>. One needs to enable this domain using <code>enable</code> command in order to start receiving the console messages. Browser collects messages issued while console domain is not enabled as well and reports them using <code>messageAdded</code> notification upon enabling.",\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "ConsoleMessage",\\r\\n                "type": "object",\\r\\n                "description": "Console message.",\\r\\n                "properties": [\\r\\n                    { "name": "source", "type": "string", "enum": ["html", "wml", "xml", "javascript", "network", "console-api", "other"], "description": "Message source." },\\r\\n                    { "name": "level", "type": "string", "enum": ["tip", "log", "warning", "error", "debug"], "description": "Message severity." },\\r\\n                    { "name": "text", "type": "string", "description": "Message text." },\\r\\n                    { "name": "type", "type": "string", "optional": true, "enum": ["log", "dir", "dirxml", "trace", "clear", "startGroup", "startGroupCollapsed", "endGroup", "assert", "timing"], "description": "Console message type." },\\r\\n                    { "name": "url", "type": "string", "optional": true, "description": "URL of the message origin." },\\r\\n                    { "name": "line", "type": "integer", "optional": true, "description": "Line number in the resource that generated this message." },\\r\\n                    { "name": "repeatCount", "type": "integer", "optional": true, "description": "Repeat count for repeated messages." },\\r\\n                    { "name": "parameters", "type": "array", "items": { "$ref": "Runtime.RemoteObject" }, "optional": true, "description": "Message parameters in case of the formatted message." },\\r\\n                    { "name": "stackTrace", "$ref": "StackTrace", "optional": true, "description": "JavaScript stack trace for assertions and error messages." },\\r\\n                    { "name": "networkRequestId", "$ref": "Network.RequestId", "optional": true, "description": "Identifier of the network request associated with this message." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "CallFrame",\\r\\n                "type": "object",\\r\\n                "description": "Stack entry for console errors and assertions.",\\r\\n                "properties": [\\r\\n                    { "name": "functionName", "type": "string", "description": "JavaScript function name." },\\r\\n                    { "name": "url", "type": "string", "description": "JavaScript script name or url." },\\r\\n                    { "name": "lineNumber", "type": "integer", "description": "JavaScript script line number." },\\r\\n                    { "name": "columnNumber", "type": "integer", "description": "JavaScript script column number." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "StackTrace",\\r\\n                "type": "array",\\r\\n                "items": { "$ref": "CallFrame" },\\r\\n                "description": "Call frames for assertions or error messages."\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables console domain, sends the messages collected so far to the client by means of the <code>messageAdded</code> notification."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables console domain, prevents further console messages from being reported to the client."\\r\\n            },\\r\\n            {\\r\\n                "name": "clearMessages",\\r\\n                "description": "Clears console messages collected in the browser."\\r\\n            },\\r\\n            {\\r\\n                "name": "setMonitoringXHREnabled",\\r\\n                "parameters": [\\r\\n                    { "name": "enabled", "type": "boolean", "description": "Monitoring enabled state." }\\r\\n                ],\\r\\n                "description": "Toggles monitoring of XMLHttpRequest. If <code>true</code>, console will receive messages upon each XHR issued.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "addInspectedNode",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "DOM.NodeId", "description": "DOM node id to be accessible by means of $x command line API." }\\r\\n                ],\\r\\n                "description": "Enables console to refer to the node with given id via $x (see Command Line API for more details $x functions).",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "addInspectedHeapObject",\\r\\n                "parameters": [\\r\\n                    { "name": "heapObjectId", "type": "integer" }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "messageAdded",\\r\\n                "parameters": [\\r\\n                    { "name": "message", "$ref": "ConsoleMessage", "description": "Console message that has been added." }\\r\\n                ],\\r\\n                "description": "Issued when new console message is added."\\r\\n            },\\r\\n            {\\r\\n                "name": "messageRepeatCountUpdated",\\r\\n                "parameters": [\\r\\n                    { "name": "count", "type": "integer", "description": "New repeat count value." }\\r\\n                ],\\r\\n                "description": "Issued when subsequent message(s) are equal to the previous one(s)."\\r\\n            },\\r\\n            {\\r\\n                "name": "messagesCleared",\\r\\n                "description": "Issued when console is cleared. This happens either upon <code>clearMessages</code> command or after page navigation."\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Network",\\r\\n        "description": "Network domain allows tracking network activities of the page. It exposes information about http, file, data and other requests and responses, their headers, bodies, timing, etc.",\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "LoaderId",\\r\\n                "type": "string",\\r\\n                "description": "Unique loader identifier."\\r\\n            },\\r\\n            {\\r\\n                "id": "FrameId",\\r\\n                "type": "string",\\r\\n                "description": "Unique frame identifier.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "id": "RequestId",\\r\\n                "type": "string",\\r\\n                "description": "Unique request identifier."\\r\\n            },\\r\\n            {\\r\\n                "id": "Timestamp",\\r\\n                "type": "number",\\r\\n                "description": "Number of seconds since epoch."\\r\\n            },\\r\\n            {\\r\\n                "id": "Headers",\\r\\n                "type": "object",\\r\\n                "description": "Request / response headers as keys / values of JSON object."\\r\\n            },\\r\\n            {\\r\\n                "id": "ResourceTiming",\\r\\n                "type": "object",\\r\\n                "description": "Timing information for the request.",\\r\\n                "properties": [\\r\\n                    { "name": "requestTime", "type": "number", "description": "Timing\\\'s requestTime is a baseline in seconds, while the other numbers are ticks in milliseconds relatively to this requestTime." },\\r\\n                    { "name": "proxyStart", "type": "number", "description": "Started resolving proxy." },\\r\\n                    { "name": "proxyEnd", "type": "number", "description": "Finished resolving proxy." },\\r\\n                    { "name": "dnsStart", "type": "number", "description": "Started DNS address resolve." },\\r\\n                    { "name": "dnsEnd", "type": "number", "description": "Finished DNS address resolve." },\\r\\n                    { "name": "connectStart", "type": "number", "description": "Started connecting to the remote host." },\\r\\n                    { "name": "connectEnd", "type": "number", "description": "Connected to the remote host." },\\r\\n                    { "name": "sslStart", "type": "number", "description": "Started SSL handshake." },\\r\\n                    { "name": "sslEnd", "type": "number", "description": "Finished SSL handshake." },\\r\\n                    { "name": "sendStart", "type": "number", "description": "Started sending request." },\\r\\n                    { "name": "sendEnd", "type": "number", "description": "Finished sending request." },\\r\\n                    { "name": "receiveHeadersEnd", "type": "number", "description": "Finished receiving response headers." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "Request",\\r\\n                "type": "object",\\r\\n                "description": "HTTP request data.",\\r\\n                "properties": [\\r\\n                    { "name": "url", "type": "string", "description": "Request URL." },\\r\\n                    { "name": "method", "type": "string", "description": "HTTP request method." },\\r\\n                    { "name": "headers", "$ref": "Headers", "description": "HTTP request headers." },\\r\\n                    { "name": "postData", "type": "string", "optional": true, "description": "HTTP POST request data." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "Response",\\r\\n                "type": "object",\\r\\n                "description": "HTTP response data.",\\r\\n                "properties": [\\r\\n                    { "name": "url", "type": "string", "description": "Response URL. This URL can be different from CachedResource.url in case of redirect." },\\r\\n                    { "name": "status", "type": "number", "description": "HTTP response status code." },\\r\\n                    { "name": "statusText", "type": "string", "description": "HTTP response status text." },\\r\\n                    { "name": "headers", "$ref": "Headers", "description": "HTTP response headers." },\\r\\n                    { "name": "headersText", "type": "string", "optional": true, "description": "HTTP response headers text." },\\r\\n                    { "name": "mimeType", "type": "string", "description": "Resource mimeType as determined by the browser." },\\r\\n                    { "name": "requestHeaders", "$ref": "Headers", "optional": true, "description": "Refined HTTP request headers that were actually transmitted over the network." },\\r\\n                    { "name": "requestHeadersText", "type": "string", "optional": true, "description": "HTTP request headers text." },\\r\\n                    { "name": "connectionReused", "type": "boolean", "description": "Specifies whether physical connection was actually reused for this request." },\\r\\n                    { "name": "connectionId", "type": "number", "description": "Physical connection id that was actually used for this request." },\\r\\n                    { "name": "fromDiskCache", "type": "boolean", "optional": true, "description": "Specifies that the request was served from the disk cache." },\\r\\n                    { "name": "timing", "$ref": "ResourceTiming", "optional": true, "description": "Timing information for the given request." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "WebSocketRequest",\\r\\n                "type": "object",\\r\\n                "description": "WebSocket request data.",\\r\\n                "hidden": true,\\r\\n                "properties": [\\r\\n                    { "name": "headers", "$ref": "Headers", "description": "HTTP response headers." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "WebSocketResponse",\\r\\n                "type": "object",\\r\\n                "description": "WebSocket response data.",\\r\\n                "hidden": true,\\r\\n                "properties": [\\r\\n                    { "name": "status", "type": "number", "description": "HTTP response status code." },\\r\\n                    { "name": "statusText", "type": "string", "description": "HTTP response status text." },\\r\\n                    { "name": "headers", "$ref": "Headers", "description": "HTTP response headers." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "WebSocketFrame",\\r\\n                "type": "object",\\r\\n                "description": "WebSocket frame data.",\\r\\n                "hidden": true,\\r\\n                "properties": [\\r\\n                    { "name": "opcode", "type": "number", "description": "WebSocket frame opcode." },\\r\\n                    { "name": "mask", "type": "boolean", "description": "WebSocke frame mask." },\\r\\n                    { "name": "payloadData", "type": "string", "description": "WebSocke frame payload data." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "CachedResource",\\r\\n                "type": "object",\\r\\n                "description": "Information about the cached resource.",\\r\\n                "properties": [\\r\\n                    { "name": "url", "type": "string", "description": "Resource URL. This is the url of the original network request." },\\r\\n                    { "name": "type", "$ref": "Page.ResourceType", "description": "Type of this resource." },\\r\\n                    { "name": "response", "$ref": "Response", "optional": true, "description": "Cached response data." },\\r\\n                    { "name": "bodySize", "type": "number", "description": "Cached response body size." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "Initiator",\\r\\n                "type": "object",\\r\\n                "description": "Information about the request initiator.",\\r\\n                "properties": [\\r\\n                    { "name": "type", "type": "string", "enum": ["parser", "script", "other"], "description": "Type of this initiator." },\\r\\n                    { "name": "stackTrace", "$ref": "Console.StackTrace", "optional": true, "description": "Initiator JavaScript stack trace, set for Script only." },\\r\\n                    { "name": "url", "type": "string", "optional": true, "description": "Initiator URL, set for Parser type only." },\\r\\n                    { "name": "lineNumber", "type": "number", "optional": true, "description": "Initiator line number, set for Parser type only." }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables network tracking, network events will now be delivered to the client."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables network tracking, prevents network events from being sent to the client."\\r\\n            },\\r\\n            {\\r\\n                "name": "setUserAgentOverride",\\r\\n                "description": "Allows overriding user agent with the given string.",\\r\\n                "parameters": [\\r\\n                    { "name": "userAgent", "type": "string", "description": "User agent to use." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "setExtraHTTPHeaders",\\r\\n                "description": "Specifies whether to always send extra HTTP headers with the requests from this page.",\\r\\n                "parameters": [\\r\\n                    { "name": "headers", "$ref": "Headers", "description": "Map with extra HTTP headers." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "getResponseBody",\\r\\n                "description": "Returns content served for the given request.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Identifier of the network request to get content for." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "body", "type": "string", "description": "Response body." },\\r\\n                    { "name": "base64Encoded", "type": "boolean", "description": "True, if content was sent as base64." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "replayXHR",\\r\\n                "description": "This method sends a new XMLHttpRequest which is identical to the original one. The following parameters should be identical: method, url, async, request body, extra headers, withCredentials attribute, user, password.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Identifier of XHR to replay." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "canClearBrowserCache",\\r\\n                "description": "Tells whether clearing browser cache is supported.",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean", "description": "True if browser cache can be cleared." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "clearBrowserCache",\\r\\n                "description": "Clears browser cache."\\r\\n            },\\r\\n            {\\r\\n                "name": "canClearBrowserCookies",\\r\\n                "description": "Tells whether clearing browser cookies is supported.",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean", "description": "True if browser cookies can be cleared." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "clearBrowserCookies",\\r\\n                "description": "Clears browser cookies."\\r\\n            },\\r\\n            {\\r\\n                "name": "setCacheDisabled",\\r\\n                "parameters": [\\r\\n                    { "name": "cacheDisabled", "type": "boolean", "description": "Cache disabled state." }\\r\\n                ],\\r\\n                "description": "Toggles ignoring cache for each request. If <code>true</code>, cache will not be used."\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "requestWillBeSent",\\r\\n                "description": "Fired when page is about to send HTTP request.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "frameId", "$ref": "FrameId", "description": "Frame identifier.", "hidden": true },\\r\\n                    { "name": "loaderId", "$ref": "LoaderId", "description": "Loader identifier." },\\r\\n                    { "name": "documentURL", "type": "string", "description": "URL of the document this request is loaded for." },\\r\\n                    { "name": "request", "$ref": "Request", "description": "Request data." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." },\\r\\n                    { "name": "initiator", "$ref": "Initiator", "description": "Request initiator." },\\r\\n                    { "name": "redirectResponse", "optional": true, "$ref": "Response", "description": "Redirect response data." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "requestServedFromCache",\\r\\n                "description": "Fired if request ended up loading from cache.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "responseReceived",\\r\\n                "description": "Fired when HTTP response is available.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "frameId", "$ref": "FrameId", "description": "Frame identifier.", "hidden": true },\\r\\n                    { "name": "loaderId", "$ref": "LoaderId", "description": "Loader identifier." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." },\\r\\n                    { "name": "type", "$ref": "Page.ResourceType", "description": "Resource type." },\\r\\n                    { "name": "response", "$ref": "Response", "description": "Response data." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "dataReceived",\\r\\n                "description": "Fired when data chunk was received over the network.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." },\\r\\n                    { "name": "dataLength", "type": "integer", "description": "Data chunk length." },\\r\\n                    { "name": "encodedDataLength", "type": "integer", "description": "Actual bytes received (might be less than dataLength for compressed encodings)." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "loadingFinished",\\r\\n                "description": "Fired when HTTP request has finished loading.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "loadingFailed",\\r\\n                "description": "Fired when HTTP request has failed to load.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." },\\r\\n                    { "name": "errorText", "type": "string", "description": "User friendly error message." },\\r\\n                    { "name": "canceled", "type": "boolean", "optional": true, "description": "True if loading was canceled." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "requestServedFromMemoryCache",\\r\\n                "description": "Fired when HTTP request has been served from memory cache.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "frameId", "$ref": "FrameId", "description": "Frame identifier.", "hidden": true },\\r\\n                    { "name": "loaderId", "$ref": "LoaderId", "description": "Loader identifier." },\\r\\n                    { "name": "documentURL", "type": "string", "description": "URL of the document this request is loaded for." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." },\\r\\n                    { "name": "initiator", "$ref": "Initiator", "description": "Request initiator." },\\r\\n                    { "name": "resource", "$ref": "CachedResource", "description": "Cached resource data." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "webSocketWillSendHandshakeRequest",\\r\\n                "description": "Fired when WebSocket is about to initiate handshake.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." },\\r\\n                    { "name": "request", "$ref": "WebSocketRequest", "description": "WebSocket request data." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "webSocketHandshakeResponseReceived",\\r\\n                "description": "Fired when WebSocket handshake response becomes available.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." },\\r\\n                    { "name": "response", "$ref": "WebSocketResponse", "description": "WebSocket response data." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "webSocketCreated",\\r\\n                "description": "Fired upon WebSocket creation.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "url", "type": "string", "description": "WebSocket request URL." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "webSocketClosed",\\r\\n                "description": "Fired when WebSocket is closed.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "webSocketFrameReceived",\\r\\n                "description": "Fired when WebSocket frame is received.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." },\\r\\n                    { "name": "response", "$ref": "WebSocketFrame", "description": "WebSocket response data." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "webSocketFrameError",\\r\\n                "description": "Fired when WebSocket frame error occurs.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." },\\r\\n                    { "name": "errorMessage", "type": "string", "description": "WebSocket frame error message." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "webSocketFrameSent",\\r\\n                "description": "Fired when WebSocket frame is sent.",\\r\\n                "parameters": [\\r\\n                    { "name": "requestId", "$ref": "RequestId", "description": "Request identifier." },\\r\\n                    { "name": "timestamp", "$ref": "Timestamp", "description": "Timestamp." },\\r\\n                    { "name": "response", "$ref": "WebSocketFrame", "description": "WebSocket response data." }\\r\\n                ],\\r\\n                "hidden": true\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Database",\\r\\n        "hidden": true,\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "DatabaseId",\\r\\n                "type": "string",\\r\\n                "description": "Unique identifier of Database object.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "id": "Database",\\r\\n                "type": "object",\\r\\n                "description": "Database object.",\\r\\n                "hidden": true,\\r\\n                "properties": [\\r\\n                    { "name": "id", "$ref": "DatabaseId", "description": "Database ID." },\\r\\n                    { "name": "domain", "type": "string", "description": "Database domain." },\\r\\n                    { "name": "name", "type": "string", "description": "Database name." },\\r\\n                    { "name": "version", "type": "string", "description": "Database version." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "Error",\\r\\n                "type": "object",\\r\\n                "description": "Database error.",\\r\\n                "properties": [\\r\\n                    { "name": "message", "type": "string", "description": "Error message." },\\r\\n                    { "name": "code", "type": "integer", "description": "Error code." }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables database tracking, database events will now be delivered to the client."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables database tracking, prevents database events from being sent to the client."\\r\\n            },\\r\\n            {\\r\\n                "name": "getDatabaseTableNames",\\r\\n                "parameters": [\\r\\n                    { "name": "databaseId", "$ref": "DatabaseId" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "tableNames", "type": "array", "items": { "type": "string" } }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "executeSQL",\\r\\n                "async": true,\\r\\n                "parameters": [\\r\\n                    { "name": "databaseId", "$ref": "DatabaseId" },\\r\\n                    { "name": "query", "type": "string" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "columnNames", "type": "array", "optional": true, "items": { "type": "string" } },\\r\\n                    { "name": "values", "type": "array", "optional": true, "items": { "type": "any" }},\\r\\n                    { "name": "sqlError", "$ref": "Error", "optional": true }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "addDatabase",\\r\\n                "parameters": [\\r\\n                    { "name": "database", "$ref": "Database" }\\r\\n                ]\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "IndexedDB",\\r\\n        "hidden": true,\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "SecurityOriginWithDatabaseNames",\\r\\n                "type": "object",\\r\\n                "description": "Security origin with database names.",\\r\\n                "properties": [\\r\\n                    { "name": "securityOrigin", "type": "string", "description": "Security origin." },\\r\\n                    { "name": "databaseNames", "type": "array", "items": { "type": "string" }, "description": "Database names for this origin." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "DatabaseWithObjectStores",\\r\\n                "type": "object",\\r\\n                "description": "Database with an array of object stores.",\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "Database name." },\\r\\n                    { "name": "version", "type": "string", "description": "Deprecated string database version." },\\r\\n                    { "name": "intVersion", "type": "integer", "description": "Integer database version." },\\r\\n                    { "name": "objectStores", "type": "array", "items": { "$ref": "ObjectStore" }, "description": "Object stores in this database." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "ObjectStore",\\r\\n                "type": "object",\\r\\n                "description": "Object store.",\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "Object store name." },\\r\\n                    { "name": "keyPath", "$ref": "KeyPath", "description": "Object store key path." },\\r\\n                    { "name": "autoIncrement", "type": "boolean", "description": "If true, object store has auto increment flag set." },\\r\\n                    { "name": "indexes", "type": "array", "items": { "$ref": "ObjectStoreIndex" }, "description": "Indexes in this object store." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "ObjectStoreIndex",\\r\\n                "type": "object",\\r\\n                "description": "Object store index.",\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "Index name." },\\r\\n                    { "name": "keyPath", "$ref": "KeyPath", "description": "Index key path." },\\r\\n                    { "name": "unique", "type": "boolean", "description": "If true, index is unique." },\\r\\n                    { "name": "multiEntry", "type": "boolean", "description": "If true, index allows multiple entries for a key." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "Key",\\r\\n                "type": "object",\\r\\n                "description": "Key.",\\r\\n                "properties": [\\r\\n                    { "name": "type", "type": "string", "enum": ["number", "string", "date", "array"], "description": "Key type." },\\r\\n                    { "name": "number", "type": "number", "optional": true, "description": "Number value." },\\r\\n                    { "name": "string", "type": "string", "optional": true, "description": "String value." },\\r\\n                    { "name": "date", "type": "number", "optional": true, "description": "Date value." },\\r\\n                    { "name": "array", "type": "array", "optional": true, "items": { "$ref": "Key" }, "description": "Array value." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "KeyRange",\\r\\n                "type": "object",\\r\\n                "description": "Key range.",\\r\\n                "properties": [\\r\\n                    { "name": "lower", "$ref": "Key", "optional": true, "description": "Lower bound." },\\r\\n                    { "name": "upper", "$ref": "Key", "optional": true, "description": "Upper bound." },\\r\\n                    { "name": "lowerOpen", "type": "boolean", "description": "If true lower bound is open." },\\r\\n                    { "name": "upperOpen", "type": "boolean", "description": "If true upper bound is open." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "DataEntry",\\r\\n                "type": "object",\\r\\n                "description": "Data entry.",\\r\\n                "properties": [\\r\\n                    { "name": "key", "$ref": "Runtime.RemoteObject", "description": "Key." },\\r\\n                    { "name": "primaryKey", "$ref": "Runtime.RemoteObject", "description": "Primary key." },\\r\\n                    { "name": "value", "$ref": "Runtime.RemoteObject", "description": "Value." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "KeyPath",\\r\\n                "type": "object",\\r\\n                "description": "Key path.",\\r\\n                "properties": [\\r\\n                    { "name": "type", "type": "string", "enum": ["null", "string", "array"], "description": "Key path type." },\\r\\n                    { "name": "string", "type": "string", "optional": true, "description": "String value." },\\r\\n                    { "name": "array", "type": "array", "optional": true, "items": { "type": "string" }, "description": "Array value." }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables events from backend."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables events from backend."\\r\\n            },\\r\\n            {\\r\\n                "name": "requestDatabaseNamesForFrame",\\r\\n                "async": true,\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Frame id." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "securityOriginWithDatabaseNames", "$ref": "SecurityOriginWithDatabaseNames", "description": "Frame with database names." }\\r\\n                ],\\r\\n                "description": "Requests database names for given frame\\\'s security origin."\\r\\n            },\\r\\n            {\\r\\n                "name": "requestDatabase",\\r\\n                "async": true,\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Frame id." },\\r\\n                    { "name": "databaseName", "type": "string", "description": "Database name." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "databaseWithObjectStores", "$ref": "DatabaseWithObjectStores", "description": "Database with an array of object stores." }\\r\\n                ],\\r\\n                "description": "Requests database with given name in given frame."\\r\\n            },\\r\\n            {\\r\\n                "name": "requestData",\\r\\n                "async": true,\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Frame id." },\\r\\n                    { "name": "databaseName", "type": "string", "description": "Database name." },\\r\\n                    { "name": "objectStoreName", "type": "string", "description": "Object store name." },\\r\\n                    { "name": "indexName", "type": "string", "description": "Index name, empty string for object store data requests." },\\r\\n                    { "name": "skipCount", "type": "integer", "description": "Number of records to skip." },\\r\\n                    { "name": "pageSize", "type": "integer", "description": "Number of records to fetch." },\\r\\n                    { "name": "keyRange", "$ref": "KeyRange", "optional": true, "description": "Key range." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "objectStoreDataEntries", "type": "array", "items": { "$ref": "DataEntry" }, "description": "Array of object store data entries." },\\r\\n                    { "name": "hasMore", "type": "boolean", "description": "If true, there are more entries to fetch in the given range." }\\r\\n                ],\\r\\n                "description": "Requests data from object store or index."\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "DOMStorage",\\r\\n        "hidden": true,\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "StorageId",\\r\\n                "type": "string",\\r\\n                "description": "Unique identifier of DOM storage entry.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "id": "Entry",\\r\\n                "type": "object",\\r\\n                "description": "DOM Storage entry.",\\r\\n                "hidden": true,\\r\\n                "properties": [\\r\\n                    { "name": "origin", "type": "string", "description": "Document origin." },\\r\\n                    { "name": "isLocalStorage", "type": "boolean", "description": "True for local storage." },\\r\\n                    { "name": "id", "$ref": "StorageId", "description": "Entry id for further reference." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "Item",\\r\\n                "type": "array",\\r\\n                "description": "DOM Storage item.",\\r\\n                "hidden": true,\\r\\n                "items": { "type": "string" }\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables storage tracking, storage events will now be delivered to the client."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables storage tracking, prevents storage events from being sent to the client."\\r\\n            },\\r\\n            {\\r\\n                "name": "getDOMStorageEntries",\\r\\n                "parameters": [\\r\\n                    { "name": "storageId", "$ref": "StorageId" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "entries", "type": "array", "items": { "$ref": "Item" } }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "setDOMStorageItem",\\r\\n                "parameters": [\\r\\n                    { "name": "storageId", "$ref": "StorageId" },\\r\\n                    { "name": "key", "type": "string" },\\r\\n                    { "name": "value", "type": "string" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "success", "type": "boolean" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "removeDOMStorageItem",\\r\\n                "parameters": [\\r\\n                    { "name": "storageId", "$ref": "StorageId" },\\r\\n                    { "name": "key", "type": "string" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "success", "type": "boolean" }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "addDOMStorage",\\r\\n                "parameters": [\\r\\n                    { "name": "storage", "$ref": "Entry" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "domStorageItemsCleared",\\r\\n                "parameters": [\\r\\n                    { "name": "storageId",  "$ref": "StorageId" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "domStorageItemRemoved",\\r\\n                "parameters": [\\r\\n                    { "name": "storageId",  "$ref": "StorageId" },\\r\\n                    { "name": "key", "type": "string" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "domStorageItemAdded",\\r\\n                "parameters": [\\r\\n                    { "name": "storageId",  "$ref": "StorageId" },\\r\\n                    { "name": "key", "type": "string" },\\r\\n                    { "name": "newValue", "type": "string" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "domStorageItemUpdated",\\r\\n                "parameters": [\\r\\n                    { "name": "storageId",  "$ref": "StorageId" },\\r\\n                    { "name": "key", "type": "string" },\\r\\n                    { "name": "oldValue", "type": "string" },\\r\\n                    { "name": "newValue", "type": "string" }\\r\\n                ]\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "ApplicationCache",\\r\\n        "hidden": true,\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "ApplicationCacheResource",\\r\\n                "type": "object",\\r\\n                "description": "Detailed application cache resource information.",\\r\\n                "properties": [\\r\\n                    { "name": "url", "type": "string", "description": "Resource url." },\\r\\n                    { "name": "size", "type": "integer", "description": "Resource size." },\\r\\n                    { "name": "type", "type": "string", "description": "Resource type." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "ApplicationCache",\\r\\n                "type": "object",\\r\\n                "description": "Detailed application cache information.",\\r\\n                "properties": [\\r\\n                    { "name": "manifestURL", "type": "string", "description": "Manifest URL." },\\r\\n                    { "name": "size", "type": "number", "description": "Application cache size." },\\r\\n                    { "name": "creationTime", "type": "number", "description": "Application cache creation time." },\\r\\n                    { "name": "updateTime", "type": "number", "description": "Application cache update time." },\\r\\n                    { "name": "resources", "type": "array", "items": { "$ref": "ApplicationCacheResource" }, "description": "Application cache resources." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "FrameWithManifest",\\r\\n                "type": "object",\\r\\n                "description": "Frame identifier - manifest URL pair.",\\r\\n                "properties": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Frame identifier." },\\r\\n                    { "name": "manifestURL", "type": "string", "description": "Manifest URL." },\\r\\n                    { "name": "status", "type": "integer", "description": "Application cache status." }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "getFramesWithManifests",\\r\\n                "returns": [\\r\\n                    { "name": "frameIds", "type": "array", "items": { "$ref": "FrameWithManifest" }, "description": "Array of frame identifiers with manifest urls for each frame containing a document associated with some application cache." }\\r\\n                ],\\r\\n                "description": "Returns array of frame identifiers with manifest urls for each frame containing a document associated with some application cache."\\r\\n            },\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables application cache domain notifications."\\r\\n            },\\r\\n            {\\r\\n                "name": "getManifestForFrame",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Identifier of the frame containing document whose manifest is retrieved." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "manifestURL", "type": "string", "description": "Manifest URL for document in the given frame." }\\r\\n                ],\\r\\n                "description": "Returns manifest URL for document in the given frame."\\r\\n            },\\r\\n            {\\r\\n                "name": "getApplicationCacheForFrame",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Identifier of the frame containing document whose application cache is retrieved." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "applicationCache", "$ref": "ApplicationCache", "description": "Relevant application cache data for the document in given frame." }\\r\\n                ],\\r\\n                "description": "Returns relevant application cache data for the document in given frame."\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "applicationCacheStatusUpdated",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Identifier of the frame containing document whose application cache updated status." },\\r\\n                    { "name": "manifestURL", "type": "string", "description": "Manifest URL." },\\r\\n                    { "name": "status", "type": "integer", "description": "Updated application cache status." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "networkStateUpdated",\\r\\n                "parameters": [\\r\\n                    { "name": "isNowOnline", "type": "boolean" }\\r\\n                ]\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "FileSystem",\\r\\n        "hidden": true,\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "Entry",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "url", "type": "string", "description": "filesystem: URL for the entry." },\\r\\n                    { "name": "name", "type": "string", "description": "The name of the file or directory." },\\r\\n                    { "name": "isDirectory", "type": "boolean", "description": "True if the entry is a directory." },\\r\\n                    { "name": "mimeType", "type": "string", "optional": true, "description": "MIME type of the entry, available for a file only." },\\r\\n                    { "name": "resourceType", "$ref": "Page.ResourceType", "optional": true, "description": "ResourceType of the entry, available for a file only." },\\r\\n                    { "name": "isTextFile", "type": "boolean", "optional": true, "description": "True if the entry is a text file." }\\r\\n                ],\\r\\n                "description": "Represents a browser side file or directory."\\r\\n            },\\r\\n            {\\r\\n                "id": "Metadata",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "modificationTime", "type": "number", "description": "Modification time." },\\r\\n                    { "name": "size", "type": "number", "description": "File size. This field is always zero for directories." }\\r\\n                ],\\r\\n                "description": "Represents metadata of a file or entry."\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables events from backend."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables events from backend."\\r\\n            },\\r\\n            {\\r\\n                "name": "requestFileSystemRoot",\\r\\n                "async": true,\\r\\n                "parameters": [\\r\\n                    { "name": "origin", "type": "string", "description": "Security origin of requesting FileSystem. One of frames in current page needs to have this security origin." },\\r\\n                    { "name": "type", "type": "string", "enum": ["temporary", "persistent"], "description": "FileSystem type of requesting FileSystem." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "errorCode", "type": "integer", "description": "0, if no error. Otherwise, errorCode is set to FileError::ErrorCode value." },\\r\\n                    { "name": "root", "$ref": "Entry", "optional": true, "description": "Contains root of the requested FileSystem if the command completed successfully." }\\r\\n                ],\\r\\n                "description": "Returns root directory of the FileSystem, if exists."\\r\\n            },\\r\\n            {\\r\\n                "name": "requestDirectoryContent",\\r\\n                "async": true,\\r\\n                "parameters": [\\r\\n                    { "name": "url", "type": "string", "description": "URL of the directory that the frontend is requesting to read from." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "errorCode", "type": "integer", "description": "0, if no error. Otherwise, errorCode is set to FileError::ErrorCode value." },\\r\\n                    { "name": "entries", "type": "array", "items": { "$ref": "Entry" }, "optional": true, "description": "Contains all entries on directory if the command completed successfully." }\\r\\n                ],\\r\\n                "description": "Returns content of the directory."\\r\\n            },\\r\\n            {\\r\\n                "name": "requestMetadata",\\r\\n                "async": true,\\r\\n                "parameters": [\\r\\n                    { "name": "url", "type": "string", "description": "URL of the entry that the frontend is requesting to get metadata from." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "errorCode", "type": "integer", "description": "0, if no error. Otherwise, errorCode is set to FileError::ErrorCode value." },\\r\\n                    { "name": "metadata", "$ref": "Metadata", "optional": true, "description": "Contains metadata of the entry if the command completed successfully." }\\r\\n                ],\\r\\n                "description": "Returns metadata of the entry."\\r\\n            },\\r\\n            {\\r\\n                "name": "requestFileContent",\\r\\n                "async": true,\\r\\n                "parameters": [\\r\\n                    { "name": "url", "type": "string", "description": "URL of the file that the frontend is requesting to read from." },\\r\\n                    { "name": "readAsText", "type": "boolean", "description": "True if the content should be read as text, otherwise the result will be returned as base64 encoded text." },\\r\\n                    { "name": "start", "type": "integer", "optional": true, "description": "Specifies the start of range to read." },\\r\\n                    { "name": "end", "type": "integer", "optional": true, "description": "Specifies the end of range to read exclusively." },\\r\\n                    { "name": "charset", "type": "string", "optional": true, "description": "Overrides charset of the content when content is served as text." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "errorCode", "type": "integer", "description": "0, if no error. Otherwise, errorCode is set to FileError::ErrorCode value." },\\r\\n                    { "name": "content", "type": "string", "optional": true, "description": "Content of the file." },\\r\\n                    { "name": "charset", "type": "string", "optional": true, "description": "Charset of the content if it is served as text." }\\r\\n                ],\\r\\n                "description": "Returns content of the file. Result should be sliced into [start, end)."\\r\\n            },\\r\\n            {\\r\\n                "name": "deleteEntry",\\r\\n                "async": true,\\r\\n                "parameters": [\\r\\n                    { "name": "url", "type": "string", "description": "URL of the entry to delete." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "errorCode", "type": "integer", "description": "0, if no error. Otherwise errorCode is set to FileError::ErrorCode value." }\\r\\n                ],\\r\\n                "description": "Deletes specified entry. If the entry is a directory, the agent deletes children recursively."\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "DOM",\\r\\n        "description": "This domain exposes DOM read/write operations. Each DOM Node is represented with its mirror object that has an <code>id</code>. This <code>id</code> can be used to get additional information on the Node, resolve it into the JavaScript object wrapper, etc. It is important that client receives DOM events only for the nodes that are known to the client. Backend keeps track of the nodes that were sent to the client and never sends the same node twice. It is client\\\'s responsibility to collect information about the nodes that were sent to the client.<p>Note that <code>iframe</code> owner elements will return corresponding document elements as their child nodes.</p>",\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "NodeId",\\r\\n                "type": "integer",\\r\\n                "description": "Unique DOM node identifier."\\r\\n            },\\r\\n            {\\r\\n                "id": "Node",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Node identifier that is passed into the rest of the DOM messages as the <code>nodeId</code>. Backend will only push node with given <code>id</code> once. It is aware of all requested nodes and will only fire DOM events for nodes known to the client." },\\r\\n                    { "name": "nodeType", "type": "integer", "description": "<code>Node</code>\\\'s nodeType." },\\r\\n                    { "name": "nodeName", "type": "string", "description": "<code>Node</code>\\\'s nodeName." },\\r\\n                    { "name": "localName", "type": "string", "description": "<code>Node</code>\\\'s localName." },\\r\\n                    { "name": "nodeValue", "type": "string", "description": "<code>Node</code>\\\'s nodeValue." },\\r\\n                    { "name": "childNodeCount", "type": "integer", "optional": true, "description": "Child count for <code>Container</code> nodes." },\\r\\n                    { "name": "children", "type": "array", "optional": true, "items": { "$ref": "Node" }, "description": "Child nodes of this node when requested with children." },\\r\\n                    { "name": "attributes", "type": "array", "optional": true, "items": { "type": "string" }, "description": "Attributes of the <code>Element</code> node in the form of flat array <code>[name1, value1, name2, value2]</code>." },\\r\\n                    { "name": "documentURL", "type": "string", "optional": true, "description": "Document URL that <code>Document</code> or <code>FrameOwner</code> node points to." },\\r\\n                    { "name": "baseURL", "type": "string", "optional": true, "description": "Base URL that <code>Document</code> or <code>FrameOwner</code> node uses for URL completion." },\\r\\n                    { "name": "publicId", "type": "string", "optional": true, "description": "<code>DocumentType</code>\\\'s publicId." },\\r\\n                    { "name": "systemId", "type": "string", "optional": true, "description": "<code>DocumentType</code>\\\'s systemId." },\\r\\n                    { "name": "internalSubset", "type": "string", "optional": true, "description": "<code>DocumentType</code>\\\'s internalSubset." },\\r\\n                    { "name": "xmlVersion", "type": "string", "optional": true, "description": "<code>Document</code>\\\'s XML version in case of XML documents." },\\r\\n                    { "name": "name", "type": "string", "optional": true, "description": "<code>Attr</code>\\\'s name." },\\r\\n                    { "name": "value", "type": "string", "optional": true, "description": "<code>Attr</code>\\\'s value." },\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "optional": true, "description": "Frame ID for frame owner elements." },\\r\\n                    { "name": "contentDocument", "$ref": "Node", "optional": true, "description": "Content document for frame owner elements." },\\r\\n                    { "name": "shadowRoots", "type": "array", "optional": true, "items": { "$ref": "Node" }, "description": "Shadow root list for given element host." },\\r\\n                    { "name": "templateContent", "$ref": "Node", "optional": true, "description": "Content document fragment for template elements" }\\r\\n                ],\\r\\n                "description": "DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type."\\r\\n            },\\r\\n            {\\r\\n                "id": "EventListener",\\r\\n                "type": "object",\\r\\n                "hidden": true,\\r\\n                "properties": [\\r\\n                    { "name": "type", "type": "string", "description": "<code>EventListener</code>\\\'s type." },\\r\\n                    { "name": "useCapture", "type": "boolean", "description": "<code>EventListener</code>\\\'s useCapture." },\\r\\n                    { "name": "isAttribute", "type": "boolean", "description": "<code>EventListener</code>\\\'s isAttribute." },\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Target <code>DOMNode</code> id." },\\r\\n                    { "name": "handlerBody", "type": "string", "description": "Event handler function body." },\\r\\n                    { "name": "location", "$ref": "Debugger.Location", "optional": true, "description": "Handler code location." },\\r\\n                    { "name": "sourceName", "type": "string", "optional": true, "description": "Source script URL." }\\r\\n                ],\\r\\n                "description": "DOM interaction is implemented in terms of mirror objects that represent the actual DOM nodes. DOMNode is a base node mirror type."\\r\\n            },\\r\\n            {\\r\\n                "id": "RGBA",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "r", "type": "integer", "description": "The red component, in the [0-255] range." },\\r\\n                    { "name": "g", "type": "integer", "description": "The green component, in the [0-255] range." },\\r\\n                    { "name": "b", "type": "integer", "description": "The blue component, in the [0-255] range." },\\r\\n                    { "name": "a", "type": "number", "optional": true, "description": "The alpha component, in the [0-1] range (default: 1)." }\\r\\n                ],\\r\\n                "description": "A structure holding an RGBA color."\\r\\n            },\\r\\n            {\\r\\n                "id": "HighlightConfig",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "showInfo", "type": "boolean", "optional": true, "description": "Whether the node info tooltip should be shown (default: false)." },\\r\\n                    { "name": "contentColor", "$ref": "RGBA", "optional": true, "description": "The content box highlight fill color (default: transparent)." },\\r\\n                    { "name": "paddingColor", "$ref": "RGBA", "optional": true, "description": "The padding highlight fill color (default: transparent)." },\\r\\n                    { "name": "borderColor", "$ref": "RGBA", "optional": true, "description": "The border highlight fill color (default: transparent)." },\\r\\n                    { "name": "marginColor", "$ref": "RGBA", "optional": true, "description": "The margin highlight fill color (default: transparent)." }\\r\\n                ],\\r\\n                "description": "Configuration data for the highlighting of page elements."\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "getDocument",\\r\\n                "returns": [\\r\\n                    { "name": "root", "$ref": "Node", "description": "Resulting node." }\\r\\n                ],\\r\\n                "description": "Returns the root DOM node to the caller."\\r\\n            },\\r\\n            {\\r\\n                "name": "requestChildNodes",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to get children for." },\\r\\n                    { "name": "depth", "type": "integer", "optional": true, "description": "The maximum depth at which children should be retrieved, defaults to 1. Use -1 for the entire subtree or provide an integer larger than 0." }\\r\\n                ],\\r\\n                "description": "Requests that children of the node with given id are returned to the caller in form of <code>setChildNodes</code> events where not only immediate children are retrieved, but all children down to the specified depth."\\r\\n            },\\r\\n            {\\r\\n                "name": "querySelector",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to query upon." },\\r\\n                    { "name": "selector", "type": "string", "description": "Selector string." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Query selector result." }\\r\\n                ],\\r\\n                "description": "Executes <code>querySelector</code> on a given node."\\r\\n            },\\r\\n            {\\r\\n                "name": "querySelectorAll",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to query upon." },\\r\\n                    { "name": "selector", "type": "string", "description": "Selector string." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "nodeIds", "type": "array", "items": { "$ref": "NodeId" }, "description": "Query selector result." }\\r\\n                ],\\r\\n                "description": "Executes <code>querySelectorAll</code> on a given node."\\r\\n            },\\r\\n            {\\r\\n                "name": "setNodeName",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to set name for." },\\r\\n                    { "name": "name", "type": "string", "description": "New node\\\'s name." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "New node\\\'s id." }\\r\\n                ],\\r\\n                "description": "Sets node name for a node with given id."\\r\\n            },\\r\\n            {\\r\\n                "name": "setNodeValue",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to set value for." },\\r\\n                    { "name": "value", "type": "string", "description": "New node\\\'s value." }\\r\\n                ],\\r\\n                "description": "Sets node value for a node with given id."\\r\\n            },\\r\\n            {\\r\\n                "name": "removeNode",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to remove." }\\r\\n                ],\\r\\n                "description": "Removes node with given id."\\r\\n            },\\r\\n            {\\r\\n                "name": "setAttributeValue",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the element to set attribute for." },\\r\\n                    { "name": "name", "type": "string", "description": "Attribute name." },\\r\\n                    { "name": "value", "type": "string", "description": "Attribute value." }\\r\\n                ],\\r\\n                "description": "Sets attribute for an element with given id."\\r\\n            },\\r\\n            {\\r\\n                "name": "setAttributesAsText",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the element to set attributes for." },\\r\\n                    { "name": "text", "type": "string", "description": "Text with a number of attributes. Will parse this text using HTML parser." },\\r\\n                    { "name": "name", "type": "string", "optional": true, "description": "Attribute name to replace with new attributes derived from text in case text parsed successfully." }\\r\\n                ],\\r\\n                "description": "Sets attributes on element with given id. This method is useful when user edits some existing attribute value and types in several attribute name/value pairs."\\r\\n            },\\r\\n            {\\r\\n                "name": "removeAttribute",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the element to remove attribute from." },\\r\\n                    { "name": "name", "type": "string", "description": "Name of the attribute to remove." }\\r\\n                ],\\r\\n                "description": "Removes attribute with given name from an element with given id."\\r\\n            },\\r\\n            {\\r\\n                "name": "getEventListenersForNode",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to get listeners for." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "listeners", "type": "array", "items": { "$ref": "EventListener"}, "description": "Array of relevant listeners." }\\r\\n                ],\\r\\n                "description": "Returns event listeners relevant to the node.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "getOuterHTML",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to get markup for." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "outerHTML", "type": "string", "description": "Outer HTML markup." }\\r\\n                ],\\r\\n                "description": "Returns node\\\'s HTML markup."\\r\\n            },\\r\\n            {\\r\\n                "name": "setOuterHTML",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to set markup for." },\\r\\n                    { "name": "outerHTML", "type": "string", "description": "Outer HTML markup to set." }\\r\\n                ],\\r\\n                "description": "Sets node HTML markup, returns new node id."\\r\\n            },\\r\\n            {\\r\\n                "name": "performSearch",\\r\\n                "parameters": [\\r\\n                    { "name": "query", "type": "string", "description": "Plain text or query selector or XPath search query." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "searchId", "type": "string", "description": "Unique search session identifier." },\\r\\n                    { "name": "resultCount", "type": "integer", "description": "Number of search results." }\\r\\n                ],\\r\\n                "description": "Searches for a given string in the DOM tree. Use <code>getSearchResults</code> to access search results or <code>cancelSearch</code> to end this search session.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "getSearchResults",\\r\\n                "parameters": [\\r\\n                    { "name": "searchId", "type": "string", "description": "Unique search session identifier." },\\r\\n                    { "name": "fromIndex", "type": "integer", "description": "Start index of the search result to be returned." },\\r\\n                    { "name": "toIndex", "type": "integer", "description": "End index of the search result to be returned." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "nodeIds", "type": "array", "items": { "$ref": "NodeId" }, "description": "Ids of the search result nodes." }\\r\\n                ],\\r\\n                "description": "Returns search results from given <code>fromIndex</code> to given <code>toIndex</code> from the sarch with the given identifier.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "discardSearchResults",\\r\\n                "parameters": [\\r\\n                    { "name": "searchId", "type": "string", "description": "Unique search session identifier." }\\r\\n                ],\\r\\n                "description": "Discards search results from the session with the given id. <code>getSearchResults</code> should no longer be called for that search.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "requestNode",\\r\\n                "parameters": [\\r\\n                    { "name": "objectId", "$ref": "Runtime.RemoteObjectId", "description": "JavaScript object id to convert into node." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Node id for given object." }\\r\\n                ],\\r\\n                "description": "Requests that the node is sent to the caller given the JavaScript node object reference. All nodes that form the path from the node to the root are also sent to the client as a series of <code>setChildNodes</code> notifications."\\r\\n            },\\r\\n            {\\r\\n                "name": "setInspectModeEnabled",\\r\\n                "hidden": true,\\r\\n                "parameters": [\\r\\n                    { "name": "enabled", "type": "boolean", "description": "True to enable inspection mode, false to disable it." },\\r\\n                    { "name": "highlightConfig", "$ref": "HighlightConfig", "optional": true, "description": "A descriptor for the highlight appearance of hovered-over nodes. May be omitted if <code>enabled == false</code>." }\\r\\n                ],\\r\\n                "description": "Enters the \\\'inspect\\\' mode. In this mode, elements that user is hovering over are highlighted. Backend then generates \\\'inspect\\\' command upon element selection."\\r\\n            },\\r\\n            {\\r\\n                "name": "highlightRect",\\r\\n                "parameters": [\\r\\n                    { "name": "x", "type": "integer", "description": "X coordinate" },\\r\\n                    { "name": "y", "type": "integer", "description": "Y coordinate" },\\r\\n                    { "name": "width", "type": "integer", "description": "Rectangle width" },\\r\\n                    { "name": "height", "type": "integer", "description": "Rectangle height" },\\r\\n                    { "name": "color", "$ref": "RGBA", "optional": true, "description": "The highlight fill color (default: transparent)." },\\r\\n                    { "name": "outlineColor", "$ref": "RGBA", "optional": true, "description": "The highlight outline color (default: transparent)." }\\r\\n                ],\\r\\n                "description": "Highlights given rectangle. Coordinates are absolute with respect to the main frame viewport."\\r\\n            },\\r\\n            {\\r\\n                "name": "highlightNode",\\r\\n                "parameters": [\\r\\n                    { "name": "highlightConfig", "$ref": "HighlightConfig",  "description": "A descriptor for the highlight appearance." },\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "optional": true, "description": "Identifier of the node to highlight." },\\r\\n                    { "name": "objectId", "$ref": "Runtime.RemoteObjectId", "optional": true, "description": "JavaScript object id of the node to be highlighted." }\\r\\n                ],\\r\\n                "description": "Highlights DOM node with given id or with the given JavaScript object wrapper. Either nodeId or objectId must be specified."\\r\\n            },\\r\\n            {\\r\\n                "name": "hideHighlight",\\r\\n                "description": "Hides DOM node highlight."\\r\\n            },\\r\\n            {\\r\\n                "name": "highlightFrame",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Identifier of the frame to highlight." },\\r\\n                    { "name": "contentColor", "$ref": "RGBA", "optional": true, "description": "The content box highlight fill color (default: transparent)." },\\r\\n                    { "name": "contentOutlineColor", "$ref": "RGBA", "optional": true, "description": "The content box highlight outline color (default: transparent)." }\\r\\n                ],\\r\\n                "description": "Highlights owner element of the frame with given id.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "pushNodeByPathToFrontend",\\r\\n                "parameters": [\\r\\n                    { "name": "path", "type": "string", "description": "Path to node in the proprietary format." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node for given path." }\\r\\n                ],\\r\\n                "description": "Requests that the node is sent to the caller given its path. // FIXME, use XPath",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "resolveNode",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to resolve." },\\r\\n                    { "name": "objectGroup", "type": "string", "optional": true, "description": "Symbolic group name that can be used to release multiple objects." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "object", "$ref": "Runtime.RemoteObject", "description": "JavaScript object wrapper for given node." }\\r\\n                ],\\r\\n                "description": "Resolves JavaScript node object for given node id."\\r\\n            },\\r\\n            {\\r\\n                "name": "getAttributes",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to retrieve attibutes for." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "attributes", "type": "array", "items": { "type": "string" }, "description": "An interleaved array of node attribute names and values." }\\r\\n                ],\\r\\n                "description": "Returns attributes for the specified node."\\r\\n            },\\r\\n            {\\r\\n                "name": "moveTo",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node to drop." },\\r\\n                    { "name": "targetNodeId", "$ref": "NodeId", "description": "Id of the element to drop into." },\\r\\n                    { "name": "insertBeforeNodeId", "$ref": "NodeId", "optional": true, "description": "Drop node before given one." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "New id of the moved node." }\\r\\n                ],\\r\\n                "description": "Moves node into the new container, places it before the given anchor."\\r\\n            },\\r\\n            {\\r\\n                "name": "undo",\\r\\n                "description": "Undoes the last performed action.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "redo",\\r\\n                "description": "Re-does the last undone action.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "markUndoableState",\\r\\n                "description": "Marks last undoable state.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "focus",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "DOM.NodeId", "description": "Id of the node to focus." }\\r\\n                ],\\r\\n                "description": "Focuses the given element.",\\r\\n                "hidden": true\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "documentUpdated",\\r\\n                "description": "Fired when <code>Document</code> has been totally updated. Node ids are no longer valid."\\r\\n            },\\r\\n            {\\r\\n                "name": "setChildNodes",\\r\\n                "parameters": [\\r\\n                    { "name": "parentId", "$ref": "NodeId", "description": "Parent node id to populate with children." },\\r\\n                    { "name": "nodes", "type": "array", "items": { "$ref": "Node"}, "description": "Child nodes array." }\\r\\n                ],\\r\\n                "description": "Fired when backend wants to provide client with the missing DOM structure. This happens upon most of the calls requesting node ids."\\r\\n            },\\r\\n            {\\r\\n                "name": "attributeModified",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node that has changed." },\\r\\n                    { "name": "name", "type": "string", "description": "Attribute name." },\\r\\n                    { "name": "value", "type": "string", "description": "Attribute value." }\\r\\n                ],\\r\\n                "description": "Fired when <code>Element</code>\\\'s attribute is modified."\\r\\n            },\\r\\n            {\\r\\n                "name": "attributeRemoved",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node that has changed." },\\r\\n                    { "name": "name", "type": "string", "description": "A ttribute name." }\\r\\n                ],\\r\\n                "description": "Fired when <code>Element</code>\\\'s attribute is removed."\\r\\n            },\\r\\n            {\\r\\n                "name": "inlineStyleInvalidated",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeIds", "type": "array", "items": { "$ref": "NodeId" }, "description": "Ids of the nodes for which the inline styles have been invalidated." }\\r\\n                ],\\r\\n                "description": "Fired when <code>Element</code>\\\'s inline style is modified via a CSS property modification.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "characterDataModified",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node that has changed." },\\r\\n                    { "name": "characterData", "type": "string", "description": "New text value." }\\r\\n                ],\\r\\n                "description": "Mirrors <code>DOMCharacterDataModified</code> event."\\r\\n            },\\r\\n            {\\r\\n                "name": "childNodeCountUpdated",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node that has changed." },\\r\\n                    { "name": "childNodeCount", "type": "integer", "description": "New node count." }\\r\\n                ],\\r\\n                "description": "Fired when <code>Container</code>\\\'s child node count has changed."\\r\\n            },\\r\\n            {\\r\\n                "name": "childNodeInserted",\\r\\n                "parameters": [\\r\\n                    { "name": "parentNodeId", "$ref": "NodeId", "description": "Id of the node that has changed." },\\r\\n                    { "name": "previousNodeId", "$ref": "NodeId", "description": "If of the previous siblint." },\\r\\n                    { "name": "node", "$ref": "Node", "description": "Inserted node data." }\\r\\n                ],\\r\\n                "description": "Mirrors <code>DOMNodeInserted</code> event."\\r\\n            },\\r\\n            {\\r\\n                "name": "childNodeRemoved",\\r\\n                "parameters": [\\r\\n                    { "name": "parentNodeId", "$ref": "NodeId", "description": "Parent id." },\\r\\n                    { "name": "nodeId", "$ref": "NodeId", "description": "Id of the node that has been removed." }\\r\\n                ],\\r\\n                "description": "Mirrors <code>DOMNodeRemoved</code> event."\\r\\n            },\\r\\n            {\\r\\n                "name": "shadowRootPushed",\\r\\n                "parameters": [\\r\\n                    { "name": "hostId", "$ref": "NodeId", "description": "Host element id." },\\r\\n                    { "name": "root", "$ref": "Node", "description": "Shadow root." }\\r\\n                ],\\r\\n                "description": "Called when shadow root is pushed into the element.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "shadowRootPopped",\\r\\n                "parameters": [\\r\\n                    { "name": "hostId", "$ref": "NodeId", "description": "Host element id." },\\r\\n                    { "name": "rootId", "$ref": "NodeId", "description": "Shadow root id." }\\r\\n                ],\\r\\n                "description": "Called when shadow root is popped from the element.",\\r\\n                "hidden": true\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "CSS",\\r\\n        "hidden": true,\\r\\n        "description": "This domain exposes CSS read/write operations. All CSS objects, like stylesheets, rules, and styles, have an associated <code>id</code> used in subsequent operations on the related object. Each object type has a specific <code>id</code> structure, and those are not interchangeable between objects of different kinds. CSS objects can be loaded using the <code>get*ForNode()</code> calls (which accept a DOM node id). Alternatively, a client can discover all the existing stylesheets with the <code>getAllStyleSheets()</code> method and subsequently load the required stylesheet contents using the <code>getStyleSheet[Text]()</code> methods.",\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "StyleSheetId",\\r\\n                "type": "string"\\r\\n            },\\r\\n            {\\r\\n                "id": "CSSStyleId",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "styleSheetId", "$ref": "StyleSheetId", "description": "Enclosing stylesheet identifier." },\\r\\n                    { "name": "ordinal", "type": "integer", "description": "The style ordinal within the stylesheet." }\\r\\n                ],\\r\\n                "description": "This object identifies a CSS style in a unique way."\\r\\n            },\\r\\n            {\\r\\n                "id": "StyleSheetOrigin",\\r\\n                "type": "string",\\r\\n                "enum": ["user", "user-agent", "inspector", "regular"],\\r\\n                "description": "Stylesheet type: \\\\"user\\\\" for user stylesheets, \\\\"user-agent\\\\" for user-agent stylesheets, \\\\"inspector\\\\" for stylesheets created by the inspector (i.e. those holding the \\\\"via inspector\\\\" rules), \\\\"regular\\\\" for regular stylesheets."\\r\\n            },\\r\\n            {\\r\\n                "id": "CSSRuleId",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "styleSheetId", "$ref": "StyleSheetId", "description": "Enclosing stylesheet identifier." },\\r\\n                    { "name": "ordinal", "type": "integer", "description": "The rule ordinal within the stylesheet." }\\r\\n                ],\\r\\n                "description": "This object identifies a CSS rule in a unique way."\\r\\n            },\\r\\n            {\\r\\n                "id": "PseudoIdMatches",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "pseudoId", "type": "integer", "description": "Pseudo style identifier (see <code>enum PseudoId</code> in <code>RenderStyleConstants.h</code>)."},\\r\\n                    { "name": "matches", "type": "array", "items": { "$ref": "RuleMatch" }, "description": "Matches of CSS rules applicable to the pseudo style."}\\r\\n                ],\\r\\n                "description": "CSS rule collection for a single pseudo style."\\r\\n            },\\r\\n            {\\r\\n                "id": "InheritedStyleEntry",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "inlineStyle", "$ref": "CSSStyle", "optional": true, "description": "The ancestor node\\\'s inline style, if any, in the style inheritance chain." },\\r\\n                    { "name": "matchedCSSRules", "type": "array", "items": { "$ref": "RuleMatch" }, "description": "Matches of CSS rules matching the ancestor node in the style inheritance chain." }\\r\\n                ],\\r\\n                "description": "CSS rule collection for a single pseudo style."\\r\\n            },\\r\\n            {\\r\\n                "id": "RuleMatch",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "rule", "$ref": "CSSRule", "description": "CSS rule in the match." },\\r\\n                    { "name": "matchingSelectors", "type": "array", "items": { "type": "integer" }, "description": "Matching selector indices in the rule\\\'s selectorList selectors (0-based)." }\\r\\n                ],\\r\\n                "description": "Match data for a CSS rule."\\r\\n            },\\r\\n            {\\r\\n                "id": "SelectorList",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "selectors", "type": "array", "items": { "type": "string" }, "description": "Selectors in the list." },\\r\\n                    { "name": "text", "type": "string", "description": "Rule selector text." },\\r\\n                    { "name": "range", "$ref": "SourceRange", "optional": true, "description": "Rule selector range in the underlying resource (if available)." }\\r\\n                ],\\r\\n                "description": "Selector list data."\\r\\n            },\\r\\n            {\\r\\n                "id": "CSSStyleAttribute",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "DOM attribute name (e.g. \\\\"width\\\\")."},\\r\\n                    { "name": "style", "$ref": "CSSStyle", "description": "CSS style generated by the respective DOM attribute."}\\r\\n                ],\\r\\n                "description": "CSS style information for a DOM style attribute."\\r\\n            },\\r\\n            {\\r\\n                "id": "CSSStyleSheetHeader",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "styleSheetId", "$ref": "StyleSheetId", "description": "The stylesheet identifier."},\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Owner frame identifier."},\\r\\n                    { "name": "sourceURL", "type": "string", "description": "Stylesheet resource URL."},\\r\\n                    { "name": "origin", "$ref": "StyleSheetOrigin", "description": "Stylesheet origin."},\\r\\n                    { "name": "title", "type": "string", "description": "Stylesheet title."},\\r\\n                    { "name": "disabled", "type": "boolean", "description": "Denotes whether the stylesheet is disabled."}\\r\\n                ],\\r\\n                "description": "CSS stylesheet metainformation."\\r\\n            },\\r\\n            {\\r\\n                "id": "CSSStyleSheetBody",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "styleSheetId", "$ref": "StyleSheetId", "description": "The stylesheet identifier."},\\r\\n                    { "name": "rules", "type": "array", "items": { "$ref": "CSSRule" }, "description": "Stylesheet resource URL."},\\r\\n                    { "name": "text", "type": "string", "optional": true, "description": "Stylesheet resource contents (if available)."}\\r\\n                ],\\r\\n                "description": "CSS stylesheet contents."\\r\\n            },\\r\\n            {\\r\\n                "id": "CSSRule",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "ruleId", "$ref": "CSSRuleId", "optional": true, "description": "The CSS rule identifier (absent for user agent stylesheet and user-specified stylesheet rules)."},\\r\\n                    { "name": "selectorList", "$ref": "SelectorList", "description": "Rule selector data." },\\r\\n                    { "name": "sourceURL", "type": "string", "optional": true, "description": "Parent stylesheet resource URL (for regular rules)."},\\r\\n                    { "name": "sourceLine", "type": "integer", "description": "Line ordinal of the rule selector start character in the resource."},\\r\\n                    { "name": "origin", "$ref": "StyleSheetOrigin", "description": "Parent stylesheet\\\'s origin."},\\r\\n                    { "name": "style", "$ref": "CSSStyle", "description": "Associated style declaration." },\\r\\n                    { "name": "media", "type": "array", "items": { "$ref": "CSSMedia" }, "optional": true, "description": "Media list array (for rules involving media queries). The array enumerates media queries starting with the innermost one, going outwards." }\\r\\n                ],\\r\\n                "description": "CSS rule representation."\\r\\n            },\\r\\n            {\\r\\n                "id": "SourceRange",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "start", "type": "integer", "description": "Start of range (inclusive)."},\\r\\n                    { "name": "end", "type": "integer", "description": "End of range (exclusive)."}\\r\\n                ],\\r\\n                "description": "Text range within a resource."\\r\\n            },\\r\\n            {\\r\\n                "id": "ShorthandEntry",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "Shorthand name." },\\r\\n                    { "name": "value", "type": "string", "description": "Shorthand value." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "CSSPropertyInfo",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "Property name." },\\r\\n                    { "name": "longhands", "type": "array", "optional": true, "items": { "type": "string" }, "description": "Longhand property names." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "CSSComputedStyleProperty",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "Computed style property name." },\\r\\n                    { "name": "value", "type": "string", "description": "Computed style property value." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "CSSStyle",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "styleId", "$ref": "CSSStyleId", "optional": true, "description": "The CSS style identifier (absent for attribute styles)." },\\r\\n                    { "name": "cssProperties", "type": "array", "items": { "$ref": "CSSProperty" }, "description": "CSS properties in the style." },\\r\\n                    { "name": "shorthandEntries", "type": "array", "items": { "$ref": "ShorthandEntry" }, "description": "Computed values for all shorthands found in the style." },\\r\\n                    { "name": "cssText", "type": "string", "optional": true, "description": "Style declaration text (if available)." },\\r\\n                    { "name": "range", "$ref": "SourceRange", "optional": true, "description": "Style declaration range in the enclosing stylesheet (if available)." },\\r\\n                    { "name": "width", "type": "string", "optional": true, "description": "The effective \\\\"width\\\\" property value from this style." },\\r\\n                    { "name": "height", "type": "string", "optional": true, "description": "The effective \\\\"height\\\\" property value from this style." }\\r\\n                ],\\r\\n                "description": "CSS style representation."\\r\\n            },\\r\\n            {\\r\\n                "id": "CSSProperty",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "name", "type": "string", "description": "The property name." },\\r\\n                    { "name": "value", "type": "string", "description": "The property value." },\\r\\n                    { "name": "priority", "type": "string", "optional": true, "description": "The property priority (implies \\\\"\\\\" if absent)." },\\r\\n                    { "name": "implicit", "type": "boolean", "optional": true, "description": "Whether the property is implicit (implies <code>false</code> if absent)." },\\r\\n                    { "name": "text", "type": "string", "optional": true, "description": "The full property text as specified in the style." },\\r\\n                    { "name": "parsedOk", "type": "boolean", "optional": true, "description": "Whether the property is understood by the browser (implies <code>true</code> if absent)." },\\r\\n                    { "name": "status", "type": "string", "enum": ["active", "inactive", "disabled", "style"], "optional": true, "description": "The property status: \\\\"active\\\\" (implied if absent) if the property is effective in the style, \\\\"inactive\\\\" if the property is overridden by a same-named property in this style later on, \\\\"disabled\\\\" if the property is disabled by the user, \\\\"style\\\\" if the property is reported by the browser rather than by the CSS source parser." },\\r\\n                    { "name": "range", "$ref": "SourceRange", "optional": true, "description": "The entire property range in the enclosing style declaration (if available)." }\\r\\n                ],\\r\\n                "description": "CSS style effective visual dimensions and source offsets."\\r\\n            },\\r\\n            {\\r\\n                "id": "CSSMedia",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "text", "type": "string", "description": "Media query text." },\\r\\n                    { "name": "source", "type": "string", "enum": ["mediaRule", "importRule", "linkedSheet", "inlineSheet"], "description": "Source of the media query: \\\\"mediaRule\\\\" if specified by a @media rule, \\\\"importRule\\\\" if specified by an @import rule, \\\\"linkedSheet\\\\" if specified by a \\\\"media\\\\" attribute in a linked stylesheet\\\'s LINK tag, \\\\"inlineSheet\\\\" if specified by a \\\\"media\\\\" attribute in an inline stylesheet\\\'s STYLE tag." },\\r\\n                    { "name": "sourceURL", "type": "string", "optional": true, "description": "URL of the document containing the media query description." },\\r\\n                    { "name": "sourceLine", "type": "integer", "optional": true, "description": "Line in the document containing the media query (not defined for the \\\\"stylesheet\\\\" source)." }\\r\\n                ],\\r\\n                "description": "CSS media query descriptor."\\r\\n            },\\r\\n            {\\r\\n                "id": "SelectorProfileEntry",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "selector", "type": "string", "description": "CSS selector of the corresponding rule." },\\r\\n                    { "name": "url", "type": "string", "description": "URL of the resource containing the corresponding rule." },\\r\\n                    { "name": "lineNumber", "type": "integer", "description": "Selector line number in the resource for the corresponding rule." },\\r\\n                    { "name": "time", "type": "number", "description": "Total time this rule handling contributed to the browser running time during profiling (in milliseconds.)" },\\r\\n                    { "name": "hitCount", "type": "integer", "description": "Number of times this rule was considered a candidate for matching against DOM elements." },\\r\\n                    { "name": "matchCount", "type": "integer", "description": "Number of times this rule actually matched a DOM element." }\\r\\n                ],\\r\\n                "description": "CSS selector profile entry."\\r\\n            },\\r\\n            {\\r\\n                "id": "SelectorProfile",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "totalTime", "type": "number", "description": "Total processing time for all selectors in the profile (in milliseconds.)" },\\r\\n                    { "name": "data", "type": "array", "items": { "$ref": "SelectorProfileEntry" }, "description": "CSS selector profile entries." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "Region",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "regionOverset", "type": "string", "enum": ["overset", "fit", "empty"], "description": "The \\\\"overset\\\\" attribute of a Named Flow." },\\r\\n                    { "name": "nodeId", "$ref": "DOM.NodeId", "description": "The corresponding DOM node id." }\\r\\n                ],\\r\\n                "description": "This object represents a region that flows from a Named Flow.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "id": "NamedFlow",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "documentNodeId", "$ref": "DOM.NodeId", "description": "The document node id." },\\r\\n                    { "name": "name", "type": "string", "description": "Named Flow identifier." },\\r\\n                    { "name": "overset", "type": "boolean", "description": "The \\\\"overset\\\\" attribute of a Named Flow." },\\r\\n                    { "name": "content", "type": "array", "items": { "$ref": "DOM.NodeId" }, "description": "An array of nodes that flow into the Named Flow." },\\r\\n                    { "name": "regions", "type": "array", "items": { "$ref": "Region" }, "description": "An array of regions associated with the Named Flow." }\\r\\n                ],\\r\\n                "description": "This object represents a Named Flow.",\\r\\n                "hidden": true\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables the CSS agent for the given page. Clients should not assume that the CSS agent has been enabled until the result of this command is received."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables the CSS agent for the given page."\\r\\n            },\\r\\n            {\\r\\n                "name": "getMatchedStylesForNode",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "DOM.NodeId" },\\r\\n                    { "name": "includePseudo", "type": "boolean", "optional": true, "description": "Whether to include pseudo styles (default: true)." },\\r\\n                    { "name": "includeInherited", "type": "boolean", "optional": true, "description": "Whether to include inherited styles (default: true)." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "matchedCSSRules", "type": "array", "items": { "$ref": "RuleMatch" }, "optional": true, "description": "CSS rules matching this node, from all applicable stylesheets." },\\r\\n                    { "name": "pseudoElements", "type": "array", "items": { "$ref": "PseudoIdMatches" }, "optional": true, "description": "Pseudo style matches for this node." },\\r\\n                    { "name": "inherited", "type": "array", "items": { "$ref": "InheritedStyleEntry" }, "optional": true, "description": "A chain of inherited styles (from the immediate node parent up to the DOM tree root)." }\\r\\n                ],\\r\\n                "description": "Returns requested styles for a DOM node identified by <code>nodeId</code>."\\r\\n            },\\r\\n            {\\r\\n                "name": "getInlineStylesForNode",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "DOM.NodeId" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "inlineStyle", "$ref": "CSSStyle", "optional": true, "description": "Inline style for the specified DOM node." },\\r\\n                    { "name": "attributesStyle", "$ref": "CSSStyle", "optional": true, "description": "Attribute-defined element style (e.g. resulting from \\\\"width=20 height=100%\\\\")."}\\r\\n                ],\\r\\n                "description": "Returns the styles defined inline (explicitly in the \\\\"style\\\\" attribute and implicitly, using DOM attributes) for a DOM node identified by <code>nodeId</code>."\\r\\n            },\\r\\n            {\\r\\n                "name": "getComputedStyleForNode",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "DOM.NodeId" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "computedStyle", "type": "array", "items": { "$ref": "CSSComputedStyleProperty" }, "description": "Computed style for the specified DOM node." }\\r\\n                ],\\r\\n                "description": "Returns the computed style for a DOM node identified by <code>nodeId</code>."\\r\\n            },\\r\\n            {\\r\\n                "name": "getAllStyleSheets",\\r\\n                "returns": [\\r\\n                    { "name": "headers", "type": "array", "items": { "$ref": "CSSStyleSheetHeader" }, "description": "Descriptor entries for all available stylesheets." }\\r\\n                ],\\r\\n                "description": "Returns metainfo entries for all known stylesheets."\\r\\n            },\\r\\n            {\\r\\n                "name": "getStyleSheet",\\r\\n                "parameters": [\\r\\n                    { "name": "styleSheetId", "$ref": "StyleSheetId" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "styleSheet", "$ref": "CSSStyleSheetBody", "description": "Stylesheet contents for the specified <code>styleSheetId</code>." }\\r\\n                ],\\r\\n                "description": "Returns stylesheet data for the specified <code>styleSheetId</code>."\\r\\n            },\\r\\n            {\\r\\n                "name": "getStyleSheetText",\\r\\n                "parameters": [\\r\\n                    { "name": "styleSheetId", "$ref": "StyleSheetId" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "text", "type": "string", "description": "The stylesheet text." }\\r\\n                ],\\r\\n                "description": "Returns the current textual content and the URL for a stylesheet."\\r\\n            },\\r\\n            {\\r\\n                "name": "setStyleSheetText",\\r\\n                "parameters": [\\r\\n                    { "name": "styleSheetId", "$ref": "StyleSheetId" },\\r\\n                    { "name": "text", "type": "string" }\\r\\n                ],\\r\\n                "description": "Sets the new stylesheet text, thereby invalidating all existing <code>CSSStyleId</code>\\\'s and <code>CSSRuleId</code>\\\'s contained by this stylesheet."\\r\\n            },\\r\\n            {\\r\\n                "name": "setPropertyText",\\r\\n                "parameters": [\\r\\n                    { "name": "styleId", "$ref": "CSSStyleId" },\\r\\n                    { "name": "propertyIndex", "type": "integer" },\\r\\n                    { "name": "text", "type": "string" },\\r\\n                    { "name": "overwrite", "type": "boolean" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "style", "$ref": "CSSStyle", "description": "The resulting style after the property text modification." }\\r\\n                ],\\r\\n                "description": "Sets the new <code>text</code> for a property in the respective style, at offset <code>propertyIndex</code>. If <code>overwrite</code> is <code>true</code>, a property at the given offset is overwritten, otherwise inserted. <code>text</code> entirely replaces the property <code>name: value</code>."\\r\\n            },\\r\\n            {\\r\\n                "name": "toggleProperty",\\r\\n                "parameters": [\\r\\n                    { "name": "styleId", "$ref": "CSSStyleId" },\\r\\n                    { "name": "propertyIndex", "type": "integer" },\\r\\n                    { "name": "disable", "type": "boolean" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "style", "$ref": "CSSStyle", "description": "The resulting style after the property toggling." }\\r\\n                ],\\r\\n                "description": "Toggles the property in the respective style, at offset <code>propertyIndex</code>. The <code>disable</code> parameter denotes whether the property should be disabled (i.e. removed from the style declaration). If <code>disable == false</code>, the property gets put back into its original place in the style declaration."\\r\\n            },\\r\\n            {\\r\\n                "name": "setRuleSelector",\\r\\n                "parameters": [\\r\\n                    { "name": "ruleId", "$ref": "CSSRuleId" },\\r\\n                    { "name": "selector", "type": "string" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "rule", "$ref": "CSSRule", "description": "The resulting rule after the selector modification." }\\r\\n                ],\\r\\n                "description": "Modifies the rule selector."\\r\\n            },\\r\\n            {\\r\\n                "name": "addRule",\\r\\n                "parameters": [\\r\\n                    { "name": "contextNodeId", "$ref": "DOM.NodeId" },\\r\\n                    { "name": "selector", "type": "string" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "rule", "$ref": "CSSRule", "description": "The newly created rule." }\\r\\n                ],\\r\\n                "description": "Creates a new empty rule with the given <code>selector</code> in a special \\\\"inspector\\\\" stylesheet in the owner document of the context node."\\r\\n            },\\r\\n            {\\r\\n                "name": "getSupportedCSSProperties",\\r\\n                "returns": [\\r\\n                    { "name": "cssProperties", "type": "array", "items": { "$ref": "CSSPropertyInfo" }, "description": "Supported property metainfo." }\\r\\n                ],\\r\\n                "description": "Returns all supported CSS property names."\\r\\n            },\\r\\n            {\\r\\n                "name": "forcePseudoState",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "DOM.NodeId", "description": "The element id for which to force the pseudo state." },\\r\\n                    { "name": "forcedPseudoClasses", "type": "array", "items": { "type": "string", "enum": ["active", "focus", "hover", "visited"] }, "description": "Element pseudo classes to force when computing the element\\\'s style." }\\r\\n                ],\\r\\n                "description": "Ensures that the given node will have specified pseudo-classes whenever its style is computed by the browser."\\r\\n            },\\r\\n            {\\r\\n                "name": "startSelectorProfiler"\\r\\n            },\\r\\n            {\\r\\n                "name": "stopSelectorProfiler",\\r\\n                "returns": [\\r\\n                    { "name": "profile", "$ref": "SelectorProfile" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "getNamedFlowCollection",\\r\\n                "parameters": [\\r\\n                    { "name": "documentNodeId", "$ref": "DOM.NodeId", "description": "The document node id for which to get the Named Flow Collection." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "namedFlows", "type": "array", "items": { "$ref": "NamedFlow" }, "description": "An array containing the Named Flows in the document." }\\r\\n                ],\\r\\n                "description": "Returns the Named Flows from the document.",\\r\\n                "hidden": true\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "mediaQueryResultChanged",\\r\\n                "description": "Fires whenever a MediaQuery result changes (for example, after a browser window has been resized.) The current implementation considers only viewport-dependent media features."\\r\\n            },\\r\\n            {\\r\\n                "name": "styleSheetChanged",\\r\\n                "parameters": [\\r\\n                    { "name": "styleSheetId", "$ref": "StyleSheetId" }\\r\\n                ],\\r\\n                "description": "Fired whenever a stylesheet is changed as a result of the client operation."\\r\\n            },\\r\\n            {\\r\\n                "name": "namedFlowCreated",\\r\\n                "parameters": [\\r\\n                    { "name": "namedFlow", "$ref": "NamedFlow", "description": "The new Named Flow." }\\r\\n                ],\\r\\n                "description": "Fires when a Named Flow is created.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "namedFlowRemoved",\\r\\n                "parameters": [\\r\\n                    { "name": "documentNodeId", "$ref": "DOM.NodeId", "description": "The document node id." },\\r\\n                    { "name": "flowName", "type": "string", "description": "Identifier of the removed Named Flow." }\\r\\n                ],\\r\\n                "description": "Fires when a Named Flow is removed: has no associated content nodes and regions.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "regionLayoutUpdated",\\r\\n                "parameters": [\\r\\n                    { "name": "namedFlow", "$ref": "NamedFlow", "description": "The Named Flow whose layout may have changed." }\\r\\n                ],\\r\\n                "description": "Fires when a Named Flow\\\'s layout may have changed.",\\r\\n                "hidden": true\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Timeline",\\r\\n        "description": "Timeline provides its clients with instrumentation records that are generated during the page runtime. Timeline instrumentation can be started and stopped using corresponding commands. While timeline is started, it is generating timeline event records.",\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "TimelineEvent",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "type", "type": "string", "description": "Event type." },\\r\\n                    { "name": "data", "type": "object", "description": "Event data." },\\r\\n                    { "name": "children", "type": "array", "optional": true, "items": { "$ref": "TimelineEvent" }, "description": "Nested records." }\\r\\n                ],\\r\\n                "description": "Timeline record contains information about the recorded activity."\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "start",\\r\\n                "parameters": [\\r\\n                    { "name": "maxCallStackDepth", "optional": true, "type": "integer", "description": "Samples JavaScript stack traces up to <code>maxCallStackDepth</code>, defaults to 5." }\\r\\n                ],\\r\\n                "description": "Starts capturing instrumentation events."\\r\\n            },\\r\\n            {\\r\\n                "name": "stop",\\r\\n                "description": "Stops capturing instrumentation events."\\r\\n            },\\r\\n            {\\r\\n                "name": "setIncludeMemoryDetails",\\r\\n                "parameters": [\\r\\n                    { "name": "enabled", "type": "boolean", "description": "True to start collecting DOM counters." }\\r\\n                ],\\r\\n                "hidden": true,\\r\\n                "description": "Starts calculating various DOM statistics and sending them as part of timeline events."\\r\\n            },\\r\\n            {\\r\\n                "name": "supportsFrameInstrumentation",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean", "description": "True if timeline supports frame instrumentation." }\\r\\n                ],\\r\\n                "hidden": true,\\r\\n                "description": "Tells whether timeline agent supports frame instrumentation."\\r\\n            },\\r\\n            {\\r\\n                "name": "canMonitorMainThread",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean", "description": "True if timeline supports main thread CPU utilization instrumentation." }\\r\\n                ],\\r\\n                "hidden": true,\\r\\n                "description": "Tells whether timeline agent supports main thread CPU utilization instrumentation."\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "eventRecorded",\\r\\n                "parameters": [\\r\\n                    { "name": "record", "$ref": "TimelineEvent", "description": "Timeline event record data." }\\r\\n                ],\\r\\n                "description": "Fired for every instrumentation event while timeline is started."\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Debugger",\\r\\n        "description": "Debugger domain exposes JavaScript debugging capabilities. It allows setting and removing breakpoints, stepping through execution, exploring stack traces, etc.",\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "BreakpointId",\\r\\n                "type": "string",\\r\\n                "description": "Breakpoint identifier."\\r\\n            },\\r\\n            {\\r\\n                "id": "ScriptId",\\r\\n                "type": "string",\\r\\n                "description": "Unique script identifier."\\r\\n            },\\r\\n            {\\r\\n                "id": "CallFrameId",\\r\\n                "type": "string",\\r\\n                "description": "Call frame identifier."\\r\\n            },\\r\\n            {\\r\\n                "id": "Location",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "scriptId", "$ref": "ScriptId", "description": "Script identifier as reported in the <code>Debugger.scriptParsed</code>." },\\r\\n                    { "name": "lineNumber", "type": "integer", "description": "Line number in the script." },\\r\\n                    { "name": "columnNumber", "type": "integer", "optional": true, "description": "Column number in the script." }\\r\\n                ],\\r\\n                "description": "Location in the source code."\\r\\n            },\\r\\n            {\\r\\n                "id": "FunctionDetails",\\r\\n                "hidden": true,\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "location", "$ref": "Location", "description": "Location of the function." },\\r\\n                    { "name": "name", "type": "string", "optional": true, "description": "Name of the function. Not present for anonymous functions." },\\r\\n                    { "name": "displayName", "type": "string", "optional": true, "description": "Display name of the function(specified in \\\'displayName\\\' property on the function object)." },\\r\\n                    { "name": "inferredName", "type": "string", "optional": true, "description": "Name of the function inferred from its initial assignment." },\\r\\n                    { "name": "scopeChain", "type": "array", "optional": true, "items": { "$ref": "Scope" }, "description": "Scope chain for this closure." }\\r\\n                ],\\r\\n                "description": "Information about the function."\\r\\n            },\\r\\n            {\\r\\n                "id": "CallFrame",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "callFrameId", "$ref": "CallFrameId", "description": "Call frame identifier. This identifier is only valid while the virtual machine is paused." },\\r\\n                    { "name": "functionName", "type": "string", "description": "Name of the JavaScript function called on this call frame." },\\r\\n                    { "name": "location", "$ref": "Location", "description": "Location in the source code." },\\r\\n                    { "name": "scopeChain", "type": "array", "items": { "$ref": "Scope" }, "description": "Scope chain for this call frame." },\\r\\n                    { "name": "this", "$ref": "Runtime.RemoteObject", "description": "<code>this</code> object for this call frame." }\\r\\n                ],\\r\\n                "description": "JavaScript call frame. Array of call frames form the call stack."\\r\\n            },\\r\\n            {\\r\\n                "id": "Scope",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "type", "type": "string", "enum": ["global", "local", "with", "closure", "catch"], "description": "Scope type." },\\r\\n                    { "name": "object", "$ref": "Runtime.RemoteObject", "description": "Object representing the scope. For <code>global</code> and <code>with</code> scopes it represents the actual object; for the rest of the scopes, it is artificial transient object enumerating scope variables as its properties." }\\r\\n                ],\\r\\n                "description": "Scope description."\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "causesRecompilation",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean", "description": "True if enabling debugger causes scripts recompilation." }\\r\\n                ],\\r\\n                "hidden": true,\\r\\n                "description": "Tells whether enabling debugger causes scripts recompilation."\\r\\n            },\\r\\n            {\\r\\n                "name": "supportsSeparateScriptCompilationAndExecution",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean", "description": "True if debugger supports separate script compilation and execution." }\\r\\n                ],\\r\\n                "hidden": true,\\r\\n                "description": "Tells whether debugger supports separate script compilation and execution."\\r\\n            },\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables debugger for the given page. Clients should not assume that the debugging has been enabled until the result for this command is received."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables debugger for given page."\\r\\n            },\\r\\n            {\\r\\n                "name": "setBreakpointsActive",\\r\\n                "parameters": [\\r\\n                    { "name": "active", "type": "boolean", "description": "New value for breakpoints active state." }\\r\\n                ],\\r\\n                "description": "Activates / deactivates all breakpoints on the page."\\r\\n            },\\r\\n            {\\r\\n                "name": "setBreakpointByUrl",\\r\\n                "parameters": [\\r\\n                    { "name": "lineNumber", "type": "integer", "description": "Line number to set breakpoint at." },\\r\\n                    { "name": "url", "type": "string", "optional": true, "description": "URL of the resources to set breakpoint on." },\\r\\n                    { "name": "urlRegex", "type": "string", "optional": true, "description": "Regex pattern for the URLs of the resources to set breakpoints on. Either <code>url</code> or <code>urlRegex</code> must be specified." },\\r\\n                    { "name": "columnNumber", "type": "integer", "optional": true, "description": "Offset in the line to set breakpoint at." },\\r\\n                    { "name": "condition", "type": "string", "optional": true, "description": "Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "breakpointId", "$ref": "BreakpointId", "description": "Id of the created breakpoint for further reference." },\\r\\n                    { "name": "locations", "type": "array", "items": { "$ref": "Location"}, "description": "List of the locations this breakpoint resolved into upon addition." }\\r\\n                ],\\r\\n                "description": "Sets JavaScript breakpoint at given location specified either by URL or URL regex. Once this command is issued, all existing parsed scripts will have breakpoints resolved and returned in <code>locations</code> property. Further matching script parsing will result in subsequent <code>breakpointResolved</code> events issued. This logical breakpoint will survive page reloads."\\r\\n            },\\r\\n            {\\r\\n                "name": "setBreakpoint",\\r\\n                "parameters": [\\r\\n                    { "name": "location", "$ref": "Location", "description": "Location to set breakpoint in." },\\r\\n                    { "name": "condition", "type": "string", "optional": true, "description": "Expression to use as a breakpoint condition. When specified, debugger will only stop on the breakpoint if this expression evaluates to true." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "breakpointId", "$ref": "BreakpointId", "description": "Id of the created breakpoint for further reference." },\\r\\n                    { "name": "actualLocation", "$ref": "Location", "description": "Location this breakpoint resolved into." }\\r\\n                ],\\r\\n                "description": "Sets JavaScript breakpoint at a given location."\\r\\n            },\\r\\n            {\\r\\n                "name": "removeBreakpoint",\\r\\n                "parameters": [\\r\\n                    { "name": "breakpointId", "$ref": "BreakpointId" }\\r\\n                ],\\r\\n                "description": "Removes JavaScript breakpoint."\\r\\n            },\\r\\n            {\\r\\n                "name": "continueToLocation",\\r\\n                "parameters": [\\r\\n                    { "name": "location", "$ref": "Location", "description": "Location to continue to." }\\r\\n                ],\\r\\n                "description": "Continues execution until specific location is reached."\\r\\n            },\\r\\n            {\\r\\n                "name": "stepOver",\\r\\n                "description": "Steps over the statement."\\r\\n            },\\r\\n            {\\r\\n                "name": "stepInto",\\r\\n                "description": "Steps into the function call."\\r\\n            },\\r\\n            {\\r\\n                "name": "stepOut",\\r\\n                "description": "Steps out of the function call."\\r\\n            },\\r\\n            {\\r\\n                "name": "pause",\\r\\n                "description": "Stops on the next JavaScript statement."\\r\\n            },\\r\\n            {\\r\\n                "name": "resume",\\r\\n                "description": "Resumes JavaScript execution."\\r\\n            },\\r\\n            {\\r\\n                "name": "searchInContent",\\r\\n                "parameters": [\\r\\n                    { "name": "scriptId", "$ref": "ScriptId", "description": "Id of the script to search in." },\\r\\n                    { "name": "query", "type": "string", "description": "String to search for."  },\\r\\n                    { "name": "caseSensitive", "type": "boolean", "optional": true, "description": "If true, search is case sensitive." },\\r\\n                    { "name": "isRegex", "type": "boolean", "optional": true, "description": "If true, treats string parameter as regex." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "array", "items": { "$ref": "Page.SearchMatch" }, "description": "List of search matches." }\\r\\n                ],\\r\\n                "description": "Searches for given string in script content."\\r\\n            },\\r\\n            {\\r\\n                "name": "canSetScriptSource",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean", "description": "True if <code>setScriptSource</code> is supported." }\\r\\n                ],\\r\\n                "description": "Tells whether <code>setScriptSource</code> is supported."\\r\\n            },\\r\\n            {\\r\\n                "name": "setScriptSource",\\r\\n                "parameters": [\\r\\n                    { "name": "scriptId", "$ref": "ScriptId", "description": "Id of the script to edit." },\\r\\n                    { "name": "scriptSource", "type": "string", "description": "New content of the script." },\\r\\n                    { "name": "preview", "type": "boolean", "optional": true, "description": " If true the change will not actually be applied. Preview mode may be used to get result description without actually modifying the code.", "hidden": true }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "callFrames", "type": "array", "optional": true, "items": { "$ref": "CallFrame"}, "description": "New stack trace in case editing has happened while VM was stopped." },\\r\\n                    { "name": "result", "type": "object", "optional": true, "description": "VM-specific description of the changes applied.", "hidden": true }\\r\\n                ],\\r\\n                "description": "Edits JavaScript source live."\\r\\n            },\\r\\n            {\\r\\n                "name": "restartFrame",\\r\\n                "parameters": [\\r\\n                    { "name": "callFrameId", "$ref": "CallFrameId", "description": "Call frame identifier to evaluate on." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "callFrames", "type": "array", "items": { "$ref": "CallFrame"}, "description": "New stack trace." },\\r\\n                    { "name": "result", "type": "object", "description": "VM-specific description.", "hidden": true }\\r\\n                ],\\r\\n                "hidden": true,\\r\\n                "description": "Restarts particular call frame from the beginning."\\r\\n            },\\r\\n            {\\r\\n                "name": "getScriptSource",\\r\\n                "parameters": [\\r\\n                    { "name": "scriptId", "$ref": "ScriptId", "description": "Id of the script to get source for." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "scriptSource", "type": "string", "description": "Script source." }\\r\\n                ],\\r\\n                "description": "Returns source for the script with given id."\\r\\n            },\\r\\n            {\\r\\n                "name": "getFunctionDetails",\\r\\n                "hidden": true,\\r\\n                "parameters": [\\r\\n                    { "name": "functionId", "$ref": "Runtime.RemoteObjectId", "description": "Id of the function to get location for." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "details", "$ref": "FunctionDetails", "description": "Information about the function." }\\r\\n                ],\\r\\n                "description": "Returns detailed informtation on given function."\\r\\n            },\\r\\n            {\\r\\n                "name": "setPauseOnExceptions",\\r\\n                "parameters": [\\r\\n                    { "name": "state", "type": "string", "enum": ["none", "uncaught", "all"], "description": "Pause on exceptions mode." }\\r\\n                ],\\r\\n                "description": "Defines pause on exceptions state. Can be set to stop on all exceptions, uncaught exceptions or no exceptions. Initial pause on exceptions state is <code>none</code>."\\r\\n            },\\r\\n            {\\r\\n                "name": "evaluateOnCallFrame",\\r\\n                "parameters": [\\r\\n                    { "name": "callFrameId", "$ref": "CallFrameId", "description": "Call frame identifier to evaluate on." },\\r\\n                    { "name": "expression", "type": "string", "description": "Expression to evaluate." },\\r\\n                    { "name": "objectGroup", "type": "string", "optional": true, "description": "String object group name to put result into (allows rapid releasing resulting object handles using <code>releaseObjectGroup</code>)." },\\r\\n                    { "name": "includeCommandLineAPI", "type": "boolean", "optional": true, "description": "Specifies whether command line API should be available to the evaluated expression, defaults to false.", "hidden": true },\\r\\n                    { "name": "doNotPauseOnExceptionsAndMuteConsole", "type": "boolean", "optional": true, "description": "Specifies whether evaluation should stop on exceptions and mute console. Overrides setPauseOnException state.", "hidden": true },\\r\\n                    { "name": "returnByValue", "type": "boolean", "optional": true, "description": "Whether the result is expected to be a JSON object that should be sent by value." },\\r\\n                    { "name": "generatePreview", "type": "boolean", "optional": true, "hidden": true, "description": "Whether preview should be generated for the result." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "result", "$ref": "Runtime.RemoteObject", "description": "Object wrapper for the evaluation result." },\\r\\n                    { "name": "wasThrown", "type": "boolean", "optional": true, "description": "True if the result was thrown during the evaluation." }\\r\\n                ],\\r\\n                "description": "Evaluates expression on a given call frame."\\r\\n            },\\r\\n            {\\r\\n                "name": "compileScript",\\r\\n                "hidden": true,\\r\\n                "parameters": [\\r\\n                    { "name": "expression", "type": "string", "description": "Expression to compile." },\\r\\n                    { "name": "sourceURL", "type": "string", "description": "Source url to be set for the script." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "scriptId", "$ref": "ScriptId", "optional": true, "description": "Id of the script." },\\r\\n                    { "name": "syntaxErrorMessage", "type": "string", "optional": true, "description": "Syntax error message if compilation failed." }\\r\\n                ],\\r\\n                "description": "Compiles expression."\\r\\n            },\\r\\n            {\\r\\n                "name": "runScript",\\r\\n                "hidden": true,\\r\\n                "parameters": [\\r\\n                    { "name": "scriptId", "$ref": "ScriptId", "description": "Id of the script to run." },\\r\\n                    { "name": "contextId", "$ref": "Runtime.ExecutionContextId", "optional": true, "description": "Specifies in which isolated context to perform script run. Each content script lives in an isolated context and this parameter may be used to specify one of those contexts. If the parameter is omitted or 0 the evaluation will be performed in the context of the inspected page." },\\r\\n                    { "name": "objectGroup", "type": "string", "optional": true, "description": "Symbolic group name that can be used to release multiple objects." },\\r\\n                    { "name": "doNotPauseOnExceptionsAndMuteConsole", "type": "boolean", "optional": true, "description": "Specifies whether script run should stop on exceptions and mute console. Overrides setPauseOnException state." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "result", "$ref": "Runtime.RemoteObject", "description": "Run result." },\\r\\n                    { "name": "wasThrown", "type": "boolean", "optional": true, "description": "True if the result was thrown during the script run." }\\r\\n                ],\\r\\n                "description": "Runs script with given id in a given context."\\r\\n            },\\r\\n            {\\r\\n                "name": "setOverlayMessage",\\r\\n                "parameters": [\\r\\n                    { "name": "message", "type": "string", "optional": true, "description": "Overlay message to display when paused in debugger." }\\r\\n                ],\\r\\n                "hidden": true,\\r\\n                "description": "Sets overlay message."\\r\\n            },\\r\\n            {\\r\\n                "name": "setVariableValue",\\r\\n                "parameters": [\\r\\n                    { "name": "callFrameId", "$ref": "CallFrameId", "optional": true, "description": "Id of callframe that holds variable." },\\r\\n                    { "name": "functionObjectId", "$ref": "Runtime.RemoteObjectId", "optional": true, "description": "Object id of closure (function) that holds variable." },\\r\\n                    { "name": "scopeNumber", "type": "integer", "description": "0-based number of scope as was listed in scope chain. Only \\\'local\\\', \\\'closure\\\' and \\\'catch\\\' scope types are allowed. Other scopes could be manipulated manually." },\\r\\n                    { "name": "variableName", "type": "string", "description": "Variable name." },\\r\\n                    { "name": "newValue", "$ref": "Runtime.CallArgument", "description": "New variable value." }\\r\\n                ],\\r\\n                "hidden": true,\\r\\n                "description": "Changes value of variable in a callframe or a closure. Either callframe or function must be specified. Object-based scopes are not supported and must be mutated manually."\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "globalObjectCleared",\\r\\n                "description": "Called when global has been cleared and debugger client should reset its state. Happens upon navigation or reload."\\r\\n            },\\r\\n            {\\r\\n                "name": "scriptParsed",\\r\\n                "parameters": [\\r\\n                    { "name": "scriptId", "$ref": "ScriptId", "description": "Identifier of the script parsed." },\\r\\n                    { "name": "url", "type": "string", "description": "URL or name of the script parsed (if any)." },\\r\\n                    { "name": "startLine", "type": "integer", "description": "Line offset of the script within the resource with given URL (for script tags)." },\\r\\n                    { "name": "startColumn", "type": "integer", "description": "Column offset of the script within the resource with given URL." },\\r\\n                    { "name": "endLine", "type": "integer", "description": "Last line of the script." },\\r\\n                    { "name": "endColumn", "type": "integer", "description": "Length of the last line of the script." },\\r\\n                    { "name": "isContentScript", "type": "boolean", "optional": true, "description": "Determines whether this script is a user extension script." },\\r\\n                    { "name": "sourceMapURL", "type": "string", "optional": true, "description": "URL of source map associated with script (if any)." },\\r\\n                    { "name": "hasSourceURL", "type": "boolean", "optional": true, "description": "True, if this script has sourceURL." }\\r\\n                ],\\r\\n                "description": "Fired when virtual machine parses script. This event is also fired for all known and uncollected scripts upon enabling debugger."\\r\\n            },\\r\\n            {\\r\\n                "name": "scriptFailedToParse",\\r\\n                "parameters": [\\r\\n                    { "name": "url", "type": "string", "description": "URL of the script that failed to parse." },\\r\\n                    { "name": "scriptSource", "type": "string", "description": "Source text of the script that failed to parse." },\\r\\n                    { "name": "startLine", "type": "integer", "description": "Line offset of the script within the resource." },\\r\\n                    { "name": "errorLine", "type": "integer", "description": "Line with error." },\\r\\n                    { "name": "errorMessage", "type": "string", "description": "Parse error message." }\\r\\n                ],\\r\\n                "description": "Fired when virtual machine fails to parse the script."\\r\\n            },\\r\\n            {\\r\\n                "name": "breakpointResolved",\\r\\n                "parameters": [\\r\\n                    { "name": "breakpointId", "$ref": "BreakpointId", "description": "Breakpoint unique identifier." },\\r\\n                    { "name": "location", "$ref": "Location", "description": "Actual breakpoint location." }\\r\\n                ],\\r\\n                "description": "Fired when breakpoint is resolved to an actual script and location."\\r\\n            },\\r\\n            {\\r\\n                "name": "paused",\\r\\n                "parameters": [\\r\\n                    { "name": "callFrames", "type": "array", "items": { "$ref": "CallFrame" }, "description": "Call stack the virtual machine stopped on." },\\r\\n                    { "name": "reason", "type": "string", "enum": [ "XHR", "DOM", "EventListener", "exception", "assert", "CSPViolation", "other" ], "description": "Pause reason." },\\r\\n                    { "name": "data", "type": "object", "optional": true, "description": "Object containing break-specific auxiliary properties." }\\r\\n                ],\\r\\n                "description": "Fired when the virtual machine stopped on breakpoint or exception or any other stop criteria."\\r\\n            },\\r\\n            {\\r\\n                "name": "resumed",\\r\\n                "description": "Fired when the virtual machine resumed execution."\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "DOMDebugger",\\r\\n        "description": "DOM debugging allows setting breakpoints on particular DOM operations and events. JavaScript execution will stop on these operations as if there was a regular breakpoint set.",\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "DOMBreakpointType",\\r\\n                "type": "string",\\r\\n                "enum": ["subtree-modified", "attribute-modified", "node-removed"],\\r\\n                "description": "DOM breakpoint type."\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "setDOMBreakpoint",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "DOM.NodeId", "description": "Identifier of the node to set breakpoint on." },\\r\\n                    { "name": "type", "$ref": "DOMBreakpointType", "description": "Type of the operation to stop upon." }\\r\\n                ],\\r\\n                "description": "Sets breakpoint on particular operation with DOM."\\r\\n            },\\r\\n            {\\r\\n                "name": "removeDOMBreakpoint",\\r\\n                "parameters": [\\r\\n                    { "name": "nodeId", "$ref": "DOM.NodeId", "description": "Identifier of the node to remove breakpoint from." },\\r\\n                    { "name": "type", "$ref": "DOMBreakpointType", "description": "Type of the breakpoint to remove." }\\r\\n                ],\\r\\n                "description": "Removes DOM breakpoint that was set using <code>setDOMBreakpoint</code>."\\r\\n            },\\r\\n            {\\r\\n                "name": "setEventListenerBreakpoint",\\r\\n                "parameters": [\\r\\n                    { "name": "eventName", "type": "string", "description": "DOM Event name to stop on (any DOM event will do)." }\\r\\n                ],\\r\\n                "description": "Sets breakpoint on particular DOM event."\\r\\n            },\\r\\n            {\\r\\n                "name": "removeEventListenerBreakpoint",\\r\\n                "parameters": [\\r\\n                    { "name": "eventName", "type": "string", "description": "Event name." }\\r\\n                ],\\r\\n                "description": "Removes breakpoint on particular DOM event."\\r\\n            },\\r\\n            {\\r\\n                "name": "setInstrumentationBreakpoint",\\r\\n                "parameters": [\\r\\n                    { "name": "eventName", "type": "string", "description": "Instrumentation name to stop on." }\\r\\n                ],\\r\\n                "description": "Sets breakpoint on particular native event.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "removeInstrumentationBreakpoint",\\r\\n                "parameters": [\\r\\n                    { "name": "eventName", "type": "string", "description": "Instrumentation name to stop on." }\\r\\n                ],\\r\\n                "description": "Sets breakpoint on particular native event.",\\r\\n                "hidden": true\\r\\n            },\\r\\n            {\\r\\n                "name": "setXHRBreakpoint",\\r\\n                "parameters": [\\r\\n                    { "name": "url", "type": "string", "description": "Resource URL substring. All XHRs having this substring in the URL will get stopped upon." }\\r\\n                ],\\r\\n                "description": "Sets breakpoint on XMLHttpRequest."\\r\\n            },\\r\\n            {\\r\\n                "name": "removeXHRBreakpoint",\\r\\n                "parameters": [\\r\\n                    { "name": "url", "type": "string", "description": "Resource URL substring." }\\r\\n                ],\\r\\n                "description": "Removes breakpoint from XMLHttpRequest."\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Profiler",\\r\\n        "hidden": true,\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "ProfileHeader",\\r\\n                "type": "object",\\r\\n                "description": "Profile header.",\\r\\n                "properties": [\\r\\n                    { "name": "typeId", "type": "string", "enum": ["CPU", "CSS", "HEAP"], "description": "Profile type name." },\\r\\n                    { "name": "title", "type": "string", "description": "Profile title." },\\r\\n                    { "name": "uid", "type": "integer", "description": "Unique identifier of the profile." },\\r\\n                    { "name": "maxJSObjectId", "type": "integer", "optional": true, "description": "Last seen JS object Id." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "CPUProfileNode",\\r\\n                "type": "object",\\r\\n                "description": "CPU Profile node. Holds callsite information, execution statistics and child nodes.",\\r\\n                "properties": [\\r\\n                    { "name": "functionName", "type": "string", "description": "Function name." },\\r\\n                    { "name": "url", "type": "string", "description": "URL." },\\r\\n                    { "name": "lineNumber", "type": "integer", "description": "Line number." },\\r\\n                    { "name": "totalTime", "type": "number", "description": "Total execution time." },\\r\\n                    { "name": "selfTime", "type": "number", "description": "Self time." },\\r\\n                    { "name": "numberOfCalls", "type": "integer", "description": "Number of calls." },\\r\\n                    { "name": "visible", "type": "boolean", "description": "Visibility." },\\r\\n                    { "name": "callUID", "type": "number", "description": "Call UID." },\\r\\n                    { "name": "children", "type": "array", "items": { "$ref": "CPUProfileNode" }, "description": "Child nodes." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "CPUProfile",\\r\\n                "type": "object",\\r\\n                "description": "Profile.",\\r\\n                "properties": [\\r\\n                    { "name": "head", "$ref": "CPUProfileNode", "optional": true },\\r\\n                    { "name": "bottomUpHead", "$ref": "CPUProfileNode", "optional": true },\\r\\n                    { "name": "idleTime", "type": "number", "optional": true }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "HeapSnapshotObjectId",\\r\\n                "type": "string",\\r\\n                "description": "Heap snashot object id."\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "causesRecompilation",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "isSampling",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "hasHeapProfiler",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "enable"\\r\\n            },\\r\\n            {\\r\\n                "name": "disable"\\r\\n            },\\r\\n            {\\r\\n                "name": "start"\\r\\n            },\\r\\n            {\\r\\n                "name": "stop"\\r\\n            },\\r\\n            {\\r\\n                "name": "getProfileHeaders",\\r\\n                "returns": [\\r\\n                    { "name": "headers", "type": "array", "items": { "$ref": "ProfileHeader"} }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "getCPUProfile",\\r\\n                "parameters": [\\r\\n                    { "name": "uid", "type": "integer" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "profile", "$ref": "CPUProfile" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "getHeapSnapshot",\\r\\n                "parameters": [\\r\\n                    { "name": "uid", "type": "integer" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "removeProfile",\\r\\n                "parameters": [\\r\\n                    { "name": "type", "type": "string" },\\r\\n                    { "name": "uid", "type": "integer" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "clearProfiles"\\r\\n            },\\r\\n            {\\r\\n                "name": "takeHeapSnapshot",\\r\\n                "parameters": [\\r\\n                    { "name": "reportProgress", "type": "boolean", "optional": true, "description": "If true \\\'reportHeapSnapshotProgress\\\' events will be generated while snapshot is being taken." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "collectGarbage"\\r\\n            },\\r\\n            {\\r\\n                "name": "getObjectByHeapObjectId",\\r\\n                "parameters": [\\r\\n                    { "name": "objectId", "$ref": "HeapSnapshotObjectId" },\\r\\n                    { "name": "objectGroup", "type": "string", "optional": true, "description": "Symbolic group name that can be used to release multiple objects." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "result", "$ref": "Runtime.RemoteObject", "description": "Evaluation result." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "getHeapObjectId",\\r\\n                "parameters": [\\r\\n                    { "name": "objectId", "$ref": "Runtime.RemoteObjectId", "description": "Identifier of the object to get heap object id for." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "heapSnapshotObjectId", "$ref": "HeapSnapshotObjectId", "description": "Id of the heap snapshot object corresponding to the passed remote object id." }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "addProfileHeader",\\r\\n                "parameters": [\\r\\n                    { "name": "header", "$ref": "ProfileHeader" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "addHeapSnapshotChunk",\\r\\n                "parameters": [\\r\\n                    { "name": "uid", "type": "integer" },\\r\\n                    { "name": "chunk", "type": "string" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "finishHeapSnapshot",\\r\\n                "parameters": [\\r\\n                    { "name": "uid", "type": "integer" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "setRecordingProfile",\\r\\n                "parameters": [\\r\\n                    { "name": "isProfiling", "type": "boolean" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "resetProfiles"\\r\\n            },\\r\\n            {\\r\\n                "name": "reportHeapSnapshotProgress",\\r\\n                "parameters": [\\r\\n                    { "name": "done", "type": "integer" },\\r\\n                    { "name": "total", "type": "integer" }\\r\\n                ]\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Worker",\\r\\n        "hidden": true,\\r\\n        "types": [],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable"\\r\\n            },\\r\\n            {\\r\\n                "name": "disable"\\r\\n            },\\r\\n            {\\r\\n                "name": "sendMessageToWorker",\\r\\n                "parameters": [\\r\\n                    { "name": "workerId", "type": "integer" },\\r\\n                    { "name": "message", "type": "object" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "connectToWorker",\\r\\n                "parameters": [\\r\\n                    { "name": "workerId", "type": "integer" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "disconnectFromWorker",\\r\\n                "parameters": [\\r\\n                    { "name": "workerId", "type": "integer" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "setAutoconnectToWorkers",\\r\\n                "parameters": [\\r\\n                    { "name": "value", "type": "boolean" }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "workerCreated",\\r\\n                "parameters": [\\r\\n                    { "name": "workerId", "type": "integer" },\\r\\n                    { "name": "url", "type": "string" },\\r\\n                    { "name": "inspectorConnected", "type": "boolean" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "workerTerminated",\\r\\n                "parameters": [\\r\\n                    { "name": "workerId", "type": "integer" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "dispatchMessageFromWorker",\\r\\n                "parameters": [\\r\\n                    { "name": "workerId", "type": "integer" },\\r\\n                    { "name": "message", "type": "object" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "disconnectedFromWorker"\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Canvas",\\r\\n        "hidden": true,\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "ResourceId",\\r\\n                "type": "string",\\r\\n                "description": "Unique resource identifier."\\r\\n            },\\r\\n            {\\r\\n                "id": "ResourceInfo",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "id", "$ref": "ResourceId" },\\r\\n                    { "name": "description", "type": "string" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "ResourceState",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "id", "$ref": "ResourceId" },\\r\\n                    { "name": "traceLogId", "$ref": "TraceLogId" },\\r\\n                    { "name": "imageURL", "type": "string", "optional": true, "description": "Screenshot image data URL." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "CallArgument",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "description", "type": "string" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "Call",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "contextId", "$ref": "ResourceId" },\\r\\n                    { "name": "functionName", "type": "string", "optional": true },\\r\\n                    { "name": "arguments", "type": "array", "items": { "$ref": "CallArgument" }, "optional": true },\\r\\n                    { "name": "result", "$ref": "CallArgument", "optional": true },\\r\\n                    { "name": "isDrawingCall", "type": "boolean", "optional": true },\\r\\n                    { "name": "property", "type": "string", "optional": true },\\r\\n                    { "name": "value", "$ref": "CallArgument", "optional": true },\\r\\n                    { "name": "sourceURL", "type": "string", "optional": true },\\r\\n                    { "name": "lineNumber", "type": "integer", "optional": true },\\r\\n                    { "name": "columnNumber", "type": "integer", "optional": true }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "TraceLogId",\\r\\n                "type": "string",\\r\\n                "description": "Unique trace log identifier."\\r\\n            },\\r\\n            {\\r\\n                "id": "TraceLog",\\r\\n                "type": "object",\\r\\n                "properties": [\\r\\n                    { "name": "id", "$ref": "TraceLogId" },\\r\\n                    { "name": "calls", "type": "array", "items": { "$ref": "Call" } },\\r\\n                    { "name": "startOffset", "type": "integer" },\\r\\n                    { "name": "alive", "type": "boolean" },\\r\\n                    { "name": "totalAvailableCalls", "type": "number" }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables Canvas inspection."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables Canvas inspection."\\r\\n            },\\r\\n            {\\r\\n                "name": "dropTraceLog",\\r\\n                "parameters": [\\r\\n                    { "name": "traceLogId", "$ref": "TraceLogId" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "hasUninstrumentedCanvases",\\r\\n                "returns": [\\r\\n                    { "name": "result", "type": "boolean" }\\r\\n                ],\\r\\n                "description": "Checks if there is any uninstrumented canvas in the inspected page."\\r\\n            },\\r\\n            {\\r\\n                "name": "captureFrame",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "optional": true, "description": "Identifier of the frame containing document whose canvases are to be captured. If omitted, main frame is assumed." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "traceLogId", "$ref": "TraceLogId", "description": "Identifier of the trace log containing captured canvas calls." }\\r\\n                ],\\r\\n                "description": "Starts (or continues) a canvas frame capturing which will be stopped automatically after the next frame is prepared."\\r\\n            },\\r\\n            {\\r\\n                "name": "startCapturing",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "optional": true, "description": "Identifier of the frame containing document whose canvases are to be captured. If omitted, main frame is assumed." }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "traceLogId", "$ref": "TraceLogId", "description": "Identifier of the trace log containing captured canvas calls." }\\r\\n                ],\\r\\n                "description": "Starts (or continues) consecutive canvas frames capturing. The capturing is stopped by the corresponding stopCapturing command."\\r\\n            },\\r\\n            {\\r\\n                "name": "stopCapturing",\\r\\n                "parameters": [\\r\\n                    { "name": "traceLogId", "$ref": "TraceLogId" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "getTraceLog",\\r\\n                "parameters": [\\r\\n                    { "name": "traceLogId", "$ref": "TraceLogId" },\\r\\n                    { "name": "startOffset", "type": "integer", "optional": true },\\r\\n                    { "name": "maxLength", "type": "integer", "optional": true }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "traceLog", "$ref": "TraceLog" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "replayTraceLog",\\r\\n                "parameters": [\\r\\n                    { "name": "traceLogId", "$ref": "TraceLogId" },\\r\\n                    { "name": "stepNo", "type": "integer" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "resourceState", "$ref": "ResourceState" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "getResourceInfo",\\r\\n                "parameters": [\\r\\n                    { "name": "resourceId", "$ref": "ResourceId" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "resourceInfo", "$ref": "ResourceInfo" }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "getResourceState",\\r\\n                "parameters": [\\r\\n                    { "name": "traceLogId", "$ref": "TraceLogId" },\\r\\n                    { "name": "resourceId", "$ref": "ResourceId" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "resourceState", "$ref": "ResourceState" }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "contextCreated",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "description": "Identifier of the frame containing a canvas with a context." }\\r\\n                ],\\r\\n                "description": "Fired when a canvas context has been created in the given frame. The context may not be instrumented (see hasUninstrumentedCanvases command)."\\r\\n            },\\r\\n            {\\r\\n                "name": "traceLogsRemoved",\\r\\n                "parameters": [\\r\\n                    { "name": "frameId", "$ref": "Network.FrameId", "optional": true, "description": "If given, trace logs from the given frame were removed." },\\r\\n                    { "name": "traceLogId", "$ref": "TraceLogId", "optional": true, "description": "If given, trace log with the given ID was removed." }\\r\\n                ],\\r\\n                "description": "Fired when a set of trace logs were removed from the backend. If no parameters are given, all trace logs were removed."\\r\\n            }\\r\\n        ]\\r\\n    },\\r\\n    {\\r\\n        "domain": "Input",\\r\\n        "hidden": true,\\r\\n        "types": [],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "dispatchKeyEvent",\\r\\n                "parameters": [\\r\\n                    { "name": "type", "type": "string", "enum": ["keyDown", "keyUp", "rawKeyDown", "char"], "description": "Type of the key event." },\\r\\n                    { "name": "modifiers", "type": "integer", "optional": true, "description": "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0)." },\\r\\n                    { "name": "timestamp", "type": "number", "optional": true, "description": "Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970 (default: current time)." },\\r\\n                    { "name": "text", "type": "string", "optional": true, "description": "Text as generated by processing a virtual key code with a keyboard layout. Not needed for for <code>keyUp</code> and <code>rawKeyDown</code> events (default: \\\\"\\\\")" },\\r\\n                    { "name": "unmodifiedText", "type": "string", "optional": true, "description": "Text that would have been generated by the keyboard if no modifiers were pressed (except for shift). Useful for shortcut (accelerator) key handling (default: \\\\"\\\\")." },\\r\\n                    { "name": "keyIdentifier", "type": "string", "optional": true, "description": "Unique key identifier (e.g., \\\'U+0041\\\') (default: \\\\"\\\\")." },\\r\\n                    { "name": "windowsVirtualKeyCode", "type": "integer", "optional": true, "description": "Windows virtual key code (default: 0)." },\\r\\n                    { "name": "nativeVirtualKeyCode", "type": "integer", "optional": true, "description": "Native virtual key code (default: 0)." },\\r\\n                    { "name": "macCharCode", "type": "integer", "optional": true, "description": "Mac character code (default: 0)." },\\r\\n                    { "name": "autoRepeat", "type": "boolean", "optional": true, "description": "Whether the event was generated from auto repeat (default: false)." },\\r\\n                    { "name": "isKeypad", "type": "boolean", "optional": true, "description": "Whether the event was generated from the keypad (default: false)." },\\r\\n                    { "name": "isSystemKey", "type": "boolean", "optional": true, "description": "Whether the event was a system key event (default: false)." }\\r\\n                ],\\r\\n                "description": "Dispatches a key event to the page."\\r\\n            },\\r\\n            {\\r\\n                "name": "dispatchMouseEvent",\\r\\n                "parameters": [\\r\\n                    { "name": "type", "type": "string", "enum": ["mousePressed", "mouseReleased", "mouseMoved"], "description": "Type of the mouse event." },\\r\\n                    { "name": "x", "type": "integer", "description": "X coordinate of the event relative to the main frame\\\'s viewport."},\\r\\n                    { "name": "y", "type": "integer", "description": "Y coordinate of the event relative to the main frame\\\'s viewport. 0 refers to the top of the viewport and Y increases as it proceeds towards the bottom of the viewport."},\\r\\n                    { "name": "modifiers", "type": "integer", "optional": true, "description": "Bit field representing pressed modifier keys. Alt=1, Ctrl=2, Meta/Command=4, Shift=8 (default: 0)." },\\r\\n                    { "name": "timestamp", "type": "number", "optional": true, "description": "Time at which the event occurred. Measured in UTC time in seconds since January 1, 1970 (default: current time)." },\\r\\n                    { "name": "button", "type": "string", "enum": ["none", "left", "middle", "right"], "optional": true, "description": "Mouse button (default: \\\\"none\\\\")." },\\r\\n                    { "name": "clickCount", "type": "integer", "optional": true, "description": "Number of times the mouse button was clicked (default: 0)." }\\r\\n                ],\\r\\n                "description": "Dispatches a mouse event to the page."\\r\\n            }\\r\\n        ],\\r\\n        "events": []\\r\\n    },\\r\\n    {\\r\\n        "domain": "LayerTree",\\r\\n        "hidden": true,\\r\\n        "types": [\\r\\n            {\\r\\n                "id": "LayerId",\\r\\n                "type": "string",\\r\\n                "description": "Unique RenderLayer identifier."\\r\\n            },\\r\\n            {\\r\\n                "id": "IntRect",\\r\\n                "type": "object",\\r\\n                "description": "A rectangle.",\\r\\n                "properties": [\\r\\n                    { "name": "x", "type": "integer", "description": "The x position." },\\r\\n                    { "name": "y", "type": "integer", "description": "The y position." },\\r\\n                    { "name": "width", "type": "integer", "description": "The width metric." },\\r\\n                    { "name": "height", "type": "integer", "description": "The height metric." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "id": "Layer",\\r\\n                "type": "object",\\r\\n                "description": "Information about a compositing layer.",\\r\\n                "properties": [\\r\\n                    { "name": "layerId", "$ref": "LayerId", "description": "The unique id for this layer." },\\r\\n                    { "name": "bounds", "$ref": "IntRect", "description": "Bounds of the layer." },\\r\\n                    { "name": "isComposited", "type": "boolean", "description": "Indicates whether this layer is composited." },\\r\\n                    { "name": "paintCount", "type": "integer", "optional": true, "description": "Indicates how many time this layer has painted." },\\r\\n                    { "name": "memory", "type": "integer", "optional": true, "description": "Estimated memory used by this layer." },\\r\\n                    { "name": "compositedBounds", "$ref": "IntRect", "optional": true, "description": "The bounds of the composited layer." },\\r\\n                    { "name": "childLayers", "type": "array", "optional": true, "items": { "$ref": "Layer" }, "description": "Child layers." }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "commands": [\\r\\n            {\\r\\n                "name": "enable",\\r\\n                "description": "Enables compositing tree inspection."\\r\\n            },\\r\\n            {\\r\\n                "name": "disable",\\r\\n                "description": "Disables compositing tree inspection."\\r\\n            },\\r\\n            {\\r\\n                "name": "getLayerTree",\\r\\n                "description": "Returns the layer tree structure of the current page.",\\r\\n                "returns": [\\r\\n                    { "name": "layerTree", "$ref": "Layer", "description": "Layer tree structure of the current page." }\\r\\n                ]\\r\\n            },\\r\\n            {\\r\\n                "name": "nodeIdForLayerId",\\r\\n                "description": "Returns the node id for a given layer id.",\\r\\n                "parameters": [\\r\\n                    { "name": "layerId", "$ref": "LayerId" }\\r\\n                ],\\r\\n                "returns": [\\r\\n                    { "name": "nodeId", "$ref": "DOM.NodeId", "description": "The node id for the given layer id." }\\r\\n                ]\\r\\n            }\\r\\n        ],\\r\\n        "events": [\\r\\n            {\\r\\n                "name": "layerTreeDidChange"\\r\\n            }\\r\\n        ]\\r\\n    }]\\r\\n}\\r\\n\';});\n\n//# sourceURL=/text!LiveDevelopment/Inspector/Inspector.json'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $, WebSocket, FileError, window, XMLHttpRequest */\r\n\r\n /**\r\n * Inspector manages the connection to Chrome/Chromium\'s remote debugger.\r\n * See inspector.html for the documentation of the remote debugger.\r\n *\r\n * __SETUP__\r\n *\r\n * To enable remote debugging in Chrome or Chromium open either application\r\n * with the following parameters:\r\n *\r\n *     --enable-remote-debugger --remote-debugging-port=9222\r\n *\r\n * This will open an HTTP server on the specified port, which can be used to\r\n * browse the available remote debugger sessions. In general, every open\r\n * browser tab can host an individual remote debugger session. The\r\n * available interfaces can be exported by requesting:\r\n *\r\n *     http://127.0.0.1:9222/json\r\n *\r\n * The response is a JSON-formatted array that specifies all available remote\r\n * debugger sessions including the remote debugging web sockets.\r\n *\r\n * Inspector can connect directly to a web socket via `connect(socketURL)`, or\r\n * it can find the web socket that corresponds to the tab at the given URL and\r\n * connect to it via `connectToURL(url)`. The later returns a promise. To \r\n * disconnect use `disconnect()`.\r\n *\r\n * __EVENTS__\r\n *\r\n * Inspector dispatches several connectivity-related events + all remote debugger\r\n * events (see below). Event handlers are attached via `on(event, function)` and\r\n * detached via `off(event, function)`.\r\n *\r\n *   `connect`    Inspector did successfully connect to the remote debugger\r\n *   `disconnect` Inspector did disconnect from the remote debugger\r\n *   `error`      Inspector encountered an error\r\n *   `message`    Inspector received a message from the remote debugger - this\r\n *                provides a low-level entry point to remote debugger events\r\n *\r\n * __REMOTE DEBUGGER COMMANDS__\r\n *\r\n * Commands are executed by calling `{Domain}.{Command}()` with the parameters\r\n * specified in the order of the remote debugger documentation. These command\r\n * functions are generated automatically at runtime from Inspector.json. The\r\n * actual implementation of these functions is found in\r\n * `_send(method, signature, varargs)`, which verifies, serializes, and\r\n * transmits the command to the remote debugger. If the last parameter of any\r\n * command function call is a function, it will be used as the callback.\r\n *\r\n * __REMOTE DEBUGGER EVENTS__\r\n *\r\n * Debugger events are dispatched as regular events using {Domain}.{Event} as\r\n * the event name. The handler function will be called with a single parameter\r\n * that stores all returned values as an object.\r\n */\r\ndefine(\'LiveDevelopment/Inspector/Inspector\',[\'require\',\'exports\',\'module\',\'utils/Async\',\'text!LiveDevelopment/Inspector/Inspector.json\'],function Inspector(require, exports, module) {\r\n    "use strict";\r\n\r\n    var Async = require("utils/Async");\r\n\r\n    // jQuery exports object for events\r\n    var $exports = $(exports);\r\n\r\n    /**\r\n     * Map message IDs to the callback function and original JSON message\r\n     * @type {Object.<number, {callback: function, message: Object}}\r\n     */\r\n    var _messageCallbacks = {};\r\n\r\n    var _messageId = 1,     // id used for remote method calls, auto-incrementing\r\n        _socket,            // remote debugger WebSocket\r\n        _connectDeferred,   // The deferred connect\r\n        _userAgent = "";    // user agent string\r\n\r\n    /** Check a parameter value against the given signature\r\n     * This only checks for optional parameters, not types\r\n     * Type checking is complex because of $ref and done on the remote end anyways\r\n     * @param {signature}\r\n     * @param {value}\r\n     */\r\n    function _verifySignature(signature, value) {\r\n        if (value === undefined) {\r\n            console.assert(signature.optional === true, "Missing argument: " + signature.name);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /** Send a message to the remote debugger\r\n     * All passed arguments after the signature are passed on as parameters.\r\n     * If the last argument is a function, it is used as the callback function.\r\n     * @param {string} remote method\r\n     * @param {object} the method signature\r\n     */\r\n    function _send(method, signature, varargs) {\r\n        if (!_socket) {\r\n            console.log("You must connect to the WebSocket before sending messages.");\r\n\r\n            // FUTURE: Our current implementation closes and re-opens an inspector connection whenever\r\n            // a new HTML file is selected. If done quickly enough, pending requests from the previous\r\n            // connection could come in before the new socket connection is established. For now we \r\n            // simply ignore this condition. \r\n            // This race condition will go away once we support multiple inspector connections and turn\r\n            // off auto re-opening when a new HTML file is selected.\r\n            return (new $.Deferred()).reject().promise();\r\n        }\r\n\r\n        var id, callback, args, i, params = {}, promise, msg;\r\n\r\n        // extract the parameters, the callback function, and the message id\r\n        args = Array.prototype.slice.call(arguments, 2);\r\n        if (typeof args[args.length - 1] === "function") {\r\n            callback = args.pop();\r\n        } else {\r\n            var deferred = new $.Deferred();\r\n            promise = deferred.promise();\r\n            callback = function (result, error) {\r\n                if (error) {\r\n                    deferred.reject(error);\r\n                } else {\r\n                    deferred.resolve(result);\r\n                }\r\n            };\r\n        }\r\n\r\n        id = _messageId++;\r\n\r\n        // verify the parameters against the method signature\r\n        // this also constructs the params object of type {name -> value}\r\n        if (signature) {\r\n            for (i in signature) {\r\n                if (_verifySignature(args[i], signature[i])) {\r\n                    params[signature[i].name] = args[i];\r\n                }\r\n            }\r\n        }\r\n\r\n        // Store message callback and send message\r\n        msg = { method: method, id: id, params: params };\r\n        _messageCallbacks[id] = { callback: callback, message: msg };\r\n        _socket.send(JSON.stringify(msg));\r\n\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * Manually send a message to the remote debugger\r\n     * All passed arguments after the command are passed on as parameters.\r\n     * If the last argument is a function, it is used as the callback function.\r\n     * @param {string} domain\r\n     * @param {string} command\r\n     */\r\n    function send(domain, command, varargs) {\r\n        return _send(domain + "." + command, null, varargs);\r\n    }\r\n\r\n    /** WebSocket did close */\r\n    function _onDisconnect() {\r\n        _socket = undefined;\r\n        $exports.triggerHandler("disconnect");\r\n    }\r\n\r\n    /** WebSocket reported an error */\r\n    function _onError(error) {\r\n        if (_connectDeferred) {\r\n            _connectDeferred.reject();\r\n            _connectDeferred = null;\r\n        }\r\n        $exports.triggerHandler("error", [error]);\r\n    }\r\n\r\n    /** WebSocket did open */\r\n    function _onConnect() {\r\n        if (_connectDeferred) {\r\n            _connectDeferred.resolve();\r\n            _connectDeferred = null;\r\n        }\r\n        $exports.triggerHandler("connect");\r\n    }\r\n\r\n    /** Received message from the WebSocket\r\n     * A message can be one of three things:\r\n     *   1. an error -> report it\r\n     *   2. the response to a previous command -> run the stored callback\r\n     *   3. an event -> trigger an event handler method\r\n     * @param {object} message\r\n     */\r\n    function _onMessage(message) {\r\n        var response    = JSON.parse(message.data),\r\n            msgRecord   = _messageCallbacks[response.id],\r\n            callback    = msgRecord && msgRecord.callback,\r\n            msgText     = (msgRecord && msgRecord.message) || "No message";\r\n\r\n        if (msgRecord) {\r\n            // Messages with an ID are a response to a command, fire callback\r\n            callback(response.result, response.error);\r\n            delete _messageCallbacks[response.id];\r\n        } else if (response.method) {\r\n            // Messages with a method are an event, trigger event handlers\r\n            var domainAndMethod = response.method.split("."),\r\n                domain = domainAndMethod[0],\r\n                method = domainAndMethod[1];\r\n\r\n            $(exports[domain]).triggerHandler(method, response.params);\r\n        }\r\n\r\n        // Always fire event handlers for all messages/errors\r\n        $exports.triggerHandler("message", [response]);\r\n\r\n        if (response.error) {\r\n            $exports.triggerHandler("error", [response.error, msgText]);\r\n        }\r\n    }\r\n\r\n\r\n    /** Public Functions *****************************************************/\r\n\r\n    /** Get a list of the available windows/tabs/extensions that are remote-debuggable\r\n     * @param {string} host IP or name\r\n     * @param {integer} debugger port\r\n     */\r\n    function getDebuggableWindows(host, port) {\r\n        if (!host) {\r\n            host = "127.0.0.1";\r\n        }\r\n        if (!port) {\r\n            port = 9222;\r\n        }\r\n        var def = new $.Deferred();\r\n        var request = new XMLHttpRequest();\r\n        request.open("GET", "http://" + host + ":" + port + "/json");\r\n        request.onload = function onLoad() {\r\n            var sockets = JSON.parse(request.response);\r\n            def.resolve(sockets);\r\n        };\r\n        request.onerror = function onError() {\r\n            def.reject(request.response);\r\n        };\r\n\r\n        request.send(null);\r\n\r\n        return def.promise();\r\n    }\r\n\r\n    /** Register a handler to be called when the given event is triggered\r\n     * @param {string} event name\r\n     * @param {function} handler function\r\n     */\r\n    function on(name, handler) {\r\n        $exports.on(name, handler);\r\n    }\r\n\r\n    /** Remove the given or all event handler(s) for the given event or remove all event handlers\r\n     * @param {string} optional event name\r\n     * @param {function} optional handler function\r\n     */\r\n    function off(name, handler) {\r\n        $exports.off(name, handler);\r\n    }\r\n\r\n    /**\r\n     * Disconnect from the remote debugger WebSocket\r\n     * @return {jQuery.Promise} Promise that is resolved immediately if not\r\n     *     currently connected or asynchronously when the socket is closed.\r\n     */\r\n    function disconnect() {\r\n        var deferred = new $.Deferred(),\r\n            promise = deferred.promise();\r\n\r\n        if (_socket && (_socket.readyState === WebSocket.OPEN)) {\r\n            _socket.onclose = function () {\r\n                // trigger disconnect event\r\n                _onDisconnect();\r\n\r\n                deferred.resolve();\r\n            };\r\n\r\n            promise = Async.withTimeout(promise, 5000);\r\n\r\n            _socket.close();\r\n        } else {\r\n            if (_socket) {\r\n                delete _socket.onmessage;\r\n                delete _socket.onopen;\r\n                delete _socket.onclose;\r\n                delete _socket.onerror;\r\n\r\n                _socket = undefined;\r\n            }\r\n            \r\n            deferred.resolve();\r\n        }\r\n\r\n        return promise;\r\n    }\r\n    \r\n    /**\r\n     * Connect to the remote debugger WebSocket at the given URL.\r\n     * Clients must listen for the `connect` event.\r\n     * @param {string} WebSocket URL\r\n     */\r\n    function connect(socketURL) {\r\n        disconnect().done(function () {\r\n            _socket = new WebSocket(socketURL);\r\n            _socket.onmessage = _onMessage;\r\n            _socket.onopen = _onConnect;\r\n            _socket.onclose = _onDisconnect;\r\n            _socket.onerror = _onError;\r\n        });\r\n    }\r\n\r\n    /** Connect to the remote debugger of the page that is at the given URL\r\n     * @param {string} url\r\n     */\r\n    function connectToURL(url) {\r\n        if (_connectDeferred) {\r\n            // reject an existing connection attempt\r\n            _connectDeferred.reject("CANCEL");\r\n        }\r\n        var deferred = new $.Deferred();\r\n        _connectDeferred = deferred;\r\n        var promise = getDebuggableWindows();\r\n        promise.done(function onGetAvailableSockets(response) {\r\n            var i, page;\r\n            for (i in response) {\r\n                page = response[i];\r\n                if (page.webSocketDebuggerUrl && page.url.indexOf(url) === 0) {\r\n                    connect(page.webSocketDebuggerUrl);\r\n                    // _connectDeferred may be resolved by onConnect or rejected by onError\r\n                    return;\r\n                }\r\n            }\r\n            deferred.reject(FileError.ERR_NOT_FOUND); // Reject with a "not found" error\r\n        });\r\n        promise.fail(function onFail(err) {\r\n            deferred.reject(err);\r\n        });\r\n        return deferred.promise();\r\n    }\r\n\r\n    /** Check if the inspector is connected */\r\n    function connected() {\r\n        return _socket !== undefined && _socket.readyState === WebSocket.OPEN;\r\n    }\r\n\r\n    /**\r\n     * Get user agent string\r\n     * @return {string}\r\n     */\r\n    function getUserAgent() {\r\n        return _userAgent;\r\n    }\r\n\r\n    /**\r\n     * Set user agent string\r\n     * @param {string} userAgent User agent string returned from Chrome\r\n     */\r\n    function setUserAgent(userAgent) {\r\n        _userAgent = userAgent;\r\n    }\r\n\r\n    /** Initialize the Inspector\r\n     * Read the Inspector.json configuration and define the command objects\r\n     * -> Inspector.domain.command()\r\n     */\r\n    function init(theConfig) {\r\n        exports.config = theConfig;\r\n\r\n        var InspectorText = require("text!LiveDevelopment/Inspector/Inspector.json"),\r\n            InspectorJSON = JSON.parse(InspectorText);\r\n        \r\n        var i, j, domain, domainDef, command;\r\n        for (i in InspectorJSON.domains) {\r\n            domain = InspectorJSON.domains[i];\r\n            exports[domain.domain] = {};\r\n            for (j in domain.commands) {\r\n                command = domain.commands[j];\r\n                exports[domain.domain][command.name] = _send.bind(undefined, domain.domain + "." + command.name, command.parameters);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Export public functions\r\n    exports.connect              = connect;\r\n    exports.connected            = connected;\r\n    exports.connectToURL         = connectToURL;\r\n    exports.disconnect           = disconnect;\r\n    exports.getDebuggableWindows = getDebuggableWindows;\r\n    exports.getUserAgent         = getUserAgent;\r\n    exports.init                 = init;\r\n    exports.off                  = off;\r\n    exports.on                   = on;\r\n    exports.send                 = send;\r\n    exports.setUserAgent         = setUserAgent;\r\n});\r\n\n//# sourceURL=/LiveDevelopment/Inspector/Inspector.js'),eval('define(\'text!widgets/StatusBar.html\',[],function () { return \'<div id="status-bar" class="statusbar no-focus">\\r\\n    <div id="status-info" class="info" >\\r\\n        <div id="status-cursor"></div>\\r\\n        <div id="status-file"></div>\\r\\n    </div>\\r\\n    <div id="status-indicators" class="indicators">\\r\\n        <div id="status-indent">\\r\\n            <div id="indent-type"></div>\\r\\n            <div id="indent-width-label"></div>\\r\\n            <input id="indent-width-input" type="number" min="1" max="10" maxlength="2" size="2" class="hidden">\\r\\n        </div>\\r\\n        <div id="status-language"></div>\\r\\n        <div id="status-overwrite">{{STATUSBAR_INSERT}}</div>\\r\\n        <div class="spinner"></div>\\r\\n    </div>\\r\\n</div>\\r\\n\';});\n\n//# sourceURL=/text!widgets/StatusBar.html'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets, window, document, Mustache */\r\n\r\n/**\r\n * A status bar with support for file information and busy and status indicators. This is a semi-generic\r\n * container; for the code that decides what content appears in the status bar, see client modules like\r\n * EditorStatusBar. (Although in practice StatusBar\'s HTML structure and initialization\r\n * assume it\'s only used for this one purpose, and all the APIs are on a singleton).\r\n */\r\ndefine(\'widgets/StatusBar\',[\'require\',\'exports\',\'module\',\'utils/AppInit\',\'text!widgets/StatusBar.html\',\'editor/EditorManager\',\'strings\',\'view/WorkspaceManager\'],function (require, exports, module) {\r\n    \'use strict\';\r\n    \r\n    var AppInit          = require("utils/AppInit"),\r\n        StatusBarHTML    = require("text!widgets/StatusBar.html"),\r\n        EditorManager    = require("editor/EditorManager"),\r\n        Strings          = require("strings"),\r\n        WorkspaceManager = require("view/WorkspaceManager");\r\n\r\n    var _init = false;\r\n    \r\n    // Indicates if the busy cursor is active to avoid unnecesary operations\r\n    var _busyCursor = false;\r\n    \r\n    // A simple regexp to sanitize indicator ids\r\n    var _indicatorIDRegexp = new RegExp("[^a-zA-Z 0-9]+", "g");\r\n    \r\n    // These vars are initialized by the AppInit.htmlReady handler\r\n    // below since they refer to DOM elements\r\n    var $statusInfo,\r\n        $statusBar,\r\n        $indicators,\r\n        $busyIndicator;\r\n        \r\n    /**\r\n     * Shows the \'busy\' indicator\r\n     * @param {boolean} updateCursor Sets the cursor to "wait"\r\n     */\r\n    function showBusyIndicator(updateCursor) {\r\n        if (!_init) {\r\n            console.error("StatusBar API invoked before status bar created");\r\n            return;\r\n        }\r\n\r\n        if (updateCursor) {\r\n            _busyCursor = true;\r\n            $("*").addClass("busyCursor");\r\n        }\r\n        \r\n        $busyIndicator.addClass("spin");\r\n    }\r\n    \r\n    /**\r\n     * Hides the \'busy\' indicator\r\n     */\r\n    function hideBusyIndicator() {\r\n        if (!_init) {\r\n            console.error("StatusBar API invoked before status bar created");\r\n            return;\r\n        }\r\n\r\n        // Check if we are using the busyCursor class to avoid\r\n        // unnecesary calls to $(\'*\').removeClass()\r\n        if (_busyCursor) {\r\n            _busyCursor = false;\r\n            $("*").removeClass("busyCursor");\r\n        }\r\n        \r\n        $busyIndicator.removeClass("spin");\r\n    }\r\n    \r\n    /**\r\n     * Registers a new status indicator\r\n     * @param {string} id Registration id of the indicator to be updated.\r\n     * @param {(DOMNode|jQueryObject)=} indicator Optional DOMNode for the indicator\r\n     * @param {boolean=} visible Shows or hides the indicator over the statusbar.\r\n     * @param {string=} style Sets the attribute "class" of the indicator.\r\n     * @param {string=} tooltip Sets the attribute "title" of the indicator.\r\n     * @param {string=} insertBefore An id of an existing status bar indicator.\r\n     *          The new indicator will be inserted before (i.e. to the left of)\r\n     *          the indicator specified by this parameter.\r\n     */\r\n    function addIndicator(id, indicator, visible, style, tooltip, insertBefore) {\r\n        if (!_init) {\r\n            console.error("StatusBar API invoked before status bar created");\r\n            return;\r\n        }\r\n        \r\n        indicator = indicator || document.createElement("div");\r\n        tooltip = tooltip || "";\r\n        style = style || "";\r\n        id = id.replace(_indicatorIDRegexp, "-") || "";\r\n        \r\n        var $indicator = $(indicator);\r\n        \r\n        $indicator.attr("id", id);\r\n        $indicator.attr("title", tooltip);\r\n        $indicator.addClass("indicator");\r\n        $indicator.addClass(style);\r\n            \r\n        if (!visible) {\r\n            $indicator.hide();\r\n        }\r\n        \r\n        // This code looks backwards because the DOM model is ordered\r\n        // top-to-bottom but the UI view is ordered right-to-left. The concept\r\n        // of "before" in the model is "after" in the view, and vice versa.\r\n        if (insertBefore && $("#" + insertBefore).length > 0) {\r\n            $indicator.insertAfter("#" + insertBefore);\r\n        } else {\r\n            // No positioning is provided, put on left end of indicators, but\r\n            // to right of "busy" indicator (which is usually hidden).\r\n            var $busyIndicator = $("#status-bar .spinner");\r\n            $indicator.insertBefore($busyIndicator);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Updates a status indicator\r\n     * @param {string} id Registration id of the indicator to be updated.\r\n     * @param {boolean} visible Shows or hides the indicator over the statusbar.\r\n     * @param {string=} style Sets the attribute "class" of the indicator.\r\n     * @param {string=} tooltip Sets the attribute "title" of the indicator.\r\n     */\r\n    function updateIndicator(id, visible, style, tooltip) {\r\n        if (!_init) {\r\n            console.error("StatusBar API invoked before status bar created");\r\n            return;\r\n        }\r\n        \r\n        var $indicator = $("#" + id.replace(_indicatorIDRegexp, "-"));\r\n        \r\n        if ($indicator) {\r\n            \r\n            if (visible) {\r\n                $indicator.show();\r\n            } else {\r\n                $indicator.hide();\r\n            }\r\n            \r\n            if (style) {\r\n                $indicator.removeClass();\r\n                $indicator.addClass(style);\r\n            } else {\r\n                $indicator.removeClass();\r\n                $indicator.addClass("indicator");\r\n            }\r\n            \r\n            if (tooltip) {\r\n                $indicator.attr("title", tooltip);\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Hide the statusbar Information Panel\r\n     */\r\n    function hideInformation() {\r\n        $statusInfo.css("display", "none");\r\n    }\r\n    \r\n    /**\r\n     * Show the statusbar Information Panel\r\n     */\r\n    function showInformation() {\r\n        $statusInfo.css("display", "");\r\n    }\r\n    \r\n    /**\r\n     * Hide the statusbar Indicators\r\n     */\r\n    function hideIndicators() {\r\n        $indicators.css("display", "none");\r\n    }\r\n    \r\n    /**\r\n     * Show the statusbar Indicators\r\n     */\r\n    function showIndicators() {\r\n        $indicators.css("display", "");\r\n    }\r\n\r\n    \r\n    /**\r\n     * Hides all panels but not the status bar\r\n     */\r\n    function hideAllPanes() {\r\n        hideInformation();\r\n        hideIndicators();\r\n    }\r\n    \r\n    /**\r\n     * Shows all panels (will not show a hidden statusbar)\r\n     */\r\n    function showAllPanes() {\r\n        showInformation();\r\n        showIndicators();\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Hide the statusbar\r\n     */\r\n    function hide() {\r\n        if (!_init) {\r\n            console.error("StatusBar API invoked before status bar created");\r\n            return;\r\n        }\r\n        \r\n        if ($statusBar.is(":visible")) {\r\n            $statusBar.hide();\r\n            WorkspaceManager.recomputeLayout();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Show the statusbar\r\n     */\r\n    function show() {\r\n        if (!_init) {\r\n            console.error("StatusBar API invoked before status bar created");\r\n            return;\r\n        }\r\n\r\n        if (!$statusBar.is(":visible")) {\r\n            $statusBar.show();\r\n            WorkspaceManager.recomputeLayout();\r\n        }\r\n    }\r\n    \r\n    AppInit.htmlReady(function () {\r\n        var $parent = $(".main-view .content");\r\n        $parent.append(Mustache.render(StatusBarHTML, Strings));\r\n\r\n        // Initialize items dependent on HTML DOM\r\n        $statusBar          = $("#status-bar");\r\n        $indicators         = $("#status-indicators");\r\n        $busyIndicator      = $("#status-bar .spinner");\r\n        $statusInfo         = $("#status-info");\r\n\r\n        _init = true;\r\n\r\n        // hide on init\r\n        hide();\r\n    });\r\n\r\n    exports.hideInformation   = hideInformation;\r\n    exports.showInformation   = showInformation;\r\n    exports.showBusyIndicator = showBusyIndicator;\r\n    exports.hideBusyIndicator = hideBusyIndicator;\r\n    exports.hideIndicators    = hideIndicators;\r\n    exports.showIndicators    = showIndicators;\r\n    exports.hideAllPanes      = hideAllPanes;\r\n    exports.showAllPanes      = showAllPanes;\r\n    exports.addIndicator      = addIndicator;\r\n    exports.updateIndicator   = updateIndicator;\r\n    exports.hide              = hide;\r\n    exports.show              = show;\r\n});\n//# sourceURL=/widgets/StatusBar.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, regexp: true */\r\n/*global define, $, brackets, window, WebSocket */\r\n\r\ndefine(\'document/DocumentCommandHandlers\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'utils/AppInit\',\'command/CommandManager\',\'command/Commands\',\'utils/DeprecationWarning\',\'project/ProjectManager\',\'document/DocumentManager\',\'view/MainViewManager\',\'editor/EditorManager\',\'filesystem/FileSystem\',\'filesystem/FileSystemError\',\'file/FileUtils\',\'project/FileViewController\',\'document/InMemoryFile\',\'utils/StringUtils\',\'utils/Async\',\'widgets/Dialogs\',\'widgets/DefaultDialogs\',\'strings\',\'widgets/PopUpManager\',\'preferences/PreferencesManager\',\'utils/DragAndDrop\',\'utils/PerfUtils\',\'utils/KeyEvent\',\'language/LanguageManager\',\'LiveDevelopment/Inspector/Inspector\',\'command/Menus\',\'utils/UrlParams\',\'widgets/StatusBar\',\'view/WorkspaceManager\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var _ = require("thirdparty/lodash");\r\n\r\n    // Load dependent modules\r\n    var AppInit             = require("utils/AppInit"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        Commands            = require("command/Commands"),\r\n        DeprecationWarning  = require("utils/DeprecationWarning"),\r\n        ProjectManager      = require("project/ProjectManager"),\r\n        DocumentManager     = require("document/DocumentManager"),\r\n        MainViewManager     = require("view/MainViewManager"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        FileSystem          = require("filesystem/FileSystem"),\r\n        FileSystemError     = require("filesystem/FileSystemError"),\r\n        FileUtils           = require("file/FileUtils"),\r\n        FileViewController  = require("project/FileViewController"),\r\n        InMemoryFile        = require("document/InMemoryFile"),\r\n        StringUtils         = require("utils/StringUtils"),\r\n        Async               = require("utils/Async"),\r\n        Dialogs             = require("widgets/Dialogs"),\r\n        DefaultDialogs      = require("widgets/DefaultDialogs"),\r\n        Strings             = require("strings"),\r\n        PopUpManager        = require("widgets/PopUpManager"),\r\n        PreferencesManager  = require("preferences/PreferencesManager"),\r\n        DragAndDrop         = require("utils/DragAndDrop"),\r\n        PerfUtils           = require("utils/PerfUtils"),\r\n        KeyEvent            = require("utils/KeyEvent"),\r\n        LanguageManager     = require("language/LanguageManager"),\r\n        Inspector           = require("LiveDevelopment/Inspector/Inspector"),\r\n        Menus               = require("command/Menus"),\r\n        UrlParams           = require("utils/UrlParams").UrlParams,\r\n        StatusBar           = require("widgets/StatusBar"),\r\n        WorkspaceManager    = require("view/WorkspaceManager");\r\n\r\n    /**\r\n     * Handlers for commands related to document handling (opening, saving, etc.)\r\n     */\r\n\r\n    /**\r\n     * Container for label shown above editor; must be an inline element\r\n     * @type {jQueryObject}\r\n     */\r\n    var _$title = null;\r\n\r\n    /**\r\n     * Container for dirty dot; must be an inline element\r\n     * @type {jQueryObject}\r\n     */\r\n    var _$dirtydot = null;\r\n\r\n    /**\r\n     * Container for _$title; need not be an inline element\r\n     * @type {jQueryObject}\r\n     */\r\n    var _$titleWrapper = null;\r\n\r\n    /**\r\n     * Label shown above editor for current document: filename and potentially some of its path\r\n     * @type {string}\r\n     */\r\n    var _currentTitlePath = null;\r\n\r\n    /**\r\n     * String template for window title. Use emdash on mac only.\r\n     * @type {string}\r\n     */\r\n    var WINDOW_TITLE_STRING = (brackets.platform !== "mac") ? "{0} - {1}" : "{0} \\u2014 {1}";\r\n\r\n    /**\r\n     * Container for _$titleWrapper; if changing title changes this element\'s height, must kick editor to resize\r\n     * @type {jQueryObject}\r\n     */\r\n    var _$titleContainerToolbar = null;\r\n\r\n    /**\r\n     * Last known height of _$titleContainerToolbar\r\n     * @type {number}\r\n     */\r\n    var _lastToolbarHeight = null;\r\n\r\n    /**\r\n     * index to use for next, new Untitled document\r\n     * @type {number}\r\n     */\r\n    var _nextUntitledIndexToUse = 1;\r\n\r\n    /**\r\n     * prevents reentrancy of browserReload()\r\n     * @type {boolean}\r\n     */\r\n    var _isReloading = false;\r\n\r\n    /** Unique token used to indicate user-driven cancellation of Save As (as opposed to file IO error) */\r\n    var USER_CANCELED = { userCanceled: true };\r\n\r\n    PreferencesManager.definePreference("defaultExtension", "string", "");\r\n\r\n    /**\r\n     * JSLint workaround for circular dependency\r\n     * @type {function}\r\n     */\r\n    var handleFileSaveAs;\r\n    \r\n    /**\r\n     * Updates the title bar with new file title or dirty indicator\r\n     * @private\r\n     */\r\n    function _updateTitle() {\r\n        var currentDoc = DocumentManager.getCurrentDocument(),\r\n            currentlyViewedPath = MainViewManager.getCurrentlyViewedPath(MainViewManager.ACTIVE_PANE),\r\n            windowTitle = brackets.config.app_title;\r\n\r\n        if (!brackets.nativeMenus) {\r\n            if (currentlyViewedPath) {\r\n                _$title.text(_currentTitlePath);\r\n                _$title.attr("title", currentlyViewedPath);\r\n                if (currentDoc) {\r\n                    // dirty dot is always in DOM so layout doesn\'t change, and visibility is toggled\r\n                    _$dirtydot.css("visibility", (currentDoc.isDirty) ? "visible" : "hidden");\r\n                } else {\r\n                    // hide dirty dot if there is no document\r\n                    _$dirtydot.css("visibility", "hidden");\r\n                }\r\n            } else {\r\n                _$title.text("");\r\n                _$title.attr("title", "");\r\n                _$dirtydot.css("visibility", "hidden");\r\n            }\r\n        \r\n            // Set _$titleWrapper to a fixed width just large enough to accomodate _$title. This seems equivalent to what\r\n            // the browser would do automatically, but the CSS trick we use for layout requires _$titleWrapper to have a\r\n            // fixed width set on it (see the "#titlebar" CSS rule for details).\r\n            _$titleWrapper.css("width", "");\r\n            var newWidth = _$title.width();\r\n            _$titleWrapper.css("width", newWidth);\r\n            \r\n            // Changing the width of the title may cause the toolbar layout to change height, which needs to resize the\r\n            // editor beneath it (toolbar changing height due to window resize is already caught by EditorManager).\r\n            var newToolbarHeight = _$titleContainerToolbar.height();\r\n            if (_lastToolbarHeight !== newToolbarHeight) {\r\n                _lastToolbarHeight = newToolbarHeight;\r\n                WorkspaceManager.recomputeLayout();\r\n            }\r\n        }\r\n\r\n        // build shell/browser window title, e.g. "• file.html — Brackets"\r\n        if (currentlyViewedPath) {\r\n            windowTitle = StringUtils.format(WINDOW_TITLE_STRING, _currentTitlePath, windowTitle);\r\n        }\r\n        \r\n        if (currentDoc) {\r\n            windowTitle = (currentDoc.isDirty) ? "• " + windowTitle : windowTitle;\r\n        } else {\r\n            // hide dirty dot if there is no document\r\n            _$dirtydot.css("visibility", "hidden");\r\n        }\r\n\r\n        // update shell/browser window title\r\n        window.document.title = windowTitle;\r\n    }\r\n\r\n    /**\r\n     * Returns a short title for a given document.\r\n     *\r\n     * @param {Document} doc - the document to compute the short title for\r\n     * @return {string} - a short title for doc.\r\n     */\r\n    function _shortTitleForDocument(doc) {\r\n        var fullPath = doc.file.fullPath;\r\n        \r\n        // If the document is untitled then return the filename, ("Untitled-n.ext");\r\n        // otherwise show the project-relative path if the file is inside the\r\n        // current project or the full absolute path if it\'s not in the project.\r\n        if (doc.isUntitled()) {\r\n            return fullPath.substring(fullPath.lastIndexOf("/") + 1);\r\n        } else {\r\n            return ProjectManager.makeProjectRelativeIfPossible(fullPath);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles currentFileChange and filenameChanged events and updates the titlebar\r\n     */\r\n    function handleCurrentFileChange() {\r\n        var newFile = MainViewManager.getCurrentlyViewedFile(MainViewManager.ACTIVE_PANE);\r\n        \r\n        if (newFile) {\r\n            var newDocument = DocumentManager.getOpenDocumentForPath(newFile.fullPath);\r\n\r\n            if (newDocument) {\r\n                _currentTitlePath = _shortTitleForDocument(newDocument);\r\n            } else {\r\n                _currentTitlePath = ProjectManager.makeProjectRelativeIfPossible(newFile.fullPath);\r\n            }\r\n        } else {\r\n            _currentTitlePath = null;\r\n        }\r\n        \r\n        // Update title text & "dirty dot" display\r\n        _updateTitle();\r\n    }\r\n\r\n    /**\r\n     * Handles dirtyFlagChange event and updates the title bar if necessary\r\n     */\r\n    function handleDirtyChange(event, changedDoc) {\r\n        var currentDoc = DocumentManager.getCurrentDocument();\r\n        \r\n        if (currentDoc && changedDoc.file.fullPath === currentDoc.file.fullPath) {\r\n            _updateTitle();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Creates a document and displays an editor for the specified file path.\r\n     * @param {!string} fullPath\r\n     * @param {boolean=} silent If true, don\'t show error message\r\n     * @param {string=} paneId, the id oi the pane in which to open the file. Can be undefined, a valid pane id or ACTIVE_PANE. \r\n     * @return {$.Promise} a jQuery promise that will either\r\n     * - be resolved with a file for the specified file path or\r\n     * - be rejected if the file can not be read.\r\n     * If paneId is undefined, the ACTIVE_PANE constant\r\n     */\r\n    function _doOpen(fullPath, silent, paneId) {\r\n        var result = new $.Deferred();\r\n        \r\n        // workaround for https://github.com/adobe/brackets/issues/6001\r\n        // TODO should be removed once bug is closed.\r\n        // if we are already displaying a file do nothing but resolve immediately.\r\n        // this fixes timing issues in test cases.\r\n        if (MainViewManager.getCurrentlyViewedPath(MainViewManager.ACTIVE_PANE) === fullPath) {\r\n            result.resolve(MainViewManager.getCurrentlyViewedFile(MainViewManager.ACTIVE_PANE));\r\n            return result.promise();\r\n        }\r\n        \r\n        function _cleanup(fullFilePath) {\r\n            if (fullFilePath) {\r\n                // For performance, we do lazy checking of file existence, so it may be in workingset\r\n                MainViewManager._removeView(paneId, FileSystem.getFileForPath(fullFilePath));\r\n                MainViewManager.focusActivePane();\r\n            }\r\n            result.reject();\r\n        }\r\n        function _showErrorAndCleanUp(fileError, fullFilePath) {\r\n            if (silent) {\r\n                _cleanup(fullFilePath);\r\n            } else {\r\n                FileUtils.showFileOpenError(fileError, fullFilePath).done(function () {\r\n                    _cleanup(fullFilePath);\r\n                });\r\n            }\r\n        }\r\n        \r\n        if (!fullPath) {\r\n            console.error("_doOpen() called without fullPath");\r\n            result.reject();\r\n        } else {\r\n            var perfTimerName = PerfUtils.markStart("Open File:\\t" + fullPath);\r\n            result.always(function () {\r\n                PerfUtils.addMeasurement(perfTimerName);\r\n            });\r\n\r\n            var file = FileSystem.getFileForPath(fullPath);\r\n            MainViewManager._open(paneId, file)\r\n                .done(function () {\r\n                    result.resolve(file);\r\n                })\r\n                .fail(function (fileError) {\r\n                    _showErrorAndCleanUp(fileError, fullPath);\r\n                    result.reject();\r\n                });\r\n        }\r\n\r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Used to track the default directory for the file open dialog\r\n     */\r\n    var _defaultOpenDialogFullPath = null;\r\n\r\n    /**\r\n     * @private\r\n     * Opens a file and displays its view (editor, image view, etc...) for the specified path.\r\n     * If no path is specified, a file prompt is provided for input.\r\n     * @param {?string} fullPath - The path of the file to open; if it\'s null we\'ll prompt for it\r\n     * @param {boolean=} silent - If true, don\'t show error message\r\n     * @param {string=}  paneId - the pane in which to open the file. Can be undefined, a valid pane id or ACTIVE_PANE\r\n     * @return {$.Promise} a jQuery promise resolved with a Document object or \r\n     *                      rejected with an err \r\n     */\r\n    function _doOpenWithOptionalPath(fullPath, silent, paneId) {\r\n        var result;\r\n        paneId = paneId || MainViewManager.ACTIVE_PANE;\r\n        if (!fullPath) {\r\n            // Create placeholder deferred\r\n            result = new $.Deferred();\r\n            \r\n            //first time through, default to the current project path\r\n            if (!_defaultOpenDialogFullPath) {\r\n                _defaultOpenDialogFullPath = ProjectManager.getProjectRoot().fullPath;\r\n            }\r\n            // Prompt the user with a dialog\r\n            FileSystem.showOpenDialog(true, false, Strings.OPEN_FILE, _defaultOpenDialogFullPath, null, function (err, paths) {\r\n                if (!err) {\r\n                    if (paths.length > 0) {\r\n                        // Add all files to the workingset without verifying that\r\n                        // they still exist on disk (for faster opening)\r\n                        var filesToOpen = [],\r\n                            filteredPaths = DragAndDrop.filterFilesToOpen(paths);\r\n                        \r\n                        filteredPaths.forEach(function (file) {\r\n                            filesToOpen.push(FileSystem.getFileForPath(file));\r\n                        });\r\n                        MainViewManager.addListToWorkingSet(paneId, filesToOpen);\r\n                        \r\n                        _doOpen(filteredPaths[filteredPaths.length - 1], silent, paneId)\r\n                            .done(function (file) {\r\n                                _defaultOpenDialogFullPath =\r\n                                    FileUtils.getDirectoryPath(\r\n                                        MainViewManager.getCurrentlyViewedPath(paneId)\r\n                                    );\r\n                            })\r\n                            // Send the resulting document that was opened\r\n                            .then(result.resolve, result.reject);\r\n                    } else {\r\n                        // Reject if the user canceled the dialog\r\n                        result.reject();\r\n                    }\r\n                }\r\n            });\r\n        } else {\r\n            result = _doOpen(fullPath, silent, paneId);\r\n        }\r\n        \r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Splits a decorated file path into its parts.\r\n     * @param {?string} path - a string of the form "fullpath[:lineNumber[:columnNumber]]"\r\n     * @return {{path: string, line: ?number, column: ?number}}\r\n     */\r\n    function _parseDecoratedPath(path) {\r\n        var result = {path: path, line: null, column: null};\r\n        if (path) {\r\n            // If the path has a trailing :lineNumber and :columnNumber, strip\r\n            // these off and assign to result.line and result.column.\r\n            var matchResult = /(.+?):([0-9]+)(:([0-9]+))?$/.exec(path);\r\n            if (matchResult) {\r\n                result.path = matchResult[1];\r\n                if (matchResult[2]) {\r\n                    result.line = parseInt(matchResult[2], 10);\r\n                }\r\n                if (matchResult[4]) {\r\n                    result.column = parseInt(matchResult[4], 10);\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @typedef {{fullPath:?string=, silent:boolean=, paneId:string=}} FileCommandData\r\n     * fullPath: is in the form "path[:lineNumber[:columnNumber]]"\r\n     * lineNumber and columnNumber are 1-origin: lines and columns are 1-based\r\n     */\r\n\r\n    /**\r\n     * @typedef {{fullPath:?string=, index:number=, silent:boolean=, forceRedraw:boolean=, paneId:string=}} PaneCommandData\r\n     * fullPath: is in the form "path[:lineNumber[:columnNumber]]"\r\n     * lineNumber and columnNumber are 1-origin: lines and columns are 1-based\r\n     */\r\n    \r\n    /**\r\n     * Opens the given file and makes it the current file. Does NOT add it to the workingset.\r\n     * @param {FileCommandData=} commandData - record with the following properties:\r\n     *   fullPath: File to open; \r\n     *   silent: optional flag to suppress error messages; \r\n     *   paneId: optional PaneId (defaults to active pane)\r\n     * @return {$.Promise} a jQuery promise that will be resolved with a file object\r\n     */\r\n    function handleFileOpen(commandData) {\r\n        var fileInfo = _parseDecoratedPath(commandData ? commandData.fullPath : null),\r\n            silent = (commandData && commandData.silent) || false,\r\n            paneId = (commandData && commandData.paneId) || MainViewManager.ACTIVE_PANE,\r\n            result = new $.Deferred();\r\n        \r\n        _doOpenWithOptionalPath(fileInfo.path, silent, paneId)\r\n            .done(function (file) {\r\n                MainViewManager.setActivePaneId(paneId);\r\n\r\n                // If a line and column number were given, position the editor accordingly.\r\n                if (fileInfo.line !== null) {\r\n                    if (fileInfo.column === null || (fileInfo.column <= 0)) {\r\n                        fileInfo.column = 1;\r\n                    }\r\n                    \r\n                    // setCursorPos expects line/column numbers as 0-origin, so we subtract 1\r\n                    EditorManager.getCurrentFullEditor().setCursorPos(fileInfo.line - 1,\r\n                                                                      fileInfo.column - 1,\r\n                                                                      true);\r\n                }\r\n                \r\n                result.resolve(file);\r\n            })\r\n            .fail(function (err) {\r\n                result.reject(err);\r\n            });\r\n        \r\n        return result;\r\n        // Testing notes: here are some recommended manual tests for handleFileOpen, on macintosh.\r\n        // Do all tests with brackets already running, and also with brackets not already running.\r\n        //\r\n        // drag a file onto brackets icon in desktop (this uses undecorated paths)\r\n        // drag a file onto brackets icon in taskbar (this uses undecorated paths)\r\n        // open a file from brackets sidebar (this uses undecorated paths)\r\n        // from command line: ...../Brackets.app/Contents path         - where \'path\' is undecorated\r\n        // from command line: ...../Brackets.app path                  - where \'path\' has the form "path:line"\r\n        // from command line: ...../Brackets.app path                  - where \'path\' has the form "path:line:column"\r\n        // from command line: open -a ...../Brackets.app path          - where \'path\' is undecorated\r\n        // do "View Source" from Adobe Scout version 1.2 or newer (this will use decorated paths of the form "path:line:column")\r\n    }\r\n\r\n    /**\r\n     * Opens the given file, makes it the current file, does NOT add it to the workingset\r\n     * @param {FileCommandData} commandData  \r\n     *   fullPath: File to open; \r\n     *   silent: optional flag to suppress error messages; \r\n     *   paneId: optional PaneId (defaults to active pane)\r\n     * @return {$.Promise} a jQuery promise that will be resolved with @type {Document} \r\n     */\r\n    function handleDocumentOpen(commandData) {\r\n        var result = new $.Deferred();\r\n        handleFileOpen(commandData)\r\n            .done(function (file) {\r\n                // if we succeeded with an open file\r\n                //  then we need to resolve that to a document.\r\n                //  getOpenDocumentForPath will return null if there isn\'t a \r\n                //  supporting document for that file (e.g. an image)\r\n                var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\r\n                result.resolve(doc);\r\n            })\r\n            .fail(function (err) {\r\n                result.reject(err);\r\n            });\r\n\r\n        return result.promise();\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Opens the given file, makes it the current file, AND adds it to the workingset\r\n     * @param {!PaneCommandData} commandData - record with the following properties:\r\n     *   fullPath: File to open; \r\n     *   index: optional index to position in workingset (defaults to last); \r\n     *   silent: optional flag to suppress error messages; \r\n     *   forceRedraw: flag to force the working set view redraw; \r\n     *   paneId: optional PaneId (defaults to active pane)\r\n     * @return {$.Promise} a jQuery promise that will be resolved with a @type {File} \r\n     */\r\n    function handleFileAddToWorkingSetAndOpen(commandData) {\r\n        return handleFileOpen(commandData).done(function (file) {\r\n            var paneId = (commandData && commandData.paneId) || MainViewManager.ACTIVE_PANE;\r\n            MainViewManager.addToWorkingSet(paneId, file, commandData.index, commandData.forceRedraw);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @deprecated\r\n     * Opens the given file, makes it the current document, AND adds it to the workingset\r\n     * @param {!PaneCommandData} commandData - record with the following properties:\r\n     *   fullPath: File to open; \r\n     *   index: optional index to position in workingset (defaults to last); \r\n     *   silent: optional flag to suppress error messages; \r\n     *   forceRedraw: flag to force the working set view redraw; \r\n     *   paneId: optional PaneId (defaults to active pane)\r\n     * @return {$.Promise} a jQuery promise that will be resolved with @type {File} \r\n     */\r\n    function handleFileAddToWorkingSet(commandData) {\r\n        // This is a legacy deprecated command that \r\n        //  will use the new command and resolve with a document\r\n        //  as the legacy command would only support.\r\n        DeprecationWarning.deprecationWarning("Commands.FILE_ADD_TO_WORKING_SET has been deprecated.  Use Commands.CMD_ADD_TO_WORKINGSET_AND_OPEN instead.");\r\n        var result = new $.Deferred();\r\n        \r\n        handleFileAddToWorkingSetAndOpen(commandData)\r\n            .done(function (file) {\r\n                // if we succeeded with an open file\r\n                //  then we need to resolve that to a document.\r\n                //  getOpenDocumentForPath will return null if there isn\'t a \r\n                //  supporting document for that file (e.g. an image)\r\n                var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\r\n                result.resolve(doc);\r\n            })\r\n            .fail(function (err) {\r\n                result.reject(err);\r\n            });\r\n        \r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Ensures the suggested file name doesn\'t already exit.\r\n     * @param {Directory} dir  The directory to use\r\n     * @param {string} baseFileName  The base to start with, "-n" will get appened to make unique\r\n     * @param {boolean} isFolder True if the suggestion is for a folder name\r\n     * @return {$.Promise} a jQuery promise that will be resolved with a unique name starting with\r\n     *   the given base name\r\n     */\r\n    function _getUntitledFileSuggestion(dir, baseFileName, isFolder) {\r\n        var suggestedName   = baseFileName + "-" + _nextUntitledIndexToUse++,\r\n            deferred        = $.Deferred();\r\n        \r\n        if (_nextUntitledIndexToUse > 9999) {\r\n            //we\'ve tried this enough\r\n            deferred.reject();\r\n        } else {\r\n            var path = dir.fullPath + suggestedName,\r\n                entry = isFolder ? FileSystem.getDirectoryForPath(path)\r\n                                 : FileSystem.getFileForPath(path);\r\n            \r\n            entry.exists(function (err, exists) {\r\n                if (err || exists) {\r\n                    _getUntitledFileSuggestion(dir, baseFileName, isFolder)\r\n                        .then(deferred.resolve, deferred.reject);\r\n                } else {\r\n                    deferred.resolve(suggestedName);\r\n                }\r\n            });\r\n        }\r\n\r\n        return deferred.promise();\r\n    }\r\n\r\n    /**\r\n     * Prevents re-entrancy into handleFileNewInProject()\r\n     *\r\n     * handleFileNewInProject() first prompts the user to name a file and then asynchronously writes the file when the\r\n     * filename field loses focus. This boolean prevent additional calls to handleFileNewInProject() when an existing\r\n     * file creation call is outstanding\r\n     */\r\n    var fileNewInProgress = false;\r\n\r\n    /**\r\n     * Bottleneck function for creating new files and folders in the project tree.\r\n     * @private\r\n     * @param {boolean} isFolder - true if creating a new folder, false if creating a new file\r\n     */\r\n    function _handleNewItemInProject(isFolder) {\r\n        if (fileNewInProgress) {\r\n            ProjectManager.forceFinishRename();\r\n            return;\r\n        }\r\n        fileNewInProgress = true;\r\n\r\n        // Determine the directory to put the new file\r\n        // If a file is currently selected in the tree, put it next to it.\r\n        // If a directory is currently selected in the tree, put it in it.\r\n        // If an Untitled document is selected or nothing is selected in the tree, put it at the root of the project.\r\n        // (Note: \'selected\' may be an item that\'s selected in the workingset and not the tree; but in that case\r\n        // ProjectManager.createNewItem() ignores the baseDir we give it and falls back to the project root on its own)\r\n        var baseDirEntry,\r\n            selected = ProjectManager.getSelectedItem();\r\n        if ((!selected) || (selected instanceof InMemoryFile)) {\r\n            selected = ProjectManager.getProjectRoot();\r\n        }\r\n        \r\n        if (selected.isFile) {\r\n            baseDirEntry = FileSystem.getDirectoryForPath(selected.parentPath);\r\n        }\r\n        \r\n        baseDirEntry = baseDirEntry || selected;\r\n        \r\n        // Create the new node. The createNewItem function does all the heavy work\r\n        // of validating file name, creating the new file and selecting.\r\n        function createWithSuggestedName(suggestedName) {\r\n            return ProjectManager.createNewItem(baseDirEntry, suggestedName, false, isFolder)\r\n                .always(function () { fileNewInProgress = false; });\r\n        }\r\n        \r\n        return _getUntitledFileSuggestion(baseDirEntry, Strings.UNTITLED, isFolder)\r\n            .then(createWithSuggestedName, createWithSuggestedName.bind(undefined, Strings.UNTITLED));\r\n    }\r\n\r\n    /**\r\n     * Create a new untitled document in the workingset, and make it the current document.\r\n     * Promise is resolved (synchronously) with the newly-created Document.\r\n     */\r\n    function handleFileNew() {\r\n        //var defaultExtension = PreferencesManager.get("defaultExtension");\r\n        //if (defaultExtension) {\r\n        //    defaultExtension = "." + defaultExtension;\r\n        //}\r\n        var defaultExtension = "";  // disable preference setting for now\r\n        \r\n        var doc = DocumentManager.createUntitledDocument(_nextUntitledIndexToUse++, defaultExtension);\r\n        MainViewManager._edit(MainViewManager.ACTIVE_PANE, doc);\r\n        \r\n        return new $.Deferred().resolve(doc).promise();\r\n    }\r\n\r\n    /**\r\n     * Create a new file in the project tree.\r\n     */\r\n    function handleFileNewInProject() {\r\n        _handleNewItemInProject(false);\r\n    }\r\n\r\n    /**\r\n     * Create a new folder in the project tree.\r\n     */\r\n    function handleNewFolderInProject() {\r\n        _handleNewItemInProject(true);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Shows an Error modal dialog\r\n     * @param {string} name\r\n     * @param {string} path\r\n     * @return {Dialog}\r\n     */\r\n    function _showSaveFileError(name, path) {\r\n        return Dialogs.showModalDialog(\r\n            DefaultDialogs.DIALOG_ID_ERROR,\r\n            Strings.ERROR_SAVING_FILE_TITLE,\r\n            StringUtils.format(\r\n                Strings.ERROR_SAVING_FILE,\r\n                StringUtils.breakableUrl(path),\r\n                FileUtils.getFileErrorString(name)\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Saves a document to its existing path. Does NOT support untitled documents.\r\n     * @param {!Document} docToSave\r\n     * @param {boolean=} force Ignore CONTENTS_MODIFIED errors from the FileSystem\r\n     * @return {$.Promise} a promise that is resolved with the File of docToSave (to mirror\r\n     *   the API of _doSaveAs()). Rejected in case of IO error (after error dialog dismissed).\r\n     */\r\n    function doSave(docToSave, force) {\r\n        var result = new $.Deferred(),\r\n            file = docToSave.file;\r\n        \r\n        function handleError(error) {\r\n            _showSaveFileError(error, file.fullPath)\r\n                .done(function () {\r\n                    result.reject(error);\r\n                });\r\n        }\r\n        \r\n        function handleContentsModified() {\r\n            Dialogs.showModalDialog(\r\n                DefaultDialogs.DIALOG_ID_ERROR,\r\n                Strings.EXT_MODIFIED_TITLE,\r\n                StringUtils.format(\r\n                    Strings.EXT_MODIFIED_WARNING,\r\n                    StringUtils.breakableUrl(docToSave.file.fullPath)\r\n                ),\r\n                [\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_LEFT,\r\n                        id        : Dialogs.DIALOG_BTN_SAVE_AS,\r\n                        text      : Strings.SAVE_AS\r\n                    },\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_NORMAL,\r\n                        id        : Dialogs.DIALOG_BTN_CANCEL,\r\n                        text      : Strings.CANCEL\r\n                    },\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_PRIMARY,\r\n                        id        : Dialogs.DIALOG_BTN_OK,\r\n                        text      : Strings.SAVE_AND_OVERWRITE\r\n                    }\r\n                ]\r\n            )\r\n                .done(function (id) {\r\n                    if (id === Dialogs.DIALOG_BTN_CANCEL) {\r\n                        result.reject();\r\n                    } else if (id === Dialogs.DIALOG_BTN_OK) {\r\n                        // Re-do the save, ignoring any CONTENTS_MODIFIED errors\r\n                        doSave(docToSave, true).then(result.resolve, result.reject);\r\n                    } else if (id === Dialogs.DIALOG_BTN_SAVE_AS) {\r\n                        // Let the user choose a different path at which to write the file\r\n                        handleFileSaveAs({doc: docToSave}).then(result.resolve, result.reject);\r\n                    }\r\n                });\r\n        }\r\n            \r\n        function trySave() {\r\n            // We don\'t want normalized line endings, so it\'s important to pass true to getText()\r\n            FileUtils.writeText(file, docToSave.getText(true), force)\r\n                .done(function () {\r\n                    docToSave.notifySaved();\r\n                    result.resolve(file);\r\n                })\r\n                .fail(function (err) {\r\n                    if (err === FileSystemError.CONTENTS_MODIFIED) {\r\n                        handleContentsModified();\r\n                    } else {\r\n                        handleError(err);\r\n                    }\r\n                });\r\n        }\r\n\r\n        if (docToSave.isDirty) {\r\n            var writeError = false;\r\n            \r\n            if (docToSave.keepChangesTime) {\r\n                // The user has decided to keep conflicting changes in the editor. Check to make sure\r\n                // the file hasn\'t changed since they last decided to do that.\r\n                docToSave.file.stat(function (err, stat) {\r\n                    // If the file has been deleted on disk, the stat will return an error, but that\'s fine since\r\n                    // that means there\'s no file to overwrite anyway, so the save will succeed without us having\r\n                    // to set force = true.\r\n                    if (!err && docToSave.keepChangesTime === stat.mtime.getTime()) {\r\n                        // OK, it\'s safe to overwrite the file even though we never reloaded the latest version,\r\n                        // since the user already said s/he wanted to ignore the disk version.\r\n                        force = true;\r\n                    }\r\n                    trySave();\r\n                });\r\n            } else {\r\n                trySave();\r\n            }\r\n        } else {\r\n            result.resolve(file);\r\n        }\r\n        result.always(function () {\r\n            MainViewManager.focusActivePane();\r\n        });\r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * Reverts the Document to the current contents of its file on disk. Discards any unsaved changes\r\n     * in the Document.\r\n     * @private\r\n     * @param {Document} doc\r\n     * @param {boolean=} suppressError If true, then a failure to read the file will be ignored and the\r\n     *      resulting promise will be resolved rather than rejected.\r\n     * @return {$.Promise} a Promise that\'s resolved when done, or (if suppressError is false) \r\n     *      rejected with a FileSystemError if the file cannot be read (after showing an error \r\n     *      dialog to the user).\r\n     */\r\n    function _doRevert(doc, suppressError) {\r\n        var result = new $.Deferred();\r\n        \r\n        FileUtils.readAsText(doc.file)\r\n            .done(function (text, readTimestamp) {\r\n                doc.refreshText(text, readTimestamp);\r\n                result.resolve();\r\n            })\r\n            .fail(function (error) {\r\n                if (suppressError) {\r\n                    result.resolve();\r\n                } else {\r\n                    FileUtils.showFileOpenError(error, doc.file.fullPath)\r\n                        .done(function () {\r\n                            result.reject(error);\r\n                        });\r\n                }\r\n            });\r\n        \r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * Opens the native OS save as dialog and saves document.\r\n     * The original document is reverted in case it was dirty.\r\n     * Text selection and cursor position from the original document\r\n     * are preserved in the new document.\r\n     * When saving to the original document the document is saved as if save was called.\r\n     * @param {Document} doc\r\n     * @param {?{cursorPos:!Object, selection:!Object, scrollPos:!Object}} settings - properties of\r\n     *      the original document\'s editor that need to be carried over to the new document\r\n     *      i.e. scrollPos, cursorPos and text selection\r\n     * @return {$.Promise} a promise that is resolved with the saved document\'s File. Rejected in\r\n     *   case of IO error (after error dialog dismissed), or if the Save dialog was canceled.\r\n     */\r\n    function _doSaveAs(doc, settings) {\r\n        var origPath,\r\n            saveAsDefaultPath,\r\n            defaultName,\r\n            result = new $.Deferred();\r\n        \r\n        function _doSaveAfterSaveDialog(path) {\r\n            var newFile;\r\n            \r\n            // Reconstruct old doc\'s editor\'s view state, & finally resolve overall promise\r\n            function _configureEditorAndResolve() {\r\n                var editor = EditorManager.getActiveEditor();\r\n                if (editor) {\r\n                    if (settings) {\r\n                        editor.setSelections(settings.selections);\r\n                        editor.setScrollPos(settings.scrollPos.x, settings.scrollPos.y);\r\n                    }\r\n                }\r\n                result.resolve(newFile);\r\n            }\r\n            \r\n            // Replace old document with new one in open editor & workingset\r\n            function openNewFile() {\r\n                var fileOpenPromise;\r\n\r\n                if (FileViewController.getFileSelectionFocus() === FileViewController.PROJECT_MANAGER) {\r\n                    // If selection is in the tree, leave workingset unchanged - even if orig file is in the list\r\n                    fileOpenPromise = FileViewController\r\n                        .openAndSelectDocument(path, FileViewController.PROJECT_MANAGER);\r\n                } else {\r\n                    // If selection is in workingset, replace orig item in place with the new file\r\n                    var info = MainViewManager.findInAllWorkingSets(doc.file.fullPath).shift();\r\n                    \r\n                    // Remove old file from workingset; no redraw yet since there\'s a pause before the new file is opened\r\n                    MainViewManager._removeView(info.paneId, doc.file, true);\r\n                    \r\n                    // Add new file to workingset, and ensure we now redraw (even if index hasn\'t changed)\r\n                    fileOpenPromise = handleFileAddToWorkingSetAndOpen({fullPath: path, paneId: info.paneId, index: info.index, forceRedraw: true});\r\n                }\r\n\r\n                // always configure editor after file is opened\r\n                fileOpenPromise.always(function () {\r\n                    _configureEditorAndResolve();\r\n                });\r\n            }\r\n            \r\n            // Same name as before - just do a regular Save\r\n            if (path === origPath) {\r\n                doSave(doc).then(result.resolve, result.reject);\r\n                return;\r\n            }\r\n            \r\n            doc.isSaving = true;    // mark that we\'re saving the document\r\n            \r\n            // First, write document\'s current text to new file\r\n            newFile = FileSystem.getFileForPath(path);\r\n            \r\n            // Save as warns you when you\'re about to overwrite a file, so we\r\n            // explictly allow "blind" writes to the filesystem in this case,\r\n            // ignoring warnings about the contents being modified outside of\r\n            // the editor.\r\n            FileUtils.writeText(newFile, doc.getText(), true)\r\n                .done(function () {\r\n                    // If there were unsaved changes before Save As, they don\'t stay with the old\r\n                    // file anymore - so must revert the old doc to match disk content.\r\n                    // Only do this if the doc was dirty: _doRevert on a file that is not dirty and\r\n                    // not in the workingset has the side effect of adding it to the workingset.\r\n                    if (doc.isDirty && !(doc.isUntitled())) {\r\n                        // if the file is dirty it must be in the workingset\r\n                        // _doRevert is side effect free in this case\r\n                        _doRevert(doc).always(openNewFile);\r\n                    } else {\r\n                        openNewFile();\r\n                    }\r\n                })\r\n                .fail(function (error) {\r\n                    _showSaveFileError(error, path)\r\n                        .done(function () {\r\n                            result.reject(error);\r\n                        });\r\n                })\r\n                .always(function () {\r\n                    // mark that we\'re done saving the document\r\n                    doc.isSaving = false;\r\n                });\r\n        }\r\n        \r\n        if (doc) {\r\n            origPath = doc.file.fullPath;\r\n            // If the document is an untitled document, we should default to project root.\r\n            if (doc.isUntitled()) {\r\n                // (Issue #4489) if we\'re saving an untitled document, go ahead and switch to this document\r\n                //   in the editor, so that if we\'re, for example, saving several files (ie. Save All),\r\n                //   then the user can visually tell which document we\'re currently prompting them to save.\r\n                var info = MainViewManager.findInAllWorkingSets(origPath).shift();\r\n                \r\n                if (info) {\r\n                    MainViewManager._open(info.paneId, doc.file);\r\n                }\r\n\r\n                // If the document is untitled, default to project root.\r\n                saveAsDefaultPath = ProjectManager.getProjectRoot().fullPath;\r\n            } else {\r\n                saveAsDefaultPath = FileUtils.getDirectoryPath(origPath);\r\n            }\r\n            defaultName = FileUtils.getBaseName(origPath);\r\n            FileSystem.showSaveDialog(Strings.SAVE_FILE_AS, saveAsDefaultPath, defaultName, function (err, selectedPath) {\r\n                if (!err) {\r\n                    if (selectedPath) {\r\n                        _doSaveAfterSaveDialog(selectedPath);\r\n                    } else {\r\n                        result.reject(USER_CANCELED);\r\n                    }\r\n                } else {\r\n                    result.reject(err);\r\n                }\r\n            });\r\n        } else {\r\n            result.reject();\r\n        }\r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * Saves the given file. If no file specified, assumes the current document.\r\n     * @param {?{doc: ?Document}} commandData  Document to close, or null\r\n     * @return {$.Promise} resolved with the saved document\'s File (which MAY DIFFER from the doc\r\n     *   passed in, if the doc was untitled). Rejected in case of IO error (after error dialog\r\n     *   dismissed), or if doc was untitled and the Save dialog was canceled (will be rejected with\r\n     *   USER_CANCELED object).\r\n     */\r\n    function handleFileSave(commandData) {\r\n        var activeEditor = EditorManager.getActiveEditor(),\r\n            activeDoc = activeEditor && activeEditor.document,\r\n            doc = (commandData && commandData.doc) || activeDoc,\r\n            settings;\r\n        \r\n        if (doc && !doc.isSaving) {\r\n            if (doc.isUntitled()) {\r\n                if (doc === activeDoc) {\r\n                    settings = {\r\n                        selections: activeEditor.getSelections(),\r\n                        scrollPos: activeEditor.getScrollPos()\r\n                    };\r\n                }\r\n                \r\n                return _doSaveAs(doc, settings);\r\n            } else {\r\n                return doSave(doc);\r\n            }\r\n        }\r\n        \r\n        return $.Deferred().reject().promise();\r\n    }\r\n\r\n    /**\r\n     * Saves all unsaved documents corresponding to \'fileList\'. Returns a Promise that will be resolved\r\n     * once ALL the save operations have been completed. If ANY save operation fails, an error dialog is\r\n     * immediately shown but after dismissing we continue saving the other files; after all files have\r\n     * been processed, the Promise is rejected if any ONE save operation failed (the error given is the\r\n     * first one encountered). If the user cancels any Save As dialog (for untitled files), the\r\n     * Promise is immediately rejected.\r\n     *\r\n     * @param {!Array.<File>} fileList\r\n     * @return {!$.Promise} Resolved with {!Array.<File>}, which may differ from \'fileList\'\r\n     *      if any of the files were Unsaved documents. Or rejected with {?FileSystemError}.\r\n     */\r\n    function _saveFileList(fileList) {\r\n        // Do in serial because doSave shows error UI for each file, and we don\'t want to stack\r\n        // multiple dialogs on top of each other\r\n        var userCanceled = false,\r\n            filesAfterSave = [];\r\n            \r\n        return Async.doSequentially(\r\n            fileList,\r\n            function (file) {\r\n                // Abort remaining saves if user canceled any Save As dialog\r\n                if (userCanceled) {\r\n                    return (new $.Deferred()).reject().promise();\r\n                }\r\n                \r\n                var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\r\n                if (doc) {\r\n                    var savePromise = handleFileSave({doc: doc});\r\n                    savePromise\r\n                        .done(function (newFile) {\r\n                            filesAfterSave.push(newFile);\r\n                        })\r\n                        .fail(function (error) {\r\n                            if (error === USER_CANCELED) {\r\n                                userCanceled = true;\r\n                            }\r\n                        });\r\n                    return savePromise;\r\n                } else {\r\n                    // workingset entry that was never actually opened - ignore\r\n                    filesAfterSave.push(file);\r\n                    return (new $.Deferred()).resolve().promise();\r\n                }\r\n            },\r\n            false  // if any save fails, continue trying to save other files anyway; then reject at end\r\n        ).then(function () {\r\n            return filesAfterSave;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Saves all unsaved documents. See _saveFileList() for details on the semantics.\r\n     * @return {$.Promise}\r\n     */\r\n    function saveAll() {\r\n        return _saveFileList(MainViewManager.getWorkingSet(MainViewManager.ALL_PANES));\r\n    }\r\n\r\n    /**\r\n     * Prompts user with save as dialog and saves document.\r\n     * @return {$.Promise} a promise that is resolved once the save has been completed\r\n     */\r\n    handleFileSaveAs = function (commandData) {\r\n        // Default to current document if doc is null\r\n        var doc = null,\r\n            settings;\r\n        \r\n        if (commandData) {\r\n            doc = commandData.doc;\r\n        } else {\r\n            var activeEditor = EditorManager.getActiveEditor();\r\n            if (activeEditor) {\r\n                doc = activeEditor.document;\r\n                settings = {};\r\n                settings.selections = activeEditor.getSelections();\r\n                settings.scrollPos = activeEditor.getScrollPos();\r\n            }\r\n        }\r\n            \r\n        // doc may still be null, e.g. if no editors are open, but _doSaveAs() does a null check on\r\n        // doc.\r\n        return _doSaveAs(doc, settings);\r\n    };\r\n\r\n    /**\r\n     * Saves all unsaved documents.\r\n     * @return {$.Promise} a promise that is resolved once ALL the saves have been completed; or rejected\r\n     *      after all operations completed if any ONE of them failed.\r\n     */\r\n    function handleFileSaveAll() {\r\n        return saveAll();\r\n    }\r\n\r\n    /**\r\n     * Closes the specified file: removes it from the workingset, and closes the main editor if one\r\n     * is open. Prompts user about saving changes first, if document is dirty.\r\n     *\r\n     * @param {?{file: File, promptOnly:boolean}} commandData  Optional bag of arguments:\r\n     *      file - File to close; assumes the current document if not specified.\r\n     *      promptOnly - If true, only displays the relevant confirmation UI and does NOT actually\r\n     *          close the document. This is useful when chaining file-close together with other user\r\n     *          prompts that may be cancelable.\r\n     *      _forceClose - If true, closes the document without prompting even if there are unsaved\r\n     *          changes. Only for use in unit tests.\r\n     * @return {$.Promise} a promise that is resolved when the file is closed, or if no file is open.\r\n     *      FUTURE: should we reject the promise if no file is open?\r\n     */\r\n    function handleFileClose(commandData) {\r\n        var file,\r\n            promptOnly,\r\n            _forceClose,\r\n            paneId = MainViewManager.ACTIVE_PANE;\r\n        \r\n        if (commandData) {\r\n            file        = commandData.file;\r\n            promptOnly  = commandData.promptOnly;\r\n            _forceClose = commandData._forceClose;\r\n            paneId      = commandData.paneId || paneId;\r\n        }\r\n        \r\n        // utility function for handleFileClose: closes document & removes from workingset\r\n        function doClose(file) {\r\n            if (!promptOnly) {\r\n                MainViewManager._close(paneId, file);\r\n            }\r\n        }\r\n\r\n        var result = new $.Deferred(), promise = result.promise();\r\n        \r\n        // Default to current document if doc is null\r\n        if (!file) {\r\n            file = MainViewManager.getCurrentlyViewedFile(MainViewManager.ACTIVE_PANE);\r\n        }\r\n        \r\n        // No-op if called when nothing is open; TODO: (issue #273) should command be grayed out instead?\r\n        if (!file) {\r\n            result.resolve();\r\n            return promise;\r\n        }\r\n        \r\n        var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\r\n        \r\n        if (doc && doc.isDirty && !_forceClose) {\r\n            // Document is dirty: prompt to save changes before closing\r\n            var filename = FileUtils.getBaseName(doc.file.fullPath);\r\n            \r\n            Dialogs.showModalDialog(\r\n                DefaultDialogs.DIALOG_ID_SAVE_CLOSE,\r\n                Strings.SAVE_CLOSE_TITLE,\r\n                StringUtils.format(\r\n                    Strings.SAVE_CLOSE_MESSAGE,\r\n                    StringUtils.breakableUrl(filename)\r\n                ),\r\n                [\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_LEFT,\r\n                        id        : Dialogs.DIALOG_BTN_DONTSAVE,\r\n                        text      : Strings.DONT_SAVE\r\n                    },\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_NORMAL,\r\n                        id        : Dialogs.DIALOG_BTN_CANCEL,\r\n                        text      : Strings.CANCEL\r\n                    },\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_PRIMARY,\r\n                        id        : Dialogs.DIALOG_BTN_OK,\r\n                        text      : Strings.SAVE\r\n                    }\r\n                ]\r\n            )\r\n                .done(function (id) {\r\n                    if (id === Dialogs.DIALOG_BTN_CANCEL) {\r\n                        result.reject();\r\n                    } else if (id === Dialogs.DIALOG_BTN_OK) {\r\n                        // "Save" case: wait until we confirm save has succeeded before closing\r\n                        handleFileSave({doc: doc})\r\n                            .done(function (newFile) {\r\n                                doClose(newFile);\r\n                                result.resolve();\r\n                            })\r\n                            .fail(function () {\r\n                                result.reject();\r\n                            });\r\n                    } else {\r\n                        // "Don\'t Save" case: even though we\'re closing the main editor, other views of\r\n                        // the Document may remain in the UI. So we need to revert the Document to a clean\r\n                        // copy of whatever\'s on disk.\r\n                        doClose(file);\r\n                        \r\n                        // Only reload from disk if we\'ve executed the Close for real.\r\n                        if (promptOnly) {\r\n                            result.resolve();\r\n                        } else {\r\n                            // Even if there are no listeners attached to the document at this point, we want\r\n                            // to do the revert anyway, because clients who are listening to the global documentChange\r\n                            // event from the Document module (rather than attaching to the document directly),\r\n                            // such as the Find in Files panel, should get a change event. However, in that case,\r\n                            // we want to ignore errors during the revert, since we don\'t want a failed revert\r\n                            // to throw a dialog if the document isn\'t actually open in the UI.\r\n                            var suppressError = !DocumentManager.getOpenDocumentForPath(file.fullPath);\r\n                            _doRevert(doc, suppressError)\r\n                                .then(result.resolve, result.reject);\r\n                        }\r\n                    }\r\n                });\r\n            result.always(function () {\r\n                MainViewManager.focusActivePane();\r\n            });\r\n        } else {\r\n            // File is not open, or IS open but Document not dirty: close immediately\r\n            doClose(file);\r\n            MainViewManager.focusActivePane();\r\n            result.resolve();\r\n        }\r\n        return promise;\r\n    }\r\n\r\n    /**\r\n     * @param {!Array.<File>} list - the list of files to close\r\n     * @param {boolean} promptOnly - true to just prompt for saving documents with actually closing them.\r\n     * @param {boolean} _forceClose Whether to force all the documents to close even if they have unsaved changes. For unit testing only.\r\n     * @return {jQuery.Promise} promise that is resolved or rejected when the function finishes.\r\n     */\r\n    function _closeList(list, promptOnly, _forceClose) {\r\n        var result      = new $.Deferred(),\r\n            unsavedDocs = [];\r\n        \r\n        list.forEach(function (file) {\r\n            var doc = DocumentManager.getOpenDocumentForPath(file.fullPath);\r\n            if (doc && doc.isDirty) {\r\n                unsavedDocs.push(doc);\r\n            }\r\n        });\r\n        \r\n        if (unsavedDocs.length === 0 || _forceClose) {\r\n            // No unsaved changes or we want to ignore them, so we can proceed without a prompt\r\n            result.resolve();\r\n            \r\n        } else if (unsavedDocs.length === 1) {\r\n            // Only one unsaved file: show the usual single-file-close confirmation UI\r\n            var fileCloseArgs = { file: unsavedDocs[0].file, promptOnly: promptOnly };\r\n\r\n            handleFileClose(fileCloseArgs).done(function () {\r\n                // still need to close any other, non-unsaved documents\r\n                result.resolve();\r\n            }).fail(function () {\r\n                result.reject();\r\n            });\r\n            \r\n        } else {\r\n            // Multiple unsaved files: show a single bulk prompt listing all files\r\n            var message = Strings.SAVE_CLOSE_MULTI_MESSAGE + FileUtils.makeDialogFileList(_.map(unsavedDocs, _shortTitleForDocument));\r\n            \r\n            Dialogs.showModalDialog(\r\n                DefaultDialogs.DIALOG_ID_SAVE_CLOSE,\r\n                Strings.SAVE_CLOSE_TITLE,\r\n                message,\r\n                [\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_LEFT,\r\n                        id        : Dialogs.DIALOG_BTN_DONTSAVE,\r\n                        text      : Strings.DONT_SAVE\r\n                    },\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_NORMAL,\r\n                        id        : Dialogs.DIALOG_BTN_CANCEL,\r\n                        text      : Strings.CANCEL\r\n                    },\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_PRIMARY,\r\n                        id        : Dialogs.DIALOG_BTN_OK,\r\n                        text      : Strings.SAVE\r\n                    }\r\n                ]\r\n            )\r\n                .done(function (id) {\r\n                    if (id === Dialogs.DIALOG_BTN_CANCEL) {\r\n                        result.reject();\r\n                    } else if (id === Dialogs.DIALOG_BTN_OK) {\r\n                        // Save all unsaved files, then if that succeeds, close all\r\n                        _saveFileList(list).done(function (listAfterSave) {\r\n                            // List of files after save may be different, if any were Untitled\r\n                            result.resolve(listAfterSave);\r\n                        }).fail(function () {\r\n                            result.reject();\r\n                        });\r\n                    } else {\r\n                        // "Don\'t Save" case--we can just go ahead and close all files.\r\n                        result.resolve();\r\n                    }\r\n                });\r\n        }\r\n        \r\n        // If all the unsaved-changes confirmations pan out above, then go ahead & close all editors\r\n        // NOTE: this still happens before any done() handlers added by our caller, because jQ\r\n        // guarantees that handlers run in the order they are added.\r\n        result.done(function (listAfterSave) {\r\n            listAfterSave = listAfterSave || list;\r\n            if (!promptOnly) {\r\n                MainViewManager._closeList(MainViewManager.ALL_PANES, listAfterSave);\r\n            }\r\n        });\r\n        \r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * Closes all open files; equivalent to calling handleFileClose() for each document, except\r\n     * that unsaved changes are confirmed once, in bulk.\r\n     * @param {?{promptOnly: boolean, _forceClose: boolean}}\r\n     *          If promptOnly is true, only displays the relevant confirmation UI and does NOT\r\n     *          actually close any documents. This is useful when chaining close-all together with\r\n     *          other user prompts that may be cancelable.\r\n     *          If _forceClose is true, forces the files to close with no confirmation even if dirty. \r\n     *          Should only be used for unit test cleanup.\r\n     * @return {$.Promise} a promise that is resolved when all files are closed\r\n     */\r\n    function handleFileCloseAll(commandData) {\r\n        return _closeList(MainViewManager.getAllOpenFiles(),\r\n                                    (commandData && commandData.promptOnly), (commandData && commandData._forceClose));\r\n    }\r\n\r\n\r\n    /**\r\n     * Closes a list of open files; equivalent to calling handleFileClose() for each document, except\r\n     * that unsaved changes are confirmed once, in bulk.\r\n     * @param {?{promptOnly: boolean, _forceClose: boolean}}\r\n     *          If promptOnly is true, only displays the relevant confirmation UI and does NOT\r\n     *          actually close any documents. This is useful when chaining close-all together with\r\n     *          other user prompts that may be cancelable.\r\n     *          If _forceClose is true, forces the files to close with no confirmation even if dirty. \r\n     *          Should only be used for unit test cleanup.\r\n     * @return {$.Promise} a promise that is resolved when all files are closed\r\n     */\r\n    function handleFileCloseList(commandData) {\r\n        return _closeList(commandData.fileList);\r\n    }\r\n\r\n    /**\r\n     * @private - tracks our closing state if we get called again\r\n     */\r\n    var _windowGoingAway = false;\r\n\r\n    /**\r\n     * @private\r\n     * Common implementation for close/quit/reload which all mostly\r\n     * the same except for the final step\r\n     * @param {Object} commandData - (not referenced)\r\n     * @param {!function()} postCloseHandler - called after close\r\n     * @param {!function()} failHandler - called when the save fails to cancel closing the window\r\n     */\r\n    function _handleWindowGoingAway(commandData, postCloseHandler, failHandler) {\r\n        if (_windowGoingAway) {\r\n            //if we get called back while we\'re closing, then just return\r\n            return (new $.Deferred()).reject().promise();\r\n        }\r\n\r\n        return CommandManager.execute(Commands.FILE_CLOSE_ALL, { promptOnly: true })\r\n            .done(function () {\r\n                _windowGoingAway = true;\r\n                \r\n                // Give everyone a chance to save their state - but don\'t let any problems block\r\n                // us from quitting\r\n                try {\r\n                    $(ProjectManager).triggerHandler("beforeAppClose");\r\n                } catch (ex) {\r\n                    console.error(ex);\r\n                }\r\n                \r\n                PreferencesManager.savePreferences();\r\n                \r\n                PreferencesManager.finalize().always(postCloseHandler);\r\n            })\r\n            .fail(function () {\r\n                _windowGoingAway = false;\r\n                if (failHandler) {\r\n                    failHandler();\r\n                }\r\n            });\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Implementation for abortQuit callback to reset quit sequence settings\r\n     */\r\n    function handleAbortQuit() {\r\n        _windowGoingAway = false;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Implementation for native APP_BEFORE_MENUPOPUP callback to trigger beforeMenuPopup event\r\n     */\r\n    function handleBeforeMenuPopup() {\r\n        $(PopUpManager).triggerHandler("beforeMenuPopup");\r\n    }\r\n\r\n    /** \r\n     * Confirms any unsaved changes, then closes the window \r\n     * @param {Object} command data\r\n     */\r\n    function handleFileCloseWindow(commandData) {\r\n        return _handleWindowGoingAway(\r\n            commandData,\r\n            function () {\r\n                window.close();\r\n            },\r\n            function () {\r\n                // if fail, tell the app to abort any pending quit operation.\r\n                brackets.app.abortQuit();\r\n            }\r\n        );\r\n    }\r\n\r\n    /** Show a textfield to rename whatever is currently selected in the sidebar (or current doc if nothing else selected) */\r\n    function handleFileRename() {\r\n        // Prefer selected sidebar item (which could be a folder)\r\n        var entry = ProjectManager.getSelectedItem();\r\n        if (!entry) {\r\n            // Else use current file (not selected in ProjectManager if not visible in tree or workingset)\r\n            entry = MainViewManager.getCurrentlyViewedFile();\r\n        }\r\n        if (entry) {\r\n            ProjectManager.renameItemInline(entry);\r\n        }\r\n    }\r\n\r\n    /** Closes the window, then quits the app */\r\n    function handleFileQuit(commandData) {\r\n        return _handleWindowGoingAway(\r\n            commandData,\r\n            function () {\r\n                brackets.app.quit();\r\n            },\r\n            function () {\r\n                // if fail, don\'t exit: user canceled (or asked us to save changes first, but we failed to do so)\r\n                brackets.app.abortQuit();\r\n            }\r\n        );\r\n    }\r\n\r\n\r\n    /** Are we already listening for a keyup to call detectDocumentNavEnd()? */\r\n    var _addedNavKeyHandler = false;\r\n\r\n    /**\r\n     * When the Ctrl key is released, if we were in the middle of a next/prev document navigation\r\n     * sequence, now is the time to end it and update the MRU order. If we allowed the order to update\r\n     * on every next/prev increment, the 1st & 2nd entries would just switch places forever and we\'d\r\n     * never get further down the list.\r\n     * @param {jQueryEvent} event Key-up event\r\n     */\r\n    function detectDocumentNavEnd(event) {\r\n        if (event.keyCode === KeyEvent.DOM_VK_CONTROL) {  // Ctrl key\r\n            MainViewManager.endTraversal();\r\n            _addedNavKeyHandler = false;\r\n            $(window.document.body).off("keyup", detectDocumentNavEnd);\r\n        }\r\n    }\r\n\r\n    /** Navigate to the next/previous (MRU) document. Don\'t update MRU order yet */\r\n    function goNextPrevDoc(inc) {\r\n        var result = MainViewManager.traverseToNextViewByMRU(inc);\r\n        if (result) {\r\n            var file = result.file,\r\n                paneId = result.paneId;\r\n            \r\n            MainViewManager.beginTraversal();\r\n            CommandManager.execute(Commands.FILE_OPEN, {fullPath: file.fullPath,\r\n                                                        paneId: paneId });\r\n            \r\n            // Listen for ending of Ctrl+Tab sequence\r\n            if (!_addedNavKeyHandler) {\r\n                _addedNavKeyHandler = true;\r\n                $(window.document.body).keyup(detectDocumentNavEnd);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Next Doc command handler **/\r\n    function handleGoNextDoc() {\r\n        goNextPrevDoc(+1);\r\n\r\n    }\r\n    /** Previous Doc command handler **/\r\n    function handleGoPrevDoc() {\r\n        goNextPrevDoc(-1);\r\n    }\r\n\r\n    /** Show in File Tree command handler **/\r\n    function handleShowInTree() {\r\n        ProjectManager.showInTree(MainViewManager.getCurrentlyViewedFile(MainViewManager.ACTIVE_PANE));\r\n    }\r\n\r\n    /** Delete file command handler  **/\r\n    function handleFileDelete() {\r\n        var entry = ProjectManager.getSelectedItem();\r\n        if (entry.isDirectory) {\r\n            Dialogs.showModalDialog(\r\n                DefaultDialogs.DIALOG_ID_EXT_DELETED,\r\n                Strings.CONFIRM_FOLDER_DELETE_TITLE,\r\n                StringUtils.format(\r\n                    Strings.CONFIRM_FOLDER_DELETE,\r\n                    StringUtils.breakableUrl(entry.name)\r\n                ),\r\n                [\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_NORMAL,\r\n                        id        : Dialogs.DIALOG_BTN_CANCEL,\r\n                        text      : Strings.CANCEL\r\n                    },\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_PRIMARY,\r\n                        id        : Dialogs.DIALOG_BTN_OK,\r\n                        text      : Strings.DELETE\r\n                    }\r\n                ]\r\n            )\r\n                .done(function (id) {\r\n                    if (id === Dialogs.DIALOG_BTN_OK) {\r\n                        ProjectManager.deleteItem(entry);\r\n                    }\r\n                });\r\n        } else {\r\n            ProjectManager.deleteItem(entry);\r\n        }\r\n    }\r\n\r\n    /** Show the selected sidebar (tree or workingset) item in Finder/Explorer */\r\n    function handleShowInOS() {\r\n        var entry = ProjectManager.getSelectedItem();\r\n        if (entry) {\r\n            brackets.app.showOSFolder(entry.fullPath, function (err) {\r\n                if (err) {\r\n                    console.error("Error showing \'" + entry.fullPath + "\' in OS folder:", err);\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables Brackets\' cache via the remote debugging protocol.\r\n     * @return {$.Promise} A jQuery promise that will be resolved when the cache is disabled and be rejected in any other case\r\n     */\r\n    function _disableCache() {\r\n        var result = new $.Deferred();\r\n        \r\n        if (brackets.inBrowser) {\r\n            result.resolve();\r\n        } else {\r\n            var port = brackets.app.getRemoteDebuggingPort ? brackets.app.getRemoteDebuggingPort() : 9234;\r\n            Inspector.getDebuggableWindows("127.0.0.1", port)\r\n                .fail(result.reject)\r\n                .done(function (response) {\r\n                    var page = response[0];\r\n                    if (!page || !page.webSocketDebuggerUrl) {\r\n                        result.reject();\r\n                        return;\r\n                    }\r\n                    var _socket = new WebSocket(page.webSocketDebuggerUrl);\r\n                    // Disable the cache\r\n                    _socket.onopen = function _onConnect() {\r\n                        _socket.send(JSON.stringify({ id: 1, method: "Network.setCacheDisabled", params: { "cacheDisabled": true } }));\r\n                    };\r\n                    // The first message will be the confirmation => disconnected to allow remote debugging of Brackets\r\n                    _socket.onmessage = function _onMessage(e) {\r\n                        _socket.close();\r\n                        result.resolve();\r\n                    };\r\n                    // In case of an error\r\n                    _socket.onerror = result.reject;\r\n                });\r\n        }\r\n         \r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n    * Does a full reload of the browser window\r\n    * @param {string} href The url to reload into the window\r\n    */\r\n    function browserReload(href) {\r\n        if (_isReloading) {\r\n            return;\r\n        }\r\n        \r\n        _isReloading = true;\r\n        \r\n        return CommandManager.execute(Commands.FILE_CLOSE_ALL, { promptOnly: true }).done(function () {\r\n            // Give everyone a chance to save their state - but don\'t let any problems block\r\n            // us from quitting\r\n            try {\r\n                $(ProjectManager).triggerHandler("beforeAppClose");\r\n            } catch (ex) {\r\n                console.error(ex);\r\n            }\r\n            \r\n            // Disable the cache to make reloads work\r\n            _disableCache().always(function () {\r\n                // Remove all menus to assure every part of Brackets is reloaded\r\n                _.forEach(Menus.getAllMenus(), function (value, key) {\r\n                    Menus.removeMenu(key);\r\n                });\r\n                \r\n                // If there\'s a fragment in both URLs, setting location.href won\'t actually reload\r\n                var fragment = href.indexOf("#");\r\n                if (fragment !== -1) {\r\n                    href = href.substr(0, fragment);\r\n                }\r\n                \r\n                window.location.href = href;\r\n            });\r\n        }).fail(function () {\r\n            _isReloading = false;\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Restarts brackets Handler\r\n     * @param {boolean=} loadWithoutExtensions - true to restart without extensions, \r\n     *                                           otherwise extensions are loadeed as it is durning a typical boot\r\n     */\r\n    function handleReload(loadWithoutExtensions) {\r\n        var href    = window.location.href,\r\n            params  = new UrlParams();\r\n        \r\n        // Make sure the Reload Without User Extensions parameter is removed\r\n        params.parse();\r\n        \r\n        if (loadWithoutExtensions) {\r\n            if (!params.get("reloadWithoutUserExts")) {\r\n                params.put("reloadWithoutUserExts", true);\r\n            }\r\n        } else {\r\n            if (params.get("reloadWithoutUserExts")) {\r\n                params.remove("reloadWithoutUserExts");\r\n            }\r\n        }\r\n        \r\n        if (href.indexOf("?") !== -1) {\r\n            href = href.substring(0, href.indexOf("?"));\r\n        }\r\n        \r\n        if (!params.isEmpty()) {\r\n            href += "?" + params.toString();\r\n        }\r\n        \r\n        // Give Mac native menus extra time to update shortcut highlighting.\r\n        // Prevents the menu highlighting from getting messed up after reload.\r\n        window.setTimeout(function () {\r\n            browserReload(href);\r\n        }, 100);\r\n    }\r\n\r\n\r\n    /** Reload Without Extensions commnad handler **/\r\n    var handleReloadWithoutExts = _.partial(handleReload, true);\r\n\r\n    /** Do some initialization when the DOM is ready **/\r\n    AppInit.htmlReady(function () {\r\n        // If in Reload Without User Extensions mode, update UI and log console message\r\n        var params      = new UrlParams(),\r\n            $icon       = $("#toolbar-extension-manager"),\r\n            $indicator  = $("<div>" + Strings.STATUSBAR_USER_EXTENSIONS_DISABLED + "</div>");\r\n        \r\n        params.parse();\r\n        \r\n        if (params.get("reloadWithoutUserExts") === "true") {\r\n            CommandManager.get(Commands.FILE_EXTENSION_MANAGER).setEnabled(false);\r\n            $icon.css({display: "none"});\r\n            StatusBar.addIndicator("status-user-exts", $indicator, true);\r\n            console.log("Brackets reloaded with extensions disabled");\r\n        }\r\n        \r\n        // Init DOM elements\r\n        _$titleContainerToolbar = $("#titlebar");\r\n        _$titleWrapper = $(".title-wrapper", _$titleContainerToolbar);\r\n        _$title = $(".title", _$titleWrapper);\r\n        _$dirtydot = $(".dirty-dot", _$titleWrapper);\r\n    });\r\n\r\n    // Exported for unit testing only\r\n    exports._parseDecoratedPath = _parseDecoratedPath;\r\n\r\n    // Set some command strings\r\n    var quitString  = Strings.CMD_QUIT,\r\n        showInOS    = Strings.CMD_SHOW_IN_OS;\r\n    if (brackets.platform === "win") {\r\n        quitString  = Strings.CMD_EXIT;\r\n        showInOS    = Strings.CMD_SHOW_IN_EXPLORER;\r\n    } else if (brackets.platform === "mac") {\r\n        showInOS    = Strings.CMD_SHOW_IN_FINDER;\r\n    }\r\n\r\n    // Deprecated commands\r\n    CommandManager.register(Strings.CMD_ADD_TO_WORKINGSET_AND_OPEN,  Commands.FILE_ADD_TO_WORKING_SET,        handleFileAddToWorkingSet);\r\n    CommandManager.register(Strings.CMD_FILE_OPEN,                   Commands.FILE_OPEN,                      handleDocumentOpen);\r\n    \r\n    // New commands\r\n    CommandManager.register(Strings.CMD_FILE_OPEN,                   Commands.CMD_OPEN,                       handleFileOpen);\r\n    CommandManager.register(Strings.CMD_ADD_TO_WORKINGSET_AND_OPEN,  Commands.CMD_ADD_TO_WORKINGSET_AND_OPEN, handleFileAddToWorkingSetAndOpen);\r\n    \r\n    // File Commands\r\n    CommandManager.register(Strings.CMD_FILE_NEW_UNTITLED,           Commands.FILE_NEW_UNTITLED,              handleFileNew);\r\n    CommandManager.register(Strings.CMD_FILE_NEW,                    Commands.FILE_NEW,                       handleFileNewInProject);\r\n    CommandManager.register(Strings.CMD_FILE_NEW_FOLDER,             Commands.FILE_NEW_FOLDER,                handleNewFolderInProject);\r\n    CommandManager.register(Strings.CMD_FILE_SAVE,                   Commands.FILE_SAVE,                      handleFileSave);\r\n    CommandManager.register(Strings.CMD_FILE_SAVE_ALL,               Commands.FILE_SAVE_ALL,                  handleFileSaveAll);\r\n    CommandManager.register(Strings.CMD_FILE_SAVE_AS,                Commands.FILE_SAVE_AS,                   handleFileSaveAs);\r\n    CommandManager.register(Strings.CMD_FILE_RENAME,                 Commands.FILE_RENAME,                    handleFileRename);\r\n    CommandManager.register(Strings.CMD_FILE_DELETE,                 Commands.FILE_DELETE,                    handleFileDelete);\r\n    \r\n    // Close Commands\r\n    CommandManager.register(Strings.CMD_FILE_CLOSE,                  Commands.FILE_CLOSE,                     handleFileClose);\r\n    CommandManager.register(Strings.CMD_FILE_CLOSE_ALL,              Commands.FILE_CLOSE_ALL,                 handleFileCloseAll);\r\n    CommandManager.register(Strings.CMD_FILE_CLOSE_LIST,             Commands.FILE_CLOSE_LIST,                handleFileCloseList);\r\n    \r\n    // Traversal\r\n    CommandManager.register(Strings.CMD_NEXT_DOC,                    Commands.NAVIGATE_NEXT_DOC,              handleGoNextDoc);\r\n    CommandManager.register(Strings.CMD_PREV_DOC,                    Commands.NAVIGATE_PREV_DOC,              handleGoPrevDoc);\r\n\r\n    // Special Commands\r\n    CommandManager.register(showInOS,                                Commands.NAVIGATE_SHOW_IN_OS,            handleShowInOS);\r\n    CommandManager.register(quitString,                              Commands.FILE_QUIT,                      handleFileQuit);\r\n    CommandManager.register(Strings.CMD_SHOW_IN_TREE,                Commands.NAVIGATE_SHOW_IN_FILE_TREE,     handleShowInTree);\r\n\r\n    // These commands have no UI representation and are only used internally\r\n    CommandManager.registerInternal(Commands.APP_ABORT_QUIT,            handleAbortQuit);\r\n    CommandManager.registerInternal(Commands.APP_BEFORE_MENUPOPUP,      handleBeforeMenuPopup);\r\n    CommandManager.registerInternal(Commands.FILE_CLOSE_WINDOW,         handleFileCloseWindow);\r\n    CommandManager.registerInternal(Commands.APP_RELOAD,                handleReload);\r\n    CommandManager.registerInternal(Commands.APP_RELOAD_WITHOUT_EXTS,   handleReloadWithoutExts);\r\n\r\n    // Listen for changes that require updating the editor titlebar\r\n    $(DocumentManager).on("dirtyFlagChange", handleDirtyChange);\r\n    $(DocumentManager).on("fileNameChange", handleCurrentFileChange);\r\n    $(MainViewManager).on("currentFileChange", handleCurrentFileChange);\r\n\r\n    // Reset the untitled document counter before changing projects\r\n    $(ProjectManager).on("beforeProjectClose", function () { _nextUntitledIndexToUse = 1; });\r\n});\r\n\n//# sourceURL=/document/DocumentCommandHandlers.js'),eval("define('text!htmlContent/code-hint-list.html',[],function () { return '{{#hints}}\\r\\n    <li>\\r\\n        <a href=\"#\">\\r\\n            <span class=\"codehint-item\">{{{formattedHint}}}</span>\\r\\n        </a>\\r\\n    </li>\\r\\n{{/hints}}';});\n\n//# sourceURL=/text!htmlContent/code-hint-list.html"),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, brackets, Mustache */\r\n\r\ndefine(\'editor/CodeHintList\',[\'require\',\'exports\',\'module\',\'command/Menus\',\'utils/StringUtils\',\'widgets/PopUpManager\',\'utils/ViewUtils\',\'command/KeyBindingManager\',\'utils/KeyEvent\',\'text!htmlContent/code-hint-list.html\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    // Load dependent modules\r\n    var Menus             = require("command/Menus"),\r\n        StringUtils       = require("utils/StringUtils"),\r\n        PopUpManager      = require("widgets/PopUpManager"),\r\n        ViewUtils         = require("utils/ViewUtils"),\r\n        KeyBindingManager = require("command/KeyBindingManager"),\r\n        KeyEvent          = require("utils/KeyEvent");\r\n    \r\n    var CodeHintListHTML  = require("text!htmlContent/code-hint-list.html");\r\n\r\n    /**\r\n     * Displays a popup list of hints for a given editor context.\r\n     *\r\n     * @constructor\r\n     * @param {Editor} editor\r\n     */\r\n    function CodeHintList(editor, insertHintOnTab) {\r\n\r\n        /**\r\n         * The list of hints to display\r\n         *\r\n         * @type {Array.<string|jQueryObject>}\r\n         */\r\n        this.hints = [];\r\n\r\n        /**\r\n         * The selected position in the list; otherwise -1.\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.selectedIndex = -1;\r\n\r\n        /**\r\n         * The maximum number of hints to display\r\n         *\r\n         * @type {number}\r\n         */\r\n        this.maxResults = 999;\r\n\r\n        /**\r\n         * Is the list currently open?\r\n         *\r\n         * @type {boolean}\r\n         */\r\n        this.opened = false;\r\n\r\n        /**\r\n         * The editor context\r\n         *\r\n         * @type {Editor}\r\n         */\r\n        this.editor = editor;\r\n        \r\n        /**\r\n         * Whether the currently selected hint should be inserted on a tab key event\r\n         *\r\n         * @type {boolean}\r\n         */\r\n        this.insertHintOnTab = insertHintOnTab;\r\n\r\n        /**\r\n         * Pending text insertion\r\n         *\r\n         * @type {string}\r\n         */\r\n        this.pendingText = "";\r\n\r\n        /**\r\n         * The hint selection callback function\r\n         *\r\n         * @type {Function}\r\n         */\r\n        this.handleSelect = null;\r\n\r\n        /**\r\n         * The hint list closure callback function\r\n         *\r\n         * @type {Function}\r\n         */\r\n        this.handleClose = null;\r\n\r\n        /**\r\n         * The hint list menu object\r\n         *\r\n         * @type {jQuery.Object}\r\n         */\r\n        this.$hintMenu =\r\n            $("<li class=\'dropdown codehint-menu\'></li>")\r\n                .append($("<a href=\'#\' class=\'dropdown-toggle\' data-toggle=\'dropdown\'></a>")\r\n                        .hide())\r\n                .append("<ul class=\'dropdown-menu\'></ul>");\r\n        \r\n        this._keydownHook = this._keydownHook.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Select the item in the hint list at the specified index, or remove the\r\n     * selection if index < 0.\r\n     *\r\n     * @private\r\n     * @param {number} index\r\n     */\r\n    CodeHintList.prototype._setSelectedIndex = function (index) {\r\n        var items = this.$hintMenu.find("li");\r\n        \r\n        // Range check\r\n        index = Math.max(-1, Math.min(index, items.length - 1));\r\n        \r\n        // Clear old highlight\r\n        if (this.selectedIndex !== -1) {\r\n            $(items[this.selectedIndex]).find("a").removeClass("highlight");\r\n        }\r\n\r\n        this.selectedIndex = index;\r\n\r\n        // Highlight the new selected item, if necessary\r\n        if (this.selectedIndex !== -1) {\r\n            var $item = $(items[this.selectedIndex]);\r\n            var $view = this.$hintMenu.find("ul.dropdown-menu");\r\n\r\n            $item.find("a").addClass("highlight");\r\n            ViewUtils.scrollElementIntoView($view, $item, false);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Appends text to end of pending text.\r\n     *\r\n     * @param {string} text\r\n     */\r\n    CodeHintList.prototype.addPendingText = function (text) {\r\n        this.pendingText += text;\r\n    };\r\n\r\n    /**\r\n     * Removes text from beginning of pending text.\r\n     *\r\n     * @param {string} text\r\n     */\r\n    CodeHintList.prototype.removePendingText = function (text) {\r\n        if (this.pendingText.indexOf(text) === 0) {\r\n            this.pendingText = this.pendingText.slice(text.length);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Rebuilds the list items for the hint list.\r\n     *\r\n     * @private\r\n     */\r\n    CodeHintList.prototype._buildListView = function (hintObj) {\r\n        var self            = this,\r\n            match           = hintObj.match,\r\n            selectInitial   = hintObj.selectInitial,\r\n            view            = { hints: [] },\r\n            _addHint;\r\n\r\n        this.hints = hintObj.hints;\r\n        this.hints.handleWideResults = hintObj.handleWideResults;\r\n\r\n        // if there is no match, assume name is already a formatted jQuery\r\n        // object; otherwise, use match to format name for display.\r\n        if (match) {\r\n            _addHint = function (name) {\r\n                var displayName = name.replace(\r\n                    new RegExp(StringUtils.regexEscape(match), "i"),\r\n                    "<strong>$&</strong>"\r\n                );\r\n                \r\n                view.hints.push({ formattedHint: "<span>" + displayName + "</span>" });\r\n            };\r\n        } else {\r\n            _addHint = function (hint) {\r\n                view.hints.push({ formattedHint: (hint.jquery) ? "" : hint });\r\n            };\r\n        }\r\n\r\n        // clear the list \r\n        this.$hintMenu.find("li").remove();\r\n\r\n        // if there are no hints then close the list; otherwise add them and\r\n        // set the selection\r\n        if (this.hints.length === 0) {\r\n            if (this.handleClose) {\r\n                this.handleClose();\r\n            }\r\n        } else {\r\n            this.hints.some(function (item, index) {\r\n                if (index > self.maxResults) {\r\n                    return true;\r\n                }\r\n                \r\n                _addHint(item);\r\n            });\r\n            \r\n            // render code hint list\r\n            var $ul = this.$hintMenu.find("ul.dropdown-menu"),\r\n                $parent = $ul.parent();\r\n            \r\n            // remove list temporarily to save rendering time\r\n            $ul.remove().append(Mustache.render(CodeHintListHTML, view));\r\n            \r\n            $ul.children("li").each(function (index, element) {\r\n                var hint        = self.hints[index],\r\n                    $element    = $(element);\r\n                \r\n                // store hint on each list item\r\n                $element.data("hint", hint);\r\n                \r\n                // insert jQuery hint objects after the template is rendered\r\n                if (hint.jquery) {\r\n                    $element.find(".codehint-item").append(hint);\r\n                }\r\n            });\r\n            \r\n            // delegate list item events to the top-level ul list element\r\n            $ul.on("click", "li", function (e) {\r\n                // Don\'t let the click propagate upward (otherwise it will\r\n                // hit the close handler in bootstrap-dropdown).\r\n                e.stopPropagation();\r\n                if (self.handleSelect) {\r\n                    self.handleSelect($(this).data("hint"));\r\n                }\r\n            });\r\n            \r\n            // Lists with wide results require different formatting\r\n            if (this.hints.handleWideResults) {\r\n                $ul.find("li a").addClass("wide-result");\r\n            }\r\n            \r\n            // attach to DOM\r\n            $parent.append($ul);\r\n            \r\n            this._setSelectedIndex(selectInitial ? 0 : -1);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Computes top left location for hint list so that the list is not clipped by the window.\r\n     * Also computes the largest available width.\r\n     *\r\n     * @private\r\n     * @return {{left: number, top: number, width: number}}\r\n     */\r\n    CodeHintList.prototype._calcHintListLocation = function () {\r\n        var cursor      = this.editor._codeMirror.cursorCoords(),\r\n            posTop      = cursor.bottom,\r\n            posLeft     = cursor.left,\r\n            textHeight  = this.editor.getTextHeight(),\r\n            $window     = $(window),\r\n            $menuWindow = this.$hintMenu.children("ul"),\r\n            menuHeight  = $menuWindow.outerHeight();\r\n\r\n        // TODO Ty: factor out menu repositioning logic so code hints and Context menus share code\r\n        // adjust positioning so menu is not clipped off bottom or right\r\n        var bottomOverhang = posTop + menuHeight - $window.height();\r\n        if (bottomOverhang > 0) {\r\n            posTop -= (textHeight + 2 + menuHeight);\r\n        }\r\n\r\n        posTop -= 30;   // shift top for hidden parent element\r\n        \r\n        var menuWidth = $menuWindow.width();\r\n        var availableWidth = menuWidth;\r\n        var rightOverhang = posLeft + menuWidth - $window.width();\r\n        if (rightOverhang > 0) {\r\n            posLeft = Math.max(0, posLeft - rightOverhang);\r\n        } else if (this.hints.handleWideResults) {\r\n            // Right overhang is negative\r\n            availableWidth = menuWidth + Math.abs(rightOverhang);\r\n        }\r\n\r\n        return {left: posLeft, top: posTop, width: availableWidth};\r\n    };\r\n    \r\n    /**\r\n     * Check whether keyCode is one of the keys that we handle or not.\r\n     *\r\n     * @param {number} keyCode\r\n     */\r\n    CodeHintList.prototype.isHandlingKeyCode = function (keyCode) {\r\n        return (keyCode === KeyEvent.DOM_VK_UP || keyCode === KeyEvent.DOM_VK_DOWN ||\r\n                keyCode === KeyEvent.DOM_VK_PAGE_UP || keyCode === KeyEvent.DOM_VK_PAGE_DOWN ||\r\n                keyCode === KeyEvent.DOM_VK_RETURN ||\r\n                (keyCode === KeyEvent.DOM_VK_TAB && this.insertHintOnTab));\r\n    };\r\n\r\n    /**\r\n     * Convert keydown events into hint list navigation actions.\r\n     *\r\n     * @param {KeyBoardEvent} keyEvent\r\n     */\r\n    CodeHintList.prototype._keydownHook = function (event) {\r\n        var keyCode,\r\n            self = this;\r\n\r\n        // positive distance rotates down; negative distance rotates up\r\n        function _rotateSelection(distance) {\r\n            var len = Math.min(self.hints.length, self.maxResults),\r\n                pos;\r\n\r\n            if (self.selectedIndex < 0) {\r\n                // set the initial selection\r\n                pos = (distance > 0) ? distance - 1 : len - 1;\r\n\r\n            } else {\r\n                // adjust current selection\r\n                pos = self.selectedIndex;\r\n\r\n                // Don\'t "rotate" until all items have been shown\r\n                if (distance > 0) {\r\n                    if (pos === (len - 1)) {\r\n                        pos = 0;  // wrap\r\n                    } else {\r\n                        pos = Math.min(pos + distance, len - 1);\r\n                    }\r\n                } else {\r\n                    if (pos === 0) {\r\n                        pos = (len - 1);  // wrap\r\n                    } else {\r\n                        pos = Math.max(pos + distance, 0);\r\n                    }\r\n                }\r\n            }\r\n\r\n            self._setSelectedIndex(pos);\r\n        }\r\n\r\n        // Calculate the number of items per scroll page.\r\n        function _itemsPerPage() {\r\n            var itemsPerPage = 1,\r\n                $items = self.$hintMenu.find("li"),\r\n                $view = self.$hintMenu.find("ul.dropdown-menu"),\r\n                itemHeight;\r\n    \r\n            if ($items.length !== 0) {\r\n                itemHeight = $($items[0]).height();\r\n                if (itemHeight) {\r\n                    // round down to integer value\r\n                    itemsPerPage = Math.floor($view.height() / itemHeight);\r\n                    itemsPerPage = Math.max(1, Math.min(itemsPerPage, $items.length));\r\n                }\r\n            }\r\n\r\n            return itemsPerPage;\r\n        }\r\n\r\n        // If we\'re no longer visible, skip handling the key and end the session.\r\n        if (!this.isOpen()) {\r\n            this.handleClose();\r\n            return false;\r\n        }\r\n\r\n        // (page) up, (page) down, enter and tab key are handled by the list\r\n        if (event.type === "keydown" && this.isHandlingKeyCode(event.keyCode)) {\r\n            keyCode = event.keyCode;\r\n\r\n            if (event.shiftKey &&\r\n                    (event.keyCode === KeyEvent.DOM_VK_UP ||\r\n                     event.keyCode === KeyEvent.DOM_VK_DOWN ||\r\n                     event.keyCode === KeyEvent.DOM_VK_PAGE_UP ||\r\n                     event.keyCode === KeyEvent.DOM_VK_PAGE_DOWN)) {\r\n                this.handleClose();\r\n                \r\n                // Let the event bubble.\r\n                return false;\r\n            } else if (keyCode === KeyEvent.DOM_VK_UP) {\r\n                _rotateSelection.call(this, -1);\r\n            } else if (keyCode === KeyEvent.DOM_VK_DOWN) {\r\n                _rotateSelection.call(this, 1);\r\n            } else if (keyCode === KeyEvent.DOM_VK_PAGE_UP) {\r\n                _rotateSelection.call(this, -_itemsPerPage());\r\n            } else if (keyCode === KeyEvent.DOM_VK_PAGE_DOWN) {\r\n                _rotateSelection.call(this, _itemsPerPage());\r\n            } else if (this.selectedIndex !== -1 &&\r\n                    (keyCode === KeyEvent.DOM_VK_RETURN ||\r\n                    (keyCode === KeyEvent.DOM_VK_TAB && this.insertHintOnTab))) {\r\n\r\n                if (this.pendingText) {\r\n                    // Issues #5003: We received a "selection" key while there is "pending\r\n                    // text". This is rare but can happen because CM uses polling, so we\r\n                    // can receive key events while CM is waiting for timeout to expire.\r\n                    // Pending text may dismiss the list, or it may cause a valid selection\r\n                    // which keeps open hint list. We can compare pending text against\r\n                    // list to determine whether list is dismissed or not, but to handle\r\n                    // inserting selection in the page we\'d need to either:\r\n                    // 1. Synchronously force CodeMirror to poll (but there is not\r\n                    //    yet a public API for that).\r\n                    // 2. Pass pending text back to where text gets inserted, which\r\n                    //    means it would need to be implemented for every HintProvider!\r\n                    // You have to be typing so fast to hit this case, that\'s it\'s\r\n                    // highly unlikely that inserting something from list was the intent,\r\n                    // which makes this pretty rare, so case #2 is not worth implementing.\r\n                    // If case #1 gets implemented, then we may want to use it here.\r\n                    // So, assume that pending text dismisses hints and let event bubble.\r\n                    return false;\r\n                }\r\n                \r\n                // Trigger a click handler to commmit the selected item\r\n                $(this.$hintMenu.find("li")[this.selectedIndex]).trigger("click");\r\n            } else {\r\n                // Let the event bubble.\r\n                return false;\r\n            }\r\n            \r\n            event.stopImmediatePropagation();\r\n            event.preventDefault();\r\n            return true;\r\n        }\r\n        \r\n        // If we didn\'t handle it, let other global keydown hooks handle it.\r\n        return false;\r\n    };\r\n\r\n    /**\r\n     * Is the CodeHintList open?\r\n     *\r\n     * @return {boolean}\r\n     */\r\n    CodeHintList.prototype.isOpen = function () {\r\n        // We don\'t get a notification when the dropdown closes. The best\r\n        // we can do is keep an "opened" flag and check to see if we\r\n        // still have the "open" class applied.\r\n        if (this.opened && !this.$hintMenu.hasClass("open")) {\r\n            this.opened = false;\r\n        }\r\n        \r\n        return this.opened;\r\n    };\r\n\r\n    /**\r\n     * Displays the hint list at the current cursor position\r\n     *\r\n     * @param {{hints: Array.<string|jQueryObject>, match: string,\r\n     *          selectInitial: boolean}} hintObj\r\n     */\r\n    CodeHintList.prototype.open = function (hintObj) {\r\n        Menus.closeAll();\r\n        this._buildListView(hintObj);\r\n\r\n        if (this.hints.length) {\r\n            // Need to add the menu to the DOM before trying to calculate its ideal location.\r\n            $("#codehint-menu-bar > ul").append(this.$hintMenu);\r\n            \r\n            var hintPos = this._calcHintListLocation();\r\n            \r\n            this.$hintMenu.addClass("open")\r\n                .css({"left": hintPos.left, "top": hintPos.top, "width": hintPos.width + "px"});\r\n            this.opened = true;\r\n            \r\n            PopUpManager.addPopUp(this.$hintMenu, this.handleClose, true);\r\n            \r\n            KeyBindingManager.addGlobalKeydownHook(this._keydownHook);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Updates the (already open) hint list window with new hints\r\n     *\r\n     * @param {{hints: Array.<string|jQueryObject>, match: string,\r\n     *          selectInitial: boolean}} hintObj\r\n     */\r\n    CodeHintList.prototype.update = function (hintObj) {\r\n        this.$hintMenu.addClass("apply-transition");\r\n        this._buildListView(hintObj);\r\n\r\n        // Update the CodeHintList location\r\n        if (this.hints.length) {\r\n            var hintPos = this._calcHintListLocation();\r\n            this.$hintMenu.css({"left": hintPos.left, "top": hintPos.top,\r\n                                "width": hintPos.width + "px"});\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Closes the hint list\r\n     */\r\n    CodeHintList.prototype.close = function () {\r\n        this.opened = false;\r\n        \r\n        if (this.$hintMenu) {\r\n            this.$hintMenu.removeClass("open");\r\n            PopUpManager.removePopUp(this.$hintMenu);\r\n            this.$hintMenu.remove();\r\n        }\r\n        \r\n        KeyBindingManager.removeGlobalKeydownHook(this._keydownHook);\r\n    };\r\n\r\n    /**\r\n     * Set the hint list selection callback function\r\n     *\r\n     * @param {Function} callback\r\n     */\r\n    CodeHintList.prototype.onSelect = function (callback) {\r\n        this.handleSelect = callback;\r\n    };\r\n\r\n    /**\r\n     * Set the hint list closure callback function\r\n     *\r\n     * @param {Function} callback\r\n     */\r\n    CodeHintList.prototype.onClose = function (callback) {\r\n        // TODO: Due to #1381, this won\'t get called if the user clicks out of\r\n        // the code hint menu. That\'s (sort of) okay right now since it doesn\'t\r\n        // really matter if a single old invisible code hint list is lying \r\n        // around (it will ignore keydown events, and it\'ll get closed the next \r\n        // time the user pops up a code hint). Once #1381 is fixed this issue \r\n        // should go away.\r\n        this.handleClose = callback;\r\n    };\r\n\r\n\r\n    // Define public API\r\n    exports.CodeHintList = CodeHintList;\r\n});\r\n\n//# sourceURL=/editor/CodeHintList.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets */\r\n\r\n/*\r\n * __CodeHintManager Overview:__\r\n *\r\n * The CodeHintManager mediates the interaction between the editor and a\r\n * collection of hint providers. If hints are requested explicitly by the\r\n * user, then the providers registered for the current language are queried\r\n * for their ability to provide hints in order of descending priority by\r\n * way their hasHints methods. Character insertions may also constitute an\r\n * implicit request for hints; consequently, providers for the current\r\n * language are also queried on character insertion for both their ability to\r\n * provide hints and also for the suitability of providing implicit hints\r\n * in the given editor context.\r\n *\r\n * Once a provider responds affirmatively to a request for hints, the\r\n * manager begins a hinting session with that provider, begins to query\r\n * that provider for hints by way of its getHints method, and opens the\r\n * hint list window. The hint list is kept open for the duration of the\r\n * current session. The manager maintains the session until either:\r\n *\r\n *  1. the provider gives a null response to a request for hints;\r\n *  2. a deferred response to getHints fails to resolve;\r\n *  3. the user explicitly dismisses the hint list window;\r\n *  4. the editor is closed or becomes inactive; or\r\n *  5. the editor undergoes a "complex" change, e.g., a multi-character\r\n *     insertion, deletion or navigation.\r\n *\r\n * Single-character insertions, deletions or navigations may not\r\n * invalidate the current session; in which case, each such change\r\n * precipitates a successive call to getHints.\r\n *\r\n * If the user selects a hint from the rendered hint list then the\r\n * provider is responsible for inserting the hint into the editor context\r\n * for the current session by way of its insertHint method. The provider\r\n * may use the return value of insertHint to request that an additional\r\n * explicit hint request be triggered, potentially beginning a new\r\n * session.\r\n *\r\n *\r\n * __CodeHintProvider Overview:__\r\n *\r\n * A code hint provider should implement the following three functions:\r\n *\r\n * - `CodeHintProvider.hasHints(editor, implicitChar)`\r\n * - `CodeHintProvider.getHints(implicitChar)`\r\n * - `CodeHintProvider.insertHint(hint)`\r\n *\r\n * The behavior of these three functions is described in detail below.\r\n *\r\n * __CodeHintProvider.hasHints(editor, implicitChar)__\r\n *\r\n * The method by which a provider indicates intent to provide hints for a\r\n * given editor. The manager calls this method both when hints are\r\n * explicitly requested (via, e.g., Ctrl-Space) and when they may be\r\n * implicitly requested as a result of character insertion in the editor.\r\n * If the provider responds negatively then the manager may query other\r\n * providers for hints. Otherwise, a new hinting session begins with this\r\n * provider, during which the manager may repeatedly query the provider\r\n * for hints via the getHints method. Note that no other providers will be\r\n * queried until the hinting session ends.\r\n *\r\n * The implicitChar parameter is used to determine whether the hinting\r\n * request is explicit or implicit. If the string is null then hints were\r\n * explicitly requested and the provider should reply based on whether it\r\n * is possible to return hints for the given editor context. Otherwise,\r\n * the string contains just the last character inserted into the editor\'s\r\n * document and the request for hints is implicit. In this case, the\r\n * provider should determine whether it is both possible and appropriate\r\n * to show hints. Because implicit hints can be triggered by every\r\n * character insertion, hasHints may be called frequently; consequently,\r\n * the provider should endeavor to return a value as quickly as possible.\r\n *\r\n * Because calls to hasHints imply that a hinting session is about to\r\n * begin, a provider may wish to clean up cached data from previous\r\n * sessions in this method. Similarly, if the provider returns true, it\r\n * may wish to prepare to cache data suitable for the current session. In\r\n * particular, it should keep a reference to the editor object so that it\r\n * can access the editor in future calls to getHints and insertHints.\r\n *\r\n * param {Editor} editor\r\n * A non-null editor object for the active window.\r\n *\r\n * param {string} implicitChar\r\n * Either null, if the hinting request was explicit, or a single character\r\n * that represents the last insertion and that indicates an implicit\r\n * hinting request.\r\n *\r\n * return {boolean}\r\n * Determines whether the current provider is able to provide hints for\r\n * the given editor context and, in case implicitChar is non- null,\r\n * whether it is appropriate to do so.\r\n *\r\n *\r\n * __CodeHintProvider.getHints(implicitChar)__\r\n *\r\n * The method by which a provider provides hints for the editor context\r\n * associated with the current session. The getHints method is called only\r\n * if the provider asserted its willingness to provide hints in an earlier\r\n * call to hasHints. The provider may return null or false, which indicates\r\n * that the manager should end the current hinting session and close the hint\r\n * list window; or true, which indicates that the manager should end the\r\n * current hinting session but immediately attempt to begin a new hinting\r\n * session by querying registered providers. Otherwise, the provider should\r\n * return a response object that contains the following properties:\r\n *\r\n *  1. hints, a sorted array hints that the provider could later insert\r\n *     into the editor;\r\n *  2. match, a string that the manager may use to emphasize substrings of\r\n *     hints in the hint list; and\r\n *  3. selectInitial, a boolean that indicates whether or not the the\r\n *     first hint in the list should be selected by default.\r\n *  4. handleWideResults, a boolean (or undefined) that indicates whether\r\n *     to allow result string to stretch width of display.\r\n *\r\n * If the array of\r\n * hints is empty, then the manager will render an empty list, but the\r\n * hinting session will remain open and the value of the selectInitial\r\n * property is irrelevant.\r\n *\r\n * Alternatively, the provider may return a jQuery.Deferred object\r\n * that resolves with an object with the structure described above. In\r\n * this case, the manager will initially render the hint list window with\r\n * a throbber and will render the actual list once the deferred object\r\n * resolves to a response object. If a hint list has already been rendered\r\n * (from an earlier call to getHints), then the old list will continue\r\n * to be displayed until the new deferred has resolved.\r\n *\r\n * Both the manager and the provider can reject the deferred object. The\r\n * manager will reject the deferred if the editor changes state (e.g., the\r\n * user types a character) or if the hinting session ends (e.g., the user\r\n * explicitly closes the hints by pressing escape). The provider can use\r\n * this event to, e.g., abort an expensive computation. Consequently, the\r\n * provider may assume that getHints will not be called again until the\r\n * deferred object from the current call has resolved or been rejected. If\r\n * the provider rejects the deferred, the manager will end the hinting\r\n * session.\r\n *\r\n * The getHints method may be called by the manager repeatedly during a\r\n * hinting session. Providers may wish to cache information for efficiency\r\n * that may be useful throughout these sessions. The same editor context\r\n * will be used throughout a session, and will only change during the\r\n * session as a result of single-character insertions, deletions and\r\n * cursor navigations. The provider may assume that, throughout the\r\n * lifetime of the session, the getHints method will be called exactly\r\n * once for each such editor change. Consequently, the provider may also\r\n * assume that the document will not be changed outside of the editor\r\n * during a session.\r\n *\r\n * param {string} implicitChar\r\n * Either null, if the request to update the hint list was a result of\r\n * navigation, or a single character that represents the last insertion.\r\n *\r\n *     return {jQuery.Deferred|{\r\n *          hints: Array.<string|jQueryObject>,\r\n *          match: string,\r\n *          selectInitial: boolean,\r\n *          handleWideResults: boolean}}\r\n *\r\n * Null if the provider wishes to end the hinting session. Otherwise, a\r\n * response object, possibly deferred, that provides 1. a sorted array\r\n * hints that consists either of strings or jQuery objects; 2. a string\r\n * match, possibly null, that is used by the manager to emphasize\r\n * matching substrings when rendering the hint list; and 3. a boolean that\r\n * indicates whether the first result, if one exists, should be selected\r\n * by default in the hint list window. If match is non-null, then the\r\n * hints should be strings.\r\n *\r\n * If the match is null, the manager will not\r\n * attempt to emphasize any parts of the hints when rendering the hint\r\n * list; instead the provider may return strings or jQuery objects for\r\n * which emphasis is self-contained. For example, the strings may contain\r\n * substrings that wrapped in bold tags. In this way, the provider can\r\n * choose to let the manager handle emphasis for the simple and common case\r\n * of prefix matching, or can provide its own emphasis if it wishes to use\r\n * a more sophisticated matching algorithm.\r\n *\r\n *\r\n * __CodeHintProvider.insertHint(hint)__\r\n *\r\n * The method by which a provider inserts a hint into the editor context\r\n * associated with the current session. The provider may assume that the\r\n * given hint was returned by the provider in some previous call in the\r\n * current session to getHints, but not necessarily the most recent call.\r\n * After the insertion has been performed, the current hinting session is\r\n * closed. The provider should return a boolean value to indicate whether\r\n * or not the end of the session should be immediately followed by a new\r\n * explicit hinting request, which may result in a new hinting session\r\n * being opened with some provider, but not necessarily the current one.\r\n *\r\n * param {string} hint\r\n * The hint to be inserted into the editor context for the current session.\r\n *\r\n * return {boolean}\r\n * Indicates whether the manager should follow hint insertion with an\r\n * explicit hint request.\r\n *\r\n *\r\n * __CodeHintProvider.insertHintOnTab__\r\n *\r\n * type {?boolean} insertHintOnTab\r\n * Indicates whether the CodeHintManager should request that the provider of\r\n * the current session insert the currently selected hint on tab key events,\r\n * or if instead a tab character should be inserted into the editor. If omitted,\r\n * the fallback behavior is determined by the CodeHintManager. The default\r\n * behavior is to insert a tab character, but this can be changed with the\r\n * insertHintOnTab Preference.\r\n */\r\ndefine(\'editor/CodeHintManager\',[\'require\',\'exports\',\'module\',\'command/Commands\',\'command/CommandManager\',\'editor/EditorManager\',\'strings\',\'utils/KeyEvent\',\'editor/CodeHintList\',\'preferences/PreferencesManager\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    // Load dependent modules\r\n    var Commands            = require("command/Commands"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        Strings             = require("strings"),\r\n        KeyEvent            = require("utils/KeyEvent"),\r\n        CodeHintList        = require("editor/CodeHintList").CodeHintList,\r\n        PreferencesManager  = require("preferences/PreferencesManager");\r\n\r\n    var hintProviders    = { "all" : [] },\r\n        lastChar         = null,\r\n        sessionProvider  = null,\r\n        sessionEditor    = null,\r\n        hintList         = null,\r\n        deferredHints    = null,\r\n        keyDownEditor    = null,\r\n        codeHintsEnabled = true;\r\n\r\n\r\n    PreferencesManager.definePreference("showCodeHints", "boolean", true);\r\n    PreferencesManager.definePreference("insertHintOnTab", "boolean", false);\r\n\r\n    PreferencesManager.on("change", "showCodeHints", function () {\r\n        codeHintsEnabled = PreferencesManager.get("showCodeHints");\r\n    });\r\n    \r\n    /**\r\n     * Comparator to sort providers from high to low priority\r\n     */\r\n    function _providerSort(a, b) {\r\n        return b.priority - a.priority;\r\n    }\r\n\r\n    /**\r\n     * The method by which a CodeHintProvider registers its willingness to\r\n     * providing hints for editors in a given language.\r\n     *\r\n     * @param {!CodeHintProvider} provider\r\n     * The hint provider to be registered, described below.\r\n     *\r\n     * @param {!Array.<string>} languageIds\r\n     * The set of language ids for which the provider is capable of\r\n     * providing hints. If the special language id name "all" is included then\r\n     * the provider may be called for any language.\r\n     *\r\n     * @param {?number} priority\r\n     * Used to break ties among hint providers for a particular language.\r\n     * Providers with a higher number will be asked for hints before those\r\n     * with a lower priority value. Defaults to zero.\r\n     */\r\n    function registerHintProvider(providerInfo, languageIds, priority) {\r\n        var providerObj = { provider: providerInfo,\r\n                            priority: priority || 0 };\r\n\r\n        if (languageIds.indexOf("all") !== -1) {\r\n            // Ignore anything else in languageIds and just register for every language. This includes\r\n            // the special "all" language since its key is in the hintProviders map from the beginning.\r\n            var languageId;\r\n            for (languageId in hintProviders) {\r\n                if (hintProviders.hasOwnProperty(languageId)) {\r\n                    hintProviders[languageId].push(providerObj);\r\n                    hintProviders[languageId].sort(_providerSort);\r\n                }\r\n            }\r\n        } else {\r\n            languageIds.forEach(function (languageId) {\r\n                if (!hintProviders[languageId]) {\r\n                    // Initialize provider list with any existing all-language providers\r\n                    hintProviders[languageId] = Array.prototype.concat(hintProviders.all);\r\n                }\r\n                hintProviders[languageId].push(providerObj);\r\n                hintProviders[languageId].sort(_providerSort);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Remove a code hint provider\r\n     * @param {!CodeHintProvider} provider Code hint provider to remove\r\n     * @param {(string|Array.<string>)=} targetLanguageId Optional set of\r\n     *     language IDs for languages to remove the provider for. Defaults\r\n     *     to all languages.\r\n     */\r\n    function _removeHintProvider(provider, targetLanguageId) {\r\n        var languageId,\r\n            languages,\r\n            index,\r\n            providers,\r\n            targetLanguageIdArr;\r\n\r\n        if (Array.isArray(targetLanguageId)) {\r\n            targetLanguageIdArr = targetLanguageId;\r\n        } else if (targetLanguageId) {\r\n            targetLanguageIdArr = [targetLanguageId];\r\n        } else {\r\n            targetLanguageIdArr = Object.keys(hintProviders);\r\n        }\r\n\r\n        targetLanguageIdArr.forEach(function (languageId) {\r\n            providers = hintProviders[languageId];\r\n\r\n            for (index = 0; index < providers.length; index++) {\r\n                if (providers[index].provider === provider) {\r\n                    providers.splice(index, 1);\r\n                    break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     *  Return the array of hint providers for the given language id.\r\n     *  This gets called (potentially) on every keypress. So, it should be fast.\r\n     *\r\n     * @param {!string} languageId\r\n     * @return {?Array.<{provider: Object, priority: number}>}\r\n     */\r\n    function _getProvidersForLanguageId(languageId) {\r\n        var providers = hintProviders[languageId] || hintProviders.all;\r\n        \r\n        // Exclude providers that are explicitly disabled in the preferences.\r\n        // All code hint providers that do not have their constructor\r\n        // names listed in the preferences are enabled by default.\r\n        return providers.filter(function (provider) {\r\n            var prefKey = "codehint." + provider.provider.constructor.name;\r\n            return PreferencesManager.get(prefKey) !== false;\r\n        });\r\n    }\r\n\r\n    var _beginSession;\r\n\r\n    /**\r\n     * End the current hinting session\r\n     */\r\n    function _endSession() {\r\n        if (!hintList) {\r\n            return;\r\n        }\r\n        hintList.close();\r\n        hintList = null;\r\n        keyDownEditor = null;\r\n        sessionProvider = null;\r\n        sessionEditor = null;\r\n        if (deferredHints) {\r\n            deferredHints.reject();\r\n            deferredHints = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Is there a hinting session active for a given editor?\r\n     *\r\n     * NOTE: the sessionEditor, sessionProvider and hintList objects are\r\n     * only guaranteed to be initialized during an active session.\r\n     *\r\n     * @param {Editor} editor\r\n     * @return boolean\r\n     */\r\n    function _inSession(editor) {\r\n        if (sessionEditor) {\r\n            if (sessionEditor === editor &&\r\n                    (hintList.isOpen() ||\r\n                     (deferredHints && deferredHints.state() === "pending"))) {\r\n                return true;\r\n            } else {\r\n                // the editor has changed\r\n                _endSession();\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * From an active hinting session, get hints from the current provider and\r\n     * render the hint list window.\r\n     *\r\n     * Assumes that it is called when a session is active (i.e. sessionProvider is not null).\r\n     */\r\n    function _updateHintList() {\r\n        if (deferredHints) {\r\n            deferredHints.reject();\r\n            deferredHints = null;\r\n        }\r\n\r\n        var response = sessionProvider.getHints(lastChar);\r\n        lastChar = null;\r\n\r\n        if (!response) {\r\n            // the provider wishes to close the session\r\n            _endSession();\r\n        } else {\r\n            // if the response is true, end the session and begin another\r\n            if (response === true) {\r\n                var previousEditor = sessionEditor;\r\n                _endSession();\r\n                _beginSession(previousEditor);\r\n            } else if (response.hasOwnProperty("hints")) { // a synchronous response\r\n                if (hintList.isOpen()) {\r\n                    // the session is open\r\n                    hintList.update(response);\r\n                } else {\r\n                    hintList.open(response);\r\n                }\r\n            } else { // response is a deferred\r\n                deferredHints = response;\r\n                response.done(function (hints) {\r\n                    // Guard against timing issues where the session ends before the\r\n                    // response gets a chance to execute the callback.  If the session\r\n                    // ends first while still waiting on the response, then hintList\r\n                    // will get cleared up.\r\n                    if (!hintList) {\r\n                        return;\r\n                    }\r\n\r\n                    if (hintList.isOpen()) {\r\n                        // the session is open\r\n                        hintList.update(hints);\r\n                    } else {\r\n                        hintList.open(hints);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Try to begin a new hinting session.\r\n     * @param {Editor} editor\r\n     */\r\n    _beginSession = function (editor) {\r\n        if (!codeHintsEnabled) {\r\n            return;\r\n        }\r\n\r\n        // Don\'t start a session if we have a multiple selection.\r\n        if (editor.getSelections().length > 1) {\r\n            return;\r\n        }\r\n        \r\n        // Find a suitable provider, if any\r\n        var language = editor.getLanguageForSelection(),\r\n            enabledProviders = _getProvidersForLanguageId(language.getId());\r\n\r\n        enabledProviders.some(function (item, index) {\r\n            if (item.provider.hasHints(editor, lastChar)) {\r\n                sessionProvider = item.provider;\r\n                return true;\r\n            }\r\n        });\r\n\r\n        // If a provider is found, initialize the hint list and update it\r\n        if (sessionProvider) {\r\n            var insertHintOnTab;\r\n            if (sessionProvider.insertHintOnTab !== undefined) {\r\n                insertHintOnTab = sessionProvider.insertHintOnTab;\r\n            } else {\r\n                insertHintOnTab = PreferencesManager.get("insertHintOnTab");\r\n            }\r\n\r\n            sessionEditor = editor;\r\n\r\n            hintList = new CodeHintList(sessionEditor, insertHintOnTab);\r\n            hintList.onSelect(function (hint) {\r\n                var restart = sessionProvider.insertHint(hint),\r\n                    previousEditor = sessionEditor;\r\n                _endSession();\r\n                if (restart) {\r\n                    _beginSession(previousEditor);\r\n                }\r\n            });\r\n            hintList.onClose(_endSession);\r\n\r\n            _updateHintList();\r\n        } else {\r\n            lastChar = null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Explicitly start a new session. If we have an existing session,\r\n     * then close the current one and restart a new one.\r\n     * @param {Editor} editor\r\n     */\r\n    function _startNewSession(editor) {\r\n        if (!editor) {\r\n            editor = EditorManager.getFocusedEditor();\r\n        }\r\n\r\n        if (editor) {\r\n            lastChar = null;\r\n            if (_inSession(editor)) {\r\n                _endSession();\r\n            }\r\n            // Begin a new explicit session\r\n            _beginSession(editor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handles keys related to displaying, searching, and navigating the hint list.\r\n     * This gets called before handleChange.\r\n     *\r\n     * TODO: Ideally, we\'d get a more semantic event from the editor that told us\r\n     * what changed so that we could do all of this logic without looking at\r\n     * key events. Then, the purposes of handleKeyEvent and handleChange could be\r\n     * combined. Doing this well requires changing CodeMirror.\r\n     *\r\n     * @param {Event} jqEvent\r\n     * @param {Editor} editor\r\n     * @param {KeyboardEvent} event\r\n     */\r\n    function _handleKeydownEvent(jqEvent, editor, event) {\r\n        keyDownEditor = editor;\r\n        if (!(event.ctrlKey || event.altKey || event.metaKey) &&\r\n                (event.keyCode === KeyEvent.DOM_VK_ENTER ||\r\n                 event.keyCode === KeyEvent.DOM_VK_RETURN ||\r\n                 event.keyCode === KeyEvent.DOM_VK_TAB)) {\r\n            lastChar = String.fromCharCode(event.keyCode);\r\n        }\r\n    }\r\n    function _handleKeypressEvent(jqEvent, editor, event) {\r\n        keyDownEditor = editor;\r\n\r\n        // Last inserted character, used later by handleChange\r\n        lastChar = String.fromCharCode(event.charCode);\r\n\r\n        // Pending Text is used in hintList._keydownHook()\r\n        if (hintList) {\r\n            hintList.addPendingText(lastChar);\r\n        }\r\n    }\r\n    function _handleKeyupEvent(jqEvent, editor, event) {\r\n        keyDownEditor = editor;\r\n        if (_inSession(editor)) {\r\n            if (event.keyCode === KeyEvent.DOM_VK_HOME || event.keyCode === KeyEvent.DOM_VK_END) {\r\n                _endSession();\r\n            } else if (event.keyCode === KeyEvent.DOM_VK_LEFT ||\r\n                       event.keyCode === KeyEvent.DOM_VK_RIGHT ||\r\n                       event.keyCode === KeyEvent.DOM_VK_BACK_SPACE) {\r\n                // Update the list after a simple navigation.\r\n                // We do this in "keyup" because we want the cursor position to be updated before\r\n                // we redraw the list.\r\n                _updateHintList();\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Handle a selection change event in the editor. If the selection becomes a\r\n     * multiple selection, end our current session.\r\n     * @param {Event} jqEvent\r\n     * @param {Editor} editor\r\n     */\r\n    function _handleCursorActivity(jqEvent, editor) {\r\n        if (_inSession(editor)) {\r\n            if (editor.getSelections().length > 1) {\r\n                _endSession();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start a new implicit hinting session, or update the existing hint list.\r\n     * Called by the editor after handleKeyEvent, which is responsible for setting\r\n     * the lastChar.\r\n     *\r\n     * @param {Event} event\r\n     * @param {Editor} editor\r\n     * @param {{from: Pos, to: Pos, text: Array, origin: string}} changeList\r\n     */\r\n    function _handleChange(event, editor, changeList) {\r\n        if (lastChar && editor === keyDownEditor) {\r\n            keyDownEditor = null;\r\n            if (_inSession(editor)) {\r\n                var charToRetest = lastChar;\r\n                _updateHintList();\r\n\r\n                // _updateHintList() may end a hinting session and clear lastChar, but a\r\n                // different provider may want to start a new session with the same character.\r\n                // So check whether current provider terminates the current hinting\r\n                // session. If so, then restore lastChar and restart a new session.\r\n                if (!_inSession(editor)) {\r\n                    lastChar = charToRetest;\r\n                    _beginSession(editor);\r\n                }\r\n            } else {\r\n                _beginSession(editor);\r\n            }\r\n\r\n            // Pending Text is used in hintList._keydownHook()\r\n            if (hintList && changeList[0] && changeList[0].text.length && changeList[0].text[0].length) {\r\n                var expectedLength = editor.getCursorPos().ch - changeList[0].from.ch,\r\n                    newText = changeList[0].text[0];\r\n                // We may get extra text in newText since some features like auto\r\n                // close braces can append some text automatically.\r\n                // See https://github.com/adobe/brackets/issues/6345#issuecomment-32548064\r\n                // as an example of this scenario.\r\n                if (newText.length > expectedLength) {\r\n                    // Strip off the extra text before calling removePendingText.\r\n                    newText = newText.substr(0, expectedLength);\r\n                }\r\n                hintList.removePendingText(newText);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Test whether the provider has an exclusion that is still the same as text after the cursor.\r\n     *\r\n     * @param {string} exclusion - Text not to be overwritten when the provider inserts the selected hint.\r\n     * @param {string} textAfterCursor - Text that is immediately after the cursor position.\r\n     * @return {boolean} true if the exclusion is not null and is exactly the same as textAfterCursor,\r\n     * false otherwise.\r\n     */\r\n    function hasValidExclusion(exclusion, textAfterCursor) {\r\n        return (exclusion && exclusion === textAfterCursor);\r\n    }\r\n\r\n    /**\r\n     *  Test if a hint popup is open.\r\n     *\r\n     * @return {boolean} - true if the hints are open, false otherwise.\r\n     */\r\n    function isOpen() {\r\n        return (hintList && hintList.isOpen());\r\n    }\r\n\r\n    /**\r\n     * Expose CodeHintList for unit testing\r\n     */\r\n    function _getCodeHintList() {\r\n        return hintList;\r\n    }\r\n\r\n    function activeEditorChangeHandler(event, current, previous) {\r\n        if (current) {\r\n            $(current).on("editorChange", _handleChange);\r\n            $(current).on("keydown",  _handleKeydownEvent);\r\n            $(current).on("keypress", _handleKeypressEvent);\r\n            $(current).on("keyup",    _handleKeyupEvent);\r\n            $(current).on("cursorActivity", _handleCursorActivity);\r\n        }\r\n\r\n        if (previous) {\r\n            //Removing all old Handlers\r\n            $(previous).off("editorChange", _handleChange);\r\n            $(previous).off("keydown",  _handleKeydownEvent);\r\n            $(previous).off("keypress", _handleKeypressEvent);\r\n            $(previous).off("keyup",    _handleKeyupEvent);\r\n            $(previous).off("cursorActivity", _handleCursorActivity);\r\n        }\r\n    }\r\n\r\n    activeEditorChangeHandler(null, EditorManager.getActiveEditor(), null);\r\n\r\n    $(EditorManager).on("activeEditorChange", activeEditorChangeHandler);\r\n\r\n    // Dismiss code hints before executing any command since the command\r\n    // may make the current hinting session irrevalent after execution.\r\n    // For example, when the user hits Ctrl+K to open Quick Doc, it is\r\n    // pointless to keep the hint list since the user wants to view the Quick Doc.\r\n    $(CommandManager).on("beforeExecuteCommand", _endSession);\r\n\r\n    CommandManager.register(Strings.CMD_SHOW_CODE_HINTS, Commands.SHOW_CODE_HINTS, _startNewSession);\r\n\r\n    exports._getCodeHintList        = _getCodeHintList;\r\n    exports._removeHintProvider     = _removeHintProvider;\r\n\r\n    // Define public API\r\n    exports.isOpen                  = isOpen;\r\n    exports.registerHintProvider    = registerHintProvider;\r\n    exports.hasValidExclusion       = hasValidExclusion;\r\n});\r\n\n//# sourceURL=/editor/CodeHintManager.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets, window */\r\n\r\n/**\r\n * A "modal bar" component. This is a lightweight replacement for modal dialogs that\r\n * appears at the top of the editor area for operations like Find and Quick Open.\r\n */\r\ndefine(\'widgets/ModalBar\',[\'require\',\'exports\',\'module\',\'editor/EditorManager\',\'view/MainViewManager\',\'utils/KeyEvent\',\'utils/AnimationUtils\',\'view/WorkspaceManager\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var EditorManager    = require("editor/EditorManager"),\r\n        MainViewManager  = require("view/MainViewManager"),\r\n        KeyEvent         = require("utils/KeyEvent"),\r\n        AnimationUtils   = require("utils/AnimationUtils"),\r\n        WorkspaceManager = require("view/WorkspaceManager");\r\n\r\n    /**\r\n     * Creates a modal bar whose contents are the given template.\r\n     * \r\n     * Dispatches one event:\r\n     * - close - When the bar is closed, either via close() or via autoClose. After this event, the\r\n     *     bar may remain visible and in the DOM while its closing animation is playing. However,\r\n     *     by the time "close" is fired, the bar has been "popped out" of the layout and the\r\n     *     editor scroll position has already been restored.\r\n     * \r\n     * @constructor\r\n     *\r\n     * @param {string} template The HTML contents of the modal bar.\r\n     * @param {boolean} autoClose If true, then close the dialog if the user hits Esc\r\n     *      or if the bar loses focus.\r\n     * @param {boolean} animate If true (the default), animate the dialog closed, otherwise\r\n     *      close it immediately.\r\n     */\r\n    function ModalBar(template, autoClose, animate) {\r\n        if (animate === undefined) {\r\n            animate = true;\r\n        }\r\n        \r\n        this._handleKeydown = this._handleKeydown.bind(this);\r\n        this._handleFocusChange = this._handleFocusChange.bind(this);\r\n        \r\n        this._$root = $("<div class=\'modal-bar\'/>")\r\n            .html(template)\r\n            .insertBefore("#editor-holder");\r\n\r\n        if (animate) {\r\n            this._$root.addClass("popout offscreen");\r\n            // Forcing the renderer to do a layout, which will cause it to apply the transform for the "offscreen"\r\n            // class, so it will animate when you remove the class.\r\n            window.getComputedStyle(this._$root.get(0)).getPropertyValue("top");\r\n            this._$root.removeClass("popout offscreen");\r\n        }\r\n        \r\n        // If something *other* than an editor (like another modal bar) has focus, set the focus \r\n        // to the editor here, before opening up the new modal bar. This ensures that the old\r\n        // focused item has time to react and close before the new modal bar is opened.\r\n        // See bugs #4287 and #3424\r\n        MainViewManager.focusActivePane();\r\n        \r\n        if (autoClose) {\r\n            this._autoClose = true;\r\n            this._$root.on("keydown", this._handleKeydown);\r\n            window.document.body.addEventListener("focusin", this._handleFocusChange, true);\r\n                \r\n            // Set focus to the first input field, or the first button if there is no input field.\r\n            // TODO: remove this logic?\r\n            var $firstInput = $("input[type=\'text\']", this._$root).first();\r\n            if ($firstInput.length > 0) {\r\n                $firstInput.focus();\r\n            } else {\r\n                $("button", this._$root).first().focus();\r\n            }\r\n        }\r\n        \r\n        // Preserve scroll position of the current full editor across the editor refresh, adjusting for the \r\n        // height of the modal bar so the code doesn\'t appear to shift if possible.\r\n        MainViewManager.cacheScrollState(MainViewManager.ALL_PANES);\r\n        WorkspaceManager.recomputeLayout();  // changes available ht for editor area\r\n        MainViewManager.restoreAdjustedScrollState(MainViewManager.ALL_PANES, this.height());\r\n    }\r\n    \r\n    /**\r\n     * A jQuery object containing the root node of the ModalBar.\r\n     */\r\n    ModalBar.prototype._$root = null;\r\n    \r\n    /**\r\n     * True if this ModalBar is set to autoclose.\r\n     */\r\n    ModalBar.prototype._autoClose = false;\r\n    \r\n    /**\r\n     * Allows client code to block autoClose from closing the ModalBar: if set, this function is called whenever\r\n     * autoClose would normally close the ModalBar. Returning true prevents the close from occurring. Programmatically\r\n     * calling close() will still close the bar, however.\r\n     * @type {?function():boolean}\r\n     */\r\n    ModalBar.prototype.isLockedOpen = null;\r\n    \r\n    /**\r\n     * @return {number} Height of the modal bar in pixels, if open.\r\n     */\r\n    ModalBar.prototype.height = function () {\r\n        return this._$root.outerHeight();\r\n    };\r\n    \r\n    /**\r\n     * Prepares the ModalBar for closing by popping it out of the main flow and resizing/\r\n     * rescrolling the Editor to maintain its current apparent code position. Useful if\r\n     * you want to do that as a separate operation from actually animating the ModalBar\r\n     * closed and removing it (for example, if you need to switch full editors in between).\r\n     * If you don\'t call this explicitly, it will get called at the beginning of `close()`.\r\n     *\r\n     * @param {boolean=} restoreScrollPos If true (the default), adjust the scroll position\r\n     *     of the editor to account for the ModalBar disappearing. If not set, the caller\r\n     *     should do it immediately on return of this function (before the animation completes),\r\n     *     because the editor will already have been resized.\r\n     */\r\n    ModalBar.prototype.prepareClose = function (restoreScrollPos) {\r\n        if (restoreScrollPos === undefined) {\r\n            restoreScrollPos = true;\r\n        }\r\n        \r\n        this._$root.addClass("popout");\r\n        \r\n        // Since the modal bar has now an absolute position relative to the editor holder,\r\n        // when there are html menus we need to adjust the top position\r\n        if (!brackets.nativeMenus) {\r\n            var top = $("#titlebar").outerHeight();\r\n            this._$root.css("top", top + "px");\r\n        }\r\n        \r\n        // Preserve scroll position of all visible views\r\n        //  adjusting for the height of the modal bar so the code doesn\'t appear to shift if possible.\r\n        var barHeight = this.height();\r\n        if (restoreScrollPos) {\r\n            MainViewManager.cacheScrollState(MainViewManager.ALL_PANES);\r\n        }\r\n        WorkspaceManager.recomputeLayout();  // changes available ht for editor area\r\n        // restore scroll position of all vies\r\n        if (restoreScrollPos) {\r\n            MainViewManager.restoreAdjustedScrollState(MainViewManager.ALL_PANES, -barHeight);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Closes the modal bar and returns focus to the active editor. Returns a promise that is\r\n     * resolved when the bar is fully closed and the container is removed from the DOM.\r\n     * @param {boolean=} restoreScrollPos If true (the default), adjust the scroll position\r\n     *     of the editor to account for the ModalBar disappearing. If not set, the caller\r\n     *     should do it immediately on return of this function (before the animation completes),\r\n     *     because the editor will already have been resized. Note that this is ignored if\r\n     *     `prepareClose()` was already called (you need to pass the parameter to that\r\n     *     function if you call it first).\r\n     * @param {boolean=} animate If true (the default), animate the closing of the ModalBar,\r\n     *     otherwise close it immediately.\r\n     * @return {$.Promise} promise resolved when close is finished\r\n     */\r\n    ModalBar.prototype.close = function (restoreScrollPos, animate) {\r\n        var result = new $.Deferred(),\r\n            self = this;\r\n\r\n        if (restoreScrollPos === undefined) {\r\n            restoreScrollPos = true;\r\n        }\r\n        if (animate === undefined) {\r\n            animate = true;\r\n        }\r\n        \r\n        // If someone hasn\'t already called `prepareClose()` to pop the ModalBar out of the flow\r\n        // and resize the editor, then do that here.\r\n        if (!this._$root.hasClass("popout")) {\r\n            this.prepareClose(restoreScrollPos);\r\n        }\r\n\r\n        if (this._autoClose) {\r\n            window.document.body.removeEventListener("focusin", this._handleFocusChange, true);\r\n        }\r\n\r\n        $(this).triggerHandler("close");\r\n        \r\n        function doRemove() {\r\n            self._$root.remove();\r\n            result.resolve();\r\n        }\r\n        \r\n        if (animate) {\r\n            AnimationUtils.animateUsingClass(this._$root.get(0), "offscreen")\r\n                .done(doRemove);\r\n        } else {\r\n            doRemove();\r\n        }\r\n        \r\n        MainViewManager.focusActivePane();\r\n\r\n        return result.promise();\r\n    };\r\n    \r\n    /**\r\n     * If autoClose is set, handles the RETURN/ESC keys in the input field.\r\n     */\r\n    ModalBar.prototype._handleKeydown = function (e) {\r\n        if (e.keyCode === KeyEvent.DOM_VK_ESCAPE) {\r\n            e.stopPropagation();\r\n            e.preventDefault();\r\n            this.close();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * If autoClose is set, detects when something other than the modal bar is getting focus and\r\n     * dismisses the modal bar. DOM nodes with "attached-to" jQuery metadata referencing an element\r\n     * within the ModalBar are allowed to take focus without closing it.\r\n     */\r\n    ModalBar.prototype._handleFocusChange = function (e) {\r\n        if (this.isLockedOpen && this.isLockedOpen()) {\r\n            return;\r\n        }\r\n        \r\n        var effectiveElem = $(e.target).data("attached-to") || e.target;\r\n        \r\n        if (!$.contains(this._$root.get(0), effectiveElem)) {\r\n            this.close();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @return {jQueryObject} A jQuery object representing the root of the ModalBar.\r\n     */\r\n    ModalBar.prototype.getRoot = function () {\r\n        return this._$root;\r\n    };\r\n    \r\n    exports.ModalBar = ModalBar;\r\n});\n//# sourceURL=/widgets/ModalBar.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, setTimeout */\r\n/*unittests: StringMatch */\r\n\r\ndefine(\'utils/StringMatch\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n    \r\n    /*\r\n     * Performs matching that is useful for QuickOpen and similar searches.\r\n     */\r\n    \r\n    /** Object representing a search result with associated metadata (added as extra ad hoc fields) */\r\n    function SearchResult(label) {\r\n        this.label = label;\r\n    }\r\n    \r\n\r\n\r\n    /*\r\n     * Identifies the "special" characters in the given string.\r\n     * Special characters for matching purposes are:\r\n     *\r\n     * * the first character\r\n     * * "/" and the character following the "/"\r\n     * * "_", "." and "-" and the character following it\r\n     * * an uppercase character that follows a lowercase one (think camelCase)\r\n     *\r\n     * The returned object contains an array called "specials". This array is\r\n     * a list of indexes into the original string where all of the special\r\n     * characters are. It also has a property "lastSegmentSpecialsIndex" which\r\n     * is an index into the specials array that denotes which location is the\r\n     * beginning of the last path segment. (This is used to allow scanning of\r\n     * the last segment\'s specials separately.)\r\n     * \r\n     * @param {string} input string to break apart (e.g. filename that is being searched)\r\n     * @return {{specials:Array.<number>, lastSegmentSpecialsIndex:number}}\r\n     */\r\n    function findSpecialCharacters(str) {\r\n        var i, c;\r\n        \r\n        // the beginning of the string is always special\r\n        var specials = [0];\r\n        \r\n        // lastSegmentSpecialsIndex starts off with the assumption that\r\n        // there are no segments\r\n        var lastSegmentSpecialsIndex = 0;\r\n        \r\n        // used to track down the camelCase changeovers\r\n        var lastWasLowerCase = false;\r\n        \r\n        for (i = 0; i < str.length; i++) {\r\n            c = str[i];\r\n            if (c === "/") {\r\n                // new segment means this character and the next are special\r\n                specials.push(i++);\r\n                specials.push(i);\r\n                lastSegmentSpecialsIndex = specials.length - 1;\r\n                lastWasLowerCase = false;\r\n            } else if (c === "." || c === "-" || c === "_") {\r\n                // _, . and - are separators so they are\r\n                // special and so is the next character\r\n                specials.push(i++);\r\n                specials.push(i);\r\n                lastWasLowerCase = false;\r\n            } else if (c.toUpperCase() === c) {\r\n                // this is the check for camelCase changeovers\r\n                if (lastWasLowerCase) {\r\n                    specials.push(i);\r\n                }\r\n                lastWasLowerCase = false;\r\n            } else {\r\n                lastWasLowerCase = true;\r\n            }\r\n        }\r\n        return {\r\n            specials: specials,\r\n            lastSegmentSpecialsIndex: lastSegmentSpecialsIndex\r\n        };\r\n    }\r\n    \r\n    // states used during the scanning of the string\r\n    var SPECIALS_MATCH = 0;\r\n    var ANY_MATCH = 1;\r\n    \r\n    // Scores can be hard to make sense of. The DEBUG_SCORES flag\r\n    // provides a way to peek into the parts that made up a score.\r\n    // This flag is used for manual debugging and in the unit tests only.\r\n    var DEBUG_SCORES = false;\r\n    function _setDebugScores(ds) {\r\n        DEBUG_SCORES = ds;\r\n    }\r\n    \r\n    // Constants for scoring\r\n    var SPECIAL_POINTS = 35;\r\n    var MATCH_POINTS = 10;\r\n    var LAST_SEGMENT_BOOST = 1;\r\n    var BEGINNING_OF_NAME_POINTS = 10;\r\n    var DEDUCTION_FOR_LENGTH = 0.2;\r\n    var CONSECUTIVE_MATCHES_POINTS = 7;\r\n    var NOT_STARTING_ON_SPECIAL_PENALTY = 25;\r\n    \r\n    // Used in match lists to designate matches of "special" characters (see\r\n    // findSpecialCharacters above\r\n    function SpecialMatch(index) {\r\n        this.index = index;\r\n    }\r\n    \r\n    // Used in match lists to designate any matched characters that are not special\r\n    function NormalMatch(index) {\r\n        this.index = index;\r\n    }\r\n    \r\n    /*\r\n     * Finds the best matches between the query and the string. The query is\r\n     * compared with str (usually a lower case string with a lower case\r\n     * query).\r\n     *\r\n     * Generally speaking, this function tries to find "special" characters\r\n     * (see findSpecialCharacters above) first. Failing that, it starts scanning\r\n     * the "normal" characters. Sometimes, it will find a special character that matches\r\n     * but then not be able to match the rest of the query. In cases like that, the\r\n     * search will backtrack and try to find matches for the whole query earlier in the\r\n     * string.\r\n     *\r\n     * A contrived example will help illustrate how the searching and backtracking works. It\'s a bit long,\r\n     * but it illustrates different pieces of the algorithm which can be tricky. Let\'s say that we\'re\r\n     * searching the string "AzzBzzCzdzezzDgxgEF" for "abcdex".\r\n     *\r\n     * To start with, it will match "abcde" from the query to "A B C D E" in the string (the spaces \r\n     * represent gaps in the matched part of the string), because those are all "special characters".\r\n     * However, the "x" in the query doesn\'t match the "F" which is the only character left in the\r\n     * string.\r\n     * \r\n     * Backtracking kicks in. The "E" is pulled off of the match list.\r\n     * deadBranches[4] is set to the "g" before the "E". This means that for the 5th\r\n     * query character (the "e") we know that we don\'t have a match beyond that point in the string.\r\n     *\r\n     * To resume searching, the backtrack function looks at the previous match (the "D") and starts\r\n     * searching in character-by-character (ANY_MATCH) mode right after that. It fails to find an\r\n     * "e" before it gets to deadBranches[4], so it has to backtrack again.\r\n     *\r\n     * This time, the "D" is pulled off the match list.\r\n     * deadBranches[3] is set to the "z" before the "D", because we know that for the "dex" part of the\r\n     * query, we can\'t make it work past the "D". We\'ll resume searching with the "z" after the "C".\r\n     *\r\n     * Doing an ANY_MATCH search, we find the "d". We then start searching specials for "e", but we\r\n     * stop before we get to "E" because deadBranches[4] tells us that\'s a dead end. So, we switch\r\n     * to ANY_MATCH and find the "e".\r\n     *\r\n     * Finally, we search for the "x". We don\'t find a special that matches, so we start an ANY_MATCH\r\n     * search. Then we find the "x", and we have a successful match.\r\n     *\r\n     * Here are some notes on how the algorithm works:\r\n     *\r\n     * * We only backtrack() when we\'re exhausted both special AND normal forward searches past that point, \r\n     *   for the query remainder we currently have.  For a different query remainder, we may well get further \r\n     *   along - hence deadBranches[] being dependent on queryCounter; but in order to get a different query \r\n     *   remainder, we must give up one or more current matches by backtracking.\r\n     *\r\n     * * Normal "any char" forward search is a superset of special matching mode -- anything that would have \r\n     *   been matched in special mode *could* also be matched by normal mode. In practice, however,\r\n     *   any special characters that could have matched would be picked up first by the specials matching\r\n     *   code.\r\n     *\r\n     * * backtrack() always goes at least as far back as str[deadBranches[queryCounter]-1] before allowing \r\n     *   forward searching to resume\r\n     *\r\n     * * When `deadBranches[queryCounter] = strCounter` it means if we\'re still trying to match \r\n     *   `queryStr[queryCounter]` and we get to `str[strCounter]`, there\'s no way we can match the \r\n     *   remainer of `queryStr` with the remainder of `str` -- either using specials-only or \r\n     *   full any-char matching.\r\n     *\r\n     * * We know this because deadBranches[] is set in backtrack(), and we don\'t get to backtrack() unless \r\n     *   either:\r\n     *   1. We\'ve already exhausted both special AND normal forward searches past that point\r\n     *      (i.e. backtrack() due to `strCounter >= str.length`, yet `queryCounter < query.length`)\r\n     *   2. We stopped searching further forward due to a previously set deadBranches[] value\r\n     *      (i.e. backtrack() due to `strCounter > deadBranches[queryCounter]`, yet \r\n     *      `queryCounter < query.length`)\r\n     *\r\n     * @param {string} query the search string (generally lower cased)\r\n     * @param {string} str the string to compare with (generally lower cased)\r\n     * @param {Array} specials list of special indexes in str (from findSpecialCharacters)\r\n     * @param {int} startingSpecial index into specials array to start scanning with\r\n     * @return {Array.<SpecialMatch|NormalMatch>} matched indexes or null if no matches possible\r\n     */\r\n    function _generateMatchList(query, str, specials, startingSpecial) {\r\n        var result = [];\r\n        \r\n        // used to keep track of which special character we\'re testing now\r\n        var specialsCounter = startingSpecial;\r\n        \r\n        // strCounter and queryCounter are the indexes used for pulling characters\r\n        // off of the str/compareStr and query.\r\n        var strCounter = specials[startingSpecial];\r\n        var queryCounter;\r\n        \r\n        // the search branches out between special characters and normal characters\r\n        // that are found via consecutive character scanning. In the process of\r\n        // performing these scans, we discover that parts of the query will not match\r\n        // beyond a given point in the string. We keep track of that information\r\n        // in deadBranches, which has a slot for each character in the query.\r\n        // The value stored in the slot is the index into the string after which we\r\n        // are certain there is no match.\r\n        var deadBranches = [];\r\n        \r\n        for (queryCounter = 0; queryCounter < query.length; queryCounter++) {\r\n            deadBranches[queryCounter] = Infinity;\r\n        }\r\n        \r\n        queryCounter = 0;\r\n        \r\n        var state = SPECIALS_MATCH;\r\n        \r\n        // Compares the current character from the query string against the\r\n        // special characters in str. Returns true if a match was found,\r\n        // false otherwise.\r\n        function findMatchingSpecial() {\r\n            // used to loop through the specials\r\n            var i;\r\n            \r\n            for (i = specialsCounter; i < specials.length; i++) {\r\n                // short circuit this search when we know there are no matches following\r\n                if (specials[i] >= deadBranches[queryCounter]) {\r\n                    break;\r\n                }\r\n                \r\n                // First, ensure that we\'re not comparing specials that\r\n                // come earlier in the string than our current search position.\r\n                // This can happen when the string position changes elsewhere.\r\n                if (specials[i] < strCounter) {\r\n                    specialsCounter = i;\r\n                } else if (query[queryCounter] === str[specials[i]]) {\r\n                    // we have a match! do the required tracking\r\n                    specialsCounter = i;\r\n                    queryCounter++;\r\n                    strCounter = specials[i];\r\n                    result.push(new SpecialMatch(strCounter++));\r\n                    return true;\r\n                }\r\n            }\r\n            \r\n            return false;\r\n        }\r\n        \r\n        // This function implements the backtracking that is done when we fail to find\r\n        // a match with the query using the "search for specials first" approach.\r\n        //\r\n        // returns false when it is not able to backtrack successfully\r\n        function backtrack() {\r\n            \r\n            // The idea is to pull matches off of our match list, rolling back\r\n            // characters from the query. We pay special attention to the special\r\n            // characters since they are searched first.\r\n            while (result.length > 0) {\r\n                var item = result.pop();\r\n                \r\n                // nothing in the list? there\'s no possible match then.\r\n                if (!item) {\r\n                    return false;\r\n                }\r\n                \r\n                // we pulled off a match, which means that we need to put a character\r\n                // back into our query. strCounter is going to be set once we\'ve pulled\r\n                // off the right special character and know where we\'re going to restart\r\n                // searching from.\r\n                queryCounter--;\r\n                \r\n                if (item instanceof SpecialMatch) {\r\n                    // pulled off a special, which means we need to make that special available\r\n                    // for matching again\r\n                    specialsCounter--;\r\n                    \r\n                    // check to see if we\'ve gone back as far as we need to\r\n                    if (item.index < deadBranches[queryCounter]) {\r\n                        // we now know that this part of the query does not match beyond this\r\n                        // point\r\n                        deadBranches[queryCounter] = item.index - 1;\r\n                        \r\n                        // since we failed with the specials along this track, we\'re\r\n                        // going to reset to looking for matches consecutively.\r\n                        state = ANY_MATCH;\r\n                        \r\n                        // we figure out where to start looking based on the new\r\n                        // last item in the list. If there isn\'t anything else\r\n                        // in the match list, we\'ll start over at the starting special\r\n                        // (which is generally the beginning of the string, or the\r\n                        // beginning of the last segment of the string)\r\n                        item = result[result.length - 1];\r\n                        if (!item) {\r\n                            strCounter = specials[startingSpecial] + 1;\r\n                            return true;\r\n                        }\r\n                        strCounter = item.index + 1;\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n        \r\n        while (true) {\r\n            \r\n            // keep looping until we\'ve either exhausted the query or the string\r\n            while (queryCounter < query.length && strCounter < str.length && strCounter <= deadBranches[queryCounter]) {\r\n                if (state === SPECIALS_MATCH) {\r\n                    if (!findMatchingSpecial()) {\r\n                        state = ANY_MATCH;\r\n                    }\r\n                }\r\n                \r\n                if (state === ANY_MATCH) {\r\n                    // we look character by character for matches\r\n                    if (query[queryCounter] === str[strCounter]) {\r\n                        // got a match! record it, and switch back to searching specials\r\n                        queryCounter++;\r\n                        result.push(new NormalMatch(strCounter++));\r\n                        state = SPECIALS_MATCH;\r\n                    } else {\r\n                        // no match, keep looking\r\n                        strCounter++;\r\n                    }\r\n                }\r\n            }\r\n            \r\n            // if we\'ve finished the query, or we haven\'t finished the query but we have no\r\n            // more backtracking we can do, then we\'re all done searching.\r\n            if (queryCounter >= query.length || (queryCounter < query.length && !backtrack())) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // return null when we don\'t find anything\r\n        if (queryCounter < query.length || result.length === 0) {\r\n            return null;\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    /*\r\n     * Seek out the best match in the last segment (generally the filename). \r\n     * Matches in the filename are preferred, but the query entered could match\r\n     * any part of the path. So, we find the best match we can get in the filename\r\n     * and then allow for searching the rest of the string with any characters that\r\n     * are left from the beginning of the query.\r\n     *\r\n     * The parameters and return value are the same as for getMatchRanges,\r\n     * except this function is always working on the last segment and the\r\n     * result can optionally include a remainder, which is the characters\r\n     * at the beginning of the query which did not match in the last segment.\r\n     *\r\n     * @param {string} query the search string (generally lower cased)\r\n     * @param {string} str the string to compare with (generally lower cased)\r\n     * @param {Array} specials list of special indexes in str (from findSpecialCharacters)\r\n     * @param {int} startingSpecial index into specials array to start scanning with\r\n     * @param {boolean} lastSegmentStart which character does the last segment start at\r\n     * @return {{remainder:int, matchList:Array.<SpecialMatch|NormalMatch>}} matched indexes or null if no matches possible\r\n     */\r\n    function _lastSegmentSearch(query, str, specials, startingSpecial, lastSegmentStart) {\r\n        var queryCounter, matchList;\r\n        \r\n        // It\'s possible that the query is longer than the last segment.\r\n        // If so, we can chop off the bit that we know couldn\'t possibly be there.\r\n        var remainder = "";\r\n        var extraCharacters = specials[startingSpecial] + query.length - str.length;\r\n\r\n        if (extraCharacters > 0) {\r\n            remainder = query.substring(0, extraCharacters);\r\n            query = query.substring(extraCharacters);\r\n        }\r\n        \r\n        for (queryCounter = 0; queryCounter < query.length; queryCounter++) {\r\n            matchList = _generateMatchList(query.substring(queryCounter),\r\n                                     str, specials, startingSpecial);\r\n            \r\n            // if we\'ve got a match *or* there are no segments in this string, we\'re done\r\n            if (matchList || startingSpecial === 0) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        if (queryCounter === query.length || !matchList) {\r\n            return null;\r\n        } else {\r\n            return {\r\n                remainder: remainder + query.substring(0, queryCounter),\r\n                matchList: matchList\r\n            };\r\n        }\r\n    }\r\n    \r\n    /*\r\n     * Implements the top-level search algorithm. Search the last segment first,\r\n     * then search the rest of the string with the remainder.\r\n     *\r\n     * The parameters and return value are the same as for getMatchRanges.\r\n     *\r\n     * @param {string} query the search string (will be searched lower case)\r\n     * @param {string} compareStr the lower-cased string to search\r\n     * @param {Array} specials list of special indexes in str (from findSpecialCharacters)\r\n     * @param {int} lastSegmentSpecialsIndex index into specials array to start scanning with\r\n     * @return {Array.<SpecialMatch|NormalMatch>} matched indexes or null if no matches possible\r\n     */\r\n    function _wholeStringSearch(query, compareStr, specials, lastSegmentSpecialsIndex) {\r\n        var lastSegmentStart = specials[lastSegmentSpecialsIndex];\r\n        var result;\r\n        var matchList;\r\n        \r\n        result = _lastSegmentSearch(query, compareStr, specials, lastSegmentSpecialsIndex, lastSegmentStart);\r\n        \r\n        if (result) {\r\n            matchList = result.matchList;\r\n            \r\n            // Do we have more query characters that did not fit?\r\n            if (result.remainder) {\r\n                // Scan with the remainder only through the beginning of the last segment\r\n                var remainderMatchList = _generateMatchList(result.remainder,\r\n                                              compareStr.substring(0, lastSegmentStart),\r\n                                              specials.slice(0, lastSegmentSpecialsIndex), 0);\r\n                \r\n                if (remainderMatchList) {\r\n                    // add the new matched ranges to the beginning of the set of ranges we had\r\n                    matchList.unshift.apply(matchList, remainderMatchList);\r\n                } else {\r\n                    // no match\r\n                    return null;\r\n                }\r\n            }\r\n        } else {\r\n            // No match in the last segment, so we start over searching the whole\r\n            // string\r\n            matchList = _generateMatchList(query, compareStr, specials, 0);\r\n        }\r\n        \r\n        return matchList;\r\n    }\r\n    \r\n    /**\r\n     * Converts a list of matches into a form suitable for returning from stringMatch.\r\n     *\r\n     * @param {Array.<SpecialMatch|NormalMatch>} matchList to convert\r\n     * @param {string} original string\r\n     * @param {int} character index where last segment begins\r\n     * @return {{ranges:Array.<{text:string, matched:boolean, includesLastSegment:boolean}>, matchGoodness:int, scoreDebug: Object}} matched ranges and score\r\n     */\r\n    function _computeRangesAndScore(matchList, str, lastSegmentStart) {\r\n        var matchCounter;\r\n        var ranges = [];\r\n        var lastMatchIndex = -1;\r\n        var lastSegmentScore = 0;\r\n        var currentRangeStartedOnSpecial = false;\r\n        \r\n        var score = 0;\r\n        var scoreDebug;\r\n        if (DEBUG_SCORES) {\r\n            scoreDebug = {\r\n                special: 0,\r\n                match: 0,\r\n                lastSegment: 0,\r\n                beginning: 0,\r\n                lengthDeduction: 0,\r\n                consecutive: 0,\r\n                notStartingOnSpecial: 0\r\n            };\r\n        }\r\n        \r\n        var currentRange = null;\r\n        \r\n        // Records the current range and adds any additional ranges required to\r\n        // get to character index c. This function is called before starting a new range\r\n        // or returning from the function.\r\n        function closeRangeGap(c) {\r\n            // Close the current range\r\n            if (currentRange) {\r\n                currentRange.includesLastSegment = lastMatchIndex >= lastSegmentStart;\r\n                if (currentRange.matched && currentRange.includesLastSegment) {\r\n                    if (DEBUG_SCORES) {\r\n                        scoreDebug.lastSegment += lastSegmentScore * LAST_SEGMENT_BOOST;\r\n                    }\r\n                    score += lastSegmentScore * LAST_SEGMENT_BOOST;\r\n                }\r\n                \r\n                if (currentRange.matched && !currentRangeStartedOnSpecial) {\r\n                    if (DEBUG_SCORES) {\r\n                        scoreDebug.notStartingOnSpecial -= NOT_STARTING_ON_SPECIAL_PENALTY;\r\n                    }\r\n                    score -= NOT_STARTING_ON_SPECIAL_PENALTY;\r\n                }\r\n                ranges.push(currentRange);\r\n            }\r\n            \r\n            // If there was space between the new range and the last,\r\n            // add a new unmatched range before the new range can be added.\r\n            if (lastMatchIndex + 1 < c) {\r\n                ranges.push({\r\n                    text: str.substring(lastMatchIndex + 1, c),\r\n                    matched: false,\r\n                    includesLastSegment: c > lastSegmentStart\r\n                });\r\n            }\r\n            currentRange = null;\r\n            lastSegmentScore = 0;\r\n        }\r\n        \r\n        // In some cases (see the use of this variable below), we accelerate the\r\n        // bonus the more consecutive matches there are.\r\n        var numConsecutive = 0;\r\n        \r\n        // Adds a matched character to the appropriate range\r\n        function addMatch(match) {\r\n            // Pull off the character index\r\n            var c = match.index;\r\n            var newPoints = 0;\r\n            \r\n            // A match means that we need to do some scoring bookkeeping.\r\n            // Start with points added for any match\r\n            if (DEBUG_SCORES) {\r\n                scoreDebug.match += MATCH_POINTS;\r\n            }\r\n            newPoints += MATCH_POINTS;\r\n            \r\n            // A bonus is given for characters that match at the beginning\r\n            // of the filename\r\n            if (c === lastSegmentStart) {\r\n                if (DEBUG_SCORES) {\r\n                    scoreDebug.beginning += BEGINNING_OF_NAME_POINTS;\r\n                }\r\n                newPoints += BEGINNING_OF_NAME_POINTS;\r\n            }\r\n            \r\n            // If the new character immediately follows the last matched character,\r\n            // we award the consecutive matches bonus. The check for score > 0\r\n            // handles the initial value of lastMatchIndex which is used for\r\n            // constructing ranges but we don\'t yet have a true match.\r\n            if (score > 0 && lastMatchIndex + 1 === c) {\r\n                // Continue boosting for each additional match at the beginning\r\n                // of the name\r\n                if (c - numConsecutive === lastSegmentStart) {\r\n                    if (DEBUG_SCORES) {\r\n                        scoreDebug.beginning += BEGINNING_OF_NAME_POINTS;\r\n                    }\r\n                    newPoints += BEGINNING_OF_NAME_POINTS;\r\n                }\r\n                \r\n                numConsecutive++;\r\n                \r\n                var boost = CONSECUTIVE_MATCHES_POINTS * numConsecutive;\r\n                \r\n                // Consecutive matches that started on a special are a\r\n                // good indicator of intent, so we award an added bonus there.\r\n                if (currentRangeStartedOnSpecial) {\r\n                    boost = boost * 2;\r\n                }\r\n                \r\n                if (DEBUG_SCORES) {\r\n                    scoreDebug.consecutive += boost;\r\n                }\r\n                newPoints += boost;\r\n            } else {\r\n                numConsecutive = 1;\r\n            }\r\n            \r\n            // add points for "special" character matches\r\n            if (match instanceof SpecialMatch) {\r\n                if (DEBUG_SCORES) {\r\n                    scoreDebug.special += SPECIAL_POINTS;\r\n                }\r\n                newPoints += SPECIAL_POINTS;\r\n            }\r\n            \r\n            score += newPoints;\r\n            \r\n            // points accumulated in the last segment get an extra bonus\r\n            if (c >= lastSegmentStart) {\r\n                lastSegmentScore += newPoints;\r\n            }\r\n            \r\n            // if the last range wasn\'t a match or there\'s a gap, we need to close off\r\n            // the range to start a new one.\r\n            if ((currentRange && !currentRange.matched) || c > lastMatchIndex + 1) {\r\n                closeRangeGap(c);\r\n            }\r\n            lastMatchIndex = c;\r\n            \r\n            // set up a new match range or add to the current one\r\n            if (!currentRange) {\r\n                currentRange = {\r\n                    text: str[c],\r\n                    matched: true\r\n                };\r\n                \r\n                // Check to see if this new matched range is starting on a special\r\n                // character. We penalize those ranges that don\'t, because most\r\n                // people will search on the logical boundaries of the name\r\n                currentRangeStartedOnSpecial = match instanceof SpecialMatch;\r\n            } else {\r\n                currentRange.text += str[c];\r\n            }\r\n        }\r\n        \r\n        // scan through the matches, adding each one in turn\r\n        for (matchCounter = 0; matchCounter < matchList.length; matchCounter++) {\r\n            var match = matchList[matchCounter];\r\n            addMatch(match);\r\n        }\r\n        \r\n        // add a range for the last part of the string\r\n        closeRangeGap(str.length);\r\n        \r\n        // shorter strings that match are often better than longer ones\r\n        var lengthPenalty = -1 * Math.round(str.length * DEDUCTION_FOR_LENGTH);\r\n        if (DEBUG_SCORES) {\r\n            scoreDebug.lengthDeduction = lengthPenalty;\r\n        }\r\n        score = score + lengthPenalty;\r\n\r\n        var result = {\r\n            ranges: ranges,\r\n            matchGoodness: score\r\n        };\r\n        \r\n        if (DEBUG_SCORES) {\r\n            result.scoreDebug = scoreDebug;\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    /*\r\n     * If we short circuit normal matching to produce a prefix match,\r\n     * this function will generate the appropriate SearchResult.\r\n     * This function assumes that the prefix match check has already\r\n     * been performed.\r\n     *\r\n     * @param {string} str  The string with the prefix match for the query\r\n     * @param {string} query  The query that matched the beginning of str\r\n     * @return {{ranges:Array.<{text:string, matched:boolean, includesLastSegment:boolean}>, matchGoodness:int, scoreDebug: Object}} ranges has a matching range for beginning of str\r\n     *                      and a non-matching range for the end of the str\r\n     *                      the score is -Number.MAX_VALUE in all cases\r\n     */\r\n    function _prefixMatchResult(str, query) {\r\n        var result = new SearchResult(str);\r\n        result.matchGoodness = -Number.MAX_VALUE;\r\n        if (DEBUG_SCORES) {\r\n            result.scoreDebug = {\r\n                beginning: Number.MAX_VALUE\r\n            };\r\n        }\r\n        result.stringRanges = [{\r\n            text: str.substr(0, query.length),\r\n            matched: true,\r\n            includesLastSegment: true\r\n        }];\r\n        if (str.length > query.length) {\r\n            result.stringRanges.push({\r\n                text: str.substring(query.length),\r\n                matched: false,\r\n                includesLastSegment: true\r\n            });\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    /*\r\n     * Match str against the query using the QuickOpen algorithm provided by\r\n     * the functions above. The general idea is to prefer matches of "special" characters and,\r\n     * optionally, matches that occur in the "last segment" (generally, the filename). stringMatch\r\n     * will try to provide the best match and produces a "matchGoodness" score\r\n     * to allow for relative ranking.\r\n     *\r\n     * The result object returned includes "stringRanges" which can be used to highlight\r\n     * the matched portions of the string, in addition to the "matchGoodness"\r\n     * mentioned above. If DEBUG_SCORES is true, scoreDebug is set on the result\r\n     * to provide insight into the score.\r\n     *\r\n     * The matching is done in a case-insensitive manner.\r\n     * \r\n     * @param {string} str  The string to search\r\n     * @param {string} query  The query string to find in string\r\n     * @param {{preferPrefixMatches:?boolean, segmentedSearch:?boolean}} options to control search behavior.\r\n     *                  preferPrefixMatches puts an exact case-insensitive prefix match ahead of all other matches,\r\n     *                  even short-circuiting the match logic. This option implies segmentedSearch=false.\r\n     *                  When segmentedSearch is true, the string is broken into segments by "/" characters\r\n     *                  and the last segment is searched first and matches there are scored higher.\r\n     * @param {?Object} special (optional) the specials data from findSpecialCharacters, if already known\r\n     *                  This is generally just used by StringMatcher for optimization.\r\n     * @return {{ranges:Array.<{text:string, matched:boolean, includesLastSegment:boolean}>, matchGoodness:int, scoreDebug: Object}} matched ranges and score\r\n     */\r\n    function stringMatch(str, query, options, special) {\r\n        var result;\r\n        \r\n        options = options || {};\r\n        \r\n        // No query? Short circuit the normal work done and just\r\n        // return a single range that covers the whole string.\r\n        if (!query) {\r\n            result = new SearchResult(str);\r\n            result.matchGoodness = 0;\r\n            if (DEBUG_SCORES) {\r\n                result.scoreDebug = {};\r\n            }\r\n            result.stringRanges = [{\r\n                text: str,\r\n                matched: false,\r\n                includesLastSegment: true\r\n            }];\r\n            return result;\r\n        }\r\n        \r\n        // comparisons are case insensitive, so switch to lower case here\r\n        query = query.toLowerCase();\r\n        var compareStr = str.toLowerCase();\r\n        \r\n        if (options.preferPrefixMatches) {\r\n            options.segmentedSearch = false;\r\n        }\r\n        \r\n        if (options.preferPrefixMatches && compareStr.substr(0, query.length) === query) {\r\n            return _prefixMatchResult(str, query);\r\n        }\r\n        \r\n        // Locate the special characters and then use orderedCompare to do the real\r\n        // work.\r\n        if (!special) {\r\n            special = findSpecialCharacters(str);\r\n        }\r\n        var lastSegmentStart, matchList;\r\n        \r\n        // For strings that are not broken into multiple segments, we can potentially\r\n        // avoid some extra work\r\n        if (options.segmentedSearch) {\r\n            lastSegmentStart = special.specials[special.lastSegmentSpecialsIndex];\r\n            matchList = _wholeStringSearch(query, compareStr, special.specials,\r\n                              special.lastSegmentSpecialsIndex);\r\n        } else {\r\n            lastSegmentStart = 0;\r\n            matchList = _generateMatchList(query, compareStr, special.specials,\r\n                                           0);\r\n        }\r\n        \r\n        // If we get a match, turn this into a SearchResult as expected by the consumers\r\n        // of this API.\r\n        if (matchList) {\r\n            var compareData = _computeRangesAndScore(matchList, str, lastSegmentStart);\r\n            result = new SearchResult(str);\r\n            result.stringRanges = compareData.ranges;\r\n            result.matchGoodness = -1 * compareData.matchGoodness;\r\n            if (DEBUG_SCORES) {\r\n                result.scoreDebug = compareData.scoreDebug;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Sorts an array of SearchResult objects on a primary field, followed by secondary fields\r\n     * in case of ties. \'fieldSpec\' provides the priority order for fields, where the first entry is the primary field, for example:\r\n     *      multiFieldSort(bugList, [ "milestone", "severity" ]);\r\n     * Would sort a bug list by milestone, and within each milestone sort bugs by severity.\r\n     *\r\n     * fieldSpec can also include comparator functions of the form normally used by the sort()\r\n     * function.\r\n     *\r\n     * Any fields that have a string value are compared case-insensitively. Fields used should be\r\n     * present on all SearchResult objects (no optional/undefined fields).\r\n     *\r\n     * @param {!Array.<SearchResult>} searchResults\r\n     * @param {!Array.<string, function>} fieldSpec\r\n     */\r\n    function multiFieldSort(searchResults, fieldSpec) {\r\n        // Move field names into an array, with primary field first\r\n        var comparisons;\r\n        if (Array.isArray(fieldSpec)) {\r\n            comparisons = fieldSpec;\r\n        } else {\r\n            // TODO Deprecate this form of calling this function\r\n            comparisons = [];\r\n            _.forEach(fieldSpec, function (priority, key) {\r\n                comparisons[priority] = key;\r\n            });\r\n        }\r\n        \r\n        searchResults.sort(function (a, b) {\r\n            var priority;\r\n            for (priority = 0; priority < comparisons.length; priority++) {\r\n                var comparison = comparisons[priority];\r\n                if (typeof comparison === "function") {\r\n                    var result = comparison(a, b);\r\n                    if (result) {\r\n                        return result;\r\n                    }\r\n                } else {\r\n                    var valueA = a[comparison];\r\n                    var valueB = b[comparison];\r\n                    if (typeof valueA === "string") {\r\n                        valueA = valueA.toLowerCase();\r\n                        valueB = valueB.toLowerCase();\r\n                    }\r\n                    \r\n                    if (valueA < valueB) {\r\n                        return -1;\r\n                    } else if (valueA > valueB) {\r\n                        return 1;\r\n                    }\r\n                }\r\n                // otherwise, move on to next sort priority\r\n            }\r\n            return 0; // all sort fields are equal\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Sorts search results generated by stringMatch(): results are sorted into several\r\n     * tiers based on how well they matched the search query, then sorted alphabetically\r\n     * within each tier.\r\n     */\r\n    function basicMatchSort(searchResults) {\r\n        multiFieldSort(searchResults, { matchGoodness: 0, label: 1 });\r\n    }\r\n    \r\n    /**\r\n     * A StringMatcher provides an interface to the stringMatch function with built-in\r\n     * caching. You should use a StringMatcher for the lifetime of queries over a\r\n     * single data set.\r\n     *\r\n     * You are free to store other data on this object to assist in higher-level caching.\r\n     * (This object\'s caches are all stored in "_" prefixed properties.)\r\n     *\r\n     * @param {{preferPrefixMatches:?boolean, segmentedSearch:?boolean}} options to control search behavior.\r\n     *                  preferPrefixMatches puts an exact case-insensitive prefix match ahead of all other matches,\r\n     *                  even short-circuiting the match logic. This option implies segmentedSearch=false.\r\n     *                  segmentedSearch treats segments of the string specially.\r\n     */\r\n    function StringMatcher(options) {\r\n        this.options = options;\r\n        this.reset();\r\n    }\r\n    \r\n    /**\r\n     * Map from search-result string to the findSpecialCharacters() result for that string - easy to cache\r\n     * since this info doesn\'t change as the query changes.\r\n     * @type {Object.<string, {specials:Array.<number>, lastSegmentSpecialsIndex:number}>}\r\n     */\r\n    StringMatcher.prototype._specialsCache = null;\r\n    \r\n    /**\r\n     * Set of search-result strings that we know don\'t match the query _lastQuery - or any other query with\r\n     * that prefix.\r\n     * @type {Object.<string, boolean>}\r\n     */\r\n    StringMatcher.prototype._noMatchCache = null;\r\n    \r\n    /**\r\n     * Clears the caches. Use this in the event that the caches may be invalid.\r\n     */\r\n    StringMatcher.prototype.reset = function () {\r\n        // We keep track of the last query to know when we need to invalidate.\r\n        this._lastQuery = null;\r\n        \r\n        this._specialsCache = {};\r\n        this._noMatchCache = {};\r\n    };\r\n    \r\n    /**\r\n     * Performs a single match using the stringMatch function. See stringMatch for full documentation.\r\n     *\r\n     * @param {string} str  The string to search\r\n     * @param {string} query  The query string to find in string\r\n     * @return {{ranges:Array.<{text:string, matched:boolean, includesLastSegment:boolean}>, matchGoodness:int, scoreDebug: Object}} matched ranges and score\r\n     */\r\n    StringMatcher.prototype.match = function (str, query) {\r\n        \r\n        // If the query is not just added characters from the previous query, we invalidate\r\n        // the no match cache and will re-match everything.\r\n        if (this._lastQuery !== null && (this._lastQuery !== query.substring(0, this._lastQuery.length))) {\r\n            this._noMatchCache = {};\r\n        }\r\n        \r\n        this._lastQuery = query;\r\n        \r\n        // Check for a known non-matching string.\r\n        if (_.has(this._noMatchCache, str)) {\r\n            return undefined;\r\n        }\r\n        \r\n        // Load up the cached specials information (or build it if this is our first time through).\r\n        var special = _.has(this._specialsCache, str) ? this._specialsCache[str] : undefined;\r\n        if (special === undefined) {\r\n            special = findSpecialCharacters(str);\r\n            this._specialsCache[str] = special;\r\n        }\r\n        \r\n        var result = stringMatch(str, query, this.options, special);\r\n        \r\n        // If this query was not a match, we cache that fact for next time.\r\n        if (!result) {\r\n            this._noMatchCache[str] = true;\r\n        }\r\n        return result;\r\n    };\r\n    \r\n    exports._findSpecialCharacters  = findSpecialCharacters;\r\n    exports._wholeStringSearch      = _wholeStringSearch;\r\n    exports._lastSegmentSearch      = _lastSegmentSearch;\r\n    exports._setDebugScores         = _setDebugScores;\r\n    exports._generateMatchList      = _generateMatchList;\r\n    exports._SpecialMatch           = SpecialMatch;\r\n    exports._NormalMatch            = NormalMatch;\r\n    exports._computeRangesAndScore  = _computeRangesAndScore;\r\n\r\n    // public exports\r\n    exports.SearchResult            = SearchResult;\r\n    exports.stringMatch             = stringMatch;\r\n    exports.basicMatchSort          = basicMatchSort;\r\n    exports.multiFieldSort          = multiFieldSort;\r\n    exports.StringMatcher           = StringMatcher;\r\n});\r\n\n//# sourceURL=/utils/StringMatch.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, setTimeout */\r\n/*unittests: QuickOpen*/\r\n\r\n/*\r\n * Displays an auto suggest pop-up list of files to allow the user to quickly navigate to a file and lines\r\n * within a file.\r\n * Uses FileIndexManger to supply the file list.\r\n * \r\n * TODO (issue 333) - currently jquery smart auto complete is used for the pop-up list. While it mostly works\r\n * it has several issues, so it should be replace with an alternative. Issues:\r\n * - the pop-up position logic has flaws that require CSS workarounds\r\n * - the pop-up properties cannot be modified once the object is constructed\r\n */\r\n\r\n\r\ndefine(\'search/QuickOpen\',[\'require\',\'exports\',\'module\',\'document/DocumentManager\',\'editor/EditorManager\',\'view/MainViewManager\',\'view/MainViewFactory\',\'command/CommandManager\',\'strings\',\'utils/StringUtils\',\'command/Commands\',\'project/ProjectManager\',\'language/LanguageManager\',\'utils/KeyEvent\',\'widgets/ModalBar\',\'utils/StringMatch\',\'utils/ViewUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var DocumentManager     = require("document/DocumentManager"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        MainViewManager     = require("view/MainViewManager"),\r\n        MainViewFactory     = require("view/MainViewFactory"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        Strings             = require("strings"),\r\n        StringUtils         = require("utils/StringUtils"),\r\n        Commands            = require("command/Commands"),\r\n        ProjectManager      = require("project/ProjectManager"),\r\n        LanguageManager     = require("language/LanguageManager"),\r\n        KeyEvent            = require("utils/KeyEvent"),\r\n        ModalBar            = require("widgets/ModalBar").ModalBar,\r\n        StringMatch         = require("utils/StringMatch"),\r\n        ViewUtils           = require("utils/ViewUtils");\r\n    \r\n    \r\n    /**\r\n     * The regular expression to check the cursor position\r\n     * @const {RegExp}\r\n     */\r\n    var CURSOR_POS_EXP = new RegExp(":([^,]+)?(,(.+)?)?");\r\n    \r\n    /**\r\n     * List of plugins\r\n     * @type {Array.<QuickOpenPlugin>}\r\n     */\r\n    var plugins = [];\r\n\r\n    /**\r\n     * Current plugin\r\n     * @type {QuickOpenPlugin}\r\n     */\r\n    var currentPlugin = null;\r\n\r\n    /**\r\n     * List of files\r\n     * @type {Array.<FileInfo>}\r\n     */\r\n    var fileList;\r\n    \r\n    /**\r\n     * File list promise\r\n     * @type {$.Promise}\r\n     */\r\n    var fileListPromise;\r\n\r\n    /**\r\n     * The currently open quick open dialog.\r\n     * @type {Dialog}\r\n     */\r\n    var _curDialog;\r\n\r\n    /**\r\n     * Defines API for new QuickOpen plug-ins\r\n     */\r\n    function QuickOpenPlugin(name, languageIds, done, search, match, itemFocus, itemSelect, resultsFormatter, matcherOptions, label) {\r\n        this.name = name;\r\n        this.languageIds = languageIds;\r\n        this.done = done;\r\n        this.search = search;\r\n        this.match = match;\r\n        this.itemFocus = itemFocus;\r\n        this.itemSelect = itemSelect;\r\n        this.resultsFormatter = resultsFormatter;\r\n        this.matcherOptions = matcherOptions;\r\n        this.label = label;\r\n    }\r\n    \r\n    /**\r\n     * Creates and registers a new QuickOpenPlugin\r\n     *\r\n     * @param { name: string, \r\n     *          languageIds: Array.<string>,\r\n     *          done: ?function(),\r\n     *          search: function(string, !StringMatch.StringMatcher):Array.<SearchResult|string>,\r\n     *          match: function(string):boolean,\r\n     *          itemFocus: ?function(?SearchResult|string),\r\n     *          itemSelect: function(?SearchResult|string),\r\n     *          resultsFormatter: ?function(SearchResult|string, string):string,\r\n     *          matcherOptions: ?Object,\r\n     *          label: ?string\r\n     *        } pluginDef\r\n     *\r\n     * Parameter Documentation:\r\n     *\r\n     * name - plug-in name, **must be unique**\r\n     * languageIds - language Ids array. Example: ["javascript", "css", "html"]. To allow any language, pass []. Required.\r\n     * done - called when quick open is complete. Plug-in should clear its internal state. Optional.\r\n     * search - takes a query string and a StringMatcher (the use of which is optional but can speed up your searches) and returns an array of strings that match the query. Required.\r\n     * match - takes a query string and returns true if this plug-in wants to provide\r\n     *      results for this query. Required.\r\n     * itemFocus - performs an action when a result has been highlighted (via arrow keys, mouseover, etc.).\r\n     *      The highlighted search result item (as returned by search()) is passed as an argument. Optional.\r\n     * itemSelect - performs an action when a result is chosen.\r\n     *      The selected search result item (as returned by search()) is passed as an argument. Required.\r\n     * resultsFormatter - takes a query string and an item string and returns \r\n     *      a <LI> item to insert into the displayed search results. Optional.\r\n     * matcherOptions - options to pass along to the StringMatcher (see StringMatch.StringMatcher\r\n     *          for available options). Optional.\r\n     * label - if provided, the label to show before the query field. Optional.\r\n     *\r\n     * If itemFocus() makes changes to the current document or cursor/scroll position and then the user\r\n     * cancels Quick Open (via Esc), those changes are automatically reverted.\r\n     */\r\n    function addQuickOpenPlugin(pluginDef) {\r\n        // Backwards compatibility (for now) for old fileTypes field, if newer languageIds not specified\r\n        if (pluginDef.fileTypes && !pluginDef.languageIds) {\r\n            console.warn("Using fileTypes for QuickOpen plugins is deprecated. Use languageIds instead.");\r\n            pluginDef.languageIds = pluginDef.fileTypes.map(function (extension) {\r\n                return LanguageManager.getLanguageForPath("file." + extension).getId();\r\n            });\r\n            delete pluginDef.fileTypes;\r\n        }\r\n        \r\n        plugins.push(new QuickOpenPlugin(\r\n            pluginDef.name,\r\n            pluginDef.languageIds,\r\n            pluginDef.done,\r\n            pluginDef.search,\r\n            pluginDef.match,\r\n            pluginDef.itemFocus,\r\n            pluginDef.itemSelect,\r\n            pluginDef.resultsFormatter,\r\n            pluginDef.matcherOptions,\r\n            pluginDef.label\r\n        ));\r\n    }\r\n\r\n    /**\r\n     * QuickNavigateDialog class\r\n     * @constructor\r\n     */\r\n    function QuickNavigateDialog() {\r\n        this.$searchField = undefined; // defined when showDialog() is called\r\n        \r\n        // Bind event handlers\r\n        this._handleItemSelect         = this._handleItemSelect.bind(this);\r\n        this._handleItemFocus          = this._handleItemFocus.bind(this);\r\n        this._handleKeyUp              = this._handleKeyUp.bind(this);\r\n        this._handleResultsReady       = this._handleResultsReady.bind(this);\r\n        this._handleShowResults        = this._handleShowResults.bind(this);\r\n        this._handleBlur               = this._handleBlur.bind(this);\r\n        this._handleDocumentMouseDown  = this._handleDocumentMouseDown.bind(this);\r\n        \r\n        // Bind callbacks from smart-autocomplete\r\n        this._filterCallback           = this._filterCallback.bind(this);\r\n        this._resultsFormatterCallback = this._resultsFormatterCallback.bind(this);\r\n        \r\n        // StringMatchers that cache in-progress query data.\r\n        this._filenameMatcher           = new StringMatch.StringMatcher({\r\n            segmentedSearch: true\r\n        });\r\n        this._matchers                  = {};\r\n    }\r\n    \r\n    /**\r\n     * True if the dialog is currently open. Note that this is set to false immediately\r\n     * when the dialog starts closing; it doesn\'t wait for the ModalBar animation to finish.\r\n     * @type {boolean}\r\n     */\r\n    QuickNavigateDialog.prototype.isOpen = false;\r\n    \r\n    /**\r\n     * @private\r\n     * Handles caching of filename search information for the lifetime of a \r\n     * QuickNavigateDialog (a single search until the dialog is dismissed)\r\n     *\r\n     * @type {StringMatch.StringMatcher}\r\n     */\r\n    QuickNavigateDialog.prototype._filenameMatcher = null;\r\n    \r\n    /**\r\n     * @private\r\n     * StringMatcher caches for each QuickOpen plugin that keep track of search\r\n     * information for the lifetime of a QuickNavigateDialog (a single search\r\n     * until the dialog is dismissed)\r\n     *\r\n     * @type {Object.<string, StringMatch.StringMatcher>}\r\n     */\r\n    QuickNavigateDialog.prototype._matchers = null;\r\n    \r\n    /**\r\n     * @private\r\n     * If the dialog is closing, this will contain a deferred that is resolved\r\n     * when it\'s done closing.\r\n     * @type {$.Deferred}\r\n     */\r\n    QuickNavigateDialog.prototype._closeDeferred = null;\r\n    \r\n\r\n    /**\r\n     * @private\r\n     * Remembers the current document that was displayed when showDialog() was called.\r\n     * TODO: in the future, if focusing an item can switch documents, need to restore this on Escape.\r\n     * @type {?string} full path\r\n     */\r\n    QuickNavigateDialog.prototype._origDocPath = null;\r\n\r\n    /**\r\n     * @private\r\n     * Remembers the selection state in origDocPath that was present when showDialog() was called. Focusing on an\r\n     * item can change the selection; we restore this original selection if the user presses Escape. Null if\r\n     * no document was open when Quick Open was invoked.\r\n     * @type {?Array.<{{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed:boolean}}>}\r\n     */\r\n    QuickNavigateDialog.prototype._origSelections = null;\r\n    \r\n    /**\r\n     * @private\r\n     * Remembers the scroll position in origDocPath when showDialog() was called (see origSelection above).\r\n     * @type {?{x:number, y:number}}\r\n     */\r\n    QuickNavigateDialog.prototype._origScrollPos = null;\r\n\r\n    function _filenameFromPath(path, includeExtension) {\r\n        var end;\r\n        if (includeExtension) {\r\n            end = path.length;\r\n        } else {\r\n            end = path.lastIndexOf(".");\r\n            if (end === -1) {\r\n                end = path.length;\r\n            }\r\n        }\r\n        return path.slice(path.lastIndexOf("/") + 1, end);\r\n    }\r\n    \r\n    /**\r\n     * Attempts to extract a line number from the query where the line number\r\n     * is followed by a colon. Callers should explicitly test result with isNaN()\r\n     * \r\n     * @param {string} query string to extract line number from\r\n     * @return {{query: string, local: boolean, line: number, ch: number}} An object with\r\n     *      the extracted line and column numbers, and two additional fields: query with the original position \r\n     *      string and local indicating if the cursor position should be applied to the current file.\r\n     *      Or null if the query is invalid\r\n     */\r\n    function extractCursorPos(query) {\r\n        var regInfo = query.match(CURSOR_POS_EXP),\r\n            result;\r\n        \r\n        if (query.length <= 1 || !regInfo ||\r\n                (regInfo[1] && isNaN(regInfo[1])) ||\r\n                (regInfo[3] && isNaN(regInfo[3]))) {\r\n            \r\n            return null;\r\n        }\r\n            \r\n        return {\r\n            query:  regInfo[0],\r\n            local:  query.indexOf(":") === 0,\r\n            line:   regInfo[1] - 1 || 0,\r\n            ch:     regInfo[3] - 1 || 0\r\n        };\r\n    }\r\n    \r\n    /** Returns the last return value of _filterCallback(), which Smart Autocomplete helpfully caches */\r\n    function getLastFilterResult() {\r\n        var cachedResult = $("input#quickOpenSearch").data("smart-autocomplete").rawResults;\r\n        return cachedResult || [];\r\n    }\r\n    \r\n    /**\r\n     * Converts from list item DOM node to search provider list object\r\n     * @param {jQueryObject} domItem\r\n     * @return {SearchResult|string} value returned from search()\r\n     */\r\n    function domItemToSearchResult(domItem) {\r\n        if (!domItem) {\r\n            return null;\r\n        }\r\n        \r\n        // Smart Autocomplete uses this assumption internally: index of DOM node in results list container\r\n        // exactly matches index of search result in list returned by _filterCallback()\r\n        var index = $(domItem).index();\r\n        \r\n        var lastFilterResult = getLastFilterResult();\r\n        return lastFilterResult[index];\r\n    }\r\n    \r\n    /**\r\n     * Navigates to the appropriate file and file location given the selected item \r\n     * and closes the dialog.\r\n     *\r\n     * Note, if selectedItem is null quick search should inspect $searchField for text\r\n     * that may have not matched anything in in the list, but may have information\r\n     * for carrying out an action (e.g. go to line).\r\n     */\r\n    QuickNavigateDialog.prototype._handleItemSelect = function (e, selectedDOMItem) {\r\n\r\n        // This is a work-around to select first item when a selection event occurs\r\n        // (usually from pressing the enter key) and no item is selected in the list.\r\n        // This is a work-around since  Smart auto complete doesn\'t select the first item\r\n        if (!selectedDOMItem) {\r\n            selectedDOMItem = $(".smart_autocomplete_container > li:first-child").get(0);\r\n        }\r\n        \r\n        var selectedItem = domItemToSearchResult(selectedDOMItem),\r\n            doClose      = true,\r\n            self         = this,\r\n            query        = this.$searchField.val(),\r\n            cursorPos    = extractCursorPos(query);\r\n\r\n        // Delegate to current plugin\r\n        if (currentPlugin) {\r\n            currentPlugin.itemSelect(selectedItem);\r\n        } else {\r\n            // Navigate to file and line number\r\n            var fullPath = selectedItem && selectedItem.fullPath;\r\n            if (fullPath) {\r\n                // This case is tricky. We want to switch editors, so we need to deal with\r\n                // resizing/rescrolling the current editor first. But we don\'t actually want\r\n                // to start the animation of the ModalBar until afterward (otherwise it glitches\r\n                // because it gets starved of cycles during the creation of the new editor). \r\n                // So we call `prepareClose()` first, and finish the close later.\r\n                doClose = false;\r\n                this.modalBar.prepareClose();\r\n                CommandManager.execute(Commands.CMD_ADD_TO_WORKINGSET_AND_OPEN, {fullPath: fullPath})\r\n                    .done(function () {\r\n                        if (cursorPos) {\r\n                            var editor = EditorManager.getCurrentFullEditor();\r\n                            editor.setCursorPos(cursorPos.line, cursorPos.ch, true);\r\n                        }\r\n                    })\r\n                    .always(function () {\r\n                        self.close();\r\n                    });\r\n            } else if (cursorPos) {\r\n                EditorManager.getCurrentFullEditor().setCursorPos(cursorPos.line, cursorPos.ch, true);\r\n            }\r\n        }\r\n\r\n        if (doClose) {\r\n            this.close();\r\n            MainViewManager.focusActivePane();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Opens the file specified by selected item if there is no current plug-in, otherwise defers handling\r\n     * to the currentPlugin\r\n     */\r\n    QuickNavigateDialog.prototype._handleItemFocus = function (e, selectedDOMItem) {\r\n        var selectedItem = domItemToSearchResult(selectedDOMItem);\r\n        \r\n        if (currentPlugin && currentPlugin.itemFocus) {\r\n            currentPlugin.itemFocus(selectedItem);\r\n        }\r\n        // TODO: Disable opening files on focus for now since this causes focus related bugs between \r\n        // the editor and the search field. \r\n        // Also, see related code in _handleItemFocus\r\n        /*\r\n        else {\r\n            var fullPath = selectedItem.fullPath;\r\n            if (fullPath) {\r\n                CommandManager.execute(Commands.FILE_OPEN, {fullPath: fullPath, focusEditor: false});\r\n            }\r\n        }\r\n        */\r\n        \r\n    };\r\n\r\n    /**\r\n     * Called before Smart Autocomplete processes the key, but after the DOM textfield ($searchField) updates its value.\r\n     * After this, Smart Autocomplete doesn\'t call _handleFilter() & re-render the list until a setTimeout(0) later.\r\n     */\r\n    QuickNavigateDialog.prototype._handleKeyUp = function (e) {\r\n        // Cancel the search on Esc key, and finish the search on Enter key\r\n        if (e.keyCode === KeyEvent.DOM_VK_RETURN || e.keyCode === KeyEvent.DOM_VK_ESCAPE) {\r\n            // Smart Autocomplete also handles Enter; but it does so without a timeout, which causes #1855.\r\n            // Since our listener was added first (see showDialog()), we can steal the Enter event and block\r\n            // Smart Autocomplete from buggily acting on it.\r\n            e.stopImmediatePropagation();\r\n            e.preventDefault();\r\n            \r\n            // Process on a timeout since letter keys are handled that way and we don\'t want to get ahead\r\n            // of processing letters that were typed before the Enter key. The ideal order of events is:\r\n            //   letter keydown/keyup, letter key processed async, enter keydown/keyup, enter key processed async\r\n            // However, we might get \'enter keyup\' before \'letter key processed async\'. The letter key\'s\r\n            // timeout will always run before ours since it was registered first.\r\n            var self = this;\r\n            setTimeout(function () {\r\n                if (e.keyCode === KeyEvent.DOM_VK_ESCAPE) {\r\n                    // Restore original selection / scroll pos\r\n                    self.close(self._origScrollPos, self._origSelections);\r\n                } else if (e.keyCode === KeyEvent.DOM_VK_RETURN) {\r\n                    self._handleItemSelect(null, $(".smart_autocomplete_highlight").get(0));  // calls close() too\r\n                }\r\n            }, 0);\r\n            \r\n        }\r\n    };\r\n\r\n    /**\r\n     * Checks if the given query string is a line number query that is either empty (the number hasn\'t been typed yet)\r\n     * or is a valid line number within the visible range of the current full editor.\r\n     * @param {string} query The query to check.\r\n     * @return {boolean} true if the given query is a valid line number query.\r\n     */\r\n    QuickNavigateDialog.prototype._isValidLineNumberQuery = function (query) {\r\n        // Empty query returns NaN from extractLineNumber, but we want to treat it as valid for UI purposes.\r\n        if (query === ":") {\r\n            return true;\r\n        }\r\n        \r\n        var cursorPos = extractCursorPos(query),\r\n            editor    = EditorManager.getCurrentFullEditor();\r\n        \r\n        // We could just use 0 and lineCount() here, but in future we might want this logic to work for inline editors as well.\r\n        return (cursorPos && editor && cursorPos.line >= editor.getFirstVisibleLine() && cursorPos.line <= editor.getLastVisibleLine());\r\n    };\r\n    \r\n    /**\r\n     * Called synchronously after _handleFilter(), but before the cached "last result" is updated and before the DOM\r\n     * list items are re-rendered. Both happen synchronously just after we return. Called even when results is empty.\r\n     */\r\n    QuickNavigateDialog.prototype._handleResultsReady = function (e, results) {\r\n        // Give visual clue when there are no results (unless we\'re in "Go To Line" mode, where there\r\n        // are never results, or we\'re in file search mode and waiting for the index to get rebuilt)\r\n        var hasNoResults = (results.length === 0 && (fileList || currentPlugin) && !this._isValidLineNumberQuery(this.$searchField.val()));\r\n        \r\n        ViewUtils.toggleClass(this.$searchField, "no-results", hasNoResults);\r\n    };\r\n    \r\n    /**\r\n     * Called synchronously after all other processing is done (_handleFilter(), updating cached "last result" and\r\n     * re-rendering DOM list items). NOT called if the last filter action had 0 results.\r\n     */\r\n    QuickNavigateDialog.prototype._handleShowResults = function (e, results) {\r\n        // Scroll to top result (unless some other item has been highlighted by user)\r\n        if ($(".smart_autocomplete_highlight").length === 0) {\r\n            this._handleItemFocus(null, $(".smart_autocomplete_container > li:first-child").get(0));\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Closes the search dialog and notifies all quick open plugins that\r\n     * searching is done.\r\n     * @param {{x: number, y: number}=} scrollPos If specified, scroll to the given\r\n     *     position when closing the ModalBar.\r\n     * @param Array.<{{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed:boolean}}>\r\n     *     selections If specified, restore the given selections when closing the ModalBar.\r\n     * @return {$.Promise} Resolved when the search bar is entirely closed.\r\n     */\r\n    QuickNavigateDialog.prototype.close = function (scrollPos, selections) {\r\n        if (!this.isOpen) {\r\n            return this._closeDeferred.promise();\r\n        }\r\n        this.isOpen = false;\r\n        \r\n        // We can\'t just return the ModalBar\'s `close()` promise because we need to do it on a\r\n        // setTimeout, so we create our own Deferred and cache it so we can return it if multiple\r\n        // callers happen to call `close()`.\r\n        this._closeDeferred = new $.Deferred();\r\n\r\n        var i;\r\n        for (i = 0; i < plugins.length; i++) {\r\n            var plugin = plugins[i];\r\n            if (plugin.done) {\r\n                plugin.done();\r\n            }\r\n        }\r\n\r\n        // Make sure Smart Autocomplete knows its popup is getting closed (in cases where there\'s no\r\n        // editor to give focus to below, it won\'t notice otherwise).\r\n        this.$searchField.trigger("lostFocus");\r\n        \r\n        // Closing the dialog is a little tricky (see #1384): some Smart Autocomplete code may run later (e.g.\r\n        // (because it\'s a later handler of the event that just triggered close()), and that code expects to\r\n        // find metadata that it stuffed onto the DOM node earlier. But $.remove() strips that metadata.\r\n        // So we wait until after this call chain is complete before actually closing the dialog.\r\n        var self = this;\r\n        setTimeout(function () {\r\n            self.modalBar.close(!scrollPos).done(function () {\r\n                self._closeDeferred.resolve();\r\n            });\r\n\r\n            // Note that we deliberately reset the scroll position synchronously on return from\r\n            // `ModalBar.close()` (before the animation completes).\r\n            // See description of `restoreScrollPos` in `ModalBar.close()`.\r\n            var editor = EditorManager.getCurrentFullEditor();\r\n            if (selections) {\r\n                editor.setSelections(selections);\r\n            }\r\n            if (scrollPos) {\r\n                editor.setScrollPos(scrollPos.x, scrollPos.y);\r\n            }\r\n        }, 0);\r\n        \r\n        $(".smart_autocomplete_container").remove();\r\n\r\n        $(window.document).off("mousedown", this._handleDocumentMouseDown);\r\n        \r\n        return this._closeDeferred.promise();\r\n    };\r\n    \r\n    /**\r\n     * Returns true if the query string doesn\'t match the query text field. This can happen when _handleFilter()\r\n     * runs slow (either synchronously or async as in searchFileList()). Several key events queue up before filtering\r\n     * is done, and each sets a timeout. After all the key events are handled, we wind up with a queue of timeouts\r\n     * waiting to run, once per key event. All but the last one reflect a stale value of the text field.\r\n     * @param {string} query\r\n     * @return {boolean}\r\n     */\r\n    function queryIsStale(query) {\r\n        var currentQuery = $("input#quickOpenSearch").val();\r\n        return currentQuery !== query;\r\n    }\r\n\r\n    function searchFileList(query, matcher) {\r\n        // The file index may still be loading asynchronously - if so, can\'t return a result yet\r\n        if (!fileList) {\r\n            // Smart Autocomplete allows us to return a Promise instead...\r\n            var asyncResult = new $.Deferred();\r\n            fileListPromise.done(function () {\r\n                // ...but it\'s not very robust. If a previous Promise is obsoleted by the query string changing, it\r\n                // keeps listening to it anyway. So the last Promise to resolve "wins" the UI update even if it\'s for\r\n                // a stale query. Guard from that by checking that filter text hasn\'t changed while we were waiting:\r\n                if (!queryIsStale(query)) {\r\n                    // We\'re still the current query. Synchronously re-run the search call and resolve with its results\r\n                    asyncResult.resolve(searchFileList(query, matcher));\r\n                } else {\r\n                    asyncResult.reject();\r\n                }\r\n            });\r\n            return asyncResult.promise();\r\n        }\r\n        \r\n        var cursorPos = extractCursorPos(query);\r\n        if (cursorPos && !cursorPos.local && cursorPos.query !== "") {\r\n            query = query.replace(cursorPos.query, "");\r\n        }\r\n\r\n        // First pass: filter based on search string; convert to SearchResults containing extra info\r\n        // for sorting & display\r\n        var filteredList = $.map(fileList, function (fileInfo) {\r\n            // Is it a match at all?\r\n            // match query against the full path (with gaps between query characters allowed)\r\n            var searchResult;\r\n            \r\n            searchResult = matcher.match(ProjectManager.makeProjectRelativeIfPossible(fileInfo.fullPath), query);\r\n            \r\n            if (searchResult) {\r\n                searchResult.label = fileInfo.name;\r\n                searchResult.fullPath = fileInfo.fullPath;\r\n                searchResult.filenameWithoutExtension = _filenameFromPath(fileInfo.name, false);\r\n            }\r\n            return searchResult;\r\n        });\r\n        \r\n        // Sort by "match goodness" tier first, then within each tier sort alphabetically - first by filename\r\n        // sans extension, (so that "abc.js" comes before "abc-d.js"), then by filename, and finally (for\r\n        // identically-named files) by full path\r\n        StringMatch.multiFieldSort(filteredList, { matchGoodness: 0, filenameWithoutExtension: 1, label: 2, fullPath: 3 });\r\n\r\n        return filteredList;\r\n    }\r\n\r\n    /**\r\n     * Handles changes to the current query in the search field.\r\n     * @param {string} query The new query.\r\n     * @return {Array} The filtered list of results.\r\n     */\r\n    QuickNavigateDialog.prototype._filterCallback = function (query) {\r\n        // If previous filter calls ran slow, we may have accumulated several query change events in the meantime.\r\n        // Only respond to the one that\'s current. Note that this only works because we\'re called on a timeout after\r\n        // the key event; checking DURING the key event itself would never yield a future value for the input field.\r\n        if (queryIsStale(query)) {\r\n            return getLastFilterResult();\r\n        }\r\n        \r\n        // "Go to line" mode is special-cased\r\n        var cursorPos = extractCursorPos(query);\r\n        if (cursorPos && cursorPos.local) {\r\n            var from = {line: cursorPos.line, ch: cursorPos.ch},\r\n                to   = {line: cursorPos.line};\r\n            \r\n            EditorManager.getCurrentFullEditor().setSelection(from, to, true);\r\n        }\r\n        \r\n        // Try to invoke a search plugin\r\n        var curDoc = DocumentManager.getCurrentDocument(), languageId;\r\n        if (curDoc) {\r\n            languageId = curDoc.getLanguage().getId();\r\n        }\r\n\r\n        var i;\r\n        for (i = 0; i < plugins.length; i++) {\r\n            var plugin = plugins[i];\r\n            var languageIdMatch = plugin.languageIds.length === 0 || plugin.languageIds.indexOf(languageId) !== -1;\r\n            if (languageIdMatch && plugin.match && plugin.match(query)) {\r\n                currentPlugin = plugin;\r\n                \r\n                // Look up the StringMatcher for this plugin.\r\n                var matcher = this._matchers[currentPlugin.name];\r\n                if (!matcher) {\r\n                    matcher = new StringMatch.StringMatcher(plugin.matcherOptions);\r\n                    this._matchers[currentPlugin.name] = matcher;\r\n                }\r\n                this._updateDialogLabel(plugin, query);\r\n                return plugin.search(query, matcher);\r\n            }\r\n        }\r\n        \r\n        // Reflect current search mode in UI\r\n        this._updateDialogLabel(null, query);\r\n        \r\n        // No matching plugin: use default file search mode\r\n        currentPlugin = null;\r\n        return searchFileList(query, this._filenameMatcher);\r\n    };\r\n\r\n    /**\r\n     * Formats item\'s label as properly escaped HTML text, highlighting sections that match \'query\'.\r\n     * If item is a SearchResult generated by stringMatch(), uses its metadata about which string ranges\r\n     * matched; else formats the label with no highlighting.\r\n     * @param {!string|SearchResult} item\r\n     * @param {?string} matchClass CSS class for highlighting matched text\r\n     * @param {?function(boolean, string):string} rangeFilter\r\n     * @return {!string} bolded, HTML-escaped result\r\n     */\r\n    function highlightMatch(item, matchClass, rangeFilter) {\r\n        var label = item.label || item;\r\n        matchClass = matchClass || "quicksearch-namematch";\r\n        \r\n        var stringRanges = item.stringRanges;\r\n        if (!stringRanges) {\r\n            // If result didn\'t come from stringMatch(), highlight nothing\r\n            stringRanges = [{\r\n                text: label,\r\n                matched: false,\r\n                includesLastSegment: true\r\n            }];\r\n        }\r\n        \r\n        var displayName = "";\r\n        if (item.scoreDebug) {\r\n            var sd = item.scoreDebug;\r\n            displayName += \'<span title="sp:\' + sd.special + \', m:\' + sd.match +\r\n                \', ls:\' + sd.lastSegment + \', b:\' + sd.beginning +\r\n                \', ld:\' + sd.lengthDeduction + \', c:\' + sd.consecutive + \', nsos: \' +\r\n                sd.notStartingOnSpecial + \'">(\' + item.matchGoodness + \') </span>\';\r\n        }\r\n        \r\n        // Put the path pieces together, highlighting the matched parts\r\n        stringRanges.forEach(function (range) {\r\n            if (range.matched) {\r\n                displayName += "<span class=\'" + matchClass + "\'>";\r\n            }\r\n            \r\n            var rangeText = rangeFilter ? rangeFilter(range.includesLastSegment, range.text) : range.text;\r\n            displayName += StringUtils.breakableUrl(rangeText);\r\n            \r\n            if (range.matched) {\r\n                displayName += "</span>";\r\n            }\r\n        });\r\n        return displayName;\r\n    }\r\n    \r\n    function defaultResultsFormatter(item, query) {\r\n        query = query.slice(query.indexOf("@") + 1, query.length);\r\n\r\n        var displayName = highlightMatch(item);\r\n        return "<li>" + displayName + "</li>";\r\n    }\r\n    \r\n    function _filenameResultsFormatter(item, query) {\r\n        // For main label, we just want filename: drop most of the string\r\n        function fileNameFilter(includesLastSegment, rangeText) {\r\n            if (includesLastSegment) {\r\n                var rightmostSlash = rangeText.lastIndexOf(\'/\');\r\n                return rangeText.substring(rightmostSlash + 1);  // safe even if rightmostSlash is -1\r\n            } else {\r\n                return "";\r\n            }\r\n        }\r\n        var displayName = highlightMatch(item, null, fileNameFilter);\r\n        var displayPath = highlightMatch(item, "quicksearch-pathmatch");\r\n        \r\n        return "<li>" + displayName + "<br /><span class=\'quick-open-path\'>" + displayPath + "</span></li>";\r\n    }\r\n\r\n    /**\r\n     * Formats the entry for the given item to be displayed in the dropdown.\r\n     * @param {Object} item The item to be displayed.\r\n     * @return {string} The HTML to be displayed.\r\n     */\r\n    QuickNavigateDialog.prototype._resultsFormatterCallback = function (item) {\r\n        var query = this.$searchField.val();\r\n        \r\n        var formatter;\r\n\r\n        if (currentPlugin) {\r\n            // Plugins use their own formatter or the default formatter\r\n            formatter = currentPlugin.resultsFormatter || defaultResultsFormatter;\r\n        } else {\r\n            // No plugin: default file search mode uses a special formatter\r\n            formatter = _filenameResultsFormatter;\r\n        }\r\n        return formatter(item, query);\r\n    };\r\n\r\n    /**\r\n     * Sets the value in the search field, updating the current mode and label based on the\r\n     * given prefix.\r\n     * @param {string} prefix The prefix that determines which mode we\'re in: must be empty (for file search),\r\n     *      "@" for go to definition, or ":" for go to line.\r\n     * @param {string} initialString The query string to search for (without the prefix).\r\n     */\r\n    QuickNavigateDialog.prototype.setSearchFieldValue = function (prefix, initialString) {\r\n        prefix = prefix || "";\r\n        initialString = initialString || "";\r\n        initialString = prefix + initialString;\r\n        \r\n        var $field = this.$searchField;\r\n        $field.val(initialString);\r\n        $field.get(0).setSelectionRange(prefix.length, initialString.length);\r\n        \r\n        // Kick smart-autocomplete to update (it only listens for keyboard events)\r\n        // (due to #1855, this will only pop up results list; it won\'t auto-"focus" the first result)\r\n        $field.trigger("keyIn", [initialString]);\r\n    };\r\n    \r\n    /**\r\n     * Sets the dialog label based on the current plugin (if any) and the current query.\r\n     * @param {Object} plugin The current Quick Open plugin, or none if there is none.\r\n     * @param {string} query The user\'s current query.\r\n     */\r\n    QuickNavigateDialog.prototype._updateDialogLabel = function (plugin, query) {\r\n        var dialogLabel = "";\r\n        if (plugin && plugin.label) {\r\n            dialogLabel = plugin.label;\r\n        } else {\r\n            var prefix = (query.length > 0 ? query.charAt(0) : "");\r\n            \r\n            // Update the dialog label based on the current prefix.\r\n            switch (prefix) {\r\n            case ":":\r\n                dialogLabel = Strings.CMD_GOTO_LINE + "\\u2026";\r\n                break;\r\n            case "@":\r\n                dialogLabel = Strings.CMD_GOTO_DEFINITION + "\\u2026";\r\n                break;\r\n            default:\r\n                dialogLabel = "";\r\n                break;\r\n            }\r\n        }\r\n        $(".find-dialog-label", this.dialog).text(dialogLabel);\r\n    };\r\n    \r\n    /**\r\n     * Close the dialog when the user clicks outside of it. Smart-autocomplete listens for this and automatically closes its popup,\r\n     * but we want to close the whole search "dialog." (And we can\'t just piggyback on the popup closing event, since there are cases\r\n     * where the popup closes that we want the dialog to remain open (e.g. deleting search term via backspace).\r\n     */\r\n    QuickNavigateDialog.prototype._handleDocumentMouseDown = function (e) {\r\n        if (this.modalBar.getRoot().find(e.target).length === 0 && $(".smart_autocomplete_container").find(e.target).length === 0) {\r\n            this.close();\r\n        } else {\r\n            // Allow clicks in the search field to propagate. Clicks in the menu should be \r\n            // blocked to prevent focus from leaving the search field.\r\n            if ($("input#quickOpenSearch").get(0) !== e.target) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Close the dialog when it loses focus.\r\n     */\r\n    QuickNavigateDialog.prototype._handleBlur = function (e) {\r\n        this.close();\r\n    };\r\n\r\n    /**\r\n     * Shows the search dialog and initializes the auto suggestion list with filenames from the current project\r\n     */\r\n    QuickNavigateDialog.prototype.showDialog = function (prefix, initialString) {\r\n        if (this.isOpen) {\r\n            return;\r\n        }\r\n        this.isOpen = true;\r\n\r\n        // Global listener to hide search bar & popup\r\n        $(window.document).on("mousedown", this._handleDocumentMouseDown);\r\n\r\n        // Record current document & cursor pos so we can restore it if search is canceled\r\n        // We record scroll pos *before* modal bar is opened since we\'re going to restore it *after* it\'s closed\r\n        var curDoc = DocumentManager.getCurrentDocument();\r\n        this._origDocPath = curDoc ? curDoc.file.fullPath : null;\r\n        if (curDoc) {\r\n            this._origSelections = EditorManager.getCurrentFullEditor().getSelections();\r\n            this._origScrollPos = EditorManager.getCurrentFullEditor().getScrollPos();\r\n        } else {\r\n            this._origSelections = null;\r\n            this._origScrollPos = null;\r\n        }\r\n\r\n        // Show the search bar ("dialog")\r\n        var dialogHTML = "<div align=\'right\'><input type=\'text\' autocomplete=\'off\' id=\'quickOpenSearch\' placeholder=\'" + Strings.CMD_QUICK_OPEN + "\\u2026\' style=\'width: 30em\'><span class=\'find-dialog-label\'></span></div>";\r\n        this.modalBar = new ModalBar(dialogHTML, false);\r\n        this.$searchField = $("input#quickOpenSearch");\r\n\r\n        // The various listeners registered below fire in this order:\r\n        //   keydown, (async gap), keyup, (async gap), filter, resultsReady, showResults/noResults\r\n        // The later events *always* come after the keydown & keyup (they\'re triggered on a timeout from keyup). But\r\n        // because of the async gaps, a keydown for the *next* key typed might come *before* they run:\r\n        //   keydown, (async gap), keyup, (async gap), keydown #2, (async gap), filter, resultsReady, showResults/noResults\r\n        // The staleness check in _filterCallback() and the forced async wait in _handleKeyUp() are due to this.\r\n        \r\n        this.$searchField.bind({\r\n            resultsReady: this._handleResultsReady,\r\n            showResults: this._handleShowResults,\r\n            itemSelect: this._handleItemSelect,\r\n            itemFocus: this._handleItemFocus,\r\n            keyup: this._handleKeyUp,   // it\'s important we register this BEFORE calling smartAutoComplete(); see handler for details\r\n            blur: this._handleBlur   // can\'t use lostFocus since smart autocomplete fires it immediately in response to the shortcut\'s keyup\r\n        });\r\n        \r\n        this.$searchField.smartAutoComplete({\r\n            source: [],\r\n            maxResults: 20,\r\n            minCharLimit: 0,\r\n            autocompleteFocused: true,\r\n            forceSelect: false,\r\n            typeAhead: false,   // won\'t work right now because smart auto complete \r\n                                // using internal raw results instead of filtered results for matching\r\n            filter: this._filterCallback,\r\n            resultFormatter: this._resultsFormatterCallback\r\n        });\r\n\r\n        this.setSearchFieldValue(prefix, initialString);\r\n\r\n        // Return files that are non-binary, or binary files that have a custom viewer\r\n        function _filter(file) {\r\n            return !LanguageManager.getLanguageForPath(file.fullPath).isBinary() ||\r\n                MainViewFactory.findSuitableFactoryForPath(file.fullPath);\r\n        }\r\n        \r\n        // Start fetching the file list, which will be needed the first time the user enters\r\n        // an un-prefixed query. If file index caches are out of date, this list might take\r\n        // some time to asynchronously build. See searchFileList() for how this is handled.\r\n        fileListPromise = ProjectManager.getAllFiles(_filter, true)\r\n            .done(function (files) {\r\n                fileList = files;\r\n                fileListPromise = null;\r\n                this._filenameMatcher.reset();\r\n            }.bind(this));\r\n    };\r\n\r\n    function getCurrentEditorSelectedText() {\r\n        var currentEditor = EditorManager.getActiveEditor();\r\n        return (currentEditor && currentEditor.getSelectedText()) || "";\r\n    }\r\n\r\n    /**\r\n     * Opens the Quick Open bar prepopulated with the given prefix (to select a mode) and optionally\r\n     * with the given query text too. Updates text field contents if Quick Open already open.\r\n     * @param {?string} prefix\r\n     * @param {?string} initialString\r\n     */\r\n    function beginSearch(prefix, initialString) {\r\n        function createDialog() {\r\n            _curDialog = new QuickNavigateDialog();\r\n            _curDialog.showDialog(prefix, initialString);\r\n        }\r\n\r\n        if (_curDialog) {\r\n            if (_curDialog.isOpen) {\r\n                // Just start a search using the existing dialog.\r\n                _curDialog.setSearchFieldValue(prefix, initialString);\r\n            } else {\r\n                // The dialog is already closing. Wait till it\'s done closing,\r\n                // then open a new dialog. (Calling close() again returns the\r\n                // promise for the deferred that was already kicked off when it\r\n                // started closing.)\r\n                _curDialog.close().done(createDialog);\r\n            }\r\n        } else {\r\n            createDialog();\r\n        }\r\n    }\r\n\r\n    function doFileSearch() {\r\n        beginSearch("", getCurrentEditorSelectedText());\r\n    }\r\n\r\n    function doGotoLine() {\r\n        // TODO: Brackets doesn\'t support disabled menu items right now, when it does goto line and\r\n        // goto definition should be disabled when there is not a current document\r\n        if (DocumentManager.getCurrentDocument()) {\r\n            beginSearch(":", "");\r\n        }\r\n    }\r\n\r\n\r\n    // TODO: should provide a way for QuickOpenJSSymbol to create this function as a plug-in\r\n    function doDefinitionSearch() {\r\n        if (DocumentManager.getCurrentDocument()) {\r\n            beginSearch("@", getCurrentEditorSelectedText());\r\n        }\r\n    }\r\n    \r\n    // Listen for a change of project to invalidate our file list\r\n    $(ProjectManager).on("projectOpen", function () {\r\n        fileList = null;\r\n    });\r\n\r\n    // TODO: allow QuickOpenJS to register it\'s own commands and key bindings\r\n    CommandManager.register(Strings.CMD_QUICK_OPEN,         Commands.NAVIGATE_QUICK_OPEN,       doFileSearch);\r\n    CommandManager.register(Strings.CMD_GOTO_DEFINITION,    Commands.NAVIGATE_GOTO_DEFINITION,  doDefinitionSearch);\r\n    CommandManager.register(Strings.CMD_GOTO_LINE,          Commands.NAVIGATE_GOTO_LINE,        doGotoLine);\r\n\r\n    exports.beginSearch             = beginSearch;\r\n    exports.addQuickOpenPlugin      = addQuickOpenPlugin;\r\n    exports.highlightMatch          = highlightMatch;\r\n    \r\n    // accessing these from this module will ultimately be deprecated\r\n    exports.stringMatch             = StringMatch.stringMatch;\r\n    exports.SearchResult            = StringMatch.SearchResult;\r\n    exports.basicMatchSort          = StringMatch.basicMatchSort;\r\n    exports.multiFieldSort          = StringMatch.multiFieldSort;\r\n});\r\n\n//# sourceURL=/search/QuickOpen.js'),eval('define(\'text!htmlContent/main-view.html\',[],function () { return \'<!-- \\r\\n  Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\\r\\n   \\r\\n  Permission is hereby granted, free of charge, to any person obtaining a\\r\\n  copy of this software and associated documentation files (the "Software"), \\r\\n  to deal in the Software without restriction, including without limitation \\r\\n  the rights to use, copy, modify, merge, publish, distribute, sublicense, \\r\\n  and/or sell copies of the Software, and to permit persons to whom the \\r\\n  Software is furnished to do so, subject to the following conditions:\\r\\n   \\r\\n  The above copyright notice and this permission notice shall be included in\\r\\n  all copies or substantial portions of the Software.\\r\\n   \\r\\n  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \\r\\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \\r\\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \\r\\n  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \\r\\n  DEALINGS IN THE SOFTWARE.\\r\\n-->\\r\\n\\r\\n\\r\\n<!--\\r\\n    HTML template for the body tag of index.html. It is rendered dynamically in\\r\\n    brackets.js with Mustache and localized with the i18n RequireJS plugin.\\r\\n\\r\\n    LOCALIZATION NOTE:\\r\\n    All display text for this file must use templating so the text can be localized.\\r\\n    \\r\\n    English text goes in src/nls/root/strings.js. All other translations go in the strings.js file for\\r\\n    the specific local in the nls folder. If a translation is missing for a specific key English\\r\\n    is used as a fallback\\r\\n\\r\\n    Strings should be referenced using the double brackets syntax.\\r\\n    Example: {{keyname}}. Note, all strings are HTML escaped unless the form \\r\\n    {{&keyname}} is used.\\r\\n\\r\\n-->\\r\\n\\r\\n    <!-- Main UI: horizontal set of sidebar, main content vertical stack, and vertical toolbar -->\\r\\n    <div class="main-view">\\r\\n        <div id="sidebar" class="sidebar panel quiet-scrollbars horz-resizable right-resizer collapsible" data-minsize="0" data-forceleft=".content">\\r\\n            <div id="working-set-list-container">\\r\\n                \\r\\n            </div>\\r\\n            <div id="project-files-header">\\r\\n                <span id="project-title" class="title"></span>\\r\\n            </div>\\r\\n            <div id="project-files-container">\\r\\n                <!-- This will contain a dynamically generated <ul> hierarchy at runtime -->\\r\\n            </div>\\r\\n        </div>\\r\\n        \\r\\n        <!--\\r\\n            Vertical stack of titlebar (in-browser), editor, bottom panels, status bar\\r\\n                (status bar is injected later - see StatusBar.init()).\\r\\n            Note: all children must be in a vertical stack with heights explicitly set in a fixed\\r\\n                unit such as px (not percent/em/auto). If you change the height later, you must\\r\\n                call WorkspaceManager.recomputeLayout() each time. Otherwise the layout will\\r\\n                not get set correctly. Use WorkspaceManager to have this managed for you automatically.\\r\\n         -->\\r\\n        <div class="content">\\r\\n            <!-- Horizontal titlebar containing menus & filename when inBrowser -->\\r\\n            <div id="titlebar" class="toolbar no-focus">\\r\\n                <!-- Menu bar -->\\r\\n                <ul class="nav" data-dropdown="dropdown">\\r\\n                </ul>\\r\\n                \\r\\n                <!-- Filename label -->\\r\\n                <div class="title-wrapper">\\r\\n                    <span class="title"></span>&nbsp;<span class=\\\'dirty-dot\\\' style="visibility:hidden;">•</span>\\r\\n                </div>\\r\\n            </div>\\r\\n            \\r\\n            <div id="editor-holder">\\r\\n                <!-- View Panes are programatically created here -->\\r\\n            </div>\\r\\n            \\r\\n            <!-- Bottom panels and status bar are programmatically created here -->\\r\\n            \\r\\n        </div>\\r\\n\\r\\n        <!-- Vertical toolbar docked to right -->\\r\\n        <div id="main-toolbar" class="toolbar no-focus">\\r\\n            <!-- Top-aligned buttons -->\\r\\n            <div class="buttons">\\r\\n                <a id="toolbar-go-live" href="#"></a> <!-- tooltip for this is set in JS -->\\r\\n                <a id="toolbar-extension-manager" title="{{EXTENSION_MANAGER_TITLE}}" href="#"></a>\\r\\n                <a id="update-notification" title="{{UPDATE_NOTIFICATION_TOOLTIP}}" href="#" style="display: none"></a>\\r\\n            </div>\\r\\n            <div class="bottom-buttons"></div>\\r\\n        </div>\\r\\n        \\r\\n        <!-- Hack to ensure that the code editor\\\'s web font is loaded early. -->\\r\\n        <!-- For more info, see note in brackets.less for class .dummy-text, or issue 76 -->\\r\\n        <div class="dummy-text">x</div>\\r\\n    </div>\\r\\n\\r\\n    <!-- Modal Windows -->\\r\\n    <div id="context-menu-bar">\\r\\n        <ul data-dropdown="dropdown"></ul>\\r\\n    </div>\\r\\n    <div id="codehint-menu-bar">\\r\\n        <ul data-dropdown="dropdown"></ul>\\r\\n    </div>\\r\\n    <div id="hidden-editors"></div>\';});\n\n//# sourceURL=/text!htmlContent/main-view.html'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, document, window, brackets  */\r\n\r\n/**\r\n * The view that controls the showing and hiding of the sidebar.\r\n * \r\n * Although the sidebar view doesn\'t dispatch any events directly, it is a\r\n * resizable element (../utils/Resizer.js), which means it can dispatch Resizer\r\n * events.  For example, if you want to listen for the sidebar showing\r\n * or hiding itself, set up listeners for the corresponding Resizer events,\r\n * panelCollapsed and panelExpanded:\r\n * \r\n *      $("#sidebar").on("panelCollapsed", ...);\r\n *      $("#sidebar").on("panelExpanded", ...);\r\n */\r\ndefine(\'project/SidebarView\',[\'require\',\'exports\',\'module\',\'utils/AppInit\',\'project/ProjectManager\',\'project/WorkingSetView\',\'view/MainViewManager\',\'command/CommandManager\',\'command/Commands\',\'strings\',\'editor/EditorManager\',\'utils/Global\',\'utils/Resizer\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var AppInit             = require("utils/AppInit"),\r\n        ProjectManager      = require("project/ProjectManager"),\r\n        WorkingSetView    = require("project/WorkingSetView"),\r\n        MainViewManager     = require("view/MainViewManager"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        Commands            = require("command/Commands"),\r\n        Strings             = require("strings"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        Global              = require("utils/Global"),\r\n        Resizer             = require("utils/Resizer"),\r\n        _                   = require("thirdparty/lodash");\r\n\r\n    // These vars are initialized by the htmlReady handler\r\n    // below since they refer to DOM elements\r\n    var $sidebar,\r\n        $sidebarMenuText,\r\n        $openFilesContainer,\r\n        $projectTitle,\r\n        $projectFilesContainer,\r\n        $workingSetViewsContainer;\r\n    \r\n    /**\r\n     * @private\r\n     * Update project title when the project root changes\r\n     */\r\n    function _updateProjectTitle() {\r\n        var displayName = ProjectManager.getProjectRoot().name;\r\n        var fullPath = ProjectManager.getProjectRoot().fullPath;\r\n        \r\n        if (displayName === "" && fullPath === "/") {\r\n            displayName = "/";\r\n        }\r\n        \r\n        $projectTitle.html(_.escape(displayName));\r\n        $projectTitle.attr("title", fullPath);\r\n        \r\n        // Trigger a scroll on the project files container to \r\n        // reposition the scroller shadows and avoid issue #2255\r\n        $projectFilesContainer.trigger("scroll");\r\n    }\r\n    \r\n    /**\r\n     * Toggle sidebar visibility.\r\n     */\r\n    function toggle() {\r\n        Resizer.toggle($sidebar);\r\n    }\r\n\r\n    /**\r\n     * Show the sidebar.\r\n     */\r\n    function show() {\r\n        Resizer.show($sidebar);\r\n    }\r\n    \r\n    /**\r\n     * Hide the sidebar.\r\n     */\r\n    function hide() {\r\n        Resizer.hide($sidebar);\r\n    }\r\n    \r\n    /**\r\n     * Returns the visibility state of the sidebar.\r\n     * @return {boolean} true if element is visible, false if it is not visible\r\n     */\r\n    function isVisible() {\r\n        return Resizer.isVisible($sidebar);\r\n    }\r\n    \r\n    // Initialize items dependent on HTML DOM\r\n    AppInit.htmlReady(function () {\r\n        $sidebar                = $("#sidebar");\r\n        $sidebarMenuText        = $("#menu-view-hide-sidebar span");\r\n        $openFilesContainer     = $("#open-files-container");\r\n        $projectTitle           = $("#project-title");\r\n        $projectFilesContainer  = $("#project-files-container");\r\n        $workingSetViewsContainer  = $("#working-set-list-container");\r\n    \r\n        function _resizeSidebarSelection() {\r\n            var $element;\r\n            $sidebar.find(".sidebar-selection").each(function (index, element) {\r\n                $element = $(element);\r\n                $element.width($element.parent()[0].scrollWidth);\r\n            });\r\n        }\r\n\r\n        // init\r\n        $sidebar.on("panelResizeStart", function (evt, width) {\r\n            $sidebar.find(".sidebar-selection-extension").css("display", "none");\r\n            $sidebar.find(".scroller-shadow").css("display", "none");\r\n        });\r\n        \r\n        $sidebar.on("panelResizeUpdate", function (evt, width) {\r\n            $sidebar.find(".sidebar-selection").width(width);\r\n        });\r\n        \r\n        $sidebar.on("panelResizeEnd", function (evt, width) {\r\n            _resizeSidebarSelection();\r\n            $sidebar.find(".sidebar-selection-extension").css("display", "block").css("left", width);\r\n            $sidebar.find(".scroller-shadow").css("display", "block");\r\n            $projectFilesContainer.triggerHandler("scroll");\r\n            WorkingSetView.syncSelectionIndicator();\r\n        });\r\n		\r\n        $sidebar.on("panelCollapsed", function (evt, width) {\r\n            CommandManager.get(Commands.VIEW_HIDE_SIDEBAR).setName(Strings.CMD_SHOW_SIDEBAR);\r\n        });\r\n        \r\n        $sidebar.on("panelExpanded", function (evt, width) {\r\n            WorkingSetView.refresh();\r\n            _resizeSidebarSelection();\r\n            $sidebar.find(".scroller-shadow").css("display", "block");\r\n            $sidebar.find(".sidebar-selection-extension").css("left", width);\r\n            $projectFilesContainer.triggerHandler("scroll");\r\n            WorkingSetView.syncSelectionIndicator();\r\n            CommandManager.get(Commands.VIEW_HIDE_SIDEBAR).setName(Strings.CMD_HIDE_SIDEBAR);\r\n        });\r\n        \r\n        // AppInit.htmlReady in utils/Resizer executes before, so it\'s possible that the sidebar\r\n        // is collapsed before we add the event. Check here initially\r\n        if (!$sidebar.is(":visible")) {\r\n            $sidebar.trigger("panelCollapsed");\r\n        }\r\n        \r\n        // wire up an event handler to monitor when panes are created\r\n        $(MainViewManager).on("paneCreate", function (evt, paneId) {\r\n            WorkingSetView.createWorkingSetViewForPane($workingSetViewsContainer, paneId);\r\n        });\r\n        \r\n        // create WorkingSetViews for each pane already created\r\n        _.forEach(MainViewManager.getPaneIdList(), function (paneId) {\r\n            WorkingSetView.createWorkingSetViewForPane($workingSetViewsContainer, paneId);\r\n        });\r\n    });\r\n    \r\n    $(ProjectManager).on("projectOpen", _updateProjectTitle);\r\n    CommandManager.register(Strings.CMD_HIDE_SIDEBAR, Commands.VIEW_HIDE_SIDEBAR, toggle);\r\n    \r\n    \r\n    // Define public API\r\n    exports.toggle      = toggle;\r\n    exports.show        = show;\r\n    exports.hide        = hide;\r\n    exports.isVisible   = isVisible;\r\n});\n//# sourceURL=/project/SidebarView.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4,\r\nmaxerr: 50, browser: true */\r\n/*global $, define, brackets, WebSocket, ArrayBuffer, Uint32Array */\r\n\r\ndefine(\'utils/NodeConnection\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    /**\r\n     * Connection attempts to make before failing\r\n     * @type {number}\r\n     */\r\n    var CONNECTION_ATTEMPTS = 10;\r\n\r\n    /**\r\n     * Milliseconds to wait before a particular connection attempt is considered failed.\r\n     * NOTE: It\'s okay for the connection timeout to be long because the\r\n     * expected behavior of WebSockets is to send a "close" event as soon\r\n     * as they realize they can\'t connect. So, we should rarely hit the\r\n     * connection timeout even if we try to connect to a port that isn\'t open.\r\n     * @type {number}\r\n     */\r\n    var CONNECTION_TIMEOUT  = 10000; // 10 seconds\r\n\r\n    /**\r\n     * Milliseconds to wait before retrying connecting\r\n     * @type {number}\r\n     */\r\n    var RETRY_DELAY         = 500;   // 1/2 second\r\n\r\n    /**\r\n     * Maximum value of the command ID counter\r\n     * @type  {number}\r\n     */\r\n    var MAX_COUNTER_VALUE = 4294967295; // 2^32 - 1\r\n    \r\n    /**\r\n     * @private\r\n     * Helper function to auto-reject a deferred after a given amount of time.\r\n     * If the deferred is resolved/rejected manually, then the timeout is\r\n     * automatically cleared.\r\n     */\r\n    function setDeferredTimeout(deferred, delay) {\r\n        var timer = setTimeout(function () {\r\n            deferred.reject("timeout");\r\n        }, delay);\r\n        deferred.always(function () { clearTimeout(timer); });\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Helper function to attempt a single connection to the node server\r\n     */\r\n    function attemptSingleConnect() {\r\n        var deferred = $.Deferred();\r\n        var port = null;\r\n        var ws = null;\r\n        setDeferredTimeout(deferred, CONNECTION_TIMEOUT);\r\n        \r\n        brackets.app.getNodeState(function (err, nodePort) {\r\n            if (!err && nodePort && deferred.state() !== "rejected") {\r\n                port = nodePort;\r\n                ws = new WebSocket("ws://localhost:" + port);\r\n                \r\n                // Expect ArrayBuffer objects from Node when receiving binary\r\n                // data instead of DOM Blobs, which are the default.\r\n                ws.binaryType = "arraybuffer";\r\n                \r\n                // If the server port isn\'t open, we get a close event\r\n                // at some point in the future (and will not get an onopen \r\n                // event)\r\n                ws.onclose = function () {\r\n                    deferred.reject("WebSocket closed");\r\n                };\r\n\r\n                ws.onopen = function () {\r\n                    // If we successfully opened, remove the old onclose \r\n                    // handler (which was present to detect failure to \r\n                    // connect at all).\r\n                    ws.onclose = null;\r\n                    deferred.resolveWith(null, [ws, port]);\r\n                };\r\n            } else {\r\n                deferred.reject("brackets.app.getNodeState error: " + err);\r\n            }\r\n        });\r\n        \r\n        return deferred.promise();\r\n    }\r\n    \r\n    /**\r\n     * Provides an interface for interacting with the node server.\r\n     * @constructor\r\n     */\r\n    function NodeConnection() {\r\n        this.domains = {};\r\n        this._registeredModules = [];\r\n        this._pendingInterfaceRefreshDeferreds = [];\r\n        this._pendingCommandDeferreds = [];\r\n    }\r\n    \r\n    /**\r\n     * @type {Object}\r\n     * Exposes the domains registered with the server. This object will\r\n     * have a property for each registered domain. Each of those properties\r\n     * will be an object containing properties for all the commands in that\r\n     * domain. So, myConnection.base.enableDebugger would point to the function\r\n     * to call to enable the debugger.\r\n     *\r\n     * This object is automatically replaced every time the API changes (based\r\n     * on the base:newDomains event from the server). Therefore, code that\r\n     * uses this object should not keep their own pointer to the domain property.\r\n     */\r\n    NodeConnection.prototype.domains = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {Array.<string>}\r\n     * List of module pathnames that should be re-registered if there is\r\n     * a disconnection/connection (i.e. if the server died).\r\n     */\r\n    NodeConnection.prototype._registeredModules = null;\r\n\r\n    /**\r\n     * @private\r\n     * @type {WebSocket}\r\n     * The connection to the server\r\n     */\r\n    NodeConnection.prototype._ws = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {?number}\r\n     * The port the WebSocket is currently connected to\r\n     */\r\n    NodeConnection.prototype._port = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {number}\r\n     * Unique ID for commands\r\n     */\r\n    NodeConnection.prototype._commandCount = 1;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     * Whether to attempt reconnection if connection fails\r\n     */\r\n    NodeConnection.prototype._autoReconnect = false;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {Array.<jQuery.Deferred>}\r\n     * List of deferred objects that should be resolved pending\r\n     * a successful refresh of the API\r\n     */\r\n    NodeConnection.prototype._pendingInterfaceRefreshDeferreds = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {Array.<jQuery.Deferred>}\r\n     * Array (indexed on command ID) of deferred objects that should be\r\n     * resolved/rejected with the response of commands.\r\n     */\r\n    NodeConnection.prototype._pendingCommandDeferreds = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @return {number} The next command ID to use. Always representable as an\r\n     * unsigned 32-bit integer.\r\n     */\r\n    NodeConnection.prototype._getNextCommandID = function () {\r\n        var nextID;\r\n        \r\n        if (this._commandCount > MAX_COUNTER_VALUE) {\r\n            nextID = this._commandCount = 0;\r\n        } else {\r\n            nextID = this._commandCount++;\r\n        }\r\n        \r\n        return nextID;\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Helper function to do cleanup work when a connection fails\r\n     */\r\n    NodeConnection.prototype._cleanup = function () {\r\n        // clear out the domains, since we may get different ones\r\n        // on the next connection\r\n        this.domains = {};\r\n        \r\n        // shut down the old connection if there is one\r\n        if (this._ws && this._ws.readyState !== WebSocket.CLOSED) {\r\n            try {\r\n                this._ws.close();\r\n            } catch (e) { }\r\n        }\r\n        var failedDeferreds = this._pendingInterfaceRefreshDeferreds\r\n            .concat(this._pendingCommandDeferreds);\r\n        failedDeferreds.forEach(function (d) {\r\n            d.reject("cleanup");\r\n        });\r\n        this._pendingInterfaceRefreshDeferreds = [];\r\n        this._pendingCommandDeferreds = [];\r\n        \r\n        this._ws = null;\r\n        this._port = null;\r\n    };\r\n    \r\n    /**\r\n     * Connect to the node server. After connecting, the NodeConnection\r\n     * object will trigger a "close" event when the underlying socket\r\n     * is closed. If the connection is set to autoReconnect, then the\r\n     * event will also include a jQuery promise for the connection.\r\n     * \r\n     * @param {boolean} autoReconnect Whether to automatically try to\r\n     *    reconnect to the server if the connection succeeds and then\r\n     *    later disconnects. Note if this connection fails initially, the\r\n     *    autoReconnect flag is set to false. Future calls to connect()\r\n     *    can reset it to true\r\n     * @return {jQuery.Promise} Promise that resolves/rejects when the\r\n     *    connection succeeds/fails\r\n     */\r\n    NodeConnection.prototype.connect = function (autoReconnect) {\r\n        var self = this;\r\n        self._autoReconnect = autoReconnect;\r\n        var deferred = $.Deferred();\r\n        var attemptCount = 0;\r\n        var attemptTimestamp = null;\r\n        \r\n        // Called after a successful connection to do final setup steps\r\n        function registerHandlersAndDomains(ws, port) {\r\n            // Called if we succeed at the final setup\r\n            function success() {\r\n                self._ws.onclose = function () {\r\n                    if (self._autoReconnect) {\r\n                        var $promise = self.connect(true);\r\n                        $(self).triggerHandler("close", [$promise]);\r\n                    } else {\r\n                        self._cleanup();\r\n                        $(self).triggerHandler("close");\r\n                    }\r\n                };\r\n                deferred.resolve();\r\n            }\r\n            // Called if we fail at the final setup\r\n            function fail(err) {\r\n                self._cleanup();\r\n                deferred.reject(err);\r\n            }\r\n            \r\n            self._ws = ws;\r\n            self._port = port;\r\n            self._ws.onmessage = self._receive.bind(self);\r\n            \r\n            // refresh the current domains, then re-register any\r\n            // "autoregister" modules\r\n            self._refreshInterface().then(\r\n                function () {\r\n                    if (self._registeredModules.length > 0) {\r\n                        self.loadDomains(self._registeredModules, false).then(\r\n                            success,\r\n                            fail\r\n                        );\r\n                    } else {\r\n                        success();\r\n                    }\r\n                },\r\n                fail\r\n            );\r\n        }\r\n        \r\n        // Repeatedly tries to connect until we succeed or until we\'ve\r\n        // failed CONNECTION_ATTEMPT times. After each attempt, waits\r\n        // at least RETRY_DELAY before trying again.\r\n        function doConnect() {\r\n            attemptCount++;\r\n            attemptTimestamp = new Date();\r\n            attemptSingleConnect().then(\r\n                registerHandlersAndDomains, // succeded\r\n                function () { // failed this attempt, possibly try again\r\n                    if (attemptCount < CONNECTION_ATTEMPTS) { //try again\r\n                        // Calculate how long we should wait before trying again\r\n                        var now = new Date();\r\n                        var delay = Math.max(\r\n                            RETRY_DELAY - (now - attemptTimestamp),\r\n                            1\r\n                        );\r\n                        setTimeout(doConnect, delay);\r\n                    } else { // too many attempts, give up\r\n                        deferred.reject("Max connection attempts reached");\r\n                    }\r\n                }\r\n            );\r\n        }\r\n        \r\n        // Start the connection process\r\n        self._cleanup();\r\n        doConnect();\r\n\r\n        return deferred.promise();\r\n    };\r\n\r\n    /**\r\n     * Determines whether the NodeConnection is currently connected\r\n     * @return {boolean} Whether the NodeConnection is connected.\r\n     */\r\n    NodeConnection.prototype.connected = function () {\r\n        return !!(this._ws && this._ws.readyState === WebSocket.OPEN);\r\n    };\r\n\r\n    /**\r\n     * Explicitly disconnects from the server. Note that even if\r\n     * autoReconnect was set to true at connection time, the connection\r\n     * will not reconnect after this call. Reconnection can be manually done\r\n     * by calling connect() again.\r\n     */\r\n    NodeConnection.prototype.disconnect = function () {\r\n        this._autoReconnect = false;\r\n        this._cleanup();\r\n    };\r\n\r\n    /**\r\n     * Load domains into the server by path\r\n     * @param {Array.<string>} List of absolute paths to load\r\n     * @param {boolean} autoReload Whether to auto-reload the domains if the server\r\n     *    fails and restarts. Note that the reload is initiated by the\r\n     *    client, so it will only happen after the client reconnects.\r\n     * @return {jQuery.Promise} Promise that resolves after the load has\r\n     *    succeeded and the new API is availale at NodeConnection.domains,\r\n     *    or that rejects on failure. \r\n     */\r\n    NodeConnection.prototype.loadDomains = function (paths, autoReload) {\r\n        var deferred = $.Deferred();\r\n        setDeferredTimeout(deferred, CONNECTION_TIMEOUT);\r\n        var pathArray = paths;\r\n        if (!Array.isArray(paths)) {\r\n            pathArray = [paths];\r\n        }\r\n        \r\n        if (autoReload) {\r\n            Array.prototype.push.apply(this._registeredModules, pathArray);\r\n        }\r\n\r\n        if (this.domains.base && this.domains.base.loadDomainModulesFromPaths) {\r\n            this.domains.base.loadDomainModulesFromPaths(pathArray).then(\r\n                function (success) { // command call succeeded\r\n                    if (!success) {\r\n                        // response from commmand call was "false" so we know\r\n                        // the actual load failed.\r\n                        deferred.reject("loadDomainModulesFromPaths failed");\r\n                    }\r\n                    // if the load succeeded, we wait for the API refresh to\r\n                    // resolve the deferred.\r\n                },\r\n                function (reason) { // command call failed\r\n                    deferred.reject("Unable to load one of the modules: " + pathArray + (reason ? ", reason: " + reason : ""));\r\n                }\r\n            );\r\n\r\n            this._pendingInterfaceRefreshDeferreds.push(deferred);\r\n        } else {\r\n            deferred.reject("this.domains.base is undefined");\r\n        }\r\n        \r\n        return deferred.promise();\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Sends a message over the WebSocket. Automatically JSON.stringifys\r\n     * the message if necessary.\r\n     * @param {Object|string} m Object to send. Must be JSON.stringify-able.\r\n     */\r\n    NodeConnection.prototype._send = function (m) {\r\n        if (this.connected()) {\r\n\r\n            // Convert the message to a string\r\n            var messageString = null;\r\n            if (typeof m === "string") {\r\n                messageString = m;\r\n            } else {\r\n                try {\r\n                    messageString = JSON.stringify(m);\r\n                } catch (stringifyError) {\r\n                    console.error("[NodeConnection] Unable to stringify message in order to send: " + stringifyError.message);\r\n                }\r\n            }\r\n            \r\n            // If we succeded in making a string, try to send it\r\n            if (messageString) {\r\n                try {\r\n                    this._ws.send(messageString);\r\n                } catch (sendError) {\r\n                    console.error("[NodeConnection] Error sending message: " + sendError.message);\r\n                }\r\n            }\r\n        } else {\r\n            console.error("[NodeConnection] Not connected to node, unable to send.");\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Handler for receiving events on the WebSocket. Parses the message\r\n     * and dispatches it appropriately.\r\n     * @param {WebSocket.Message} message Message object from WebSocket\r\n     */\r\n    NodeConnection.prototype._receive = function (message) {\r\n        var responseDeferred = null;\r\n        var data = message.data;\r\n        var m;\r\n        \r\n        if (message.data instanceof ArrayBuffer) {\r\n            // The first four bytes encode the command ID as an unsigned 32-bit integer\r\n            if (data.byteLength < 4) {\r\n                console.error("[NodeConnection] received malformed binary message");\r\n                return;\r\n            }\r\n            \r\n            var header = data.slice(0, 4),\r\n                body = data.slice(4),\r\n                headerView = new Uint32Array(header),\r\n                id = headerView[0];\r\n            \r\n            // Unpack the binary message into a commandResponse\r\n            m = {\r\n                type: "commandResponse",\r\n                message: {\r\n                    id: id,\r\n                    response: body\r\n                }\r\n            };\r\n        } else {\r\n            try {\r\n                m = JSON.parse(data);\r\n            } catch (e) {\r\n                console.error("[NodeConnection] received malformed message", message, e.message);\r\n                return;\r\n            }\r\n        }\r\n        \r\n        switch (m.type) {\r\n        case "event":\r\n            var $this = $(this);\r\n\r\n            if (m.message.domain === "base" && m.message.event === "newDomains") {\r\n                this._refreshInterface();\r\n            }\r\n            \r\n            // Event type for backwards compatibility for original design: "domain.event"\r\n            $this.triggerHandler(m.message.domain + "." + m.message.event,\r\n                                   m.message.parameters);\r\n\r\n            // Event type "domain:event"\r\n            $this.triggerHandler(m.message.domain + ":" + m.message.event,\r\n                                   m.message.parameters);\r\n            break;\r\n        case "commandResponse":\r\n            responseDeferred = this._pendingCommandDeferreds[m.message.id];\r\n            if (responseDeferred) {\r\n                responseDeferred.resolveWith(this, [m.message.response]);\r\n                delete this._pendingCommandDeferreds[m.message.id];\r\n            }\r\n            break;\r\n        case "commandError":\r\n            responseDeferred = this._pendingCommandDeferreds[m.message.id];\r\n            if (responseDeferred) {\r\n                responseDeferred.rejectWith(\r\n                    this,\r\n                    [m.message.message, m.message.stack]\r\n                );\r\n                delete this._pendingCommandDeferreds[m.message.id];\r\n            }\r\n            break;\r\n        case "error":\r\n            console.error("[NodeConnection] received error: " +\r\n                            m.message.message);\r\n            break;\r\n        default:\r\n            console.error("[NodeConnection] unknown event type: " + m.type);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Helper function for refreshing the interface in the "domain" property.\r\n     * Automatically called when the connection receives a base:newDomains\r\n     * event from the server, and also called at connection time.\r\n     */\r\n    NodeConnection.prototype._refreshInterface = function () {\r\n        var deferred = $.Deferred();\r\n        var self = this;\r\n        \r\n        var pendingDeferreds = this._pendingInterfaceRefreshDeferreds;\r\n        this._pendingInterfaceRefreshDeferreds = [];\r\n        deferred.then(\r\n            function () {\r\n                pendingDeferreds.forEach(function (d) { d.resolve(); });\r\n            },\r\n            function (err) {\r\n                pendingDeferreds.forEach(function (d) { d.reject(err); });\r\n            }\r\n        );\r\n        \r\n        function refreshInterfaceCallback(spec) {\r\n            function makeCommandFunction(domainName, commandSpec) {\r\n                return function () {\r\n                    var deferred = $.Deferred();\r\n                    var parameters = Array.prototype.slice.call(arguments, 0);\r\n                    var id = self._getNextCommandID();\r\n                    self._pendingCommandDeferreds[id] = deferred;\r\n                    self._send({id: id,\r\n                               domain: domainName,\r\n                               command: commandSpec.name,\r\n                               parameters: parameters\r\n                               });\r\n                    return deferred;\r\n                };\r\n            }\r\n            \r\n            // TODO: Don\'t replace the domain object every time. Instead, merge.\r\n            self.domains = {};\r\n            self.domainEvents = {};\r\n            spec.forEach(function (domainSpec) {\r\n                self.domains[domainSpec.domain] = {};\r\n                domainSpec.commands.forEach(function (commandSpec) {\r\n                    self.domains[domainSpec.domain][commandSpec.name] =\r\n                        makeCommandFunction(domainSpec.domain, commandSpec);\r\n                });\r\n                self.domainEvents[domainSpec.domain] = {};\r\n                domainSpec.events.forEach(function (eventSpec) {\r\n                    var parameters = eventSpec.parameters;\r\n                    self.domainEvents[domainSpec.domain][eventSpec.name] = parameters;\r\n                });\r\n            });\r\n            deferred.resolve();\r\n        }\r\n        \r\n        if (this.connected()) {\r\n            $.getJSON("http://localhost:" + this._port + "/api")\r\n                .done(refreshInterfaceCallback)\r\n                .fail(function (err) { deferred.reject(err); });\r\n        } else {\r\n            deferred.reject("Attempted to call _refreshInterface when not connected.");\r\n        }\r\n        \r\n        return deferred.promise();\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Get the default timeout value\r\n     * @return {number} Timeout value in milliseconds\r\n     */\r\n    NodeConnection._getConnectionTimeout = function () {\r\n        return CONNECTION_TIMEOUT;\r\n    };\r\n    \r\n    module.exports = NodeConnection;\r\n    \r\n});\r\n\n//# sourceURL=/utils/NodeConnection.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, browser: true, nomen: true, regexp: true,\r\nindent: 4, maxerr: 50 */\r\n/*global define, $, brackets, PathUtils */\r\n\r\n/**\r\n * Functions for working with extension packages\r\n */\r\ndefine(\'extensibility/Package\',[\'require\',\'exports\',\'module\',\'utils/AppInit\',\'filesystem/FileSystem\',\'file/FileUtils\',\'utils/StringUtils\',\'strings\',\'utils/ExtensionLoader\',\'utils/NodeConnection\',\'preferences/PreferencesManager\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var AppInit              = require("utils/AppInit"),\r\n        FileSystem           = require("filesystem/FileSystem"),\r\n        FileUtils            = require("file/FileUtils"),\r\n        StringUtils          = require("utils/StringUtils"),\r\n        Strings              = require("strings"),\r\n        ExtensionLoader      = require("utils/ExtensionLoader"),\r\n        NodeConnection       = require("utils/NodeConnection"),\r\n        PreferencesManager   = require("preferences/PreferencesManager");\r\n    \r\n    PreferencesManager.definePreference("proxy", "string", undefined);\r\n    \r\n    var Errors = {\r\n        ERROR_LOADING: "ERROR_LOADING",\r\n        MALFORMED_URL: "MALFORMED_URL",\r\n        UNSUPPORTED_PROTOCOL: "UNSUPPORTED_PROTOCOL"\r\n    };\r\n    \r\n    var InstallationStatuses = {\r\n        FAILED: "FAILED",\r\n        INSTALLED: "INSTALLED",\r\n        ALREADY_INSTALLED: "ALREADY_INSTALLED",\r\n        SAME_VERSION: "SAME_VERSION",\r\n        OLDER_VERSION: "OLDER_VERSION",\r\n        NEEDS_UPDATE: "NEEDS_UPDATE",\r\n        DISABLED: "DISABLED"\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * @type {NodeConnection}\r\n     * Connects to ExtensionManagerDomain\r\n     */\r\n    var _nodeConnection;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {jQuery.Deferred.<NodeConnection>}\r\n     * A deferred which is resolved with a NodeConnection or rejected if\r\n     * we are unable to connect to Node.\r\n     */\r\n    var _nodeConnectionDeferred = $.Deferred();\r\n    \r\n    /**\r\n     * @type {number} Used to generate unique download ids\r\n     */\r\n    var _uniqueId = 0;\r\n    \r\n    function _extensionManagerCall(callback) {\r\n        if (_nodeConnection.domains.extensionManager) {\r\n            return callback(_nodeConnection.domains.extensionManager);\r\n        } else {\r\n            return new $.Deferred().reject("extensionManager domain is undefined").promise();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * TODO: can this go away now that we never call it directly?\r\n     * \r\n     * Validates the package at the given path. The actual validation is\r\n     * handled by the Node server.\r\n     * \r\n     * The promise is resolved with an object:\r\n     * { errors: Array.<{string}>, metadata: { name:string, version:string, ... } }\r\n     * metadata is pulled straight from package.json and will be undefined\r\n     * if there are errors or null if the extension did not include package.json.\r\n     *\r\n     * @param {string} Absolute path to the package zip file\r\n     * @param {{requirePackageJSON: ?boolean}} validation options\r\n     * @return {$.Promise} A promise that is resolved with information about the package\r\n     */\r\n    function validate(path, options) {\r\n        return _extensionManagerCall(function (extensionManager) {\r\n            var d = new $.Deferred();\r\n            \r\n            extensionManager.validate(path, options)\r\n                .done(function (result) {\r\n                    d.resolve({\r\n                        errors: result.errors,\r\n                        metadata: result.metadata\r\n                    });\r\n                })\r\n                .fail(function (error) {\r\n                    d.reject(error);\r\n                });\r\n    \r\n            return d.promise();\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Validates and installs the package at the given path. Validation and\r\n     * installation is handled by the Node process.\r\n     *\r\n     * The extension will be installed into the user\'s extensions directory.\r\n     * If the user already has the extension installed, it will instead go\r\n     * into their disabled extensions directory.\r\n     * \r\n     * The promise is resolved with an object:\r\n     * { errors: Array.<{string}>, metadata: { name:string, version:string, ... },\r\n     * disabledReason:string, installedTo:string, commonPrefix:string }\r\n     * metadata is pulled straight from package.json and is likely to be undefined\r\n     * if there are errors. It is null if there was no package.json.\r\n     * \r\n     * disabledReason is either null or the reason the extension was installed disabled.\r\n     *\r\n     * @param {string} path Absolute path to the package zip file\r\n     * @param {?string} nameHint Hint for the extension folder\'s name (used in favor of\r\n     *          path\'s filename if present, and if no package metadata present).\r\n     * @param {?boolean} _doUpdate private argument used to signal an update\r\n     * @return {$.Promise} A promise that is resolved with information about the package\r\n     *          (which may include errors, in which case the extension was disabled), or\r\n     *          rejected with an error object.\r\n     */\r\n    function install(path, nameHint, _doUpdate) {\r\n        return _extensionManagerCall(function (extensionManager) {\r\n            var d                       = new $.Deferred(),\r\n                destinationDirectory    = ExtensionLoader.getUserExtensionPath(),\r\n                disabledDirectory       = destinationDirectory.replace(/\\/user$/, "/disabled"),\r\n                systemDirectory         = FileUtils.getNativeBracketsDirectoryPath() + "/extensions/default/";\r\n            \r\n            var operation = _doUpdate ? "update" : "install";\r\n            extensionManager[operation](path, destinationDirectory, {\r\n                disabledDirectory: disabledDirectory,\r\n                systemExtensionDirectory: systemDirectory,\r\n                apiVersion: brackets.metadata.apiVersion,\r\n                nameHint: nameHint\r\n            })\r\n                .done(function (result) {\r\n                    result.keepFile = false;\r\n                    \r\n                    if (result.installationStatus !== InstallationStatuses.INSTALLED || _doUpdate) {\r\n                        d.resolve(result);\r\n                    } else {\r\n                        // This was a new extension and everything looked fine.\r\n                        // We load it into Brackets right away.\r\n                        ExtensionLoader.loadExtension(result.name, {\r\n                            // On Windows, it looks like Node converts Unix-y paths to backslashy paths.\r\n                            // We need to convert them back.\r\n                            baseUrl: FileUtils.convertWindowsPathToUnixPath(result.installedTo)\r\n                        }, "main").then(function () {\r\n                            d.resolve(result);\r\n                        }, function () {\r\n                            d.reject(Errors.ERROR_LOADING);\r\n                        });\r\n                    }\r\n                })\r\n                .fail(function (error) {\r\n                    d.reject(error);\r\n                });\r\n            \r\n            return d.promise();\r\n        });\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n     * Special case handling to make the common case of downloading from GitHub easier; modifies \'urlInfo\' as\r\n     * needed. Converts a bare GitHub repo URL to the corresponding master ZIP URL; or if given a direct\r\n     * master ZIP URL already, sets a nicer download filename (both cases use the repo name).\r\n     * \r\n     * @param {{url:string, parsed:Array.<string>, filenameHint:string}} urlInfo\r\n     */\r\n    function githubURLFilter(urlInfo) {\r\n        if (urlInfo.parsed.hostname === "github.com" || urlInfo.parsed.hostname === "www.github.com") {\r\n            // Is it a URL to the root of a repo? (/user/repo)\r\n            var match = /^\\/[^\\/?]+\\/([^\\/?]+)(\\/?)$/.exec(urlInfo.parsed.pathname);\r\n            if (match) {\r\n                if (!match[2]) {\r\n                    urlInfo.url += "/";\r\n                }\r\n                urlInfo.url += "archive/master.zip";\r\n                urlInfo.filenameHint = match[1] + ".zip";\r\n                \r\n            } else {\r\n                // Is it a URL directly to the repo\'s \'master.zip\'? (/user/repo/archive/master.zip)\r\n                match = /^\\/[^\\/?]+\\/([^\\/?]+)\\/archive\\/master.zip$/.exec(urlInfo.parsed.pathname);\r\n                if (match) {\r\n                    urlInfo.filenameHint = match[1] + ".zip";\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Downloads from the given URL to a temporary location. On success, resolves with the path of the\r\n     * downloaded file (typically in a temp folder) and a hint for the real filename. On failure, rejects\r\n     * with an error object.\r\n     * \r\n     * @param {string} url URL of the file to be downloaded\r\n     * @param {number} downloadId Unique number to identify this request\r\n     * @return {$.Promise}\r\n     */\r\n    function download(url, downloadId) {\r\n        return _extensionManagerCall(function (extensionManager) {\r\n            var d = new $.Deferred();\r\n            \r\n            // Validate URL\r\n            // TODO: PathUtils fails to parse URLs that are missing the protocol part (e.g. starts immediately with "www...")\r\n            var parsed = PathUtils.parseUrl(url);\r\n            if (!parsed.hostname) {  // means PathUtils failed to parse at all\r\n                d.reject(Errors.MALFORMED_URL);\r\n                return d.promise();\r\n            }\r\n            if (parsed.protocol !== "http:" && parsed.protocol !== "https:") {\r\n                d.reject(Errors.UNSUPPORTED_PROTOCOL);\r\n                return d.promise();\r\n            }\r\n            \r\n            var urlInfo = { url: url, parsed: parsed, filenameHint: parsed.filename };\r\n            githubURLFilter(urlInfo);\r\n            \r\n            // Decide download destination\r\n            var filename = urlInfo.filenameHint;\r\n            filename = filename.replace(/[^a-zA-Z0-9_\\- \\(\\)\\.]/g, "_"); // make sure it\'s a valid filename\r\n            if (!filename) {  // in case of URL ending in "/"\r\n                filename = "extension.zip";\r\n            }\r\n            \r\n            // Download the bits (using Node since brackets-shell doesn\'t support binary file IO)\r\n            var r = extensionManager.downloadFile(downloadId, urlInfo.url, PreferencesManager.get("proxy"));\r\n            r.done(function (result) {\r\n                d.resolve({ localPath: FileUtils.convertWindowsPathToUnixPath(result), filenameHint: urlInfo.filenameHint });\r\n            }).fail(function (err) {\r\n                d.reject(err);\r\n            });\r\n            \r\n            return d.promise();\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Attempts to synchronously cancel the given pending download. This may not be possible, e.g.\r\n     * if the download has already finished.\r\n     * \r\n     * @param {number} downloadId Identifier previously passed to download()\r\n     */\r\n    function cancelDownload(downloadId) {\r\n        return _extensionManagerCall(function (extensionManager) {\r\n            return extensionManager.abortDownload(downloadId);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * On success, resolves with an extension metadata object; at that point, the extension has already\r\n     * started running in Brackets. On failure (including validation errors), rejects with an error object.\r\n     * \r\n     * An error object consists of either a string error code OR an array where the first entry is the error\r\n     * code and the remaining entries are further info. The error code string is one of either\r\n     * ExtensionsDomain.Errors or Package.Errors. Use formatError() to convert an error object to a friendly,\r\n     * localized error message.\r\n     * \r\n     * @param {string} path Absolute path to the package zip file\r\n     * @param {?string} filenameHint Hint for the extension folder\'s name (used in favor of\r\n     *          path\'s filename if present, and if no package metadata present).\r\n     * @return {$.Promise} A promise that is rejected if there are errors during\r\n     *          install or the extension is disabled.\r\n     */\r\n    function installFromPath(path, filenameHint) {\r\n        var d = new $.Deferred();\r\n\r\n        install(path, filenameHint)\r\n            .done(function (result) {\r\n                result.keepFile = true;\r\n                \r\n                var installationStatus = result.installationStatus;\r\n                if (installationStatus === InstallationStatuses.ALREADY_INSTALLED ||\r\n                        installationStatus === InstallationStatuses.NEEDS_UPDATE ||\r\n                        installationStatus === InstallationStatuses.SAME_VERSION ||\r\n                        installationStatus === InstallationStatuses.OLDER_VERSION) {\r\n                    d.resolve(result);\r\n                } else {\r\n                    if (result.errors && result.errors.length > 0) {\r\n                        // Validation errors - for now, only return the first one\r\n                        d.reject(result.errors[0]);\r\n                    } else if (result.disabledReason) {\r\n                        // Extension valid but left disabled (wrong API version, extension name collision, etc.)\r\n                        d.reject(result.disabledReason);\r\n                    } else {\r\n                        // Success! Extension is now running in Brackets\r\n                        d.resolve(result);\r\n                    }\r\n                }\r\n            })\r\n            .fail(function (err) {\r\n                d.reject(err);\r\n            });\r\n\r\n        return d.promise();\r\n    }\r\n    \r\n    /**\r\n     * On success, resolves with an extension metadata object; at that point, the extension has already\r\n     * started running in Brackets. On failure (including validation errors), rejects with an error object.\r\n     * \r\n     * An error object consists of either a string error code OR an array where the first entry is the error\r\n     * code and the remaining entries are further info. The error code string is one of either\r\n     * ExtensionsDomain.Errors or Package.Errors. Use formatError() to convert an error object to a friendly,\r\n     * localized error message.\r\n     * \r\n     * The returned cancel() function will *attempt* to cancel installation, but it is not guaranteed to\r\n     * succeed. If cancel() succeeds, the Promise is rejected with a CANCELED error code. If we\'re unable\r\n     * to cancel, the Promise is resolved or rejected normally, as if cancel() had never been called.\r\n     * \r\n     * @return {{promise: $.Promise, cancel: function():boolean}}\r\n     */\r\n    function installFromURL(url) {\r\n        var STATE_DOWNLOADING = 1,\r\n            STATE_INSTALLING = 2,\r\n            STATE_SUCCEEDED = 3,\r\n            STATE_FAILED = 4;\r\n        \r\n        var d = new $.Deferred();\r\n        var state = STATE_DOWNLOADING;\r\n        \r\n        var downloadId = (_uniqueId++);\r\n        download(url, downloadId)\r\n            .done(function (downloadResult) {\r\n                state = STATE_INSTALLING;\r\n                \r\n                installFromPath(downloadResult.localPath, downloadResult.filenameHint)\r\n                    .done(function (result) {\r\n                        var installationStatus = result.installationStatus;\r\n\r\n                        state = STATE_SUCCEEDED;\r\n                        result.localPath = downloadResult.localPath;\r\n                        result.keepFile = false;\r\n\r\n                        if (installationStatus === InstallationStatuses.INSTALLED) {\r\n                            // Delete temp file\r\n                            FileSystem.getFileForPath(downloadResult.localPath).unlink();\r\n                        }\r\n\r\n                        d.resolve(result);\r\n                    })\r\n                    .fail(function (err) {\r\n                        // File IO errors, internal error in install()/validate(), or extension startup crashed\r\n                        state = STATE_FAILED;\r\n                        FileSystem.getFileForPath(downloadResult.localPath).unlink();\r\n                        d.reject(err);  // TODO: needs to be err.message ?\r\n                    });\r\n            })\r\n            .fail(function (err) {\r\n                // Download error (the Node-side download code cleans up any partial ZIP file)\r\n                state = STATE_FAILED;\r\n                d.reject(err);\r\n            });\r\n        \r\n        return {\r\n            promise: d.promise(),\r\n            cancel: function () {\r\n                if (state === STATE_DOWNLOADING) {\r\n                    // This will trigger download()\'s fail() handler with CANCELED as the err code\r\n                    cancelDownload(downloadId);\r\n                }\r\n                // Else it\'s too late to cancel; we\'ll continue on through the done() chain and emit\r\n                // a success result (calling done() handlers) if all else goes well.\r\n            }\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Converts an error object as returned by install(), installFromPath() or\r\n     * installFromURL() into a flattened, localized string.\r\n     *\r\n     * @param {string|Array.<string>} error\r\n     * @return {string}\r\n     */\r\n    function formatError(error) {\r\n        function localize(key) {\r\n            if (Strings[key]) {\r\n                return Strings[key];\r\n            }\r\n            console.log("Unknown installation error", key);\r\n            return Strings.UNKNOWN_ERROR;\r\n        }\r\n        \r\n        if (Array.isArray(error)) {\r\n            error[0] = localize(error[0]);\r\n            return StringUtils.format.apply(window, error);\r\n        } else {\r\n            return localize(error);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Removes the extension at the given path.\r\n     *\r\n     * @param {string} path The absolute path to the extension to remove.\r\n     * @return {$.Promise} A promise that\'s resolved when the extension is removed, or\r\n     *     rejected if there was an error.\r\n     */\r\n    function remove(path) {\r\n        return _extensionManagerCall(function (extensionManager) {\r\n            return extensionManager.remove(path);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Install an extension update located at path.\r\n     * This assumes that the installation was previously attempted\r\n     * and an installationStatus of "ALREADY_INSTALLED", "NEEDS_UPDATE", "SAME_VERSION",\r\n     * or "OLDER_VERSION" was the result.\r\n     *\r\n     * This workflow ensures that there should not generally be validation errors\r\n     * because the first pass at installation the extension looked at the metadata\r\n     * and installed packages.\r\n     *\r\n     * @param {string} path to package file\r\n     * @param {?string} nameHint Hint for the extension folder\'s name (used in favor of\r\n     *          path\'s filename if present, and if no package metadata present).\r\n     * @return {$.Promise} A promise that is resolved when the extension is successfully\r\n     *      installed or rejected if there is a problem.\r\n     */\r\n    function installUpdate(path, nameHint) {\r\n        var d = new $.Deferred();\r\n        install(path, nameHint, true)\r\n            .done(function (result) {\r\n                if (result.installationStatus !== InstallationStatuses.INSTALLED) {\r\n                    d.reject(result.errors);\r\n                } else {\r\n                    d.resolve(result);\r\n                }\r\n            })\r\n            .fail(function (error) {\r\n                d.reject(error);\r\n            });\r\n        return d.promise();\r\n    }\r\n        \r\n    /**\r\n     * Allows access to the deferred that manages the node connection. This\r\n     * is *only* for unit tests. Messing with this not in testing will\r\n     * potentially break everything.\r\n     *\r\n     * @private\r\n     * @return {jQuery.Deferred} The deferred that manages the node connection\r\n     */\r\n    function _getNodeConnectionDeferred() {\r\n        return _nodeConnectionDeferred;\r\n    }\r\n    \r\n    // Initializes node connection\r\n    // TODO: duplicates code from StaticServer\r\n    // TODO: can this be done lazily?\r\n    AppInit.appReady(function () {\r\n        _nodeConnection = new NodeConnection();\r\n        _nodeConnection.connect(true).then(function () {\r\n            var domainPath = FileUtils.getNativeBracketsDirectoryPath() + "/" + FileUtils.getNativeModuleDirectoryPath(module) + "/node/ExtensionManagerDomain";\r\n            \r\n            _nodeConnection.loadDomains(domainPath, true)\r\n                .then(\r\n                    function () {\r\n                        _nodeConnectionDeferred.resolve();\r\n                    },\r\n                    function () { // Failed to connect\r\n                        console.error("[Extensions] Failed to connect to node", arguments);\r\n                        _nodeConnectionDeferred.reject();\r\n                    }\r\n                );\r\n        });\r\n    });\r\n\r\n    // For unit tests only\r\n    exports._getNodeConnectionDeferred = _getNodeConnectionDeferred;\r\n\r\n    exports.installFromURL = installFromURL;\r\n    exports.installFromPath = installFromPath;\r\n    exports.validate = validate;\r\n    exports.install = install;\r\n    exports.remove = remove;\r\n    exports.installUpdate = installUpdate;\r\n    exports.formatError = formatError;\r\n    exports.InstallationStatuses = InstallationStatuses;\r\n});\r\n\n//# sourceURL=/extensibility/Package.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, window, $ */\r\n\r\n/**\r\n * The ViewCommandHandlers object dispatches the following event(s):\r\n *    - fontSizeChange -- Triggered when the font size is changed via the\r\n *      Increase Font Size, Decrease Font Size, or Restore Font Size commands.\r\n *      The 2nd arg to the listener is the amount of the change. The 3rd arg\r\n *      is a string containing the new font size after applying the change.\r\n */\r\ndefine(\'view/ViewCommandHandlers\',[\'require\',\'exports\',\'module\',\'command/Commands\',\'command/CommandManager\',\'command/KeyBindingManager\',\'strings\',\'utils/StringUtils\',\'project/ProjectManager\',\'editor/EditorManager\',\'preferences/PreferencesManager\',\'document/DocumentManager\',\'view/ThemeSettings\',\'view/MainViewManager\',\'utils/AppInit\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var Commands            = require("command/Commands"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        KeyBindingManager   = require("command/KeyBindingManager"),\r\n        Strings             = require("strings"),\r\n        StringUtils         = require("utils/StringUtils"),\r\n        ProjectManager      = require("project/ProjectManager"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        PreferencesManager  = require("preferences/PreferencesManager"),\r\n        DocumentManager     = require("document/DocumentManager"),\r\n        ThemeSettings       = require("view/ThemeSettings"),\r\n        MainViewManager     = require("view/MainViewManager"),\r\n        AppInit             = require("utils/AppInit");\r\n\r\n    var prefs = PreferencesManager.getExtensionPrefs("fonts");\r\n\r\n    /**\r\n     * @const\r\n     * @type {string}\r\n     */\r\n    var DYNAMIC_FONT_STYLE_ID = "codemirror-dynamic-fonts";\r\n\r\n    /**\r\n     * @const\r\n     * @type {string}\r\n     */\r\n    var DYNAMIC_FONT_FAMILY_ID = "codemirror-dynamic-font-family";\r\n\r\n    /**\r\n     * @const\r\n     * @private\r\n     * The smallest font size in pixels\r\n     * @type {number}\r\n     */\r\n    var MIN_FONT_SIZE = 1;\r\n\r\n    /**\r\n     * @const\r\n     * @private\r\n     * The largest font size in pixels\r\n     * @type {number}\r\n     */\r\n    var MAX_FONT_SIZE = 72;\r\n\r\n    /**\r\n     * @const\r\n     * @private\r\n     * The default font size used only to convert the old fontSizeAdjustment view state to the new fontSize\r\n     * @type {number}\r\n     */\r\n    var DEFAULT_FONT_SIZE = 12;\r\n\r\n    /**\r\n     * @const\r\n     * @private\r\n     * The default font family\r\n     * @type {string}\r\n     */\r\n    var DEFAULT_FONT_FAMILY = "\'SourceCodePro-Medium\', ＭＳ ゴシック, \'MS Gothic\', monospace";\r\n\r\n    /**\r\n     * @private\r\n     * Removes style property from the DOM\r\n     * @param {string} propertyID is the id of the property to be removed\r\n     */\r\n    function _removeDynamicProperty(propertyID) {\r\n        $("#" + propertyID).remove();\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Add the style property to the DOM\r\n     * @param {string} propertyID Is the property ID to be added\r\n     * @param {string} name Is the name of the style property\r\n     * @param {string} value Is the value of the style\r\n     * @param {boolean} important Is a flag to make the style property !important\r\n     */\r\n    function _addDynamicProperty(propertyID, name, value, important, cssRule) {\r\n        cssRule = cssRule || ".CodeMirror";\r\n        var $style   = $("<style type=\'text/css\'></style>").attr("id", propertyID);\r\n        var styleStr = StringUtils.format("{0}: {1}{2}", name, value, important ? " !important" : "");\r\n        $style.html(cssRule + "{ " + styleStr + " }");\r\n\r\n        // Let\'s make sure we remove the already existing item from the DOM.\r\n        _removeDynamicProperty(propertyID);\r\n        $("head").append($style);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Removes the styles used to update the font size\r\n     */\r\n    function _removeDynamicFontSize() {\r\n        _removeDynamicProperty(DYNAMIC_FONT_STYLE_ID);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Add the styles used to update the font size\r\n     * @param {string} fontSize  A string with the font size and the size unit\r\n     */\r\n    function _addDynamicFontSize(fontSize) {\r\n        _addDynamicProperty(DYNAMIC_FONT_STYLE_ID, "font-size", fontSize, true);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Removes the styles used to update the font family\r\n     */\r\n    function _removeDynamicFontFamily() {\r\n        _removeDynamicProperty(DYNAMIC_FONT_FAMILY_ID);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Add the styles used to update the font family\r\n     * @param {string} fontFamily  A string with the font family\r\n     */\r\n    function _addDynamicFontFamily(fontFamily) {\r\n        _addDynamicProperty(DYNAMIC_FONT_FAMILY_ID, "font-family", fontFamily);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Sets the font size and restores the scroll position as best as possible.\r\n     * @param {string=} fontSize  A string with the font size and the size unit\r\n     */\r\n    function _updateScroll(fontSize) {\r\n        var editor      = EditorManager.getCurrentFullEditor(),\r\n            oldWidth    = editor._codeMirror.defaultCharWidth(),\r\n            oldFontSize = prefs.get("fontSize"),\r\n            newFontSize = fontSize,\r\n            delta       = 0,\r\n            adjustment  = 0,\r\n            scrollPos   = editor.getScrollPos(),\r\n            line        = editor._codeMirror.lineAtHeight(scrollPos.y, "local");\r\n\r\n        delta = /em$/.test(oldFontSize) ? 10 : 1;\r\n        adjustment = parseInt((parseFloat(newFontSize) - parseFloat(oldFontSize)) * delta, 10);\r\n\r\n        // Only adjust the scroll position if there was any adjustments to the font size.\r\n        // Otherwise there will be unintended scrolling.\r\n        //\r\n        if (adjustment) {\r\n            editor.refreshAll();\r\n        }\r\n\r\n        // Calculate the new scroll based on the old font sizes and scroll position\r\n        var newWidth   = editor._codeMirror.defaultCharWidth(),\r\n            deltaX     = scrollPos.x / oldWidth,\r\n            scrollPosX = scrollPos.x + Math.round(deltaX * (newWidth  - oldWidth)),\r\n            scrollPosY = editor._codeMirror.heightAtLine(line, "local");\r\n\r\n        editor.setScrollPos(scrollPosX, scrollPosY);\r\n    }\r\n\r\n    /**\r\n     * Font size setter to set the font size for the document editor\r\n     * @param {string} fontSize The font size with size unit as \'px\' or \'em\'\r\n     */\r\n    function setFontSize(fontSize) {\r\n        var oldValue = prefs.get("fontSize");\r\n\r\n        if (oldValue === fontSize) {\r\n            return;\r\n        }\r\n\r\n        _removeDynamicFontSize();\r\n        if (fontSize) {\r\n            _addDynamicFontSize(fontSize);\r\n        }\r\n\r\n        if (EditorManager.getCurrentFullEditor()) {\r\n            _updateScroll(fontSize);\r\n        }\r\n\r\n        $(exports).triggerHandler("fontSizeChange", [fontSize, oldValue]);\r\n        prefs.set("fontSize", fontSize);\r\n    }\r\n\r\n    /**\r\n     * Font size getter to get the current font size for the document editor\r\n     * @return {string} Font size with size unit as \'px\' or \'em\'\r\n     */\r\n    function getFontSize() {\r\n        return prefs.get("fontSize");\r\n    }\r\n\r\n\r\n    /**\r\n     * Font family setter to set the font family for the document editor\r\n     * @param {string} fontFamily The font family to be set.  It can be a string with multiple comma separated fonts\r\n     */\r\n    function setFontFamily(fontFamily) {\r\n        var editor = EditorManager.getCurrentFullEditor(),\r\n            oldValue = prefs.get("fontFamily");\r\n\r\n        if (oldValue === fontFamily) {\r\n            return;\r\n        }\r\n\r\n        _removeDynamicFontFamily();\r\n        if (fontFamily) {\r\n            _addDynamicFontFamily(fontFamily);\r\n        }\r\n\r\n        $(exports).triggerHandler("fontFamilyChange", [fontFamily, oldValue]);\r\n        prefs.set("fontFamily", fontFamily);\r\n\r\n        if (editor) {\r\n            editor.refreshAll();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Font family getter to get the currently configured font family for the document editor\r\n     * @return {string} The font family for the document editor\r\n     */\r\n    function getFontFamily() {\r\n        return prefs.get("fontFamily");\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Increases or decreases the editor\'s font size.\r\n     * @param {number} adjustment  Negative number to make the font smaller; positive number to make it bigger\r\n     * @return {boolean} true if adjustment occurred, false if it did not occur\r\n     */\r\n    function _adjustFontSize(adjustment) {\r\n        var fsStyle   = prefs.get("fontSize"),\r\n            validFont = /^[\\d\\.]+(px|em)$/;\r\n\r\n        // Make sure that the font size is expressed in terms we can handle (px or em). If not, simply bail.\r\n        if (fsStyle.search(validFont) === -1) {\r\n            return false;\r\n        }\r\n\r\n        // Guaranteed to work by the validation above.\r\n        var fsUnits = fsStyle.substring(fsStyle.length - 2, fsStyle.length),\r\n            delta   = fsUnits === "px" ? 1 : 0.1,\r\n            fsOld   = parseFloat(fsStyle.substring(0, fsStyle.length - 2)),\r\n            fsNew   = fsOld + (delta * adjustment),\r\n            fsStr   = fsNew + fsUnits;\r\n\r\n        // Don\'t let the font size get too small or too large. The minimum font size is 1px or 0.1em\r\n        // and the maximum font size is 72px or 7.2em depending on the unit used\r\n        if (fsNew < MIN_FONT_SIZE * delta || fsNew > MAX_FONT_SIZE * delta) {\r\n            return false;\r\n        }\r\n\r\n        setFontSize(fsStr);\r\n        return true;\r\n    }\r\n\r\n    /** Increases the font size by 1 */\r\n    function _handleIncreaseFontSize() {\r\n        _adjustFontSize(1);\r\n    }\r\n\r\n    /** Decreases the font size by 1 */\r\n    function _handleDecreaseFontSize() {\r\n        _adjustFontSize(-1);\r\n    }\r\n\r\n    /** Restores the font size to the original size */\r\n    function _handleRestoreFontSize() {\r\n        setFontSize(DEFAULT_FONT_SIZE + "px");\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Updates the user interface appropriately based on whether or not a document is\r\n     * currently open in the editor.\r\n     */\r\n    function _updateUI() {\r\n        if (DocumentManager.getCurrentDocument() !== null) {\r\n            if (!CommandManager.get(Commands.VIEW_INCREASE_FONT_SIZE).getEnabled()) {\r\n                // If one is disabled then they all are disabled, so enable them all\r\n                CommandManager.get(Commands.VIEW_INCREASE_FONT_SIZE).setEnabled(true);\r\n                CommandManager.get(Commands.VIEW_DECREASE_FONT_SIZE).setEnabled(true);\r\n                CommandManager.get(Commands.VIEW_RESTORE_FONT_SIZE).setEnabled(true);\r\n            }\r\n        } else {\r\n            // No current document so disable all of the Font Size commands\r\n            CommandManager.get(Commands.VIEW_INCREASE_FONT_SIZE).setEnabled(false);\r\n            CommandManager.get(Commands.VIEW_DECREASE_FONT_SIZE).setEnabled(false);\r\n            CommandManager.get(Commands.VIEW_RESTORE_FONT_SIZE).setEnabled(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializes the different settings that need to loaded\r\n     */\r\n    function init() {\r\n        _addDynamicFontFamily(prefs.get("fontFamily"));\r\n        _addDynamicFontSize(prefs.get("fontSize"));\r\n        _updateUI();\r\n    }\r\n\r\n    /**\r\n     * Restores the font size using the saved style and migrates the old fontSizeAdjustment\r\n     * view state to the new fontSize, when required\r\n     */\r\n    function restoreFontSize() {\r\n        var fsStyle      = prefs.get("fontSize"),\r\n            fsAdjustment = PreferencesManager.getViewState("fontSizeAdjustment");\r\n\r\n        if (fsAdjustment) {\r\n            // Always remove the old view state even if we also have the new view state.\r\n            PreferencesManager.setViewState("fontSizeAdjustment");\r\n\r\n            if (!fsStyle) {\r\n                // Migrate the old view state to the new one.\r\n                fsStyle = (DEFAULT_FONT_SIZE + fsAdjustment) + "px";\r\n                prefs.set("fontSize", fsStyle);\r\n            }\r\n        }\r\n\r\n        if (fsStyle) {\r\n            _removeDynamicFontSize();\r\n            _addDynamicFontSize(fsStyle);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Restores the font size and font family back to factory settings.\r\n     */\r\n    function restoreFonts() {\r\n        setFontFamily(DEFAULT_FONT_FAMILY);\r\n        setFontSize(DEFAULT_FONT_SIZE + "px");\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Calculates the first and last visible lines of the focused editor\r\n     * @param {number} textHeight\r\n     * @param {number} scrollTop\r\n     * @param {number} editorHeight\r\n     * @return {{first: number, last: number}}\r\n     */\r\n    function _getLinesInView(textHeight, scrollTop, editorHeight) {\r\n        var scrolledTop    = scrollTop / textHeight,\r\n            scrolledBottom = (scrollTop + editorHeight) / textHeight;\r\n\r\n        // Adjust the last line to round inward to show a whole lines.\r\n        var firstLine      = Math.ceil(scrolledTop),\r\n            lastLine       = Math.floor(scrolledBottom) - 1;\r\n\r\n        return { first: firstLine, last: lastLine };\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Scroll the viewport one line up or down.\r\n     * @param {number} direction -1 to scroll one line up; 1 to scroll one line down.\r\n     */\r\n    function _scrollLine(direction) {\r\n        var editor        = EditorManager.getCurrentFullEditor(),\r\n            textHeight    = editor.getTextHeight(),\r\n            cursorPos     = editor.getCursorPos(),\r\n            hasSelecction = editor.hasSelection(),\r\n            inlineEditors = editor.getInlineWidgets(),\r\n            scrollInfo    = editor._codeMirror.getScrollInfo(),\r\n            paddingTop    = editor._getLineSpaceElement().offsetTop,\r\n            editorHeight  = scrollInfo.clientHeight,\r\n            scrollTop     = scrollInfo.top - paddingTop,\r\n            removedScroll = paddingTop;\r\n\r\n        // Go through all the editors and reduce the scroll top and editor height to properly calculate the lines in view\r\n        var line, coords;\r\n        inlineEditors.forEach(function (inlineEditor) {\r\n            line   = editor._getInlineWidgetLineNumber(inlineEditor);\r\n            coords = editor._codeMirror.charCoords({line: line, ch: 0}, "local");\r\n\r\n            if (coords.top < scrollInfo.top) {\r\n                scrollTop     -= inlineEditor.info.height;\r\n                removedScroll += inlineEditor.info.height;\r\n\r\n            } else if (coords.top + inlineEditor.info.height < scrollInfo.top + editorHeight) {\r\n                editorHeight -= inlineEditor.info.height;\r\n            }\r\n        });\r\n\r\n        // Calculate the lines in view\r\n        var linesInView = _getLinesInView(textHeight, scrollTop, editorHeight);\r\n\r\n        // If there is no selection move the cursor so that is always visible.\r\n        if (!hasSelecction) {\r\n            // Move the cursor to the first visible line.\r\n            if (cursorPos.line < linesInView.first) {\r\n                editor.setCursorPos({line: linesInView.first + direction, ch: cursorPos.ch});\r\n\r\n            // Move the cursor to the last visible line.\r\n            } else if (cursorPos.line > linesInView.last) {\r\n                editor.setCursorPos({line: linesInView.last + direction, ch: cursorPos.ch});\r\n\r\n            // Move the cursor up or down using moveV to keep the goal column intact, since setCursorPos deletes it.\r\n            } else if ((direction > 0 && cursorPos.line === linesInView.first) ||\r\n                    (direction < 0 && cursorPos.line === linesInView.last)) {\r\n                editor._codeMirror.moveV(direction, "line");\r\n            }\r\n        }\r\n\r\n        // Scroll and make it snap to lines\r\n        var lines = linesInView.first + direction;\r\n        editor.setScrollPos(scrollInfo.left, (textHeight * lines) + removedScroll);\r\n    }\r\n\r\n    /** Scrolls one line up */\r\n    function _handleScrollLineUp() {\r\n        _scrollLine(-1);\r\n    }\r\n\r\n    /** Scrolls one line down */\r\n    function _handleScrollLineDown() {\r\n        _scrollLine(1);\r\n    }\r\n\r\n    /** Open theme settings dialog */\r\n    function _handleThemeSettings() {\r\n        ThemeSettings.showDialog();\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Convert the old "fontSizeAdjustment" preference to the new view state.\r\n     *\r\n     * @param {string} key  The key of the preference to be examined for migration\r\n     *      of old preferences. Not used since we only have one in this module.\r\n     * @param {string} value  The value of "fontSizeAdjustment" preference\r\n     * @return {Object} JSON object for the new view state equivalent to\r\n     *      the old "fontSizeAdjustment" preference.\r\n     */\r\n    function _convertToNewViewState(key, value) {\r\n        return { "fontSizeStyle": (DEFAULT_FONT_SIZE + value) + "px" };\r\n    }\r\n\r\n    // Register command handlers\r\n    CommandManager.register(Strings.CMD_INCREASE_FONT_SIZE, Commands.VIEW_INCREASE_FONT_SIZE,  _handleIncreaseFontSize);\r\n    CommandManager.register(Strings.CMD_DECREASE_FONT_SIZE, Commands.VIEW_DECREASE_FONT_SIZE,  _handleDecreaseFontSize);\r\n    CommandManager.register(Strings.CMD_RESTORE_FONT_SIZE,  Commands.VIEW_RESTORE_FONT_SIZE,   _handleRestoreFontSize);\r\n    CommandManager.register(Strings.CMD_SCROLL_LINE_UP,     Commands.VIEW_SCROLL_LINE_UP,      _handleScrollLineUp);\r\n    CommandManager.register(Strings.CMD_SCROLL_LINE_DOWN,   Commands.VIEW_SCROLL_LINE_DOWN,    _handleScrollLineDown);\r\n    CommandManager.register(Strings.CMD_THEMES,             Commands.CMD_THEMES_OPEN_SETTINGS, _handleThemeSettings);\r\n\r\n    PreferencesManager.convertPreferences(module, {"fontSizeAdjustment": "user"}, true, _convertToNewViewState);\r\n\r\n    prefs.definePreference("fontSize",   "string", DEFAULT_FONT_SIZE + "px");\r\n    prefs.definePreference("fontFamily", "string", DEFAULT_FONT_FAMILY);\r\n\r\n    // Update UI when opening or closing a document\r\n    $(MainViewManager).on("currentFileChange", _updateUI);\r\n\r\n    // Update UI when Brackets finishes loading\r\n    AppInit.appReady(init);\r\n\r\n    exports.restoreFontSize = restoreFontSize;\r\n    exports.restoreFonts    = restoreFonts;\r\n    exports.getFontSize     = getFontSize;\r\n    exports.setFontSize     = setFontSize;\r\n    exports.getFontFamily   = getFontFamily;\r\n    exports.setFontFamily   = setFontFamily;\r\n});\r\n\n//# sourceURL=/view/ViewCommandHandlers.js'),eval('define(\'text!htmlContent/themes-settings.html\',[],function () { return \'<div class="theme-settings modal">\\r\\n    <div class="modal-header">\\r\\n        <h1 class="dialog-title">{{Strings.THEMES_SETTINGS}}</h1>\\r\\n    </div>\\r\\n    <div class="modal-body">\\r\\n        <form class="form-horizontal">\\r\\n            <div class="control-group">\\r\\n                <label class="control-label">{{Strings.CURRENT_THEME}}:</label>\\r\\n                <div class="controls">\\r\\n                    <select>\\r\\n                        {{#themes}}\\r\\n                        <option style="text-align:left;" value="{{name}}" data-target="theme">{{displayName}}</option>\\r\\n                        {{/themes}}\\r\\n                    </select>\\r\\n                </div>\\r\\n            </div>\\r\\n\\r\\n            <div class="control-group">\\r\\n                <label class="control-label">{{Strings.USE_THEME_SCROLLBARS}}:</label>\\r\\n                <div class="controls">\\r\\n                    {{#settings.themeScrollbars}}\\r\\n                        <input type="checkbox" data-target="themeScrollbars" checked>\\r\\n                    {{/settings.themeScrollbars}}\\r\\n                    {{^settings.themeScrollbars}}\\r\\n                        <input type="checkbox" data-target="themeScrollbars">\\r\\n                    {{/settings.themeScrollbars}}\\r\\n                </div>\\r\\n            </div>\\r\\n\\r\\n            <div class="control-group">\\r\\n                <label class="control-label">{{Strings.FONT_SIZE}}:</label>\\r\\n                <div class="controls">\\r\\n                    <input type="text" data-target="fontSize" value="{{settings.fontSize}}">\\r\\n                </div>\\r\\n            </div>\\r\\n\\r\\n            <div class="control-group">\\r\\n                <label class="control-label">{{Strings.FONT_FAMILY}}:</label>\\r\\n                <div class="controls">\\r\\n                    <input type="text" data-target="fontFamily" value="{{settings.fontFamily}}">\\r\\n                </div>\\r\\n            </div>\\r\\n        </form>\\r\\n    </div>\\r\\n    <div class="modal-footer">\\r\\n        <button class="dialog-button btn" data-button-id="cancel">{{Strings.CANCEL}}</button>\\r\\n        <button class="dialog-button btn primary" data-button-id="save">{{Strings.DONE}}</button>\\r\\n    </div>\\r\\n</div>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/themes-settings.html'),eval('/**\r\n * Brackets Themes Copyright (c) 2014 Miguel Castillo.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global $, define, require, Mustache */\r\n\r\ndefine(\'view/ThemeSettings\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'widgets/Dialogs\',\'strings\',\'view/ViewCommandHandlers\',\'text!htmlContent/themes-settings.html\',\'preferences/PreferencesManager\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var _                   = require("thirdparty/lodash"),\r\n        Dialogs             = require("widgets/Dialogs"),\r\n        Strings             = require("strings"),\r\n        ViewCommandHandlers = require("view/ViewCommandHandlers"),\r\n        settingsTemplate    = require("text!htmlContent/themes-settings.html"),\r\n        PreferencesManager  = require("preferences/PreferencesManager"),\r\n        prefs               = PreferencesManager.getExtensionPrefs("themes");\r\n\r\n    /**\r\n     * @type {Object}\r\n     * Currently loaded themes that are available to choose from.\r\n     */\r\n    var loadedThemes = {};\r\n\r\n    /**\r\n     * Object with all default values that can be configure via the settings UI\r\n     */\r\n    var defaults = {\r\n        "themeScrollbars": true,\r\n        "theme": "light-theme"\r\n    };\r\n\r\n\r\n    /**\r\n     * Cached html settings jQuery object for easier processing when opening the settings dialog\r\n     */\r\n    var $settings = $(settingsTemplate).addClass("themeSettings");\r\n\r\n    /**\r\n     * @private\r\n     * Gets all the configurable settings that need to be loaded in the settings dialog\r\n     *\r\n     * @return {Object} a collection with all the settings\r\n     */\r\n    function getValues() {\r\n        var result = {};\r\n\r\n        Object.keys(defaults).forEach(function (key) {\r\n            result[key] = prefs.get(key);\r\n        });\r\n\r\n        result.fontFamily = ViewCommandHandlers.getFontFamily();\r\n        result.fontSize   = ViewCommandHandlers.getFontSize();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Opens the settings dialog\r\n     */\r\n    function showDialog() {\r\n        var currentSettings = getValues();\r\n        var newSettings     = {};\r\n        var themes          = _.map(loadedThemes, function (theme) { return theme; });\r\n        var template        = $("<div>").append($settings).html();\r\n        var $template       = $(Mustache.render(template, {"settings": currentSettings, "themes": themes, "Strings": Strings}));\r\n\r\n        // Select the correct theme.\r\n        var $currentThemeOption = $template\r\n            .find("[value=\'" + currentSettings.theme + "\']");\r\n        \r\n        if ($currentThemeOption.length === 0) {\r\n            $currentThemeOption = $template.find("[value=\'" + defaults.theme + "\']");\r\n        }\r\n        $currentThemeOption.attr("selected", "selected");\r\n\r\n        $template\r\n            .find("[data-toggle=tab].default")\r\n            .tab("show");\r\n\r\n        $template\r\n            .on("change", "[data-target]:checkbox", function () {\r\n                var $target = $(this);\r\n                var attr = $target.attr("data-target");\r\n                newSettings[attr] = $target.is(":checked");\r\n            })\r\n            .on("input", "[data-target]:text", function () {\r\n                var $target = $(this);\r\n                var attr = $target.attr("data-target");\r\n                newSettings[attr] = $target.val();\r\n            })\r\n            .on("change", function () {\r\n                var $target = $(":selected", this);\r\n                var attr = $target.attr("data-target");\r\n\r\n                if (attr) {\r\n                    prefs.set(attr, $target.val());\r\n                }\r\n            });\r\n\r\n        Dialogs.showModalDialogUsingTemplate($template).done(function (id) {\r\n            var setterFn;\r\n\r\n            if (id === "save") {\r\n                // Go through each new setting and apply it\r\n                Object.keys(newSettings).forEach(function (setting) {\r\n                    if (defaults.hasOwnProperty(setting)) {\r\n                        prefs.set(setting, newSettings[setting]);\r\n                    } else {\r\n                        // Figure out if the setting is in the ViewCommandHandlers, which means it is\r\n                        // a font setting\r\n                        setterFn = "set" + setting[0].toLocaleUpperCase() + setting.substr(1);\r\n                        if (typeof ViewCommandHandlers[setterFn] === \'function\') {\r\n                            ViewCommandHandlers[setterFn](newSettings[setting]);\r\n                        }\r\n                    }\r\n                });\r\n            } else if (id === "cancel") {\r\n                // Make sure we revert any changes to theme selection\r\n                prefs.set("theme", currentSettings.theme);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Interface to set the themes that are available to chose from in the setting dialog\r\n     * @param {ThemeManager.Theme} themes is a collection of themes created by the ThemeManager\r\n     */\r\n    function setThemes(themes) {\r\n        loadedThemes = themes;\r\n    }\r\n\r\n    /**\r\n     * Restores themes to factory settings.\r\n     */\r\n    function restore() {\r\n        prefs.set("theme", defaults.theme);\r\n        prefs.set("themeScrollbars", defaults.themeScrollbars);\r\n    }\r\n\r\n    prefs.definePreference("theme", "string", defaults.theme);\r\n    prefs.definePreference("themeScrollbars", "boolean", defaults.themeScrollbars);\r\n\r\n    exports._setThemes = setThemes;\r\n    exports.restore    = restore;\r\n    exports.showDialog = showDialog;\r\n});\r\n\n//# sourceURL=/view/ThemeSettings.js'),eval('/**\r\n * Brackets Themes Copyright (c) 2014 Miguel Castillo.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global $, define, require */\r\n\r\ndefine(\'view/ThemeView\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'thirdparty/CodeMirror2/lib/codemirror\',\'preferences/PreferencesManager\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var currentThemes = [];\r\n\r\n    var _                  = require("thirdparty/lodash"),\r\n        CodeMirror         = require("thirdparty/CodeMirror2/lib/codemirror"),\r\n        PreferencesManager = require("preferences/PreferencesManager"),\r\n        prefs              = PreferencesManager.getExtensionPrefs("themes");\r\n\r\n    var $scrollbars = $("<style id=\'scrollbars\'>").appendTo("head");\r\n\r\n\r\n    /**\r\n     * Load scrollbar styling based on whether or not theme scrollbars are enabled.\r\n     *\r\n     * @param {ThemeManager.Theme} theme Is the theme object with the corresponding scrollbar style\r\n     *   to be updated\r\n     */\r\n    function updateScrollbars(theme) {\r\n        theme = theme || {};\r\n        if (prefs.get("themeScrollbars")) {\r\n            var scrollbar = (theme.scrollbar || []).join(" ");\r\n            $scrollbars.text(scrollbar || "");\r\n        } else {\r\n            $scrollbars.text("");\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     *  Handles updating codemirror with the current selection of themes.\r\n     *\r\n     * @param {CodeMirror} cm is the CodeMirror instance currently loaded\r\n     */\r\n    function updateThemes(cm) {\r\n        var newTheme = prefs.get("theme"),\r\n            cmTheme  = (cm.getOption("theme") || "").replace(/[\\s]*/, ""); // Normalize themes string\r\n\r\n        // Check if the editor already has the theme applied...\r\n        if (cmTheme === newTheme) {\r\n            return;\r\n        }\r\n\r\n        // Setup current and further documents to get the new theme...\r\n        CodeMirror.defaults.theme = newTheme;\r\n        cm.setOption("theme", newTheme);\r\n    }\r\n\r\n\r\n    exports.updateScrollbars = updateScrollbars;\r\n    exports.updateThemes     = updateThemes;\r\n});\r\n\n//# sourceURL=/view/ThemeView.js'),eval('/**\r\n * Brackets Themes Copyright (c) 2014 Miguel Castillo.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, regexp: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global $, define, require, less */\r\n\r\ndefine(\'view/ThemeManager\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'filesystem/FileSystem\',\'file/FileUtils\',\'editor/EditorManager\',\'utils/ExtensionUtils\',\'view/ThemeSettings\',\'view/ThemeView\',\'utils/AppInit\',\'preferences/PreferencesManager\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var _                  = require("thirdparty/lodash"),\r\n        FileSystem         = require("filesystem/FileSystem"),\r\n        FileUtils          = require("file/FileUtils"),\r\n        EditorManager      = require("editor/EditorManager"),\r\n        ExtensionUtils     = require("utils/ExtensionUtils"),\r\n        ThemeSettings      = require("view/ThemeSettings"),\r\n        ThemeView          = require("view/ThemeView"),\r\n        AppInit            = require("utils/AppInit"),\r\n        PreferencesManager = require("preferences/PreferencesManager"),\r\n        prefs              = PreferencesManager.getExtensionPrefs("themes");\r\n\r\n    var loadedThemes    = {},\r\n        currentTheme    = null,\r\n        styleNode       = $(ExtensionUtils.addEmbeddedStyleSheet("")),\r\n        defaultTheme    = "thor-light-theme",\r\n        commentRegex    = /\\/\\*([\\s\\S]*?)\\*\\//mg,\r\n        scrollbarsRegex = /((?:[^}|,]*)::-webkit-scrollbar(?:[^{]*)[{](?:[^}]*?)[}])/mgi,\r\n        stylesPath      = FileUtils.getNativeBracketsDirectoryPath() + "/styles/",\r\n        validExtensions = ["css", "less"];\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Takes all dashes and converts them to white spaces. Then takes all first letters\r\n     * and capitalizes them.\r\n     *\r\n     * @param {string} name is what needs to be procseed to generate a display name\r\n     * @return {string} theme name properly formatted for display\r\n     */\r\n    function toDisplayName(name) {\r\n        var extIndex = name.lastIndexOf(\'.\');\r\n        name = name.substring(0, extIndex !== -1 ? extIndex : undefined).replace(/-/g, \' \');\r\n\r\n        return name.split(" ").map(function (part) {\r\n            return part[0].toUpperCase() + part.substring(1);\r\n        }).join(" ");\r\n    }\r\n\r\n\r\n    /**\r\n     * @constructor\r\n     * Theme contains all the essential bit to load a theme from disk, display a theme in the settings\r\n     * dialog, and to properly add a theme into CodeMirror along with the rest of brackets.\r\n     *\r\n     * @param {File} file for the theme\r\n     * @param {{name: string, title: string}} options to configure different\r\n     *   properties in the theme\r\n     */\r\n    function Theme(file, options) {\r\n        options = options || {};\r\n        var fileName = file.name;\r\n\r\n        // If no options.name is provided, then we derive the name of the theme from whichever we find\r\n        // first, the options.title or the filename.\r\n        if (!options.name) {\r\n            if (options.title) {\r\n                options.name = options.title;\r\n            } else {\r\n                // Remove the file extension when the filename is used as the theme name. This is to\r\n                // follow CodeMirror conventions where themes are just a CSS file and the filename\r\n                // (without the extension) is used to build CSS rules.  Also handle removing .min\r\n                // in case the ".min" is part of the file name.\r\n                options.name = FileUtils.getFilenameWithoutExtension(fileName).replace(/\\.min$/, "");\r\n            }\r\n\r\n            // We do a bit of string treatment here to make sure we generate theme names that can be\r\n            // used as a CSS class name by CodeMirror.\r\n            options.name = options.name.toLocaleLowerCase().replace(/[\\W]/g, \'-\');\r\n        }\r\n\r\n        this.file        = file;\r\n        this.name        = options.name;\r\n        this.displayName = options.title || toDisplayName(fileName);\r\n        this.dark        = options.theme !== undefined && options.theme.dark === true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Extracts the scrollbar text from the css/less content so that it can be treated\r\n     * as a separate styling component that can be anabled/disabled independently from\r\n     * the theme.\r\n     *\r\n     * @param {string} content is the css/less input string to be processed\r\n     * @return {{content: string, scrollbar: Array.<string>}} content is the new css/less content\r\n     *   with the scrollbar rules extracted out and put in scrollbar\r\n     */\r\n    function extractScrollbars(content) {\r\n        var scrollbar = [];\r\n\r\n        // Go through and extract out scrollbar customizations so that we can\r\n        // enable/disable via settings.\r\n        content = content\r\n            .replace(scrollbarsRegex, function (match) {\r\n                scrollbar.push(match);\r\n                return "";\r\n            });\r\n\r\n        return {\r\n            content: content,\r\n            scrollbar: scrollbar\r\n        };\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Function will process a string and figure out if it looks like window path with a\r\n     * a drive.  If that\'s the case, then we lower case everything.\r\n     * --- NOTE: There is a bug in less that only checks for lowercase in order to handle\r\n     * the rootPath configuration...  Hopefully a PR will be coming their way soon.\r\n     *\r\n     * @param {string} path is a string to search for drive letters that need to be converted\r\n     *   to lower case.\r\n     *\r\n     * @return {string} Windows Drive letter in lowercase.\r\n     */\r\n    function fixPath(path) {\r\n        return path.replace(/^([A-Z]+:)?\\//, function (match) {\r\n            return match.toLocaleLowerCase();\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Takes the content of a file and feeds it through the less processor in order\r\n     * to provide support for less files.\r\n     *\r\n     * @param {string} content is the css/less string to be processed\r\n     * @param {Theme} theme is the object the css/less corresponds to\r\n     * @return {$.Promise} promsie with the processed css/less as the resolved value\r\n     */\r\n    function lessifyTheme(content, theme) {\r\n        var deferred = new $.Deferred();\r\n        var parser   = new less.Parser({\r\n            rootpath: fixPath(stylesPath),\r\n            filename: fixPath(theme.file._path)\r\n        });\r\n\r\n        parser.parse("#editor-holder {" + content + "\\n}", function (err, tree) {\r\n            if (err) {\r\n                deferred.reject(err);\r\n            } else {\r\n                deferred.resolve(tree.toCSS());\r\n            }\r\n        });\r\n\r\n        return deferred.promise();\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Verifies that the file passed in is a valid theme file type.\r\n     *\r\n     * @param {File} file is object to verify if it is a valid theme file type\r\n     * @return {boolean} to confirm if the file is a valid theme file type\r\n     */\r\n    function isFileTypeValid(file) {\r\n        return file.isFile &&\r\n            validExtensions.indexOf(FileUtils.getFileExtension(file.name)) !== -1;\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Will search all loaded themes for one the matches the file passed in\r\n     *\r\n     * @param {File} file is the search criteria\r\n     * @return {Theme} theme that matches the file\r\n     */\r\n    function getThemeByFile(file) {\r\n        var path = file._path;\r\n        return _.find(loadedThemes, function (item) {\r\n            return item.file._path === path;\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Get current theme object that is loaded in the editor.\r\n     *\r\n     * @return {Theme} the current theme instance\r\n     */\r\n    function getCurrentTheme() {\r\n        if (!currentTheme) {\r\n            currentTheme = loadedThemes[prefs.get("theme")] || loadedThemes[defaultTheme];\r\n        }\r\n\r\n        return currentTheme;\r\n    }\r\n\r\n\r\n    /**\r\n     * Gets all available themes\r\n     * @return {Array.<Theme>} collection of all available themes\r\n     */\r\n    function getAllThemes() {\r\n        return _.map(loadedThemes, function (theme) {\r\n            return theme;\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Process and load the current theme into the editor\r\n     *\r\n     * @return {$.Promise} promise object resolved with the theme object and all\r\n     *    corresponding new css/less and scrollbar information\r\n     */\r\n    function loadCurrentTheme() {\r\n        var theme = getCurrentTheme();\r\n\r\n        var pending = theme && FileUtils.readAsText(theme.file)\r\n            .then(function (lessContent) {\r\n                return lessifyTheme(lessContent.replace(commentRegex, ""), theme);\r\n            })\r\n            .then(function (content) {\r\n                var result = extractScrollbars(content);\r\n                theme.scrollbar = result.scrollbar;\r\n                return result.content;\r\n            })\r\n            .then(function (cssContent) {\r\n                $("body").toggleClass("dark", theme.dark);\r\n                styleNode.text(cssContent);\r\n                return theme;\r\n            });\r\n\r\n        return $.when(pending);\r\n    }\r\n\r\n\r\n    /**\r\n     * Refresh current theme in the editor\r\n     *\r\n     * @param {boolean} force Forces a reload the current theme.  It reload the theme file.\r\n     */\r\n    function refresh(force) {\r\n        if (force) {\r\n            currentTheme = null;\r\n        }\r\n\r\n        $.when(force && loadCurrentTheme()).done(function () {\r\n            var editor = EditorManager.getActiveEditor();\r\n            if (!editor || !editor._codeMirror) {\r\n                return;\r\n            }\r\n\r\n            var cm = editor._codeMirror;\r\n            ThemeView.updateThemes(cm);\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Loads a theme from a file.\r\n     *\r\n     * @param {string} fileName is the full path to the file to be opened\r\n     * @param {Object} options is an optional parameter to specify metadata\r\n     *    for the theme.\r\n     * @return {$.Promise} promise object resolved with the theme to be loaded from fileName\r\n     */\r\n    function loadFile(fileName, options) {\r\n        var deferred         = new $.Deferred(),\r\n            file             = FileSystem.getFileForPath(fileName),\r\n            currentThemeName = prefs.get("theme");\r\n\r\n        file.exists(function (err, exists) {\r\n            var theme;\r\n\r\n            if (exists) {\r\n                theme = new Theme(file, options);\r\n                loadedThemes[theme.name] = theme;\r\n                ThemeSettings._setThemes(loadedThemes);\r\n\r\n                // For themes that are loaded after ThemeManager has been loaded,\r\n                // we should check if it\'s the current theme.  If it is, then we just\r\n                // load it.\r\n                if (currentThemeName === theme.name) {\r\n                    refresh(true);\r\n                }\r\n\r\n                deferred.resolve(theme);\r\n            } else if (err || !exists) {\r\n                deferred.reject(err);\r\n            }\r\n        });\r\n\r\n        return deferred.promise();\r\n    }\r\n\r\n\r\n    /**\r\n     * Loads a theme from an extension package.\r\n     *\r\n     * @param {Object} themePackage is a package from the extension manager for the theme to be loaded.\r\n     * @return {$.Promise} promise object resolved with the theme to be loaded from the pacakge\r\n     */\r\n    function loadPackage(themePackage) {\r\n        var fileName = themePackage.path + "/" + themePackage.metadata.theme.file;\r\n        return loadFile(fileName, themePackage.metadata);\r\n    }\r\n\r\n\r\n    prefs.on("change", "theme", function () {\r\n        // Make sure we don\'t reprocess a theme that\'s already loaded\r\n        if (currentTheme && currentTheme.name === prefs.get("theme")) {\r\n            return;\r\n        }\r\n\r\n        // Refresh editor with the new theme\r\n        refresh(true);\r\n\r\n        // Process the scrollbars for the editor\r\n        ThemeView.updateScrollbars(getCurrentTheme());\r\n\r\n        // Expose event for theme changes\r\n        $(exports).trigger("themeChange", getCurrentTheme());\r\n    });\r\n\r\n    prefs.on("change", "themeScrollbars", function () {\r\n        refresh();\r\n        ThemeView.updateScrollbars(getCurrentTheme());\r\n    });\r\n\r\n    // Monitor file changes.  If the file that has changed is actually the currently loaded\r\n    // theme, then we just reload the theme.  This allows to live edit the theme\r\n    FileSystem.on("change", function (evt, file) {\r\n        if (!file || file.isDirectory) {\r\n            return;\r\n        }\r\n\r\n        if (getThemeByFile(file)) {\r\n            refresh(true);\r\n        }\r\n    });\r\n\r\n    $(EditorManager).on("activeEditorChange", function () {\r\n        refresh();\r\n    });\r\n\r\n\r\n    exports.refresh         = refresh;\r\n    exports.loadFile        = loadFile;\r\n    exports.loadPackage     = loadPackage;\r\n    exports.getCurrentTheme = getCurrentTheme;\r\n    exports.getAllThemes    = getAllThemes;\r\n\r\n    // Exposed for testing purposes\r\n    exports._toDisplayName     = toDisplayName;\r\n    exports._extractScrollbars = extractScrollbars;\r\n});\r\n\n//# sourceURL=/view/ThemeManager.js'),eval(";(function(exports) {\r\n\r\n// export the class if we are in a Node-like system.\r\nif (typeof module === 'object' && module.exports === exports)\r\n  exports = module.exports = SemVer;\r\n\r\n// The debug function is excluded entirely from the minified version.\r\n\r\n// Note: this is the semver.org version of the spec that it implements\r\n// Not necessarily the package version of this code.\r\nexports.SEMVER_SPEC_VERSION = '2.0.0';\r\n\r\n// The actual regexps go on exports.re\r\nvar re = exports.re = [];\r\nvar src = exports.src = [];\r\nvar R = 0;\r\n\r\n// The following Regular Expressions can be used for tokenizing,\r\n// validating, and parsing SemVer version strings.\r\n\r\n// ## Numeric Identifier\r\n// A single `0`, or a non-zero digit followed by zero or more digits.\r\n\r\nvar NUMERICIDENTIFIER = R++;\r\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*';\r\nvar NUMERICIDENTIFIERLOOSE = R++;\r\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+';\r\n\r\n\r\n// ## Non-numeric Identifier\r\n// Zero or more digits, followed by a letter or hyphen, and then zero or\r\n// more letters, digits, or hyphens.\r\n\r\nvar NONNUMERICIDENTIFIER = R++;\r\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*';\r\n\r\n\r\n// ## Main Version\r\n// Three dot-separated numeric identifiers.\r\n\r\nvar MAINVERSION = R++;\r\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\r\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\r\n                   '(' + src[NUMERICIDENTIFIER] + ')';\r\n\r\nvar MAINVERSIONLOOSE = R++;\r\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\r\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\r\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';\r\n\r\n// ## Pre-release Version Identifier\r\n// A numeric identifier, or a non-numeric identifier.\r\n\r\nvar PRERELEASEIDENTIFIER = R++;\r\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\r\n                            '|' + src[NONNUMERICIDENTIFIER] + ')';\r\n\r\nvar PRERELEASEIDENTIFIERLOOSE = R++;\r\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\r\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')';\r\n\r\n\r\n// ## Pre-release Version\r\n// Hyphen, followed by one or more dot-separated pre-release version\r\n// identifiers.\r\n\r\nvar PRERELEASE = R++;\r\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\r\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))';\r\n\r\nvar PRERELEASELOOSE = R++;\r\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\r\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';\r\n\r\n// ## Build Metadata Identifier\r\n// Any combination of digits, letters, or hyphens.\r\n\r\nvar BUILDIDENTIFIER = R++;\r\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';\r\n\r\n// ## Build Metadata\r\n// Plus sign, followed by one or more period-separated build metadata\r\n// identifiers.\r\n\r\nvar BUILD = R++;\r\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\r\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))';\r\n\r\n\r\n// ## Full Version String\r\n// A main version, followed optionally by a pre-release version and\r\n// build metadata.\r\n\r\n// Note that the only major, minor, patch, and pre-release sections of\r\n// the version string are capturing groups.  The build metadata is not a\r\n// capturing group, because it should not ever be used in version\r\n// comparison.\r\n\r\nvar FULL = R++;\r\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\r\n                src[PRERELEASE] + '?' +\r\n                src[BUILD] + '?';\r\n\r\nsrc[FULL] = '^' + FULLPLAIN + '$';\r\n\r\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\r\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\r\n// common in the npm registry.\r\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\r\n                 src[PRERELEASELOOSE] + '?' +\r\n                 src[BUILD] + '?';\r\n\r\nvar LOOSE = R++;\r\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$';\r\n\r\nvar GTLT = R++;\r\nsrc[GTLT] = '((?:<|>)?=?)';\r\n\r\n// Something like \"2.*\" or \"1.2.x\".\r\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\r\n// Only the first item is strictly required.\r\nvar XRANGEIDENTIFIERLOOSE = R++;\r\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*';\r\nvar XRANGEIDENTIFIER = R++;\r\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*';\r\n\r\nvar XRANGEPLAIN = R++;\r\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\r\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\r\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\r\n                   '(?:(' + src[PRERELEASE] + ')' +\r\n                   ')?)?)?';\r\n\r\nvar XRANGEPLAINLOOSE = R++;\r\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\r\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\r\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\r\n                        '(?:(' + src[PRERELEASELOOSE] + ')' +\r\n                        ')?)?)?';\r\n\r\n// >=2.x, for example, means >=2.0.0-0\r\n// <1.x would be the same as \"<1.0.0-0\", though.\r\nvar XRANGE = R++;\r\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$';\r\nvar XRANGELOOSE = R++;\r\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$';\r\n\r\n// Tilde ranges.\r\n// Meaning is \"reasonably at or greater than\"\r\nvar LONETILDE = R++;\r\nsrc[LONETILDE] = '(?:~>?)';\r\n\r\nvar TILDETRIM = R++;\r\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+';\r\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');\r\nvar tildeTrimReplace = '$1~';\r\n\r\nvar TILDE = R++;\r\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';\r\nvar TILDELOOSE = R++;\r\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';\r\n\r\n// Caret ranges.\r\n// Meaning is \"at least and backwards compatible with\"\r\nvar LONECARET = R++;\r\nsrc[LONECARET] = '(?:\\\\^)';\r\n\r\nvar CARETTRIM = R++;\r\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+';\r\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');\r\nvar caretTrimReplace = '$1^';\r\n\r\nvar CARET = R++;\r\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';\r\nvar CARETLOOSE = R++;\r\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';\r\n\r\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\r\nvar COMPARATORLOOSE = R++;\r\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$';\r\nvar COMPARATOR = R++;\r\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$';\r\n\r\n\r\n// An expression to strip any whitespace between the gtlt and the thing\r\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\r\nvar COMPARATORTRIM = R++;\r\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\r\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';\r\n\r\n// this one has to use the /g flag\r\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');\r\nvar comparatorTrimReplace = '$1$2$3';\r\n\r\n\r\n// Something like `1.2.3 - 1.2.4`\r\n// Note that these all use the loose form, because they'll be\r\n// checked against either the strict or loose comparator form\r\n// later.\r\nvar HYPHENRANGE = R++;\r\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\r\n                   '\\\\s+-\\\\s+' +\r\n                   '(' + src[XRANGEPLAIN] + ')' +\r\n                   '\\\\s*$';\r\n\r\nvar HYPHENRANGELOOSE = R++;\r\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\r\n                        '\\\\s+-\\\\s+' +\r\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\r\n                        '\\\\s*$';\r\n\r\n// Star ranges basically just allow anything at all.\r\nvar STAR = R++;\r\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*';\r\n\r\n// Compile to actual regexp objects.\r\n// All are flag-free, unless they were created above with a flag.\r\nfor (var i = 0; i < R; i++) {\r\n  ;\r\n  if (!re[i])\r\n    re[i] = new RegExp(src[i]);\r\n}\r\n\r\nexports.parse = parse;\r\nfunction parse(version, loose) {\r\n  var r = loose ? re[LOOSE] : re[FULL];\r\n  return (r.test(version)) ? new SemVer(version, loose) : null;\r\n}\r\n\r\nexports.valid = valid;\r\nfunction valid(version, loose) {\r\n  var v = parse(version, loose);\r\n  return v ? v.version : null;\r\n}\r\n\r\n\r\nexports.clean = clean;\r\nfunction clean(version, loose) {\r\n  var s = parse(version, loose);\r\n  return s ? s.version : null;\r\n}\r\n\r\nexports.SemVer = SemVer;\r\n\r\nfunction SemVer(version, loose) {\r\n  if (version instanceof SemVer) {\r\n    if (version.loose === loose)\r\n      return version;\r\n    else\r\n      version = version.version;\r\n  }\r\n\r\n  if (!(this instanceof SemVer))\r\n    return new SemVer(version, loose);\r\n\r\n  ;\r\n  this.loose = loose;\r\n  var m = version.trim().match(loose ? re[LOOSE] : re[FULL]);\r\n\r\n  if (!m)\r\n    throw new TypeError('Invalid Version: ' + version);\r\n\r\n  this.raw = version;\r\n\r\n  // these are actually numbers\r\n  this.major = +m[1];\r\n  this.minor = +m[2];\r\n  this.patch = +m[3];\r\n\r\n  // numberify any prerelease numeric ids\r\n  if (!m[4])\r\n    this.prerelease = [];\r\n  else\r\n    this.prerelease = m[4].split('.').map(function(id) {\r\n      return (/^[0-9]+$/.test(id)) ? +id : id;\r\n    });\r\n\r\n  this.build = m[5] ? m[5].split('.') : [];\r\n  this.format();\r\n}\r\n\r\nSemVer.prototype.format = function() {\r\n  this.version = this.major + '.' + this.minor + '.' + this.patch;\r\n  if (this.prerelease.length)\r\n    this.version += '-' + this.prerelease.join('.');\r\n  return this.version;\r\n};\r\n\r\nSemVer.prototype.inspect = function() {\r\n  return '<SemVer \"' + this + '\">';\r\n};\r\n\r\nSemVer.prototype.toString = function() {\r\n  return this.version;\r\n};\r\n\r\nSemVer.prototype.compare = function(other) {\r\n  ;\r\n  if (!(other instanceof SemVer))\r\n    other = new SemVer(other, this.loose);\r\n\r\n  return this.compareMain(other) || this.comparePre(other);\r\n};\r\n\r\nSemVer.prototype.compareMain = function(other) {\r\n  if (!(other instanceof SemVer))\r\n    other = new SemVer(other, this.loose);\r\n\r\n  return compareIdentifiers(this.major, other.major) ||\r\n         compareIdentifiers(this.minor, other.minor) ||\r\n         compareIdentifiers(this.patch, other.patch);\r\n};\r\n\r\nSemVer.prototype.comparePre = function(other) {\r\n  if (!(other instanceof SemVer))\r\n    other = new SemVer(other, this.loose);\r\n\r\n  // NOT having a prerelease is > having one\r\n  if (this.prerelease.length && !other.prerelease.length)\r\n    return -1;\r\n  else if (!this.prerelease.length && other.prerelease.length)\r\n    return 1;\r\n  else if (!this.prerelease.lenth && !other.prerelease.length)\r\n    return 0;\r\n\r\n  var i = 0;\r\n  do {\r\n    var a = this.prerelease[i];\r\n    var b = other.prerelease[i];\r\n    ;\r\n    if (a === undefined && b === undefined)\r\n      return 0;\r\n    else if (b === undefined)\r\n      return 1;\r\n    else if (a === undefined)\r\n      return -1;\r\n    else if (a === b)\r\n      continue;\r\n    else\r\n      return compareIdentifiers(a, b);\r\n  } while (++i);\r\n};\r\n\r\nSemVer.prototype.inc = function(release) {\r\n  switch (release) {\r\n    case 'major':\r\n      this.major++;\r\n      this.minor = -1;\r\n    case 'minor':\r\n      this.minor++;\r\n      this.patch = -1;\r\n    case 'patch':\r\n      this.patch++;\r\n      this.prerelease = [];\r\n      break;\r\n    case 'prerelease':\r\n      if (this.prerelease.length === 0)\r\n        this.prerelease = [0];\r\n      else {\r\n        var i = this.prerelease.length;\r\n        while (--i >= 0) {\r\n          if (typeof this.prerelease[i] === 'number') {\r\n            this.prerelease[i]++;\r\n            i = -2;\r\n          }\r\n        }\r\n        if (i === -1) // didn't increment anything\r\n          this.prerelease.push(0);\r\n      }\r\n      break;\r\n\r\n    default:\r\n      throw new Error('invalid increment argument: ' + release);\r\n  }\r\n  this.format();\r\n  return this;\r\n};\r\n\r\nexports.inc = inc;\r\nfunction inc(version, release, loose) {\r\n  try {\r\n    return new SemVer(version, loose).inc(release).version;\r\n  } catch (er) {\r\n    return null;\r\n  }\r\n}\r\n\r\nexports.compareIdentifiers = compareIdentifiers;\r\n\r\nvar numeric = /^[0-9]+$/;\r\nfunction compareIdentifiers(a, b) {\r\n  var anum = numeric.test(a);\r\n  var bnum = numeric.test(b);\r\n\r\n  if (anum && bnum) {\r\n    a = +a;\r\n    b = +b;\r\n  }\r\n\r\n  return (anum && !bnum) ? -1 :\r\n         (bnum && !anum) ? 1 :\r\n         a < b ? -1 :\r\n         a > b ? 1 :\r\n         0;\r\n}\r\n\r\nexports.rcompareIdentifiers = rcompareIdentifiers;\r\nfunction rcompareIdentifiers(a, b) {\r\n  return compareIdentifiers(b, a);\r\n}\r\n\r\nexports.compare = compare;\r\nfunction compare(a, b, loose) {\r\n  return new SemVer(a, loose).compare(b);\r\n}\r\n\r\nexports.compareLoose = compareLoose;\r\nfunction compareLoose(a, b) {\r\n  return compare(a, b, true);\r\n}\r\n\r\nexports.rcompare = rcompare;\r\nfunction rcompare(a, b, loose) {\r\n  return compare(b, a, loose);\r\n}\r\n\r\nexports.sort = sort;\r\nfunction sort(list, loose) {\r\n  return list.sort(function(a, b) {\r\n    return exports.compare(a, b, loose);\r\n  });\r\n}\r\n\r\nexports.rsort = rsort;\r\nfunction rsort(list, loose) {\r\n  return list.sort(function(a, b) {\r\n    return exports.rcompare(a, b, loose);\r\n  });\r\n}\r\n\r\nexports.gt = gt;\r\nfunction gt(a, b, loose) {\r\n  return compare(a, b, loose) > 0;\r\n}\r\n\r\nexports.lt = lt;\r\nfunction lt(a, b, loose) {\r\n  return compare(a, b, loose) < 0;\r\n}\r\n\r\nexports.eq = eq;\r\nfunction eq(a, b, loose) {\r\n  return compare(a, b, loose) === 0;\r\n}\r\n\r\nexports.neq = neq;\r\nfunction neq(a, b, loose) {\r\n  return compare(a, b, loose) !== 0;\r\n}\r\n\r\nexports.gte = gte;\r\nfunction gte(a, b, loose) {\r\n  return compare(a, b, loose) >= 0;\r\n}\r\n\r\nexports.lte = lte;\r\nfunction lte(a, b, loose) {\r\n  return compare(a, b, loose) <= 0;\r\n}\r\n\r\nexports.cmp = cmp;\r\nfunction cmp(a, op, b, loose) {\r\n  var ret;\r\n  switch (op) {\r\n    case '===': ret = a === b; break;\r\n    case '!==': ret = a !== b; break;\r\n    case '': case '=': case '==': ret = eq(a, b, loose); break;\r\n    case '!=': ret = neq(a, b, loose); break;\r\n    case '>': ret = gt(a, b, loose); break;\r\n    case '>=': ret = gte(a, b, loose); break;\r\n    case '<': ret = lt(a, b, loose); break;\r\n    case '<=': ret = lte(a, b, loose); break;\r\n    default: throw new TypeError('Invalid operator: ' + op);\r\n  }\r\n  return ret;\r\n}\r\n\r\nexports.Comparator = Comparator;\r\nfunction Comparator(comp, loose) {\r\n  if (comp instanceof Comparator) {\r\n    if (comp.loose === loose)\r\n      return comp;\r\n    else\r\n      comp = comp.value;\r\n  }\r\n\r\n  if (!(this instanceof Comparator))\r\n    return new Comparator(comp, loose);\r\n\r\n  ;\r\n  this.loose = loose;\r\n  this.parse(comp);\r\n\r\n  if (this.semver === ANY)\r\n    this.value = '';\r\n  else\r\n    this.value = this.operator + this.semver.version;\r\n}\r\n\r\nvar ANY = {};\r\nComparator.prototype.parse = function(comp) {\r\n  var r = this.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\r\n  var m = comp.match(r);\r\n\r\n  if (!m)\r\n    throw new TypeError('Invalid comparator: ' + comp);\r\n\r\n  this.operator = m[1];\r\n  // if it literally is just '>' or '' then allow anything.\r\n  if (!m[2])\r\n    this.semver = ANY;\r\n  else {\r\n    this.semver = new SemVer(m[2], this.loose);\r\n\r\n    // <1.2.3-rc DOES allow 1.2.3-beta (has prerelease)\r\n    // >=1.2.3 DOES NOT allow 1.2.3-beta\r\n    // <=1.2.3 DOES allow 1.2.3-beta\r\n    // However, <1.2.3 does NOT allow 1.2.3-beta,\r\n    // even though `1.2.3-beta < 1.2.3`\r\n    // The assumption is that the 1.2.3 version has something you\r\n    // *don't* want, so we push the prerelease down to the minimum.\r\n    if (this.operator === '<' && !this.semver.prerelease.length) {\r\n      this.semver.prerelease = ['0'];\r\n      this.semver.format();\r\n    }\r\n  }\r\n};\r\n\r\nComparator.prototype.inspect = function() {\r\n  return '<SemVer Comparator \"' + this + '\">';\r\n};\r\n\r\nComparator.prototype.toString = function() {\r\n  return this.value;\r\n};\r\n\r\nComparator.prototype.test = function(version) {\r\n  ;\r\n  return (this.semver === ANY) ? true :\r\n         cmp(version, this.operator, this.semver, this.loose);\r\n};\r\n\r\n\r\nexports.Range = Range;\r\nfunction Range(range, loose) {\r\n  if ((range instanceof Range) && range.loose === loose)\r\n    return range;\r\n\r\n  if (!(this instanceof Range))\r\n    return new Range(range, loose);\r\n\r\n  this.loose = loose;\r\n\r\n  // First, split based on boolean or ||\r\n  this.raw = range;\r\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function(range) {\r\n    return this.parseRange(range.trim());\r\n  }, this).filter(function(c) {\r\n    // throw out any that are not relevant for whatever reason\r\n    return c.length;\r\n  });\r\n\r\n  if (!this.set.length) {\r\n    throw new TypeError('Invalid SemVer Range: ' + range);\r\n  }\r\n\r\n  this.format();\r\n}\r\n\r\nRange.prototype.inspect = function() {\r\n  return '<SemVer Range \"' + this.range + '\">';\r\n};\r\n\r\nRange.prototype.format = function() {\r\n  this.range = this.set.map(function(comps) {\r\n    return comps.join(' ').trim();\r\n  }).join('||').trim();\r\n  return this.range;\r\n};\r\n\r\nRange.prototype.toString = function() {\r\n  return this.range;\r\n};\r\n\r\nRange.prototype.parseRange = function(range) {\r\n  var loose = this.loose;\r\n  range = range.trim();\r\n  ;\r\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\r\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];\r\n  range = range.replace(hr, hyphenReplace);\r\n  ;\r\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\r\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);\r\n  ;\r\n\r\n  // `~ 1.2.3` => `~1.2.3`\r\n  range = range.replace(re[TILDETRIM], tildeTrimReplace);\r\n\r\n  // `^ 1.2.3` => `^1.2.3`\r\n  range = range.replace(re[CARETTRIM], caretTrimReplace);\r\n\r\n  // normalize spaces\r\n  range = range.split(/\\s+/).join(' ');\r\n\r\n  // At this point, the range is completely trimmed and\r\n  // ready to be split into comparators.\r\n\r\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];\r\n  var set = range.split(' ').map(function(comp) {\r\n    return parseComparator(comp, loose);\r\n  }).join(' ').split(/\\s+/);\r\n  if (this.loose) {\r\n    // in loose mode, throw out any that are not valid comparators\r\n    set = set.filter(function(comp) {\r\n      return !!comp.match(compRe);\r\n    });\r\n  }\r\n  set = set.map(function(comp) {\r\n    return new Comparator(comp, loose);\r\n  });\r\n\r\n  return set;\r\n};\r\n\r\n// Mostly just for testing and legacy API reasons\r\nexports.toComparators = toComparators;\r\nfunction toComparators(range, loose) {\r\n  return new Range(range, loose).set.map(function(comp) {\r\n    return comp.map(function(c) {\r\n      return c.value;\r\n    }).join(' ').trim().split(' ');\r\n  });\r\n}\r\n\r\n// comprised of xranges, tildes, stars, and gtlt's at this point.\r\n// already replaced the hyphen ranges\r\n// turn into a set of JUST comparators.\r\nfunction parseComparator(comp, loose) {\r\n  ;\r\n  comp = replaceCarets(comp, loose);\r\n  ;\r\n  comp = replaceTildes(comp, loose);\r\n  ;\r\n  comp = replaceXRanges(comp, loose);\r\n  ;\r\n  comp = replaceStars(comp, loose);\r\n  ;\r\n  return comp;\r\n}\r\n\r\nfunction isX(id) {\r\n  return !id || id.toLowerCase() === 'x' || id === '*';\r\n}\r\n\r\n// ~, ~> --> * (any, kinda silly)\r\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\r\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\r\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\r\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\r\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\r\nfunction replaceTildes(comp, loose) {\r\n  return comp.trim().split(/\\s+/).map(function(comp) {\r\n    return replaceTilde(comp, loose);\r\n  }).join(' ');\r\n}\r\n\r\nfunction replaceTilde(comp, loose) {\r\n  var r = loose ? re[TILDELOOSE] : re[TILDE];\r\n  return comp.replace(r, function(_, M, m, p, pr) {\r\n    ;\r\n    var ret;\r\n\r\n    if (isX(M))\r\n      ret = '';\r\n    else if (isX(m))\r\n      ret = '>=' + M + '.0.0-0 <' + (+M + 1) + '.0.0-0';\r\n    else if (isX(p))\r\n      // ~1.2 == >=1.2.0- <1.3.0-\r\n      ret = '>=' + M + '.' + m + '.0-0 <' + M + '.' + (+m + 1) + '.0-0';\r\n    else if (pr) {\r\n      ;\r\n      if (pr.charAt(0) !== '-')\r\n        pr = '-' + pr;\r\n      ret = '>=' + M + '.' + m + '.' + p + pr +\r\n            ' <' + M + '.' + (+m + 1) + '.0-0';\r\n    } else\r\n      // ~1.2.3 == >=1.2.3-0 <1.3.0-0\r\n      ret = '>=' + M + '.' + m + '.' + p + '-0' +\r\n            ' <' + M + '.' + (+m + 1) + '.0-0';\r\n\r\n    ;\r\n    return ret;\r\n  });\r\n}\r\n\r\n// ^ --> * (any, kinda silly)\r\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\r\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\r\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\r\n// ^1.2.3 --> >=1.2.3 <2.0.0\r\n// ^1.2.0 --> >=1.2.0 <2.0.0\r\nfunction replaceCarets(comp, loose) {\r\n  return comp.trim().split(/\\s+/).map(function(comp) {\r\n    return replaceCaret(comp, loose);\r\n  }).join(' ');\r\n}\r\n\r\nfunction replaceCaret(comp, loose) {\r\n  var r = loose ? re[CARETLOOSE] : re[CARET];\r\n  return comp.replace(r, function(_, M, m, p, pr) {\r\n    ;\r\n    var ret;\r\n\r\n    if (isX(M))\r\n      ret = '';\r\n    else if (isX(m))\r\n      ret = '>=' + M + '.0.0-0 <' + (+M + 1) + '.0.0-0';\r\n    else if (isX(p))\r\n      if (M === '0') ret = '>=' + M + '.' + m + '.0-0 <' + M + '.' + (+m + 1) + '.0-0';\r\n      else ret = '>=' + M + '.' + m + '.0-0 <' + (+M + 1) + '.0.0-0';\r\n    else if (pr) {\r\n      ;\r\n      if (pr.charAt(0) !== '-')\r\n        pr = '-' + pr;\r\n      if (M === '0')\r\n        if (m === '0') ret = '=' + M + '.' + m + '.' + p + pr;\r\n        else ret = '>=' + M + '.' + m + '.' + p + pr +\r\n                   ' <' + M + '.' + (+m + 1) + '.0-0';\r\n      else ret = '>=' + M + '.' + m + '.' + p + pr +\r\n                 ' <' + (+M + 1) + '.0.0-0';\r\n    } else\r\n      if (M === '0')\r\n        if (m === '0') ret = '=' + M + '.' + m + '.' + p;\r\n        else ret = '>=' + M + '.' + m + '.' + p + '-0' +\r\n                   ' <' + M + '.' + (+m + 1) + '.0-0';\r\n      else ret = '>=' + M + '.' + m + '.' + p + '-0' +\r\n                 ' <' + (+M + 1) + '.0.0-0';\r\n\r\n    ;\r\n    return ret;\r\n  });\r\n}\r\n\r\nfunction replaceXRanges(comp, loose) {\r\n  ;\r\n  return comp.split(/\\s+/).map(function(comp) {\r\n    return replaceXRange(comp, loose);\r\n  }).join(' ');\r\n}\r\n\r\nfunction replaceXRange(comp, loose) {\r\n  comp = comp.trim();\r\n  var r = loose ? re[XRANGELOOSE] : re[XRANGE];\r\n  return comp.replace(r, function(ret, gtlt, M, m, p, pr) {\r\n    ;\r\n    var xM = isX(M);\r\n    var xm = xM || isX(m);\r\n    var xp = xm || isX(p);\r\n    var anyX = xp;\r\n\r\n    if (gtlt === '=' && anyX)\r\n      gtlt = '';\r\n\r\n    if (gtlt && anyX) {\r\n      // replace X with 0, and then append the -0 min-prerelease\r\n      if (xM)\r\n        M = 0;\r\n      if (xm)\r\n        m = 0;\r\n      if (xp)\r\n        p = 0;\r\n\r\n      if (gtlt === '>') {\r\n        // >1 => >=2.0.0-0\r\n        // >1.2 => >=1.3.0-0\r\n        // >1.2.3 => >= 1.2.4-0\r\n        gtlt = '>=';\r\n        if (xM) {\r\n          // no change\r\n        } else if (xm) {\r\n          M = +M + 1;\r\n          m = 0;\r\n          p = 0;\r\n        } else if (xp) {\r\n          m = +m + 1;\r\n          p = 0;\r\n        }\r\n      }\r\n\r\n\r\n      ret = gtlt + M + '.' + m + '.' + p + '-0';\r\n    } else if (xM) {\r\n      // allow any\r\n      ret = '*';\r\n    } else if (xm) {\r\n      // append '-0' onto the version, otherwise\r\n      // '1.x.x' matches '2.0.0-beta', since the tag\r\n      // *lowers* the version value\r\n      ret = '>=' + M + '.0.0-0 <' + (+M + 1) + '.0.0-0';\r\n    } else if (xp) {\r\n      ret = '>=' + M + '.' + m + '.0-0 <' + M + '.' + (+m + 1) + '.0-0';\r\n    }\r\n\r\n    ;\r\n\r\n    return ret;\r\n  });\r\n}\r\n\r\n// Because * is AND-ed with everything else in the comparator,\r\n// and '' means \"any version\", just remove the *s entirely.\r\nfunction replaceStars(comp, loose) {\r\n  ;\r\n  // Looseness is ignored here.  star is always as loose as it gets!\r\n  return comp.trim().replace(re[STAR], '');\r\n}\r\n\r\n// This function is passed to string.replace(re[HYPHENRANGE])\r\n// M, m, patch, prerelease, build\r\n// 1.2 - 3.4.5 => >=1.2.0-0 <=3.4.5\r\n// 1.2.3 - 3.4 => >=1.2.0-0 <3.5.0-0 Any 3.4.x will do\r\n// 1.2 - 3.4 => >=1.2.0-0 <3.5.0-0\r\nfunction hyphenReplace($0,\r\n                       from, fM, fm, fp, fpr, fb,\r\n                       to, tM, tm, tp, tpr, tb) {\r\n\r\n  if (isX(fM))\r\n    from = '';\r\n  else if (isX(fm))\r\n    from = '>=' + fM + '.0.0-0';\r\n  else if (isX(fp))\r\n    from = '>=' + fM + '.' + fm + '.0-0';\r\n  else\r\n    from = '>=' + from;\r\n\r\n  if (isX(tM))\r\n    to = '';\r\n  else if (isX(tm))\r\n    to = '<' + (+tM + 1) + '.0.0-0';\r\n  else if (isX(tp))\r\n    to = '<' + tM + '.' + (+tm + 1) + '.0-0';\r\n  else if (tpr)\r\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;\r\n  else\r\n    to = '<=' + to;\r\n\r\n  return (from + ' ' + to).trim();\r\n}\r\n\r\n\r\n// if ANY of the sets match ALL of its comparators, then pass\r\nRange.prototype.test = function(version) {\r\n  if (!version)\r\n    return false;\r\n  for (var i = 0; i < this.set.length; i++) {\r\n    if (testSet(this.set[i], version))\r\n      return true;\r\n  }\r\n  return false;\r\n};\r\n\r\nfunction testSet(set, version) {\r\n  for (var i = 0; i < set.length; i++) {\r\n    if (!set[i].test(version))\r\n      return false;\r\n  }\r\n  return true;\r\n}\r\n\r\nexports.satisfies = satisfies;\r\nfunction satisfies(version, range, loose) {\r\n  try {\r\n    range = new Range(range, loose);\r\n  } catch (er) {\r\n    return false;\r\n  }\r\n  return range.test(version);\r\n}\r\n\r\nexports.maxSatisfying = maxSatisfying;\r\nfunction maxSatisfying(versions, range, loose) {\r\n  return versions.filter(function(version) {\r\n    return satisfies(version, range, loose);\r\n  }).sort(function(a, b) {\r\n    return rcompare(a, b, loose);\r\n  })[0] || null;\r\n}\r\n\r\nexports.validRange = validRange;\r\nfunction validRange(range, loose) {\r\n  try {\r\n    // Return '*' instead of '' so that truthiness works.\r\n    // This will throw if it's invalid anyway\r\n    return new Range(range, loose).range || '*';\r\n  } catch (er) {\r\n    return null;\r\n  }\r\n}\r\n\r\n// Use the define() function if we're in AMD land\r\nif (typeof define === 'function' && define.amd)\r\n  define('extensibility/node/node_modules/semver/semver.browser',exports);\r\n\r\n})(\r\n  typeof exports === 'object' ? exports :\r\n  typeof define === 'function' && define.amd ? {} :\r\n  semver = {}\r\n);\r\n\n//# sourceURL=/extensibility/node/node_modules/semver/semver.browser.js"),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, window, $, brackets, semver */\r\n/*unittests: ExtensionManager*/\r\n\r\n/**\r\n * The ExtensionManager fetches/caches the extension registry and provides\r\n * information about the status of installed extensions. ExtensionManager raises the\r\n * following events:\r\n * - statusChange - indicates that an extension has been installed/uninstalled or\r\n *   its status has otherwise changed. Second parameter is the id of the\r\n *   extension.\r\n * - registryUpdate - indicates that an existing extension was synchronized\r\n *   with new data from the registry.\r\n */\r\ndefine(\'extensibility/ExtensionManager\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'file/FileUtils\',\'extensibility/Package\',\'utils/Async\',\'utils/ExtensionLoader\',\'utils/ExtensionUtils\',\'filesystem/FileSystem\',\'strings\',\'utils/StringUtils\',\'view/ThemeManager\',\'extensibility/node/node_modules/semver/semver.browser\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var _                = require("thirdparty/lodash"),\r\n        FileUtils        = require("file/FileUtils"),\r\n        Package          = require("extensibility/Package"),\r\n        Async            = require("utils/Async"),\r\n        ExtensionLoader  = require("utils/ExtensionLoader"),\r\n        ExtensionUtils   = require("utils/ExtensionUtils"),\r\n        FileSystem       = require("filesystem/FileSystem"),\r\n        Strings          = require("strings"),\r\n        StringUtils      = require("utils/StringUtils"),\r\n        ThemeManager     = require("view/ThemeManager");\r\n\r\n    // semver.browser is an AMD-compatible module\r\n    var semver = require("extensibility/node/node_modules/semver/semver.browser");\r\n\r\n    /**\r\n     * @private\r\n     * @type {$.Deferred} Keeps track of the current registry download so that if a request is already\r\n     * in progress and another request to download the registry comes in, we don\'t send yet another request.\r\n     * This is primarily used when multiple view models need to download the registry at the same time.\r\n     */\r\n    var pendingDownloadRegistry = null;\r\n\r\n    /**\r\n     * Extension status constants.\r\n     */\r\n    var ENABLED      = "enabled",\r\n        START_FAILED = "startFailed";\r\n\r\n    /**\r\n     * Extension location constants.\r\n     */\r\n    var LOCATION_DEFAULT = "default",\r\n        LOCATION_DEV     = "dev",\r\n        LOCATION_USER    = "user",\r\n        LOCATION_UNKNOWN = "unknown";\r\n\r\n    /**\r\n     * @private\r\n     * @type {Object.<string, {metadata: Object, path: string, status: string}>}\r\n     * The set of all known extensions, both from the registry and locally installed.\r\n     * The keys are either "name" from package.json (for extensions that have package metadata)\r\n     * or the last segment of local file paths (for installed legacy extensions\r\n     * with no package metadata). The fields of each record are:\r\n     *     registryInfo: object containing the info for this id from the main registry (containing metadata, owner,\r\n     *         and versions). This will be null for legacy extensions.\r\n     *     installInfo: object containing the info for a locally-installed extension:\r\n     *         metadata: the package metadata loaded from the local package.json, or null if it\'s a legacy extension.\r\n     *             This will be different from registryInfo.metadata if there\'s a newer version in the registry.\r\n     *         path: the local path to the extension folder on disk\r\n     *         locationType: general type of installation; one of the LOCATION_* constants above\r\n     *         status: the current status, one of the status constants above\r\n     */\r\n    var extensions = {};\r\n\r\n    /**\r\n     * Requested changes to the installed extensions.\r\n     */\r\n    var _idsToRemove = [],\r\n        _idsToUpdate = [];\r\n\r\n    /**\r\n     * @private\r\n     * Synchronizes the information between the public registry and the installed\r\n     * extensions. Specifically, this makes the `owner` available in each and sets\r\n     * an `updateAvailable` flag.\r\n     *\r\n     * @param {string} id of the extension to synchronize\r\n     */\r\n    function synchronizeEntry(id) {\r\n        var entry = extensions[id];\r\n\r\n        // Do nothing if we only have one set of data\r\n        if (!entry || !entry.installInfo || !entry.registryInfo) {\r\n            return;\r\n        }\r\n\r\n        entry.installInfo.owner = entry.registryInfo.owner;\r\n\r\n        // Assume false\r\n        entry.installInfo.updateAvailable   = false;\r\n        entry.registryInfo.updateAvailable  = false;\r\n        entry.installInfo.updateCompatible  = false;\r\n        entry.registryInfo.updateCompatible = false;\r\n\r\n        var currentVersion = entry.installInfo.metadata ? entry.installInfo.metadata.version : null;\r\n        if (currentVersion && semver.lt(currentVersion, entry.registryInfo.metadata.version)) {\r\n            // Note: available update may still be incompatible; we check for this when rendering the Update button in ExtensionManagerView._renderItem()\r\n            entry.registryInfo.updateAvailable  = true;\r\n            entry.installInfo.updateAvailable   = true;\r\n            // Calculate updateCompatible to check if there\'s an update for current version of Brackets\r\n            var lastCompatibleVersionInfo = _.findLast(entry.registryInfo.versions, function (versionInfo) {\r\n                return semver.satisfies(brackets.metadata.apiVersion, versionInfo.brackets);\r\n            });\r\n            if (lastCompatibleVersionInfo && lastCompatibleVersionInfo.version && semver.lt(currentVersion, lastCompatibleVersionInfo.version)) {\r\n                entry.installInfo.updateCompatible        = true;\r\n                entry.registryInfo.updateCompatible       = true;\r\n                entry.installInfo.lastCompatibleVersion   = lastCompatibleVersionInfo.version;\r\n                entry.registryInfo.lastCompatibleVersion  = lastCompatibleVersionInfo.version;\r\n            }\r\n        }\r\n\r\n        $(exports).triggerHandler("registryUpdate", [id]);\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Verifies if an extension is a theme based on the presence of the field "theme"\r\n     * in the package.json.  If it is a theme, then the theme file is just loaded by the\r\n     * ThemeManager\r\n     *\r\n     * @param {string} id of the theme extension to load\r\n     */\r\n    function loadTheme(id) {\r\n        var extension = extensions[id];\r\n        if (extension.installInfo && extension.installInfo.metadata && extension.installInfo.metadata.theme) {\r\n            ThemeManager.loadPackage(extension.installInfo);\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * Sets our data. For unit testing only.\r\n     */\r\n    function _setExtensions(newExtensions) {\r\n        exports.extensions = extensions = newExtensions;\r\n        Object.keys(extensions).forEach(function (id) {\r\n            synchronizeEntry(id);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Clears out our existing data. For unit testing only.\r\n     */\r\n    function _reset() {\r\n        exports.extensions = extensions = {};\r\n        _idsToRemove = [];\r\n        _idsToUpdate = [];\r\n    }\r\n\r\n    /**\r\n     * Downloads the registry of Brackets extensions and stores the information in our\r\n     * extension info.\r\n     *\r\n     * @return {$.Promise} a promise that\'s resolved with the registry JSON data\r\n     * or rejected if the server can\'t be reached.\r\n     */\r\n    function downloadRegistry() {\r\n        if (pendingDownloadRegistry) {\r\n            return pendingDownloadRegistry.promise();\r\n        }\r\n\r\n        pendingDownloadRegistry = new $.Deferred();\r\n\r\n        $.ajax({\r\n            url: brackets.config.extension_registry,\r\n            dataType: "json",\r\n            cache: false\r\n        })\r\n            .done(function (data) {\r\n                Object.keys(data).forEach(function (id) {\r\n                    if (!extensions[id]) {\r\n                        extensions[id] = {};\r\n                    }\r\n                    extensions[id].registryInfo = data[id];\r\n                    synchronizeEntry(id);\r\n                });\r\n                $(exports).triggerHandler("registryDownload");\r\n                pendingDownloadRegistry.resolve();\r\n            })\r\n            .fail(function () {\r\n                pendingDownloadRegistry.reject();\r\n            })\r\n            .always(function () {\r\n                // Make sure to clean up the pending registry so that new requests can be made.\r\n                pendingDownloadRegistry = null;\r\n            });\r\n\r\n        return pendingDownloadRegistry.promise();\r\n    }\r\n\r\n\r\n    /**\r\n     * @private\r\n     * When an extension is loaded, fetches the package.json and stores the extension in our map.\r\n     * @param {$.Event} e The event object\r\n     * @param {string} path The local path of the loaded extension\'s folder.\r\n     */\r\n    function _handleExtensionLoad(e, path) {\r\n        function setData(id, metadata) {\r\n            var locationType,\r\n                userExtensionPath = ExtensionLoader.getUserExtensionPath();\r\n            if (path.indexOf(userExtensionPath) === 0) {\r\n                locationType = LOCATION_USER;\r\n            } else {\r\n                var segments = path.split("/"), parent;\r\n                if (segments.length > 2) {\r\n                    parent = segments[segments.length - 2];\r\n                }\r\n                if (parent === "dev") {\r\n                    locationType = LOCATION_DEV;\r\n                } else if (parent === "default") {\r\n                    locationType = LOCATION_DEFAULT;\r\n                } else {\r\n                    locationType = LOCATION_UNKNOWN;\r\n                }\r\n            }\r\n            if (!extensions[id]) {\r\n                extensions[id] = {};\r\n            }\r\n            extensions[id].installInfo = {\r\n                metadata: metadata,\r\n                path: path,\r\n                locationType: locationType,\r\n                status: (e.type === "loadFailed" ? START_FAILED : ENABLED)\r\n            };\r\n            synchronizeEntry(id);\r\n            loadTheme(id);\r\n            $(exports).triggerHandler("statusChange", [id]);\r\n        }\r\n\r\n        ExtensionUtils.loadPackageJson(path)\r\n            .done(function (metadata) {\r\n                setData(metadata.name, metadata);\r\n            })\r\n            .fail(function () {\r\n                // If there\'s no package.json, this is a legacy extension. It was successfully loaded,\r\n                // but we don\'t have an official ID or metadata for it, so we just create an id and\r\n                // "title" for it (which is the last segment of its pathname)\r\n                // and record that it\'s enabled.\r\n                var match = path.match(/\\/([^\\/]+)$/),\r\n                    name = (match && match[1]) || path,\r\n                    metadata = { name: name, title: name };\r\n                setData(name, metadata);\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Determines if the given versions[] entry is compatible with the given Brackets API version, and if not\r\n     * specifies why.\r\n     * @param {Object} extVersion\r\n     * @param {string} apiVersion\r\n     * @return {{isCompatible: boolean, requiresNewer: ?boolean, compatibleVersion: ?string}}\r\n     */\r\n    function getCompatibilityInfoForVersion(extVersion, apiVersion) {\r\n        var requiredVersion = (extVersion.brackets || (extVersion.engines && extVersion.engines.brackets)),\r\n            result = {};\r\n        result.isCompatible = !requiredVersion || semver.satisfies(apiVersion, requiredVersion);\r\n        if (result.isCompatible) {\r\n            result.compatibleVersion = extVersion.version;\r\n        } else {\r\n            // Find out reason for incompatibility\r\n            if (requiredVersion.charAt(0) === \'<\') {\r\n                result.requiresNewer = false;\r\n            } else if (requiredVersion.charAt(0) === \'>\') {\r\n                result.requiresNewer = true;\r\n            } else if (requiredVersion.charAt(0) === "~") {\r\n                var compareVersion = requiredVersion.slice(1);\r\n                // Need to add .0s to this style of range in order to compare (since valid version\r\n                // numbers must have major/minor/patch).\r\n                if (compareVersion.match(/^[0-9]+$/)) {\r\n                    compareVersion += ".0.0";\r\n                } else if (compareVersion.match(/^[0-9]+\\.[0-9]+$/)) {\r\n                    compareVersion += ".0";\r\n                }\r\n                result.requiresNewer = semver.lt(apiVersion, compareVersion);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Finds the newest version of the entry that is compatible with the given Brackets API version, if any.\r\n     * @param {Object} entry The registry entry to check.\r\n     * @param {string} apiVersion The Brackets API version to check against.\r\n     * @return {{isCompatible: boolean, requiresNewer: ?boolean, compatibleVersion: ?string, isLatestVersion: boolean}}\r\n     *      Result contains an "isCompatible" member saying whether it\'s compatible. If compatible, "compatibleVersion"\r\n     *      specifies the newest version that is compatible and "isLatestVersion" indicates if this is the absolute\r\n     *      latest version of the extension or not. If !isCompatible or !isLatestVersion, "requiresNewer" says whether\r\n     *      the latest version is incompatible due to requiring a newer (vs. older) version of Brackets.\r\n     */\r\n    function getCompatibilityInfo(entry, apiVersion) {\r\n        if (!entry.versions) {\r\n            var fallback = getCompatibilityInfoForVersion(entry.metadata, apiVersion);\r\n            if (fallback.isCompatible) {\r\n                fallback.isLatestVersion = true;\r\n            }\r\n            return fallback;\r\n        }\r\n\r\n        var i = entry.versions.length - 1,\r\n            latestInfo = getCompatibilityInfoForVersion(entry.versions[i], apiVersion);\r\n\r\n        if (latestInfo.isCompatible) {\r\n            latestInfo.isLatestVersion = true;\r\n            return latestInfo;\r\n        } else {\r\n            // Look at earlier versions (skipping very latest version since we already checked it)\r\n            for (i--; i >= 0; i--) {\r\n                var compatInfo = getCompatibilityInfoForVersion(entry.versions[i], apiVersion);\r\n                if (compatInfo.isCompatible) {\r\n                    compatInfo.isLatestVersion = false;\r\n                    compatInfo.requiresNewer = latestInfo.requiresNewer;\r\n                    return compatInfo;\r\n                }\r\n            }\r\n\r\n            // No version is compatible, so just return info for the latest version\r\n            return latestInfo;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Given an extension id and version number, returns the URL for downloading that extension from\r\n     * the repository. Does not guarantee that the extension exists at that URL.\r\n     * @param {string} id The extension\'s name from the metadata.\r\n     * @param {string} version The version to download.\r\n     * @return {string} The URL to download the extension from.\r\n     */\r\n    function getExtensionURL(id, version) {\r\n        return StringUtils.format(brackets.config.extension_url, id, version);\r\n    }\r\n\r\n    /**\r\n     * Removes the installed extension with the given id.\r\n     * @param {string} id The id of the extension to remove.\r\n     * @return {$.Promise} A promise that\'s resolved when the extension is removed or\r\n     *     rejected with an error if there\'s a problem with the removal.\r\n     */\r\n    function remove(id) {\r\n        var result = new $.Deferred();\r\n        if (extensions[id] && extensions[id].installInfo) {\r\n            Package.remove(extensions[id].installInfo.path)\r\n                .done(function () {\r\n                    extensions[id].installInfo = null;\r\n                    result.resolve();\r\n                    $(exports).triggerHandler("statusChange", [id]);\r\n                })\r\n                .fail(function (err) {\r\n                    result.reject(err);\r\n                });\r\n        } else {\r\n            result.reject(StringUtils.format(Strings.EXTENSION_NOT_INSTALLED, id));\r\n        }\r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * Updates an installed extension with the given package file.\r\n     * @param {string} id of the extension\r\n     * @param {string} packagePath path to the package file\r\n     * @param {boolean=} keepFile Flag to keep extension package file, default=false\r\n     * @return {$.Promise} A promise that\'s resolved when the extension is updated or\r\n     *     rejected with an error if there\'s a problem with the update.\r\n     */\r\n    function update(id, packagePath, keepFile) {\r\n        return Package.installUpdate(packagePath, id).done(function () {\r\n            if (!keepFile) {\r\n                FileSystem.getFileForPath(packagePath).unlink();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Deletes any temporary files left behind by extensions that\r\n     * were marked for update.\r\n     */\r\n    function cleanupUpdates() {\r\n        Object.keys(_idsToUpdate).forEach(function (id) {\r\n            var installResult = _idsToUpdate[id],\r\n                keepFile = installResult.keepFile,\r\n                filename = installResult.localPath;\r\n\r\n            if (filename && !keepFile) {\r\n                FileSystem.getFileForPath(filename).unlink();\r\n            }\r\n        });\r\n        _idsToUpdate = {};\r\n    }\r\n\r\n    /**\r\n     * Unmarks all extensions marked for removal.\r\n     */\r\n    function unmarkAllForRemoval() {\r\n        _idsToRemove = {};\r\n    }\r\n\r\n    /**\r\n     * Marks an extension for later removal, or unmarks an extension previously marked.\r\n     * @param {string} id The id of the extension to mark for removal.\r\n     * @param {boolean} mark Whether to mark or unmark it.\r\n     */\r\n    function markForRemoval(id, mark) {\r\n        if (mark) {\r\n            _idsToRemove[id] = true;\r\n        } else {\r\n            delete _idsToRemove[id];\r\n        }\r\n        $(exports).triggerHandler("statusChange", [id]);\r\n    }\r\n\r\n    /**\r\n     * Returns true if an extension is marked for removal.\r\n     * @param {string} id The id of the extension to check.\r\n     * @return {boolean} true if it\'s been marked for removal, false otherwise.\r\n     */\r\n    function isMarkedForRemoval(id) {\r\n        return !!(_idsToRemove[id]);\r\n    }\r\n\r\n    /**\r\n     * Returns true if there are any extensions marked for removal.\r\n     * @return {boolean} true if there are extensions to remove\r\n     */\r\n    function hasExtensionsToRemove() {\r\n        return Object.keys(_idsToRemove).length > 0;\r\n    }\r\n\r\n    /**\r\n     * If a downloaded package appears to be an update, mark the extension for update.\r\n     * If an extension was previously marked for removal, marking for update will\r\n     * turn off the removal mark.\r\n     * @param {Object} installationResult info about the install provided by the Package.download function\r\n     */\r\n    function updateFromDownload(installationResult) {\r\n        if (installationResult.keepFile === undefined) {\r\n            installationResult.keepFile = false;\r\n        }\r\n\r\n        var installationStatus = installationResult.installationStatus;\r\n        if (installationStatus === Package.InstallationStatuses.ALREADY_INSTALLED ||\r\n                installationStatus === Package.InstallationStatuses.NEEDS_UPDATE ||\r\n                installationStatus === Package.InstallationStatuses.SAME_VERSION ||\r\n                installationStatus === Package.InstallationStatuses.OLDER_VERSION) {\r\n            var id = installationResult.name;\r\n            delete _idsToRemove[id];\r\n            _idsToUpdate[id] = installationResult;\r\n            $(exports).triggerHandler("statusChange", [id]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the mark for an extension to be updated on restart. Also deletes the\r\n     * downloaded package file.\r\n     * @param {string} id The id of the extension for which the update is being removed\r\n     */\r\n    function removeUpdate(id) {\r\n        var installationResult = _idsToUpdate[id];\r\n        if (!installationResult) {\r\n            return;\r\n        }\r\n        if (installationResult.localPath && !installationResult.keepFile) {\r\n            FileSystem.getFileForPath(installationResult.localPath).unlink();\r\n        }\r\n        delete _idsToUpdate[id];\r\n        $(exports).triggerHandler("statusChange", [id]);\r\n    }\r\n\r\n    /**\r\n     * Returns true if an extension is marked for update.\r\n     * @param {string} id The id of the extension to check.\r\n     * @return {boolean} true if it\'s been marked for update, false otherwise.\r\n     */\r\n    function isMarkedForUpdate(id) {\r\n        return !!(_idsToUpdate[id]);\r\n    }\r\n\r\n    /**\r\n     * Returns true if there are any extensions marked for update.\r\n     * @return {boolean} true if there are extensions to update\r\n     */\r\n    function hasExtensionsToUpdate() {\r\n        return Object.keys(_idsToUpdate).length > 0;\r\n    }\r\n\r\n    /**\r\n     * Removes extensions previously marked for removal.\r\n     * @return {$.Promise} A promise that\'s resolved when all extensions are removed, or rejected\r\n     *     if one or more extensions can\'t be removed. When rejected, the argument will be an\r\n     *     array of error objects, each of which contains an "item" property with the id of the\r\n     *     failed extension and an "error" property with the actual error.\r\n     */\r\n    function removeMarkedExtensions() {\r\n        return Async.doInParallel_aggregateErrors(\r\n            Object.keys(_idsToRemove),\r\n            function (id) {\r\n                return remove(id);\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Updates extensions previously marked for update.\r\n     * @return {$.Promise} A promise that\'s resolved when all extensions are updated, or rejected\r\n     *     if one or more extensions can\'t be updated. When rejected, the argument will be an\r\n     *     array of error objects, each of which contains an "item" property with the id of the\r\n     *     failed extension and an "error" property with the actual error.\r\n     */\r\n    function updateExtensions() {\r\n        return Async.doInParallel_aggregateErrors(\r\n            Object.keys(_idsToUpdate),\r\n            function (id) {\r\n                var installationResult = _idsToUpdate[id];\r\n                return update(installationResult.name, installationResult.localPath, installationResult.keepFile);\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Gets an array of extensions that are currently installed and can be updated to a new version\r\n     * @return {Array.<{id: string, installVersion: string, registryVersion: string}>}\r\n     *     where id = extensionId\r\n     *     installVersion = currently installed version of extension\r\n     *     registryVersion = latest version compatible with current Brackets\r\n     */\r\n    function getAvailableUpdates() {\r\n        var result = [];\r\n        Object.keys(extensions).forEach(function (extensionId) {\r\n            var extensionInfo = extensions[extensionId];\r\n            // skip extensions that are not installed or are not in the registry\r\n            if (!extensionInfo.installInfo || !extensionInfo.registryInfo) {\r\n                return;\r\n            }\r\n            if (extensionInfo.registryInfo.updateCompatible) {\r\n                result.push({\r\n                    id: extensionId,\r\n                    installVersion: extensionInfo.installInfo.metadata.version,\r\n                    registryVersion: extensionInfo.registryInfo.lastCompatibleVersion\r\n                });\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Takes the array returned from getAvailableUpdates() as an input and removes those entries\r\n     * that are no longer current - when currently installed version of an extension\r\n     * is equal or newer than registryVersion returned by getAvailableUpdates().\r\n     * This function is designed to work without the necessity to download extension registry\r\n     * @param {Array.<{id: string, installVersion: string, registryVersion: string}>} updates\r\n     *     previous output of getAvailableUpdates()\r\n     * @return {Array.<{id: string, installVersion: string, registryVersion: string}>}\r\n     *     filtered input as function description\r\n     */\r\n    function cleanAvailableUpdates(updates) {\r\n        return updates.reduce(function (arr, updateInfo) {\r\n            var extDefinition = extensions[updateInfo.id];\r\n            if (!extDefinition || !extDefinition.installInfo) {\r\n                // extension has been uninstalled in the meantime\r\n                return arr;\r\n            }\r\n\r\n            var installedVersion = extDefinition.installInfo.metadata.version;\r\n            if (semver.lt(installedVersion, updateInfo.registryVersion)) {\r\n                arr.push(updateInfo);\r\n            }\r\n\r\n            return arr;\r\n        }, []);\r\n    }\r\n\r\n    // Listen to extension load and loadFailed events\r\n    $(ExtensionLoader)\r\n        .on("load", _handleExtensionLoad)\r\n        .on("loadFailed", _handleExtensionLoad);\r\n\r\n    // Public exports\r\n    exports.downloadRegistry        = downloadRegistry;\r\n    exports.getCompatibilityInfo    = getCompatibilityInfo;\r\n    exports.getExtensionURL         = getExtensionURL;\r\n    exports.remove                  = remove;\r\n    exports.update                  = update;\r\n    exports.extensions              = extensions;\r\n    exports.cleanupUpdates          = cleanupUpdates;\r\n    exports.markForRemoval          = markForRemoval;\r\n    exports.isMarkedForRemoval      = isMarkedForRemoval;\r\n    exports.unmarkAllForRemoval     = unmarkAllForRemoval;\r\n    exports.hasExtensionsToRemove   = hasExtensionsToRemove;\r\n    exports.updateFromDownload      = updateFromDownload;\r\n    exports.removeUpdate            = removeUpdate;\r\n    exports.isMarkedForUpdate       = isMarkedForUpdate;\r\n    exports.hasExtensionsToUpdate   = hasExtensionsToUpdate;\r\n    exports.removeMarkedExtensions  = removeMarkedExtensions;\r\n    exports.updateExtensions        = updateExtensions;\r\n    exports.getAvailableUpdates     = getAvailableUpdates;\r\n    exports.cleanAvailableUpdates   = cleanAvailableUpdates;\r\n    exports.ENABLED       = ENABLED;\r\n    exports.START_FAILED  = START_FAILED;\r\n\r\n    exports.LOCATION_DEFAULT  = LOCATION_DEFAULT;\r\n    exports.LOCATION_DEV      = LOCATION_DEV;\r\n    exports.LOCATION_USER     = LOCATION_USER;\r\n    exports.LOCATION_UNKNOWN  = LOCATION_UNKNOWN;\r\n\r\n    // For unit testing only\r\n    exports._reset          = _reset;\r\n    exports._setExtensions  = _setExtensions;\r\n});\r\n\n//# sourceURL=/extensibility/ExtensionManager.js'),eval('define(\'text!htmlContent/update-dialog.html\',[],function () { return \'<div class="update-dialog modal">\\r\\n    <div class="modal-header">\\r\\n        <h1 class="dialog-title">{{UPDATE_AVAILABLE_TITLE}}</h1>\\r\\n    </div>\\r\\n    <div class="modal-body no-padding">\\r\\n        <img class="update-icon" src="styles/images/update_large_icon.svg">\\r\\n        <div class="update-text">\\r\\n            <p class="dialog-message">{{UPDATE_MESSAGE}}</p>\\r\\n            <div class="update-info">\\r\\n            </div>\\r\\n        </div>\\r\\n    </div>\\r\\n    <div class="modal-footer">\\r\\n        <button class="dialog-button btn left" data-button-id="cancel">{{CANCEL}}</button>\\r\\n        <button class="dialog-button btn primary" data-button-id="download">{{GET_IT_NOW}}</button>\\r\\n    </div>\\r\\n</div>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/update-dialog.html'),eval("define('text!htmlContent/update-list.html',[],function () { return '{{#.}}\\r\\n<div>\\r\\n    <h3>{{versionString}} - {{dateString}} (<a href=\"{{releaseNotesURL}}\" title=\"{{releaseNotesURL}}\">{{Strings.RELEASE_NOTES}}</a>)</h3>\\r\\n    <ul>\\r\\n        {{#newFeatures}}\\r\\n        <li><b>{{name}}</b> - {{description}}</li>\\r\\n        {{/newFeatures}}\\r\\n    </ul>\\r\\n</div>\\r\\n{{/.}}';});\n\n//# sourceURL=/text!htmlContent/update-list.html"),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets, PathUtils, window, Mustache */\r\n\r\n/**\r\n *  Utilities functions for displaying update notifications\r\n *\r\n */\r\ndefine(\'utils/UpdateNotification\',[\'require\',\'exports\',\'module\',\'widgets/Dialogs\',\'widgets/DefaultDialogs\',\'extensibility/ExtensionManager\',\'preferences/PreferencesManager\',\'utils/Global\',\'utils/NativeApp\',\'utils/StringUtils\',\'strings\',\'text!htmlContent/update-dialog.html\',\'text!htmlContent/update-list.html\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var Dialogs              = require("widgets/Dialogs"),\r\n        DefaultDialogs       = require("widgets/DefaultDialogs"),\r\n        ExtensionManager     = require("extensibility/ExtensionManager"),\r\n        PreferencesManager   = require("preferences/PreferencesManager"),\r\n        Global               = require("utils/Global"),\r\n        NativeApp            = require("utils/NativeApp"),\r\n        StringUtils          = require("utils/StringUtils"),\r\n        Strings              = require("strings"),\r\n        UpdateDialogTemplate = require("text!htmlContent/update-dialog.html"),\r\n        UpdateListTemplate   = require("text!htmlContent/update-list.html");\r\n    \r\n    // duration of one day in milliseconds\r\n    var ONE_DAY = 1000 * 60 * 60 * 24;\r\n\r\n    // duration of two minutes in milliseconds\r\n    var TWO_MINUTES = 1000 * 60 * 2;\r\n\r\n    // Extract current build number from package.json version field 0.0.0-0\r\n    var _buildNumber = Number(/-([0-9]+)/.exec(brackets.metadata.version)[1]);\r\n    \r\n    // Init default last build number\r\n    PreferencesManager.stateManager.definePreference("lastNotifiedBuildNumber", "number", 0);\r\n    \r\n    // Init default last info URL fetch time\r\n    PreferencesManager.stateManager.definePreference("lastInfoURLFetchTime", "number", 0);\r\n    \r\n    // Time of last registry check for update\r\n    PreferencesManager.stateManager.definePreference("lastExtensionRegistryCheckTime", "number", 0);\r\n    // Data about available updates in the registry\r\n    PreferencesManager.stateManager.definePreference("extensionUpdateInfo", "Array", []);\r\n\r\n    PreferencesManager.convertPreferences(module, {\r\n        "lastNotifiedBuildNumber": "user",\r\n        "lastInfoURLFetchTime": "user",\r\n        "updateInfo": "user"\r\n    }, true);\r\n    \r\n    // URL to load version info from. By default this is loaded no more than once a day. If\r\n    // you force an update check it is always loaded.\r\n    \r\n    // Information on all posted builds of Brackets. This is an Array, where each element is\r\n    // an Object with the following fields:\r\n    //\r\n    //  {Number} buildNumber Number of the build\r\n    //  {String} versionString String representation of the build number (ie "Release 0.40")\r\n    //  {String} dateString Date of the build\r\n    //  {String} releaseNotesURL URL of the release notes for this build\r\n    //  {String} downloadURL URL to download this build\r\n    //  {Array} newFeatures Array of new features in this build. Each entry has two fields:\r\n    //      {String} name Name of the feature\r\n    //      {String} description Description of the feature\r\n    //\r\n    // This array must be reverse sorted by buildNumber (newest build info first)\r\n    \r\n    /**\r\n     * @private\r\n     * Flag that indicates if we\'ve added a click handler to the update notification icon.\r\n     */\r\n    var _addedClickHandler = false;\r\n\r\n    /**\r\n     * Construct a new version update url with the given locale.\r\n     *\r\n     * @param {string=} locale - optional locale, defaults to \'brackets.getLocale()\' when omitted.\r\n     * @param {boolean=} removeCountryPartOfLocale - optional, remove existing country information from locale \'en-gb\' => \'en\'\r\n     * return {string} the new version update url\r\n     */\r\n    function _getVersionInfoUrl(locale, removeCountryPartOfLocale) {\r\n        locale = locale || brackets.getLocale();\r\n\r\n        if (removeCountryPartOfLocale) {\r\n            locale = locale.substring(0, 2);\r\n        }\r\n\r\n        return brackets.config.update_info_url + locale + ".json";\r\n    }\r\n\r\n    /**\r\n     * Get a data structure that has information for all builds of Brackets.\r\n     *\r\n     * If force is true, the information is always fetched from _versionInfoURL.\r\n     * If force is false, we try to use cached information. If more than\r\n     * 24 hours have passed since the last fetch, or if cached data can\'t be found,\r\n     * the data is fetched again.\r\n     *\r\n     * If new data is fetched and dontCache is false, the data is saved in preferences\r\n     * for quick fetching later.\r\n     * _versionInfoUrl is used for unit testing.\r\n     */\r\n    function _getUpdateInformation(force, dontCache, _versionInfoUrl) {\r\n        // Last time the versionInfoURL was fetched\r\n        var lastInfoURLFetchTime = PreferencesManager.getViewState("lastInfoURLFetchTime");\r\n\r\n        var result = new $.Deferred();\r\n        var fetchData = false;\r\n        var data;\r\n        \r\n        // If force is true, always fetch\r\n        if (force) {\r\n            fetchData = true;\r\n        }\r\n        \r\n        // If we don\'t have data saved in prefs, fetch\r\n        data = PreferencesManager.getViewState("updateInfo");\r\n        if (!data) {\r\n            fetchData = true;\r\n        }\r\n        \r\n        // If more than 24 hours have passed since our last fetch, fetch again\r\n        if ((new Date()).getTime() > lastInfoURLFetchTime + ONE_DAY) {\r\n            fetchData = true;\r\n        }\r\n        \r\n        if (fetchData) {\r\n            var lookupPromise = new $.Deferred(),\r\n                localVersionInfoUrl;\r\n\r\n            // If the current locale isn\'t "en" or "en-US", check whether we actually have a\r\n            //   locale-specific update notification, and fall back to "en" if not.\r\n            // Note: we check for both "en" and "en-US" to watch for the general case or\r\n            //    country-specific English locale.  The former appears default on Mac, while\r\n            //    the latter appears default on Windows.\r\n            var locale = brackets.getLocale().toLowerCase();\r\n            if (locale !== "en" && locale !== "en-us") {\r\n                localVersionInfoUrl = _versionInfoUrl || _getVersionInfoUrl();\r\n                $.ajax({\r\n                    url: localVersionInfoUrl,\r\n                    cache: false,\r\n                    type: "HEAD"\r\n                }).fail(function (jqXHR, status, error) {\r\n                    // get rid of any country information from locale and try again\r\n                    var tmpUrl = _getVersionInfoUrl(brackets.getLocale(), true);\r\n                    if (tmpUrl !== localVersionInfoUrl) {\r\n                        $.ajax({\r\n                            url: tmpUrl,\r\n                            cache: false,\r\n                            type: "HEAD"\r\n                        }).fail(function (jqXHR, status, error) {\r\n                            localVersionInfoUrl = _getVersionInfoUrl("en");\r\n                        }).done(function (jqXHR, status, error) {\r\n                            localVersionInfoUrl = tmpUrl;\r\n                        }).always(function (jqXHR, status, error) {\r\n                            lookupPromise.resolve();\r\n                        });\r\n                    } else {\r\n                        localVersionInfoUrl = _getVersionInfoUrl("en");\r\n                        lookupPromise.resolve();\r\n                    }\r\n                }).done(function (jqXHR, status, error) {\r\n                    lookupPromise.resolve();\r\n                });\r\n            } else {\r\n                localVersionInfoUrl = _versionInfoUrl || _getVersionInfoUrl("en");\r\n                lookupPromise.resolve();\r\n            }\r\n\r\n            lookupPromise.done(function () {\r\n                $.ajax({\r\n                    url: localVersionInfoUrl,\r\n                    dataType: "json",\r\n                    cache: false\r\n                }).done(function (updateInfo, textStatus, jqXHR) {\r\n                    if (!dontCache) {\r\n                        lastInfoURLFetchTime = (new Date()).getTime();\r\n                        PreferencesManager.setViewState("lastInfoURLFetchTime", lastInfoURLFetchTime);\r\n                        PreferencesManager.setViewState("updateInfo", updateInfo);\r\n                    }\r\n                    result.resolve(updateInfo);\r\n                }).fail(function (jqXHR, status, error) {\r\n                    // When loading data for unit tests, the error handler is\r\n                    // called but the responseText is valid. Try to use it here,\r\n                    // but *don\'t* save the results in prefs.\r\n\r\n                    if (!jqXHR.responseText) {\r\n                        // Text is NULL or empty string, reject().\r\n                        result.reject();\r\n                        return;\r\n                    }\r\n\r\n                    try {\r\n                        data = JSON.parse(jqXHR.responseText);\r\n                        result.resolve(data);\r\n                    } catch (e) {\r\n                        result.reject();\r\n                    }\r\n                });\r\n            });\r\n        } else {\r\n            result.resolve(data);\r\n        }\r\n\r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Return a new array of version information that is newer than "buildNumber".\r\n     * Returns null if there is no new version information.\r\n     */\r\n    function _stripOldVersionInfo(versionInfo, buildNumber) {\r\n        // Do a simple linear search. Since we are going in reverse-chronological order, we\r\n        // should get through the search quickly.\r\n        var lastIndex = 0;\r\n        var len = versionInfo.length;\r\n        \r\n        while (lastIndex < len) {\r\n            if (versionInfo[lastIndex].buildNumber <= buildNumber) {\r\n                break;\r\n            }\r\n            lastIndex++;\r\n        }\r\n        \r\n        if (lastIndex > 0) {\r\n            return versionInfo.slice(0, lastIndex);\r\n        }\r\n        \r\n        // No new version info\r\n        return null;\r\n    }\r\n    \r\n    /**\r\n     * Show a dialog that shows the update\r\n     */\r\n    function _showUpdateNotificationDialog(updates) {\r\n        Dialogs.showModalDialogUsingTemplate(Mustache.render(UpdateDialogTemplate, Strings))\r\n            .done(function (id) {\r\n                if (id === Dialogs.DIALOG_BTN_DOWNLOAD) {\r\n                    // The first entry in the updates array has the latest download link\r\n                    NativeApp.openURLInDefaultBrowser(updates[0].downloadURL);\r\n                }\r\n            });\r\n        \r\n        // Populate the update data\r\n        var $dlg        = $(".update-dialog.instance"),\r\n            $updateList = $dlg.find(".update-info");\r\n        \r\n        updates.Strings = Strings;\r\n        $updateList.html(Mustache.render(UpdateListTemplate, updates));\r\n    }\r\n    \r\n    /**\r\n     * Calculate state of notification everytime registries are downloaded - no matter who triggered the download\r\n     */\r\n    function _onRegistryDownloaded() {\r\n        var availableUpdates = ExtensionManager.getAvailableUpdates();\r\n        PreferencesManager.setViewState("extensionUpdateInfo", availableUpdates);\r\n        PreferencesManager.setViewState("lastExtensionRegistryCheckTime", (new Date()).getTime());\r\n        $("#toolbar-extension-manager").toggleClass("updatesAvailable", availableUpdates.length > 0);\r\n    }\r\n\r\n    /**\r\n     *  Every 24 hours downloads registry information to check for update, but only if the registry download\r\n     *  wasn\'t triggered by another action (like opening extension manager)\r\n     *  If there isn\'t 24 hours elapsed from the last download, use cached information from last download\r\n     *  to determine state of the update notification.\r\n     */\r\n    function checkForExtensionsUpdate() {\r\n        var lastExtensionRegistryCheckTime = PreferencesManager.getViewState("lastExtensionRegistryCheckTime"),\r\n            timeOfNextCheck = lastExtensionRegistryCheckTime + ONE_DAY,\r\n            currentTime = (new Date()).getTime();\r\n\r\n        // update icon according to previously saved information\r\n        var availableUpdates = PreferencesManager.getViewState("extensionUpdateInfo");\r\n        availableUpdates = ExtensionManager.cleanAvailableUpdates(availableUpdates);\r\n        $("#toolbar-extension-manager").toggleClass("updatesAvailable", availableUpdates.length > 0);\r\n\r\n        if (availableUpdates.length === 0) {\r\n            // icon is gray, no updates available\r\n            if (currentTime > timeOfNextCheck) {\r\n                // downloadRegistry, will be resolved in _onRegistryDownloaded\r\n                ExtensionManager.downloadRegistry().done(function () {\r\n                    // schedule another check in 24 hours + 2 minutes\r\n                    setTimeout(checkForExtensionsUpdate, ONE_DAY + TWO_MINUTES);\r\n                });\r\n            } else {\r\n                // schedule the download of the registry in appropriate time\r\n                setTimeout(checkForExtensionsUpdate, (timeOfNextCheck - currentTime) + TWO_MINUTES);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check for updates. If "force" is true, update notification dialogs are always displayed\r\n     * (if an update is available). If "force" is false, the update notification is only\r\n     * displayed for newly available updates.\r\n     *\r\n     * If an update is available, show the "update available" notification icon in the title bar.\r\n     *\r\n     * @param {boolean} force If true, always show the notification dialog.\r\n     * @param {Object} _testValues This should only be used for testing purposes. See comments for details.\r\n     * @return {$.Promise} jQuery Promise object that is resolved or rejected after the update check is complete.\r\n     */\r\n    function checkForUpdate(force, _testValues) {\r\n        // This is the last version we notified the user about. If checkForUpdate()\r\n        // is called with "false", only show the update notification dialog if there\r\n        // is an update newer than this one. This value is saved in preferences.\r\n        var lastNotifiedBuildNumber = PreferencesManager.getViewState("lastNotifiedBuildNumber");\r\n\r\n        // The second param, if non-null, is an Object containing value overrides. Values\r\n        // in the object temporarily override the local values. This should *only* be used for testing.\r\n        // If any overrides are set, permanent changes are not made (including showing\r\n        // the update notification icon and saving prefs).\r\n        var oldValues;\r\n        var usingOverrides = false; // true if any of the values are overridden.\r\n        var result = new $.Deferred();\r\n        var versionInfoUrl;\r\n        \r\n        if (_testValues) {\r\n            oldValues = {};\r\n            \r\n            if (_testValues.hasOwnProperty("_buildNumber")) {\r\n                oldValues._buildNumber = _buildNumber;\r\n                _buildNumber = _testValues._buildNumber;\r\n                usingOverrides = true;\r\n            }\r\n\r\n            if (_testValues.hasOwnProperty("lastNotifiedBuildNumber")) {\r\n                oldValues.lastNotifiedBuildNumber = lastNotifiedBuildNumber;\r\n                lastNotifiedBuildNumber = _testValues.lastNotifiedBuildNumber;\r\n                usingOverrides = true;\r\n            }\r\n\r\n            if (_testValues.hasOwnProperty("_versionInfoURL")) {\r\n                versionInfoUrl = _testValues._versionInfoURL;\r\n                usingOverrides = true;\r\n            }\r\n        }\r\n        \r\n        _getUpdateInformation(force || usingOverrides, usingOverrides, versionInfoUrl)\r\n            .done(function (versionInfo) {\r\n                // Get all available updates\r\n                var allUpdates = _stripOldVersionInfo(versionInfo, _buildNumber);\r\n                \r\n                // When running directly from GitHub source (as opposed to\r\n                // an installed build), _buildNumber is 0. In this case, if the\r\n                // test is not forced, don\'t show the update notification icon or\r\n                // dialog.\r\n                if (_buildNumber === 0 && !force) {\r\n                    result.resolve();\r\n                    return;\r\n                }\r\n                \r\n                if (allUpdates) {\r\n                    // Always show the "update available" icon if any updates are available\r\n                    var $updateNotification = $("#update-notification");\r\n                    \r\n                    $updateNotification.css("display", "block");\r\n                    if (!_addedClickHandler) {\r\n                        _addedClickHandler = true;\r\n                        $updateNotification.on("click", function () {\r\n                            checkForUpdate(true);\r\n                        });\r\n                    }\r\n                \r\n                    // Only show the update dialog if force = true, or if the user hasn\'t been\r\n                    // alerted of this update\r\n                    if (force || allUpdates[0].buildNumber >  lastNotifiedBuildNumber) {\r\n                        _showUpdateNotificationDialog(allUpdates);\r\n                        \r\n                        // Update prefs with the last notified build number\r\n                        lastNotifiedBuildNumber = allUpdates[0].buildNumber;\r\n                        // Don\'t save prefs is we have overridden values\r\n                        if (!usingOverrides) {\r\n                            PreferencesManager.setViewState("lastNotifiedBuildNumber", lastNotifiedBuildNumber);\r\n                        }\r\n                    }\r\n                } else if (force) {\r\n                    // No updates are available. If force == true, let the user know.\r\n                    Dialogs.showModalDialog(\r\n                        DefaultDialogs.DIALOG_ID_ERROR,\r\n                        Strings.NO_UPDATE_TITLE,\r\n                        Strings.NO_UPDATE_MESSAGE\r\n                    );\r\n                }\r\n        \r\n                if (oldValues) {\r\n                    if (oldValues.hasOwnProperty("_buildNumber")) {\r\n                        _buildNumber = oldValues._buildNumber;\r\n                    }\r\n                    if (oldValues.hasOwnProperty("lastNotifiedBuildNumber")) {\r\n                        lastNotifiedBuildNumber = oldValues.lastNotifiedBuildNumber;\r\n                    }\r\n                }\r\n                result.resolve();\r\n            })\r\n            .fail(function () {\r\n                // Error fetching the update data. If this is a forced check, alert the user\r\n                if (force) {\r\n                    Dialogs.showModalDialog(\r\n                        DefaultDialogs.DIALOG_ID_ERROR,\r\n                        Strings.ERROR_FETCHING_UPDATE_INFO_TITLE,\r\n                        Strings.ERROR_FETCHING_UPDATE_INFO_MSG\r\n                    );\r\n                }\r\n                result.reject();\r\n            });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * Launches both check for Brackets update and check for installed extensions update\r\n     */\r\n    function launchAutomaticUpdate() {\r\n        // launch immediately and then every 24 hours + 2 minutes\r\n        checkForUpdate();\r\n        checkForExtensionsUpdate();\r\n        window.setInterval(checkForUpdate, ONE_DAY + TWO_MINUTES);\r\n    }\r\n\r\n    // Events listeners\r\n    $(ExtensionManager).on("registryDownload", _onRegistryDownloaded);\r\n\r\n    // Define public API\r\n    exports.launchAutomaticUpdate = launchAutomaticUpdate;\r\n    exports.checkForUpdate        = checkForUpdate;\r\n});\r\n\n//# sourceURL=/utils/UpdateNotification.js'),eval("/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $, brackets, window */\r\n\r\ndefine('LiveDevelopment/Servers/BaseServer',['require','exports','module'],function (require, exports, module) {\r\n    \"use strict\";\r\n\r\n    /**\r\n     * Base class for live preview servers\r\n     *\r\n     * Configuration parameters for this server:\r\n     * - baseUrl      - Optional base URL (populated by the current project)\r\n     * - pathResolver - Function to covert absolute native paths to project relative paths\r\n     * - root         - Native path to the project root (and base URL)\r\n     *\r\n     * @constructor\r\n     * @param {!{baseUrl: string, root: string, pathResolver: function(string): string}} config\r\n     */\r\n    function BaseServer(config) {\r\n        this._baseUrl       = config.baseUrl;\r\n        this._root          = config.root;          // ProjectManager.getProjectRoot().fullPath\r\n        this._pathResolver  = config.pathResolver;  // ProjectManager.makeProjectRelativeIfPossible(doc.file.fullPath)\r\n        this._liveDocuments = {};\r\n    }\r\n\r\n    /**\r\n     * Returns a base url for current project. \r\n     *\r\n     * @return {string}\r\n     * Base url for current project.\r\n     */\r\n    BaseServer.prototype.getBaseUrl = function () {\r\n        return this._baseUrl;\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Augments the given Brackets document with information that's useful for live development\r\n     * @param {Object} liveDocument\r\n     */\r\n    BaseServer.prototype._setDocInfo = function (liveDocument) {\r\n        var parentUrl,\r\n            rootUrl,\r\n            matches,\r\n            doc = liveDocument.doc;\r\n\r\n        // FUTURE: some of these things should just be moved into core Document; others should\r\n        // be in a LiveDevelopment-specific object attached to the doc.\r\n        matches = /^(.*\\/)(.+\\.([^.]+))$/.exec(doc.file.fullPath);\r\n        if (!matches) {\r\n            return;\r\n        }\r\n\r\n        doc.extension = matches[3];\r\n\r\n        parentUrl = this.pathToUrl(matches[1]);\r\n        doc.url = parentUrl + encodeURI(matches[2]);\r\n\r\n        // the root represents the document that should be displayed in the browser\r\n        // for live development (the file for HTML files)\r\n        // TODO: Issue #2033 Improve how default page is determined\r\n        doc.root = { url: doc.url };\r\n\r\n        // TODO: Better workflow of liveDocument.doc.url assignment\r\n        // Force sync the browser after a URL is assigned\r\n        if (doc.isDirty && liveDocument._updateBrowser) {\r\n            liveDocument._updateBrowser();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns a URL for a given path\r\n     * @param {string} path Absolute path to covert to a URL\r\n     * @return {?string} Converts a path within the project root to a URL.\r\n     *  Returns null if the path is not a descendant of the project root.\r\n     */\r\n    BaseServer.prototype.pathToUrl = function (path) {\r\n        var url             = null,\r\n            baseUrl         = this.getBaseUrl(),\r\n            relativePath    = this._pathResolver(path);\r\n\r\n        // See if base url has been specified and path is within project\r\n        if (relativePath !== path) {\r\n            // Map to server url. Base url is already encoded, so don't encode again.\r\n            var encodedDocPath = encodeURI(path);\r\n            var encodedProjectPath = encodeURI(this._root);\r\n\r\n            return encodedDocPath.replace(encodedProjectPath, baseUrl);\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Convert a URL to a local full file path\r\n     * @param {string} url\r\n     * @return {?string} The absolute path for given URL or null if the path is\r\n     *  not a descendant of the project.\r\n     */\r\n    BaseServer.prototype.urlToPath = function (url) {\r\n        var path,\r\n            baseUrl = \"\";\r\n\r\n        baseUrl = this.getBaseUrl();\r\n\r\n        if (baseUrl !== \"\" && url.indexOf(baseUrl) === 0) {\r\n            // Use base url to translate to local file path.\r\n            // Need to use encoded project path because it's decoded below.\r\n            path = url.replace(baseUrl, encodeURI(this._root));\r\n        \r\n            return decodeURI(path);\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Called by LiveDevelopment before to prepare the server before navigating\r\n     * to the project's base URL. The provider returns a jQuery promise.\r\n     * The Live Development launch process waits until the promise\r\n     * is resolved or rejected. If the promise is rejected, an error window\r\n     * is shown and Live Development does not start..\r\n     *\r\n     * @return {jQuery.Promise} Promise that may be asynchronously resolved\r\n     *  when the server is ready to handle HTTP requests.\r\n     */\r\n    BaseServer.prototype.readyToServe = function () {\r\n        // Base implementation always resolves\r\n        return $.Deferred().resolve().promise();\r\n    };\r\n    \r\n    /**\r\n     * Determines if this server can serve local file. LiveDevServerManager\r\n     * calls this method when determining if a server can serve a file.\r\n     * @param {string} localPath A local path to file being served.\r\n     * @return {boolean} true When the file can be served, otherwise false.\r\n     */\r\n    BaseServer.prototype.canServe = function (localPath) {\r\n        return true;\r\n    };\r\n\r\n    BaseServer.prototype._documentKey = function (absolutePath) {\r\n        return \"/\" + encodeURI(this._pathResolver(absolutePath));\r\n    };\r\n\r\n    /**\r\n     * Adds a live document to server\r\n     * @param {Object} liveDocument\r\n     */\r\n    BaseServer.prototype.add = function (liveDocument) {\r\n        if (!liveDocument) {\r\n            return;\r\n        }\r\n        \r\n        // use the project relative path as a key to lookup requests\r\n        var key = this._documentKey(liveDocument.doc.file.fullPath);\r\n        \r\n        this._setDocInfo(liveDocument);\r\n        this._liveDocuments[key] = liveDocument;\r\n    };\r\n\r\n    /**\r\n     * Removes a live document from the server\r\n     * @param {Object} liveDocument\r\n     */\r\n    BaseServer.prototype.remove = function (liveDocument) {\r\n        if (!liveDocument) {\r\n            return;\r\n        }\r\n        \r\n        var key = this._liveDocuments[this._documentKey(liveDocument.doc.file.fullPath)];\r\n        \r\n        if (key) {\r\n            delete this._liveDocuments[key];\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Lookup a live document using it's full path key\r\n     * @param {string} path Absolute path to covert to a URL\r\n     * @param {?Object} liveDocument Returns a live document or undefined if a\r\n     *     document does not exist for the path.\r\n     */\r\n    BaseServer.prototype.get = function (path) {\r\n        return this._liveDocuments[this._documentKey(path)];\r\n    };\r\n\r\n    /**\r\n     * Clears all live documents currently attached to the server\r\n     */\r\n    BaseServer.prototype.clear = function () {\r\n        this._liveDocuments = {};\r\n    };\r\n\r\n    /**\r\n     * Start the server\r\n     */\r\n    BaseServer.prototype.start = function () {\r\n        // do nothing\r\n    };\r\n\r\n    /**\r\n     * Stop the server\r\n     */\r\n    BaseServer.prototype.stop = function () {\r\n        // do nothing\r\n    };\r\n\r\n    exports.BaseServer = BaseServer;\r\n});\n//# sourceURL=/LiveDevelopment/Servers/BaseServer.js"),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $, brackets, window */\r\n\r\ndefine(\'LiveDevelopment/Servers/FileServer\',[\'require\',\'exports\',\'module\',\'LiveDevelopment/Servers/BaseServer\',\'file/FileUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var BaseServer  = require("LiveDevelopment/Servers/BaseServer").BaseServer,\r\n        FileUtils   = require("file/FileUtils");\r\n\r\n    // The path on Windows starts with a drive letter (e.g. "C:").\r\n    // In order to make it a valid file: URL we need to add an\r\n    // additional slash to the prefix.\r\n    var PREFIX = (brackets.platform === "win") ? "file:///" : "file://";\r\n\r\n    /**\r\n     * Server for file: URLs\r\n     *\r\n     * Configuration parameters for this server:\r\n     * - baseUrl      - Optional base URL (populated by the current project)\r\n     * - pathResolver - Function to covert absolute native paths to project relative paths\r\n     * - root         - Native path to the project root (and base URL)\r\n     *\r\n     * @constructor\r\n     * @param {!{baseUrl: string, root: string, pathResolver: function(string): string}} config\r\n     * @extends {BaseServer}\r\n     */\r\n    function FileServer(config) {\r\n        BaseServer.call(this, config);\r\n    }\r\n    \r\n    FileServer.prototype = Object.create(BaseServer.prototype);\r\n    FileServer.prototype.constructor = FileServer;\r\n\r\n    /**\r\n     * Determines whether we can serve local file.\r\n     * @param {string} localPath A local path to file being served.\r\n     * @return {boolean} true for yes, otherwise false.\r\n     */\r\n    FileServer.prototype.canServe = function (localPath) {\r\n        // FileServer requires that the base URL is undefined and static HTML files\r\n        return (!this._baseUrl && FileUtils.isStaticHtmlFileExt(localPath));\r\n    };\r\n\r\n    /**\r\n     * Convert a file: URL to a absolute file path\r\n     * @param {string} url\r\n     * @return {?string} The absolute path for given file: URL or null if the path is\r\n     *  not a descendant of the project.\r\n     */\r\n    FileServer.prototype.urlToPath = function (url) {\r\n        if (url.indexOf(PREFIX) === 0) {\r\n            // Convert a file URL to local file path\r\n            return decodeURI(url.slice(PREFIX.length));\r\n        }\r\n\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Returns a file: URL for a given absolute path\r\n     * @param {string} path Absolute path to covert to a file: URL\r\n     * @return {string} Converts an absolute path within the project root to a file: URL.\r\n     */\r\n    FileServer.prototype.pathToUrl = function (path) {\r\n        return encodeURI(PREFIX + path);\r\n    };\r\n\r\n    exports.FileServer = FileServer;\r\n});\n//# sourceURL=/LiveDevelopment/Servers/FileServer.js'),eval("/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\n/**\r\n * LiveDevServerManager Overview:\r\n *\r\n * The LiveDevServerManager allows extensions to register to be Live Development\r\n * servers. Servers are queried for their ability to serve a page in\r\n * order of descending priority by way their canServe methods.\r\n *\r\n * NOTE: This API is currently experimental and intented to be internal-only.\r\n * It is very likely that it will be changed in the near future and/or\r\n * removed entirely.\r\n *\r\n *   `LiveDevServerManager.getServer(localPath)`\r\n *\r\n * Returns highest priority server (BaseServer) that can serve the local file.\r\n *\r\n * A Live Development server must implement the BaseServer API. See\r\n * LiveDevelopment/Servers/BaseServer base class.\r\n */\r\ndefine('LiveDevelopment/LiveDevServerManager',['require','exports','module','file/FileUtils','project/ProjectManager'],function (require, exports, module) {\r\n    \"use strict\";\r\n\r\n    var FileUtils           = require(\"file/FileUtils\"),\r\n        ProjectManager      = require(\"project/ProjectManager\");\r\n\r\n    var _serverProviders   = [];\r\n\r\n    /**\r\n     * @private\r\n     * Comparator to sort providers based on their priority\r\n     * @param {number} a\r\n     * @param {number} b\r\n     */\r\n    function _providerSort(a, b) {\r\n        return b.priority - a.priority;\r\n    }\r\n\r\n    /**\r\n     * Determines which provider can serve a file with a local path.\r\n     *\r\n     * @param {string} localPath A local path to file being served.\r\n     * @return {?BaseServer} A server no null if no servers can serve the file\r\n     */\r\n    function getServer(localPath) {\r\n        var provider, server, i;\r\n\r\n        for (i = 0; i < _serverProviders.length; i++) {\r\n            provider = _serverProviders[i];\r\n            server = provider.create();\r\n\r\n            if (server.canServe(localPath)) {\r\n                return server;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * The method by which a server registers itself.\r\n     *\r\n     * @param {BaseServer|{create: function():BaseServer}} provider\r\n     *  The provider to be registered, described below.\r\n     * @param {number} priority\r\n     *  A non-negative number used to break ties among providers for a\r\n     *  particular url. Providers that register with a higher priority will\r\n     *  have the opportunity to provide a given url before those with a\r\n     *  lower priority. The higher the number, the higher the priority.\r\n     */\r\n    function registerServer(provider, priority) {\r\n        if (!provider.create) {\r\n            console.error(\"Incompatible live development server provider\");\r\n            return;\r\n        }\r\n\r\n        var providerObj = {};\r\n\r\n        providerObj.create = provider.create;\r\n        providerObj.priority = priority || 0;\r\n\r\n        _serverProviders.push(providerObj);\r\n        _serverProviders.sort(_providerSort);\r\n    }\r\n    \r\n    // Backwards compatibility\r\n    exports.getProvider         = getServer;\r\n    exports.registerProvider    = registerServer;\r\n\r\n    // Define public API\r\n    exports.getServer           = getServer;\r\n    exports.registerServer      = registerServer;\r\n});\r\n\n//# sourceURL=/LiveDevelopment/LiveDevServerManager.js"),eval("/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $, brackets, window */\r\n\r\ndefine('LiveDevelopment/Servers/UserServer',['require','exports','module','LiveDevelopment/Servers/BaseServer','file/FileUtils'],function (require, exports, module) {\r\n    \"use strict\";\r\n    \r\n    var BaseServer  = require(\"LiveDevelopment/Servers/BaseServer\").BaseServer,\r\n        FileUtils   = require(\"file/FileUtils\");\r\n\r\n    /**\r\n     * Live preview server for user specified server as defined with Live Preview Base Url\r\n     * Project setting. In a clean installation of Brackets, this is the highest priority\r\n     * server provider, if defined.\r\n     *\r\n     * Configuration parameters for this server:\r\n     * - baseUrl      - Optional base URL (populated by the current project)\r\n     * - pathResolver - Function to covert absolute native paths to project relative paths\r\n     * - root         - Native path to the project root (and base URL)\r\n     *\r\n     * @constructor\r\n     * @param {!{baseUrl: string, root: string, pathResolver: function(string)}} config\r\n     * @extends {BaseServer}\r\n     */\r\n    function UserServer(config) {\r\n        BaseServer.call(this, config);\r\n    }\r\n    \r\n    UserServer.prototype = Object.create(BaseServer.prototype);\r\n    UserServer.prototype.constructor = UserServer;\r\n\r\n    /**\r\n     * Determines whether we can serve local file.\r\n     * @param {string} localPath A local path to file being served.\r\n     * @return {boolean} true for yes, otherwise false.\r\n     */\r\n    UserServer.prototype.canServe = function (localPath) {\r\n        // UserServer can only function when the project specifies a base URL\r\n        if (!this._baseUrl) {\r\n            return false;\r\n        }\r\n\r\n        // If we can't transform the local path to a project relative path,\r\n        // the path cannot be served\r\n        if (localPath === this._pathResolver(localPath)) {\r\n            return false;\r\n        }\r\n\r\n        return FileUtils.isStaticHtmlFileExt(localPath) ||\r\n            FileUtils.isServerHtmlFileExt(localPath);\r\n    };\r\n\r\n    exports.UserServer = UserServer;\r\n});\n//# sourceURL=/LiveDevelopment/Servers/UserServer.js"),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $, PathUtils */\r\n\r\n/**\r\n * CSSAgent keeps track of loaded style sheets and allows reloading them\r\n * from a {Document}.\r\n *\r\n * CSSAgent dispatches styleSheetAdded and styleSheetRemoved events, passing\r\n * the URL for the added/removed style sheet.\r\n */\r\ndefine(\'LiveDevelopment/Agents/CSSAgent\',[\'require\',\'exports\',\'module\',\'thirdparty/path-utils/path-utils.min\',\'thirdparty/lodash\',\'LiveDevelopment/Inspector/Inspector\'],function CSSAgent(require, exports, module) {\r\n    "use strict";\r\n\r\n    require("thirdparty/path-utils/path-utils.min");\r\n\r\n    var _ = require("thirdparty/lodash");\r\n\r\n    var Inspector = require("LiveDevelopment/Inspector/Inspector");\r\n\r\n    /**\r\n     * Stylesheet details\r\n     * @type {Object.<string, CSS.CSSStyleSheetHeader>}\r\n     */\r\n    var _styleSheetDetails = {};\r\n\r\n    /**\r\n     * Is getAllStyleSheets() API defined? - This is undefined until we test for API\r\n     * @type {boolean}\r\n     */\r\n    var _getAllStyleSheetsNotFound;\r\n\r\n    /** \r\n     * Create a canonicalized version of the given URL, stripping off query strings and hashes.\r\n     * @param {string} url the URL to canonicalize\r\n     * @return the canonicalized URL\r\n     */\r\n    function _canonicalize(url) {\r\n        return PathUtils.parseUrl(url).hrefNoSearch;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * WebInspector Event: Page.frameNavigated\r\n     * @param {jQuery.Event} event\r\n     * @param {frame: Frame} res\r\n     */\r\n    function _onFrameNavigated(event, res) {\r\n        // Clear maps when navigating to a new page, but not if an iframe was loaded\r\n        if (!res.frame.parentId) {\r\n            _styleSheetDetails = {};\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the style sheets for a url\r\n     * @param {string} url\r\n     * @return {Object.<string, CSSStyleSheetHeader>}\r\n     */\r\n    function styleForURL(url) {\r\n        var styleSheetId, styles = {};\r\n        url = _canonicalize(url);\r\n        for (styleSheetId in _styleSheetDetails) {\r\n            if (_styleSheetDetails[styleSheetId].canonicalizedURL === url) {\r\n                styles[styleSheetId] = _styleSheetDetails[styleSheetId];\r\n            }\r\n        }\r\n        return styles;\r\n    }\r\n\r\n    /**\r\n     * Use styleSheetAdded and styleSheetRemoved events.\r\n     * Get a list of all loaded stylesheet files by URL.\r\n     * @deprecated\r\n     */\r\n    function getStylesheetURLs() {\r\n        var styleSheetId, urls = [];\r\n        for (styleSheetId in _styleSheetDetails) {\r\n            urls[_styleSheetDetails[styleSheetId].canonicalizedURL] = true;\r\n        }\r\n        return _.keys(urls);\r\n    }\r\n\r\n    /**\r\n     * Reload a CSS style sheet from a document\r\n     * @param {Document} document\r\n     * @param {string=} newContent new content of every stylesheet. Defaults to doc.getText() if omitted\r\n     * @return {jQuery.Promise}\r\n     */\r\n    function reloadCSSForDocument(doc, newContent) {\r\n        var styles = styleForURL(doc.url),\r\n            styleSheetId,\r\n            deferreds = [];\r\n\r\n        if (newContent === undefined) {\r\n            newContent = doc.getText();\r\n        }\r\n        for (styleSheetId in styles) {\r\n            deferreds.push(Inspector.CSS.setStyleSheetText(styles[styleSheetId].styleSheetId, newContent));\r\n        }\r\n        if (!deferreds.length) {\r\n            console.error("Style Sheet for document not loaded: " + doc.url);\r\n            return new $.Deferred().reject().promise();\r\n        }\r\n        // return master deferred\r\n        return $.when.apply($, deferreds);\r\n    }\r\n\r\n    /**\r\n     * Empties a CSS style sheet given a document that has been deleted\r\n     * @param {Document} document\r\n     * @return {jQuery.Promise}\r\n     */\r\n    function clearCSSForDocument(doc) {\r\n        return reloadCSSForDocument(doc, "");\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * @param {jQuery.Event} event\r\n     * @param {header: CSSStyleSheetHeader}\r\n     */\r\n    function _styleSheetAdded(event, res) {\r\n        var url             = _canonicalize(res.header.sourceURL),\r\n            existing        = styleForURL(res.header.sourceURL),\r\n            styleSheetId    = res.header.styleSheetId,\r\n            duplicate;\r\n        \r\n        // detect duplicates\r\n        duplicate = _.some(existing, function (styleSheet) {\r\n            return styleSheet && styleSheet.styleSheetId === styleSheetId;\r\n        });\r\n        if (duplicate) {\r\n            return;\r\n        }\r\n        \r\n        _styleSheetDetails[styleSheetId] = res.header;\r\n        _styleSheetDetails[styleSheetId].canonicalizedURL = url; // canonicalized URL\r\n        \r\n        $(exports).triggerHandler("styleSheetAdded", [url, res.header]);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * @param {jQuery.Event} event\r\n     * @param {styleSheetId: StyleSheetId}\r\n     */\r\n    function _styleSheetRemoved(event, res) {\r\n        var header = _styleSheetDetails[res.styleSheetId];\r\n        \r\n        delete _styleSheetDetails[res.styleSheetId];\r\n        \r\n        $(exports).triggerHandler("styleSheetRemoved", [header.canonicalizedURL, header]);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Attempt to use deleted API CSS.getAllStyleSheets\r\n     * @param {jQuery.Event} event\r\n     * @param {frameId: Network.FrameId}\r\n     */\r\n    function _onFrameStoppedLoading(event, res) {\r\n        var regexChromeUA,\r\n            userAgent,\r\n            uaMatch;\r\n\r\n        // Check for undefined so user agent string is only parsed once\r\n        if (_getAllStyleSheetsNotFound === undefined) {\r\n            regexChromeUA = /Chrome\\/(\\d+)\\./;  // Example: "... Chrome/34.0.1847.131 ..."\r\n            userAgent     = Inspector.getUserAgent();\r\n            uaMatch       = userAgent.match(regexChromeUA);\r\n\r\n            // If we have user agent string, and Chrome is >= 34, then don\'t use getAllStyleSheets\r\n            if (uaMatch && parseInt(uaMatch[1], 10) >= 34) {\r\n                _getAllStyleSheetsNotFound = true;\r\n                $(Inspector.Page).off("frameStoppedLoading.CSSAgent", _onFrameStoppedLoading);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Manually fire getAllStyleSheets since it will be removed from\r\n        // Inspector.json in a future update\r\n        Inspector.send("CSS", "getAllStyleSheets").done(function (res) {\r\n            res.headers.forEach(function (header) {\r\n                // _styleSheetAdded will ignore duplicates\r\n                _getAllStyleSheetsNotFound = false;\r\n                _styleSheetAdded(null, { header: header });\r\n            });\r\n        }).fail(function (err) {\r\n            // Disable getAllStyleSheets if the first call fails\r\n            _getAllStyleSheetsNotFound = (err.code === -32601);\r\n            $(Inspector.Page).off("frameStoppedLoading.CSSAgent", _onFrameStoppedLoading);\r\n        });\r\n    }\r\n\r\n    /** Enable the domain */\r\n    function enable() {\r\n        return Inspector.CSS.enable();\r\n    }\r\n\r\n    /** Initialize the agent */\r\n    function load() {\r\n        $(Inspector.Page).on("frameNavigated.CSSAgent", _onFrameNavigated);\r\n        $(Inspector.CSS).on("styleSheetAdded.CSSAgent", _styleSheetAdded);\r\n        $(Inspector.CSS).on("styleSheetRemoved.CSSAgent", _styleSheetRemoved);\r\n\r\n        // getAllStyleSheets was deleted beginning with Chrome 34\r\n        if (!_getAllStyleSheetsNotFound) {\r\n            $(Inspector.Page).on("frameStoppedLoading.CSSAgent", _onFrameStoppedLoading);\r\n        }\r\n    }\r\n\r\n    /** Clean up */\r\n    function unload() {\r\n        $(Inspector.Page).off(".CSSAgent");\r\n        $(Inspector.CSS).off(".CSSAgent");\r\n    }\r\n\r\n    // Export public functions\r\n    exports.enable = enable;\r\n    exports.styleForURL = styleForURL;\r\n    exports.getStylesheetURLs = getStylesheetURLs;\r\n    exports.reloadCSSForDocument = reloadCSSForDocument;\r\n    exports.clearCSSForDocument = clearCSSForDocument;\r\n    exports.load = load;\r\n    exports.unload = unload;\r\n});\r\n\n//# sourceURL=/LiveDevelopment/Agents/CSSAgent.js'),eval('define(\'text!LiveDevelopment/Agents/RemoteFunctions.js\',[],function () { return \'/*\\r\\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\\r\\n *  \\r\\n * Permission is hereby granted, free of charge, to any person obtaining a\\r\\n * copy of this software and associated documentation files (the "Software"), \\r\\n * to deal in the Software without restriction, including without limitation \\r\\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \\r\\n * and/or sell copies of the Software, and to permit persons to whom the \\r\\n * Software is furnished to do so, subject to the following conditions:\\r\\n *  \\r\\n * The above copyright notice and this permission notice shall be included in\\r\\n * all copies or substantial portions of the Software.\\r\\n *  \\r\\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \\r\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \\r\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \\r\\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \\r\\n * DEALINGS IN THE SOFTWARE.\\r\\n * \\r\\n */\\r\\n\\r\\n\\r\\n/*jslint vars: true, plusplus: true, browser: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\\r\\n/*global define, $, window, navigator, Node, console */\\r\\n/*theseus instrument: false */\\r\\n\\r\\n/**\\r\\n * RemoteFunctions define the functions to be executed in the browser. This\\r\\n * modules should define a single function that returns an object of all\\r\\n * exported functions.\\r\\n */\\r\\nfunction RemoteFunctions(experimental) {\\r\\n    "use strict";\\r\\n\\r\\n    var lastKeepAliveTime = Date.now();\\r\\n    \\r\\n    /**\\r\\n     * @type {DOMEditHandler}\\r\\n     */\\r\\n    var _editHandler;\\r\\n    \\r\\n    var HIGHLIGHT_CLASSNAME = "__brackets-ld-highlight",\\r\\n        KEEP_ALIVE_TIMEOUT  = 3000;   // Keep alive timeout value, in milliseconds\\r\\n    \\r\\n    // determine whether an event should be processed for Live Development\\r\\n    function _validEvent(event) {\\r\\n        if (navigator.platform.substr(0, 3) === "Mac") {\\r\\n            // Mac\\r\\n            return event.metaKey;\\r\\n        } else {\\r\\n            // Windows\\r\\n            return event.ctrlKey;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // determine the color for a type\\r\\n    function _typeColor(type, highlight) {\\r\\n        switch (type) {\\r\\n        case "html":\\r\\n            return highlight ? "#eec" : "#ffe";\\r\\n        case "css":\\r\\n            return highlight ? "#cee" : "#eff";\\r\\n        case "js":\\r\\n            return highlight ? "#ccf" : "#eef";\\r\\n        default:\\r\\n            return highlight ? "#ddd" : "#eee";\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // compute the screen offset of an element\\r\\n    function _screenOffset(element, key) {\\r\\n        var bounds = element.getBoundingClientRect();\\r\\n        if (key === "offsetLeft") {\\r\\n            return bounds.left + window.pageXOffset;\\r\\n        } else {\\r\\n            return bounds.top + window.pageYOffset;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // set an event on a element\\r\\n    function _trigger(element, name, value, autoRemove) {\\r\\n        var key = "data-ld-" + name;\\r\\n        if (value !== undefined && value !== null) {\\r\\n            element.setAttribute(key, value);\\r\\n            if (autoRemove) {\\r\\n                window.setTimeout(element.removeAttribute.bind(element, key));\\r\\n            }\\r\\n        } else {\\r\\n            element.removeAttribute(key);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // construct the info menu\\r\\n    function Menu(element) {\\r\\n        this.element = element;\\r\\n        _trigger(this.element, "showgoto", 1, true);\\r\\n        window.setTimeout(window.remoteShowGoto);\\r\\n        this.remove = this.remove.bind(this);\\r\\n    }\\r\\n\\r\\n    Menu.prototype = {\\r\\n        onClick: function (url, event) {\\r\\n            event.preventDefault();\\r\\n            _trigger(this.element, "goto", url, true);\\r\\n            this.remove();\\r\\n        },\\r\\n\\r\\n        createBody: function () {\\r\\n            if (this.body) {\\r\\n                return;\\r\\n            }\\r\\n\\r\\n            // compute the position on screen\\r\\n            var x = _screenOffset(this.element, "offsetLeft");\\r\\n            var y = _screenOffset(this.element, "offsetTop") + this.element.offsetHeight;\\r\\n\\r\\n            // create the container\\r\\n            this.body = document.createElement("div");\\r\\n            this.body.style.setProperty("z-index", 2147483647);\\r\\n            this.body.style.setProperty("position", "absolute");\\r\\n            this.body.style.setProperty("left", x + "px");\\r\\n            this.body.style.setProperty("top", y + "px");\\r\\n            this.body.style.setProperty("font-size", "11pt");\\r\\n\\r\\n            // draw the background\\r\\n            this.body.style.setProperty("background", "#fff");\\r\\n            this.body.style.setProperty("border", "1px solid #888");\\r\\n            this.body.style.setProperty("-webkit-box-shadow", "2px 2px 6px 0px #ccc");\\r\\n            this.body.style.setProperty("border-radius", "6px");\\r\\n            this.body.style.setProperty("padding", "6px");\\r\\n        },\\r\\n\\r\\n        addItem: function (target) {\\r\\n            var item = document.createElement("div");\\r\\n            item.style.setProperty("padding", "2px 6px");\\r\\n            if (this.body.childNodes.length > 0) {\\r\\n                item.style.setProperty("border-top", "1px solid #ccc");\\r\\n            }\\r\\n            item.style.setProperty("cursor", "pointer");\\r\\n            item.style.setProperty("background", _typeColor(target.type));\\r\\n            item.innerHTML = target.name;\\r\\n            item.addEventListener("click", this.onClick.bind(this, target.url));\\r\\n\\r\\n            if (target.file) {\\r\\n                var file = document.createElement("i");\\r\\n                file.style.setProperty("float", "right");\\r\\n                file.style.setProperty("margin-left", "12px");\\r\\n                file.innerHTML = " " + target.file;\\r\\n                item.appendChild(file);\\r\\n            }\\r\\n            this.body.appendChild(item);\\r\\n        },\\r\\n\\r\\n        show: function () {\\r\\n            if (!this.body) {\\r\\n                this.body = this.createBody();\\r\\n            }\\r\\n            if (!this.body.parentNode) {\\r\\n                document.body.appendChild(this.body);\\r\\n            }\\r\\n            document.addEventListener("click", this.remove);\\r\\n        },\\r\\n\\r\\n        remove: function () {\\r\\n            if (this.body && this.body.parentNode) {\\r\\n                document.body.removeChild(this.body);\\r\\n            }\\r\\n            document.removeEventListener("click", this.remove);\\r\\n        }\\r\\n\\r\\n    };\\r\\n\\r\\n    function Editor(element) {\\r\\n        this.onBlur = this.onBlur.bind(this);\\r\\n        this.onKeyPress = this.onKeyPress.bind(this);\\r\\n\\r\\n        this.element = element;\\r\\n        this.element.setAttribute("contenteditable", "true");\\r\\n        this.element.focus();\\r\\n        this.element.addEventListener("blur", this.onBlur);\\r\\n        this.element.addEventListener("keypress", this.onKeyPress);\\r\\n\\r\\n        this.revertText = this.element.innerHTML;\\r\\n\\r\\n        _trigger(this.element, "edit", 1);\\r\\n    }\\r\\n\\r\\n    Editor.prototype = {\\r\\n        onBlur: function (event) {\\r\\n            this.element.removeAttribute("contenteditable");\\r\\n            this.element.removeEventListener("blur", this.onBlur);\\r\\n            this.element.removeEventListener("keypress", this.onKeyPress);\\r\\n            _trigger(this.element, "edit", 0, true);\\r\\n        },\\r\\n\\r\\n        onKeyPress: function (event) {\\r\\n            switch (event.which) {\\r\\n            case 13: // return\\r\\n                this.element.blur();\\r\\n                break;\\r\\n            case 27: // esc\\r\\n                this.element.innerHTML = this.revertText;\\r\\n                this.element.blur();\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\r\\n    function Highlight(color, trigger) {\\r\\n        this.color = color;\\r\\n        this.trigger = !!trigger;\\r\\n        this.elements = [];\\r\\n        this.selector = "";\\r\\n    }\\r\\n\\r\\n    Highlight.prototype = {\\r\\n        _elementExists: function (element) {\\r\\n            var i;\\r\\n            for (i in this.elements) {\\r\\n                if (this.elements[i] === element) {\\r\\n                    return true;\\r\\n                }\\r\\n            }\\r\\n            return false;\\r\\n        },\\r\\n\\r\\n        _makeHighlightDiv: function (element, doAnimation) {\\r\\n            var elementBounds = element.getBoundingClientRect(),\\r\\n                highlight = window.document.createElement("div"),\\r\\n                styles = window.getComputedStyle(element);\\r\\n            \\r\\n            // Don\\\'t highlight elements with 0 width & height\\r\\n            if (elementBounds.width === 0 && elementBounds.height === 0) {\\r\\n                return;\\r\\n            }\\r\\n            \\r\\n            highlight.className = HIGHLIGHT_CLASSNAME;\\r\\n            \\r\\n            var stylesToSet = {\\r\\n                "left": _screenOffset(element, "offsetLeft") + "px",\\r\\n                "top": _screenOffset(element, "offsetTop") + "px",\\r\\n                "width": elementBounds.width + "px",\\r\\n                "height": elementBounds.height + "px",\\r\\n                "z-index": 2000000,\\r\\n                "margin": 0,\\r\\n                "padding": 0,\\r\\n                "position": "absolute",\\r\\n                "pointer-events": "none",\\r\\n                "border-top-left-radius": styles.borderTopLeftRadius,\\r\\n                "border-top-right-radius": styles.borderTopRightRadius,\\r\\n                "border-bottom-left-radius": styles.borderBottomLeftRadius,\\r\\n                "border-bottom-right-radius": styles.borderBottomRightRadius,\\r\\n                "border-style": "solid",\\r\\n                "border-width": "1px",\\r\\n                "border-color": "#00a2ff",\\r\\n                "box-shadow": "0 0 1px #fff",\\r\\n                "box-sizing": "border-box"\\r\\n            };\\r\\n            \\r\\n            var animateStartValues = {\\r\\n                "background-color": "rgba(0, 162, 255, 0.5)",\\r\\n                "opacity": 0\\r\\n            };\\r\\n            \\r\\n            var animateEndValues = {\\r\\n                "background-color": "rgba(0, 162, 255, 0)",\\r\\n                "opacity": 1\\r\\n            };\\r\\n            \\r\\n            var transitionValues = {\\r\\n                "-webkit-transition-property": "opacity, background-color",\\r\\n                "-webkit-transition-duration": "300ms, 2.3s",\\r\\n                "transition-property": "opacity, background-color",\\r\\n                "transition-duration": "300ms, 2.3s"\\r\\n            };\\r\\n            \\r\\n            function _setStyleValues(styleValues, obj) {\\r\\n                var prop;\\r\\n                \\r\\n                for (prop in styleValues) {\\r\\n                    obj.setProperty(prop, styleValues[prop]);\\r\\n                }\\r\\n            }\\r\\n\\r\\n            _setStyleValues(stylesToSet, highlight.style);\\r\\n            _setStyleValues(\\r\\n                doAnimation ? animateStartValues : animateEndValues,\\r\\n                highlight.style\\r\\n            );\\r\\n            \\r\\n            \\r\\n            if (doAnimation) {\\r\\n                _setStyleValues(transitionValues, highlight.style);\\r\\n                \\r\\n                window.setTimeout(function () {\\r\\n                    _setStyleValues(animateEndValues, highlight.style);\\r\\n                }, 0);\\r\\n            }\\r\\n        \\r\\n            window.document.body.appendChild(highlight);\\r\\n        },\\r\\n        \\r\\n        add: function (element, doAnimation) {\\r\\n            if (this._elementExists(element) || element === document) {\\r\\n                return;\\r\\n            }\\r\\n            if (this.trigger) {\\r\\n                _trigger(element, "highlight", 1);\\r\\n            }\\r\\n            this.elements.push(element);\\r\\n            \\r\\n            this._makeHighlightDiv(element, doAnimation);\\r\\n        },\\r\\n\\r\\n        clear: function () {\\r\\n            var i, highlights = window.document.querySelectorAll("." + HIGHLIGHT_CLASSNAME),\\r\\n                body = window.document.body;\\r\\n        \\r\\n            for (i = 0; i < highlights.length; i++) {\\r\\n                body.removeChild(highlights[i]);\\r\\n            }\\r\\n\\r\\n            if (this.trigger) {\\r\\n                for (i = 0; i < this.elements.length; i++) {\\r\\n                    _trigger(this.elements[i], "highlight", 0);\\r\\n                }\\r\\n            }\\r\\n            \\r\\n            this.elements = [];\\r\\n        },\\r\\n        \\r\\n        redraw: function () {\\r\\n            var i, highlighted;\\r\\n            \\r\\n            // When redrawing a selector-based highlight, run a new selector\\r\\n            // query to ensure we have the latest set of elements to highlight.\\r\\n            if (this.selector) {\\r\\n                highlighted = window.document.querySelectorAll(this.selector);\\r\\n            } else {\\r\\n                highlighted = this.elements.slice(0);\\r\\n            }\\r\\n            \\r\\n            this.clear();\\r\\n            for (i = 0; i < highlighted.length; i++) {\\r\\n                this.add(highlighted[i], false);\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n\\r\\n    var _currentEditor;\\r\\n    function _toggleEditor(element) {\\r\\n        _currentEditor = new Editor(element);\\r\\n    }\\r\\n\\r\\n    var _currentMenu;\\r\\n    function _toggleMenu(element) {\\r\\n        if (_currentMenu) {\\r\\n            _currentMenu.remove();\\r\\n        }\\r\\n        _currentMenu = new Menu(element);\\r\\n    }\\r\\n\\r\\n    var _localHighlight;\\r\\n    var _remoteHighlight;\\r\\n    var _setup = false;\\r\\n\\r\\n\\r\\n    /** Event Handlers ***********************************************************/\\r\\n\\r\\n    function onMouseOver(event) {\\r\\n        if (_validEvent(event)) {\\r\\n            _localHighlight.add(event.target, true);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function onMouseOut(event) {\\r\\n        if (_validEvent(event)) {\\r\\n            _localHighlight.clear();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function onMouseMove(event) {\\r\\n        onMouseOver(event);\\r\\n        document.removeEventListener("mousemove", onMouseMove);\\r\\n    }\\r\\n\\r\\n    function onClick(event) {\\r\\n        if (_validEvent(event)) {\\r\\n            event.preventDefault();\\r\\n            event.stopPropagation();\\r\\n            if (event.altKey) {\\r\\n                _toggleEditor(event.target);\\r\\n            } else {\\r\\n                _toggleMenu(event.target);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function onKeyUp(event) {\\r\\n        if (_setup && !_validEvent(event)) {\\r\\n            document.removeEventListener("keyup", onKeyUp);\\r\\n            document.removeEventListener("mouseover", onMouseOver);\\r\\n            document.removeEventListener("mouseout", onMouseOut);\\r\\n            document.removeEventListener("mousemove", onMouseMove);\\r\\n            document.removeEventListener("click", onClick);\\r\\n            _localHighlight.clear();\\r\\n            _localHighlight = undefined;\\r\\n            _setup = false;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function onKeyDown(event) {\\r\\n        if (!_setup && _validEvent(event)) {\\r\\n            document.addEventListener("keyup", onKeyUp);\\r\\n            document.addEventListener("mouseover", onMouseOver);\\r\\n            document.addEventListener("mouseout", onMouseOut);\\r\\n            document.addEventListener("mousemove", onMouseMove);\\r\\n            document.addEventListener("click", onClick);\\r\\n            _localHighlight = new Highlight("#ecc", true);\\r\\n            _setup = true;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /** Public Commands **********************************************************/\\r\\n\\r\\n    // keep alive. Called once a second when a Live Development connection is active.\\r\\n    // If several seconds have passed without this method being called, we can assume\\r\\n    // that the connection has been severed and we should remove all our code/hooks.\\r\\n    function keepAlive() {\\r\\n        lastKeepAliveTime = Date.now();\\r\\n    }\\r\\n    \\r\\n    // show goto\\r\\n    function showGoto(targets) {\\r\\n        if (!_currentMenu) {\\r\\n            return;\\r\\n        }\\r\\n        _currentMenu.createBody();\\r\\n        var i;\\r\\n        for (i in targets) {\\r\\n            _currentMenu.addItem(targets[i]);\\r\\n        }\\r\\n        _currentMenu.show();\\r\\n    }\\r\\n\\r\\n    // remove active highlights\\r\\n    function hideHighlight() {\\r\\n        if (_remoteHighlight) {\\r\\n            _remoteHighlight.clear();\\r\\n            _remoteHighlight = null;\\r\\n        }\\r\\n    }\\r\\n\\r\\n    // highlight a node\\r\\n    function highlight(node, clear) {\\r\\n        if (!_remoteHighlight) {\\r\\n            _remoteHighlight = new Highlight("#cfc");\\r\\n        }\\r\\n        if (clear) {\\r\\n            _remoteHighlight.clear();\\r\\n        }\\r\\n        _remoteHighlight.add(node, true);\\r\\n    }\\r\\n\\r\\n    // highlight a rule\\r\\n    function highlightRule(rule) {\\r\\n        hideHighlight();\\r\\n        var i, nodes = document.querySelectorAll(rule);\\r\\n        for (i = 0; i < nodes.length; i++) {\\r\\n            highlight(nodes[i]);\\r\\n        }\\r\\n        _remoteHighlight.selector = rule;\\r\\n    }\\r\\n    \\r\\n    // redraw active highlights\\r\\n    function redrawHighlights() {\\r\\n        if (_remoteHighlight) {\\r\\n            _remoteHighlight.redraw();\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    window.addEventListener("resize", redrawHighlights);\\r\\n    // Add a capture-phase scroll listener to update highlights when\\r\\n    // any element scrolls.\\r\\n    \\r\\n    function _scrollHandler(e) {\\r\\n        // Document scrolls can be updated immediately. Any other scrolls\\r\\n        // need to be updated on a timer to ensure the layout is correct.\\r\\n        if (e.target === document) {\\r\\n            redrawHighlights();\\r\\n        } else {\\r\\n            if (_remoteHighlight || _localHighlight) {\\r\\n                window.setTimeout(redrawHighlights, 0);\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n    \\r\\n    window.addEventListener("scroll", _scrollHandler, true);\\r\\n    \\r\\n    var aliveTest = window.setInterval(function () {\\r\\n        if (Date.now() > lastKeepAliveTime + KEEP_ALIVE_TIMEOUT) {\\r\\n            // Remove highlights\\r\\n            hideHighlight();\\r\\n            \\r\\n            // Remove listeners\\r\\n            window.removeEventListener("resize", redrawHighlights);\\r\\n            window.removeEventListener("scroll", _scrollHandler, true);\\r\\n            \\r\\n            // Clear this interval\\r\\n            window.clearInterval(aliveTest);\\r\\n        }\\r\\n    }, 1000);\\r\\n    \\r\\n    /**\\r\\n     * Constructor\\r\\n     * @param {Document} htmlDocument\\r\\n     */\\r\\n    function DOMEditHandler(htmlDocument) {\\r\\n        this.htmlDocument = htmlDocument;\\r\\n        this.rememberedNodes = null;\\r\\n        this.entityParseParent = htmlDocument.createElement("div");\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @private\\r\\n     * Find the first matching element with the specified data-brackets-id\\r\\n     * @param {string} id\\r\\n     * @return {Element}\\r\\n     */\\r\\n    DOMEditHandler.prototype._queryBracketsID = function (id) {\\r\\n        if (!id) {\\r\\n            return null;\\r\\n        }\\r\\n        \\r\\n        if (this.rememberedNodes && this.rememberedNodes[id]) {\\r\\n            return this.rememberedNodes[id];\\r\\n        }\\r\\n        \\r\\n        var results = this.htmlDocument.querySelectorAll("[data-brackets-id=\\\'" + id + "\\\']");\\r\\n        return results && results[0];\\r\\n    };\\r\\n    \\r\\n    /**\\r\\n     * @private\\r\\n     * Insert a new child element\\r\\n     * @param {Element} targetElement Parent element already in the document\\r\\n     * @param {Element} childElement New child element\\r\\n     * @param {Object} edit\\r\\n     */\\r\\n    DOMEditHandler.prototype._insertChildNode = function (targetElement, childElement, edit) {\\r\\n        var before = this._queryBracketsID(edit.beforeID),\\r\\n            after  = this._queryBracketsID(edit.afterID);\\r\\n        \\r\\n        if (edit.firstChild) {\\r\\n            before = targetElement.firstChild;\\r\\n        } else if (edit.lastChild) {\\r\\n            after = targetElement.lastChild;\\r\\n        }\\r\\n        \\r\\n        if (before) {\\r\\n            targetElement.insertBefore(childElement, before);\\r\\n        } else if (after && (after !== targetElement.lastChild)) {\\r\\n            targetElement.insertBefore(childElement, after.nextSibling);\\r\\n        } else {\\r\\n            targetElement.appendChild(childElement);\\r\\n        }\\r\\n    };\\r\\n    \\r\\n    /**\\r\\n     * @private\\r\\n     * Given a string containing encoded entity references, returns the string with the entities decoded.\\r\\n     * @param {string} text The text to parse.\\r\\n     * @return {string} The decoded text.\\r\\n     */\\r\\n    DOMEditHandler.prototype._parseEntities = function (text) {\\r\\n        // Kind of a hack: just set the innerHTML of a div to the text, which will parse the entities, then\\r\\n        // read the content out.\\r\\n        var result;\\r\\n        this.entityParseParent.innerHTML = text;\\r\\n        result = this.entityParseParent.textContent;\\r\\n        this.entityParseParent.textContent = "";\\r\\n        return result;\\r\\n    };\\r\\n    \\r\\n    /**\\r\\n     * @private\\r\\n     * @param {Node} node\\r\\n     * @return {boolean} true if node expects its content to be raw text (not parsed for entities) according to the HTML5 spec.\\r\\n     */\\r\\n    function _isRawTextNode(node) {\\r\\n        return (node.nodeType === Node.ELEMENT_NODE && /script|style|noscript|noframes|noembed|iframe|xmp/i.test(node.tagName));\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     * @private\\r\\n     * Replace a range of text and comment nodes with an optional new text node\\r\\n     * @param {Element} targetElement\\r\\n     * @param {Object} edit\\r\\n     */\\r\\n    DOMEditHandler.prototype._textReplace = function (targetElement, edit) {\\r\\n        function prevIgnoringHighlights(node) {\\r\\n            do {\\r\\n                node = node.previousSibling;\\r\\n            } while (node && node.className === HIGHLIGHT_CLASSNAME);\\r\\n            return node;\\r\\n        }\\r\\n        function nextIgnoringHighlights(node) {\\r\\n            do {\\r\\n                node = node.nextSibling;\\r\\n            } while (node && node.className === HIGHLIGHT_CLASSNAME);\\r\\n            return node;\\r\\n        }\\r\\n        function lastChildIgnoringHighlights(node) {\\r\\n            node = (node.childNodes.length ? node.childNodes.item(node.childNodes.length - 1) : null);\\r\\n            if (node && node.className === HIGHLIGHT_CLASSNAME) {\\r\\n                node = prevIgnoringHighlights(node);\\r\\n            }\\r\\n            return node;\\r\\n        }\\r\\n        \\r\\n        var start           = (edit.afterID)  ? this._queryBracketsID(edit.afterID)  : null,\\r\\n            startMissing    = edit.afterID && !start,\\r\\n            end             = (edit.beforeID) ? this._queryBracketsID(edit.beforeID) : null,\\r\\n            endMissing      = edit.beforeID && !end,\\r\\n            moveNext        = start && nextIgnoringHighlights(start),\\r\\n            current         = moveNext || (end && prevIgnoringHighlights(end)) || lastChildIgnoringHighlights(targetElement),\\r\\n            next,\\r\\n            textNode        = (edit.content !== undefined) ? this.htmlDocument.createTextNode(_isRawTextNode(targetElement) ? edit.content : this._parseEntities(edit.content)) : null,\\r\\n            lastRemovedWasText,\\r\\n            isText;\\r\\n        \\r\\n        // remove all nodes inside the range\\r\\n        while (current && (current !== end)) {\\r\\n            isText = current.nodeType === Node.TEXT_NODE;\\r\\n\\r\\n            // if start is defined, delete following text nodes\\r\\n            // if start is not defined, delete preceding text nodes\\r\\n            next = (moveNext) ? nextIgnoringHighlights(current) : prevIgnoringHighlights(current);\\r\\n\\r\\n            // only delete up to the nearest element.\\r\\n            // if the start/end tag was deleted in a prior edit, stop removing\\r\\n            // nodes when we hit adjacent text nodes\\r\\n            if ((current.nodeType === Node.ELEMENT_NODE) ||\\r\\n                    ((startMissing || endMissing) && (isText && lastRemovedWasText))) {\\r\\n                break;\\r\\n            } else {\\r\\n                lastRemovedWasText = isText;\\r\\n\\r\\n                current.remove();\\r\\n                current = next;\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        if (textNode) {\\r\\n            // OK to use nextSibling here (not nextIgnoringHighlights) because we do literally\\r\\n            // want to insert immediately after the start tag.\\r\\n            if (start && start.nextSibling) {\\r\\n                targetElement.insertBefore(textNode, start.nextSibling);\\r\\n            } else if (end) {\\r\\n                targetElement.insertBefore(textNode, end);\\r\\n            } else {\\r\\n                targetElement.appendChild(textNode);\\r\\n            }\\r\\n        }\\r\\n    };\\r\\n    \\r\\n    /**\\r\\n     * @private\\r\\n     * Apply an array of DOM edits to the document\\r\\n     * @param {Array.<Object>} edits\\r\\n     */\\r\\n    DOMEditHandler.prototype.apply = function (edits) {\\r\\n        var targetID,\\r\\n            targetElement,\\r\\n            childElement,\\r\\n            self = this;\\r\\n        \\r\\n        this.rememberedNodes = {};\\r\\n        \\r\\n        edits.forEach(function (edit) {\\r\\n            var editIsSpecialTag = edit.type === "elementInsert" && (edit.tag === "html" || edit.tag === "head" || edit.tag === "body");\\r\\n            \\r\\n            if (edit.type === "rememberNodes") {\\r\\n                edit.tagIDs.forEach(function (tagID) {\\r\\n                    var node = self._queryBracketsID(tagID);\\r\\n                    self.rememberedNodes[tagID] = node;\\r\\n                    node.remove();\\r\\n                });\\r\\n                return;\\r\\n            }\\r\\n            \\r\\n            targetID = edit.type.match(/textReplace|textDelete|textInsert|elementInsert|elementMove/) ? edit.parentID : edit.tagID;\\r\\n            targetElement = self._queryBracketsID(targetID);\\r\\n            \\r\\n            if (!targetElement && !editIsSpecialTag) {\\r\\n                console.error("data-brackets-id=" + targetID + " not found");\\r\\n                return;\\r\\n            }\\r\\n            \\r\\n            switch (edit.type) {\\r\\n            case "attrChange":\\r\\n            case "attrAdd":\\r\\n                targetElement.setAttribute(edit.attribute, self._parseEntities(edit.value));\\r\\n                break;\\r\\n            case "attrDelete":\\r\\n                targetElement.removeAttribute(edit.attribute);\\r\\n                break;\\r\\n            case "elementDelete":\\r\\n                targetElement.remove();\\r\\n                break;\\r\\n            case "elementInsert":\\r\\n                childElement = null;\\r\\n                if (editIsSpecialTag) {\\r\\n                    // If we already have one of these elements (which we should), then\\r\\n                    // just copy the attributes and set the ID.\\r\\n                    childElement = self.htmlDocument[edit.tag === "html" ? "documentElement" : edit.tag];\\r\\n                    if (!childElement) {\\r\\n                        // Treat this as a normal insertion.\\r\\n                        editIsSpecialTag = false;\\r\\n                    }\\r\\n                }\\r\\n                if (!editIsSpecialTag) {\\r\\n                    childElement = self.htmlDocument.createElement(edit.tag);\\r\\n                }\\r\\n                \\r\\n                Object.keys(edit.attributes).forEach(function (attr) {\\r\\n                    childElement.setAttribute(attr, self._parseEntities(edit.attributes[attr]));\\r\\n                });\\r\\n                childElement.setAttribute("data-brackets-id", edit.tagID);\\r\\n                \\r\\n                if (!editIsSpecialTag) {\\r\\n                    self._insertChildNode(targetElement, childElement, edit);\\r\\n                }\\r\\n                break;\\r\\n            case "elementMove":\\r\\n                childElement = self._queryBracketsID(edit.tagID);\\r\\n                self._insertChildNode(targetElement, childElement, edit);\\r\\n                break;\\r\\n            case "textInsert":\\r\\n                var textElement = self.htmlDocument.createTextNode(_isRawTextNode(targetElement) ? edit.content : self._parseEntities(edit.content));\\r\\n                self._insertChildNode(targetElement, textElement, edit);\\r\\n                break;\\r\\n            case "textReplace":\\r\\n            case "textDelete":\\r\\n                self._textReplace(targetElement, edit);\\r\\n                break;\\r\\n            }\\r\\n        });\\r\\n        \\r\\n        this.rememberedNodes = {};\\r\\n        \\r\\n        // update highlight after applying diffs\\r\\n        redrawHighlights();\\r\\n    };\\r\\n    \\r\\n    function applyDOMEdits(edits) {\\r\\n        _editHandler.apply(edits);\\r\\n    }\\r\\n    \\r\\n    /**\\r\\n     *\\r\\n     * @param {Element} elem\\r\\n     */\\r\\n    function _domElementToJSON(elem) {\\r\\n        var json = { tag: elem.tagName.toLowerCase(), attributes: {}, children: [] },\\r\\n            i,\\r\\n            len,\\r\\n            node,\\r\\n            value;\\r\\n        \\r\\n        len = elem.attributes.length;\\r\\n        for (i = 0; i < len; i++) {\\r\\n            node = elem.attributes.item(i);\\r\\n            value = (node.name === "data-brackets-id") ? parseInt(node.value, 10) : node.value;\\r\\n            json.attributes[node.name] = value;\\r\\n        }\\r\\n        \\r\\n        len = elem.childNodes.length;\\r\\n        for (i = 0; i < len; i++) {\\r\\n            node = elem.childNodes.item(i);\\r\\n            \\r\\n            // ignores comment nodes and visuals generated by live preview\\r\\n            if (node.nodeType === Node.ELEMENT_NODE && node.className !== HIGHLIGHT_CLASSNAME) {\\r\\n                json.children.push(_domElementToJSON(node));\\r\\n            } else if (node.nodeType === Node.TEXT_NODE) {\\r\\n                json.children.push({ content: node.nodeValue });\\r\\n            }\\r\\n        }\\r\\n        \\r\\n        return json;\\r\\n    }\\r\\n    \\r\\n    function getSimpleDOM() {\\r\\n        return JSON.stringify(_domElementToJSON(document.documentElement));\\r\\n    }\\r\\n\\r\\n    // init\\r\\n    _editHandler = new DOMEditHandler(window.document);\\r\\n    \\r\\n    if (experimental) {\\r\\n        window.document.addEventListener("keydown", onKeyDown);\\r\\n    }\\r\\n\\r\\n    return {\\r\\n        "DOMEditHandler"        : DOMEditHandler,\\r\\n        "keepAlive"             : keepAlive,\\r\\n        "showGoto"              : showGoto,\\r\\n        "hideHighlight"         : hideHighlight,\\r\\n        "highlight"             : highlight,\\r\\n        "highlightRule"         : highlightRule,\\r\\n        "redrawHighlights"      : redrawHighlights,\\r\\n        "applyDOMEdits"         : applyDOMEdits,\\r\\n        "getSimpleDOM"          : getSimpleDOM\\r\\n    };\\r\\n}\';});\n\n//# sourceURL=/text!LiveDevelopment/Agents/RemoteFunctions.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $, XMLHttpRequest, window */\r\n\r\n/**\r\n * RemoteAgent defines and provides an interface for custom remote functions\r\n * loaded from RemoteFunctions. Remote commands are executed via\r\n * `call(name, varargs)`.\r\n *\r\n * Remote events are dispatched as events on this object.\r\n */\r\ndefine(\'LiveDevelopment/Agents/RemoteAgent\',[\'require\',\'exports\',\'module\',\'LiveDevelopment/LiveDevelopment\',\'LiveDevelopment/Inspector/Inspector\',\'text!LiveDevelopment/Agents/RemoteFunctions.js\'],function RemoteAgent(require, exports, module) {\r\n    "use strict";\r\n\r\n    var $exports = $(exports);\r\n\r\n    var LiveDevelopment = require("LiveDevelopment/LiveDevelopment"),\r\n        Inspector       = require("LiveDevelopment/Inspector/Inspector"),\r\n        RemoteFunctions = require("text!LiveDevelopment/Agents/RemoteFunctions.js");\r\n\r\n    var _load; // deferred load\r\n    var _objectId; // the object id of the remote object\r\n    var _intervalId; // interval used to send keepAlive events\r\n\r\n    // WebInspector Event: DOM.attributeModified\r\n    function _onAttributeModified(event, res) {\r\n        // res = {nodeId, name, value}\r\n        var matches = /^data-ld-(.*)/.exec(res.name);\r\n        if (matches) {\r\n            $exports.triggerHandler(matches[1], res);\r\n        }\r\n    }\r\n\r\n    function _call(objectId, method, varargs) {\r\n        console.assert(objectId, "Attempted to call remote method without objectId set.");\r\n        var args = Array.prototype.slice.call(arguments, 2),\r\n            callback,\r\n            deferred = new $.Deferred();\r\n\r\n        // if the last argument is a function it is the callback function\r\n        if (typeof args[args.length - 1] === "function") {\r\n            callback = args.pop();\r\n        }\r\n\r\n        // Resolve node parameters\r\n        args = args.map(function (arg) {\r\n            if (arg && arg.nodeId) {\r\n                return arg.resolve();\r\n            }\r\n\r\n            return arg;\r\n        });\r\n\r\n        $.when.apply(undefined, args).done(function onResolvedAllNodes() {\r\n            var params = [];\r\n\r\n            args.forEach(function (arg) {\r\n                if (arg.objectId) {\r\n                    params.push({objectId: arg.objectId});\r\n                } else {\r\n                    params.push({value: arg});\r\n                }\r\n            });\r\n\r\n            Inspector.Runtime.callFunctionOn(objectId, method, params, undefined, callback)\r\n                .then(deferred.resolve, deferred.reject);\r\n        });\r\n\r\n        return deferred.promise();\r\n    }\r\n\r\n    /** Call a remote function\r\n     * The parameters are passed on to the remote functions. Nodes are resolved\r\n     * and sent as objectIds.\r\n     * @param {string} function name\r\n     */\r\n    function call(method, varargs) {\r\n        var argsArray = [_objectId, "_LD." + method];\r\n\r\n        if (arguments.length > 1) {\r\n            argsArray = argsArray.concat(Array.prototype.slice.call(arguments, 1));\r\n        }\r\n\r\n        return _call.apply(null, argsArray);\r\n    }\r\n\r\n    function _stopKeepAliveInterval() {\r\n        if (_intervalId) {\r\n            window.clearInterval(_intervalId);\r\n            _intervalId = null;\r\n        }\r\n    }\r\n\r\n    function _startKeepAliveInterval() {\r\n        _stopKeepAliveInterval();\r\n\r\n        _intervalId = window.setInterval(function () {\r\n            call("keepAlive");\r\n        }, 1000);\r\n    }\r\n    \r\n    // WebInspector Event: Page.frameNavigated\r\n    function _onFrameNavigated(event, res) {\r\n        // res = {frame}\r\n        // Re-inject RemoteFunctions when navigating to a new page, but not if an iframe was loaded\r\n        if (res.frame.parentId) {\r\n            return;\r\n        }\r\n\r\n        _stopKeepAliveInterval();\r\n\r\n        // inject RemoteFunctions\r\n        var command = "window._LD=" + RemoteFunctions + "(" + LiveDevelopment.config.experimental + ");";\r\n\r\n        Inspector.Runtime.evaluate(command, function onEvaluate(response) {\r\n            if (response.error || response.wasThrown) {\r\n                _load.reject(response.error);\r\n            } else {\r\n                _objectId = response.result.objectId;\r\n                _load.resolve();\r\n\r\n                _startKeepAliveInterval();\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Initialize the agent */\r\n    function load() {\r\n        _load = new $.Deferred();\r\n        $(Inspector.Page).on("frameNavigated.RemoteAgent", _onFrameNavigated);\r\n        $(Inspector.Page).on("frameStartedLoading.RemoteAgent", _stopKeepAliveInterval);\r\n        $(Inspector.DOM).on("attributeModified.RemoteAgent", _onAttributeModified);\r\n\r\n        return _load.promise();\r\n    }\r\n\r\n    /** Clean up */\r\n    function unload() {\r\n        $(Inspector.Page).off(".RemoteAgent");\r\n        $(Inspector.DOM).off(".RemoteAgent");\r\n        _stopKeepAliveInterval();\r\n    }\r\n\r\n    // Export public functions\r\n    exports.call = call;\r\n    exports.load = load;\r\n    exports.unload = unload;\r\n});\r\n\n//# sourceURL=/LiveDevelopment/Agents/RemoteAgent.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $ */\r\n\r\n/**\r\n * ScriptAgent tracks all executed scripts, defines internal breakpoints, and\r\n * interfaces with the remote debugger.\r\n */\r\ndefine(\'LiveDevelopment/Agents/ScriptAgent\',[\'require\',\'exports\',\'module\',\'LiveDevelopment/Inspector/Inspector\',\'LiveDevelopment/Agents/DOMAgent\'],function ScriptAgent(require, exports, module) {\r\n    "use strict";\r\n\r\n    var Inspector = require("LiveDevelopment/Inspector/Inspector");\r\n    var DOMAgent = require("LiveDevelopment/Agents/DOMAgent");\r\n\r\n    var _load; // the load promise\r\n    var _urlToScript; // url -> script info\r\n    var _idToScript; // id -> script info\r\n    var _insertTrace; // the last recorded trace of a DOM insertion\r\n\r\n    /** Add a call stack trace to a node\r\n     * @param {integer} node id\r\n     * @param [{Debugger.CallFrame}] call stack\r\n     */\r\n    function _addTraceToNode(nodeId, trace) {\r\n        var node = DOMAgent.nodeWithId(nodeId);\r\n        node.trace = trace;\r\n    }\r\n\r\n    // TODO: should the parameter to this be an ID rather than a URL?\r\n    /** Get the script information for a given url\r\n     * @param {string} url\r\n     */\r\n    function scriptWithId(url) {\r\n        return _idToScript[url];\r\n    }\r\n\r\n    // TODO: Strip off query/hash strings from URL (see CSSAgent._canonicalize())\r\n    /** Get the script information for a given url\r\n     * @param {string} url\r\n     */\r\n    function scriptForURL(url) {\r\n        return _urlToScript[url];\r\n    }\r\n\r\n    // DOMAgent Event: Document root loaded\r\n    function _onGetDocument(event, res) {\r\n        Inspector.DOMDebugger.setDOMBreakpoint(res.root.nodeId, "subtree-modified");\r\n        _load.resolve();\r\n    }\r\n\r\n    // WebInspector Event: DOM.childNodeInserted\r\n    function _onChildNodeInserted(event, res) {\r\n        // res = {parentNodeId, previousNodeId, node}\r\n        if (_insertTrace) {\r\n            var node = DOMAgent.nodeWithId(res.node.nodeId);\r\n            node.trace = _insertTrace;\r\n            _insertTrace = undefined;\r\n        }\r\n    }\r\n\r\n    // TODO: Strip off query/hash strings from URL (see CSSAgent._canonicalize())\r\n    // WebInspector Event: Debugger.scriptParsed\r\n    function _onScriptParsed(event, res) {\r\n        // res = {scriptId, url, startLine, startColumn, endLine, endColumn, isContentScript, sourceMapURL}\r\n        _idToScript[res.scriptId] = res;\r\n        _urlToScript[res.url] = res;\r\n    }\r\n\r\n    // WebInspector Event: Debugger.scriptFailedToParse\r\n    function _onScriptFailedToParse(event, res) {\r\n        // res = {url, scriptSource, startLine, errorLine, errorMessage}\r\n    }\r\n\r\n    // WebInspector Event: Debugger.paused\r\n    function _onPaused(event, res) {\r\n        // res = {callFrames, reason, data}\r\n        switch (res.reason) {\r\n\r\n        // Exception\r\n        case "exception":\r\n            Inspector.Debugger.resume();\r\n            // var callFrame = res.callFrames[0];\r\n            // var script = scriptWithId(callFrame.location.scriptId);\r\n            break;\r\n\r\n        // DOMBreakpoint\r\n        case "DOM":\r\n            Inspector.Debugger.resume();\r\n            if (res.data.type === "subtree-modified" && res.data.insertion === true) {\r\n                _insertTrace = res.callFrames;\r\n            }\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    function _reset() {\r\n        _urlToScript = {};\r\n        _idToScript = {};\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * WebInspector Event: Page.frameNavigated\r\n     * @param {jQuery.Event} event\r\n     * @param {frame: Frame} res\r\n     */\r\n    function _onFrameNavigated(event, res) {\r\n        // Clear maps when navigating to a new page, but not if an iframe was loaded\r\n        if (!res.frame.parentId) {\r\n            _reset();\r\n        }\r\n    }\r\n\r\n    /** Initialize the agent */\r\n    function load() {\r\n        _reset();\r\n        _load = new $.Deferred();\r\n\r\n        var enableResult = new $.Deferred();\r\n\r\n        Inspector.Debugger.enable().done(function () {\r\n            Inspector.Debugger.setPauseOnExceptions("uncaught").done(function () {\r\n                enableResult.resolve();\r\n            });\r\n        });\r\n\r\n        $(Inspector.Page).on("frameNavigated.ScriptAgent", _onFrameNavigated);\r\n        $(DOMAgent).on("getDocument.ScriptAgent", _onGetDocument);\r\n        $(Inspector.Debugger)\r\n            .on("scriptParsed.ScriptAgent", _onScriptParsed)\r\n            .on("scriptFailedToParse.ScriptAgent", _onScriptFailedToParse)\r\n            .on("paused.ScriptAgent", _onPaused);\r\n        $(Inspector.DOM).on("childNodeInserted.ScriptAgent", _onChildNodeInserted);\r\n\r\n        return $.when(_load.promise(), enableResult.promise());\r\n    }\r\n\r\n    /** Clean up */\r\n    function unload() {\r\n        _reset();\r\n        $(Inspector.Page).off(".ScriptAgent");\r\n        $(DOMAgent).off(".ScriptAgent");\r\n        $(Inspector.Debugger).off(".ScriptAgent");\r\n        $(Inspector.DOM).off(".ScriptAgent");\r\n    }\r\n\r\n    // Export public functions\r\n    exports.scriptWithId = scriptWithId;\r\n    exports.scriptForURL = scriptForURL;\r\n    exports.load = load;\r\n    exports.unload = unload;\r\n});\r\n\n//# sourceURL=/LiveDevelopment/Agents/ScriptAgent.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, brackets, $, window */\r\n\r\n/**\r\n * GotoAgent constructs and responds to the in-browser goto dialog.\r\n */\r\ndefine(\'LiveDevelopment/Agents/GotoAgent\',[\'require\',\'exports\',\'module\',\'utils/Global\',\'LiveDevelopment/Inspector/Inspector\',\'LiveDevelopment/Agents/DOMAgent\',\'LiveDevelopment/Agents/ScriptAgent\',\'LiveDevelopment/Agents/RemoteAgent\',\'document/DocumentManager\',\'editor/EditorManager\',\'view/MainViewManager\'],function GotoAgent(require, exports, module) {\r\n    "use strict";\r\n\r\n    require("utils/Global");\r\n\r\n    var Inspector = require("LiveDevelopment/Inspector/Inspector");\r\n    var DOMAgent = require("LiveDevelopment/Agents/DOMAgent");\r\n    var ScriptAgent = require("LiveDevelopment/Agents/ScriptAgent");\r\n    var RemoteAgent = require("LiveDevelopment/Agents/RemoteAgent");\r\n\r\n    var DocumentManager = require("document/DocumentManager");\r\n    var EditorManager = require("editor/EditorManager");\r\n    var MainViewManager = require("view/MainViewManager");\r\n\r\n    /** Return the URL without the query string\r\n     * @param {string} URL\r\n     */\r\n    function _urlWithoutQueryString(url) {\r\n        var index = url.search(/[#\\?]/);\r\n        if (index >= 0) {\r\n            url = url.substr(0, index);\r\n        }\r\n        return url;\r\n    }\r\n\r\n    /** Get the file component of the given url\r\n     * @param {string} URL\r\n     */\r\n    function _fileFromURL(url) {\r\n        var comp = url.split("/");\r\n        return comp[comp.length - 1];\r\n    }\r\n\r\n    /** Make the given node a target for goto\r\n     * @param [] targets array\r\n     * @param {DOMNode} node\r\n     */\r\n    function _makeHTMLTarget(targets, node) {\r\n        if (node.location) {\r\n            var target = {};\r\n            var url = DOMAgent.url;\r\n            var location = node.location;\r\n            if (node.canHaveChildren()) {\r\n                location += node.length;\r\n            }\r\n            url += ":" + location;\r\n            var name = "&lt;" + node.name + "&gt;";\r\n            var file = _fileFromURL(url);\r\n            targets.push({"type": "html", "url": url, "name": name, "file": file});\r\n        }\r\n    }\r\n\r\n    /** Make the given css rule a target for goto\r\n     * @param [] targets array\r\n     * @param {CSS.Rule} node\r\n     */\r\n    function _makeCSSTarget(targets, rule) {\r\n        if (rule.sourceURL) {\r\n            var target = {};\r\n            var url = rule.sourceURL;\r\n            url += ":" + rule.style.range.start;\r\n            var name = rule.selectorList.text;\r\n            var file = _fileFromURL(url);\r\n            targets.push({"type": "css", "url": url, "name": name, "file": file});\r\n        }\r\n    }\r\n\r\n    /** Make the given javascript callFrame the target for goto\r\n     * @param [] targets array\r\n     * @param {Debugger.CallFrame} node\r\n     */\r\n    function _makeJSTarget(targets, callFrame) {\r\n        var script = ScriptAgent.scriptWithId(callFrame.location.scriptId);\r\n        if (script && script.url) {\r\n            var target = {};\r\n            var url = script.url;\r\n            url += ":" + callFrame.location.lineNumber + "," + callFrame.location.columnNumber;\r\n            var name = callFrame.functionName;\r\n            if (name === "") {\r\n                name = "anonymous function";\r\n            }\r\n            var file = _fileFromURL(url);\r\n            targets.push({"type": "js", "url": url, "name": name, "file": file});\r\n        }\r\n    }\r\n\r\n    /** Gather options where to go to from the given source node */\r\n    function _onRemoteShowGoto(event, res) {\r\n        // res = {nodeId, name, value}\r\n        var node = DOMAgent.nodeWithId(res.nodeId);\r\n\r\n        // get all css rules that apply to the given node\r\n        Inspector.CSS.getMatchedStylesForNode(node.nodeId, function onMatchedStyles(res) {\r\n            var i, callFrame, name, script, url, rule, targets = [];\r\n            _makeHTMLTarget(targets, node);\r\n            for (i in node.trace) {\r\n                _makeJSTarget(targets, node.trace[i]);\r\n            }\r\n            for (i in node.events) {\r\n                var trace = node.events[i];\r\n                _makeJSTarget(targets, trace.callFrames[0]);\r\n            }\r\n            for (i in res.matchedCSSRules.reverse()) {\r\n                _makeCSSTarget(targets, res.matchedCSSRules[i].rule);\r\n            }\r\n            RemoteAgent.call("showGoto", targets);\r\n        });\r\n    }\r\n\r\n    /** Point the master editor to the given location\r\n     * @param {integer} location in file\r\n     */\r\n    function openLocation(location, noFlash) {\r\n        var editor = EditorManager.getCurrentFullEditor();\r\n        var codeMirror = editor._codeMirror;\r\n        if (typeof location === "number") {\r\n            location = codeMirror.posFromIndex(location);\r\n        }\r\n        codeMirror.setCursor(location);\r\n        editor.focus();\r\n\r\n        if (!noFlash) {\r\n            codeMirror.addLineClass(location.line, "wrap", "flash");\r\n            window.setTimeout(function () {\r\n                codeMirror.removeLineClass(location.line, "wrap", "flash");\r\n            }, 1000);\r\n        }\r\n    }\r\n\r\n    /** Open the editor at the given url and editor location\r\n     * @param {string} url\r\n     * @param {integer} optional location in file\r\n     */\r\n    function open(url, location, noFlash) {\r\n        console.assert(url.substr(0, 7) === "file://", "Cannot open non-file URLs");\r\n\r\n        var result = new $.Deferred();\r\n\r\n        url = _urlWithoutQueryString(url);\r\n        // Extract the path, also strip the third slash when on Windows\r\n        var path = url.slice(brackets.platform === "win" ? 8 : 7);\r\n        // URL-decode the path (\'%20\' => \' \')\r\n        path = decodeURI(path);\r\n        var promise = DocumentManager.getDocumentForPath(path);\r\n        promise.done(function onDone(doc) {\r\n            MainViewManager._edit(MainViewManager.ACTIVE_PANE, doc);\r\n            if (location) {\r\n                openLocation(location, noFlash);\r\n            }\r\n            result.resolve();\r\n        });\r\n        promise.fail(function onErr(err) {\r\n            console.error(err);\r\n            result.reject(err);\r\n        });\r\n\r\n        return result.promise();\r\n    }\r\n\r\n    /** Go to the given source node */\r\n    function _onRemoteGoto(event, res) {\r\n        // res = {nodeId, name, value}\r\n        var location, url = res.value;\r\n        var matches = /^(.*):([^:]+)$/.exec(url);\r\n        if (matches) {\r\n            url = matches[1];\r\n            location = matches[2].split(",");\r\n            if (location.length === 1) {\r\n                location = parseInt(location[0], 10);\r\n            } else {\r\n                location = { line: parseInt(location[0], 10), ch: parseInt(location[1], 10) };\r\n            }\r\n        }\r\n        open(url, location);\r\n    }\r\n\r\n    /** Initialize the agent */\r\n    function load() {\r\n        $(RemoteAgent)\r\n            .on("showgoto.GotoAgent", _onRemoteShowGoto)\r\n            .on("goto.GotoAgent", _onRemoteGoto);\r\n    }\r\n\r\n    /** Initialize the agent */\r\n    function unload() {\r\n        $(RemoteAgent).off(".GotoAgent");\r\n    }\r\n\r\n    // Export public functions\r\n    exports.openLocation = openLocation;\r\n    exports.open = open;\r\n    exports.load = load;\r\n    exports.unload = unload;\r\n});\n//# sourceURL=/LiveDevelopment/Agents/GotoAgent.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $ */\r\n\r\n/**\r\n * EditAgent propagates changes from the in-document editor to the source\r\n * document.\r\n */\r\ndefine(\'LiveDevelopment/Agents/EditAgent\',[\'require\',\'exports\',\'module\',\'LiveDevelopment/Inspector/Inspector\',\'LiveDevelopment/Agents/DOMAgent\',\'LiveDevelopment/Agents/RemoteAgent\',\'LiveDevelopment/Agents/GotoAgent\',\'editor/EditorManager\'],function EditAgent(require, exports, module) {\r\n    "use strict";\r\n\r\n    var Inspector = require("LiveDevelopment/Inspector/Inspector");\r\n    var DOMAgent = require("LiveDevelopment/Agents/DOMAgent");\r\n    var RemoteAgent = require("LiveDevelopment/Agents/RemoteAgent");\r\n    var GotoAgent = require("LiveDevelopment/Agents/GotoAgent");\r\n\r\n    var EditorManager = require("editor/EditorManager");\r\n\r\n    var _editedNode;\r\n\r\n    /** Find changed characters\r\n     * @param {string} old value\r\n     * @param {string} changed value\r\n     * @return {from, to, text}\r\n     */\r\n    function _findChangedCharacters(oldValue, value) {\r\n        if (oldValue === value) {\r\n            return undefined;\r\n        }\r\n        var length = oldValue.length;\r\n        var index = 0;\r\n\r\n        // find the first character that changed\r\n        var i;\r\n        for (i = 0; i < length; i++) {\r\n            if (value[i] !== oldValue[i]) {\r\n                break;\r\n            }\r\n        }\r\n        index += i;\r\n        value = value.substr(i);\r\n        length -= i;\r\n\r\n        // find the last character that changed\r\n        for (i = 0; i < length; i++) {\r\n            if (value[value.length - 1 - i] !== oldValue[oldValue.length - 1 - i]) {\r\n                break;\r\n            }\r\n        }\r\n        length -= i;\r\n        value = value.substr(0, value.length - i);\r\n\r\n        return { from: index, to: index + length, text: value };\r\n    }\r\n\r\n    // WebInspector Event: DOM.characterDataModified\r\n    function _onCharacterDataModified(event, res) {\r\n        // res = {nodeId, characterData}\r\n        if (_editedNode.nodeId !== res.nodeId) {\r\n            return;\r\n        }\r\n\r\n        GotoAgent.open(DOMAgent.url);\r\n        var editor = EditorManager.getCurrentFullEditor();\r\n        var codeMirror = editor._codeMirror;\r\n        var change = _findChangedCharacters(_editedNode.value, res.characterData);\r\n        if (change) {\r\n            var from = codeMirror.posFromIndex(_editedNode.location + change.from);\r\n            var to = codeMirror.posFromIndex(_editedNode.location + change.to);\r\n            exports.isEditing = true;\r\n            editor.document.replaceRange(change.text, from, to);\r\n            exports.isEditing = false;\r\n\r\n            var newPos = codeMirror.posFromIndex(_editedNode.location + change.from + change.text.length);\r\n            editor.setCursorPos(newPos.line, newPos.ch);\r\n        }\r\n    }\r\n\r\n    // Remote Event: Go to the given source node\r\n    function _onRemoteEdit(event, res) {\r\n        // res = {nodeId, name, value}\r\n\r\n        // detach from DOM change events\r\n        if (res.value === "0") {\r\n            $(Inspector.DOM).off(".EditAgent");\r\n            return;\r\n        }\r\n\r\n        // find and store the edited node\r\n        var node = DOMAgent.nodeWithId(res.nodeId);\r\n        node = node.children[0];\r\n        if (!node.location) {\r\n            return;\r\n        }\r\n        _editedNode = node;\r\n\r\n        // attach to character data modified events\r\n        $(Inspector.DOM).on("characterDataModified.EditAgent", _onCharacterDataModified);\r\n    }\r\n\r\n    /** Initialize the agent */\r\n    function load() {\r\n        $(RemoteAgent).on("edit.EditAgent", _onRemoteEdit);\r\n    }\r\n\r\n    /** Initialize the agent */\r\n    function unload() {\r\n        $(RemoteAgent).off(".EditAgent");\r\n    }\r\n\r\n    // Export public functions\r\n    exports.load = load;\r\n    exports.unload = unload;\r\n});\n//# sourceURL=/LiveDevelopment/Agents/EditAgent.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $ */\r\n\r\n/**\r\n * DOMHelpers is a collection of functions used by the DOMAgent exports `eachNode(src, callback)`\r\n */\r\ndefine(\'LiveDevelopment/Agents/DOMHelpers\',[\'require\',\'exports\',\'module\'],function DOMHelpersModule(require, exports, module) {\r\n    "use strict";\r\n\r\n    /** Test if the given character is a quote character\r\n     * {char} source character\r\n     * {char} escape (previous) character\r\n     * {char} quote character\r\n     */\r\n    function _isQuote(c, escape, quote) {\r\n        if (escape === "\\\\") {\r\n            return false;\r\n        }\r\n        if (quote !== undefined) {\r\n            return c === quote;\r\n        }\r\n        return c === "\\"" || c === "\'";\r\n    }\r\n\r\n    /** Remove quotes from the string and adjust escaped quotes\r\n     * @param {string} source string\r\n     */\r\n    function _removeQuotes(src) {\r\n        if (_isQuote(src[0]) && src[src.length - 1] === src[0]) {\r\n            var q = src[0];\r\n            src = src.substr(1, src.length - 2);\r\n            src = src.replace("\\\\" + q, q);\r\n        }\r\n        return src;\r\n    }\r\n\r\n    /** Find the next match using several constraints\r\n     * @param {string} source string\r\n     * @param {string} or [{regex}, {length}] the match definition\r\n     * @param {integer} ignore characters before this offset\r\n     * @param {boolean} watch for quotes\r\n     * @param [{string},{string}] watch for comments\r\n     */\r\n    function _find(src, match, skip, quotes, comments) {\r\n        if (typeof match === "string") {\r\n            match = [match, match.length];\r\n        }\r\n        if (skip === undefined) {\r\n            skip = 0;\r\n        }\r\n        var i, activeQuote, isComment = false;\r\n        for (i = skip; i < src.length; i++) {\r\n            if (quotes && _isQuote(src[i], src[i - 1], activeQuote)) {\r\n                // starting quote\r\n                activeQuote = activeQuote ? undefined : src[i];\r\n            } else if (!activeQuote) {\r\n                if (comments && !isComment && src.substr(i, comments[0].length) === comments[0]) {\r\n                    // opening comment\r\n                    isComment = true;\r\n                    i += comments[0].length - 1;\r\n                } else if (isComment) {\r\n                    // we are commented\r\n                    if (src.substr(i, comments[1].length) === comments[1]) {\r\n                        isComment = false;\r\n                        i += comments[1].length - 1;\r\n                    }\r\n                } else if (src.substr(i, match[1]).search(match[0]) === 0) {\r\n                    // match\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /** Callback iterator using `_find` */\r\n    function _findEach(src, match, quotes, comments, callback) {\r\n        var from = 0;\r\n        var to;\r\n        while (from < src.length) {\r\n            to = _find(src, match, from, quotes, comments);\r\n            if (to < 0) {\r\n                to = src.length;\r\n            }\r\n            callback(src.substr(from, to - from));\r\n            from = to + 1;\r\n        }\r\n    }\r\n\r\n    /** Find the next tag\r\n     * @param {string} source string\r\n     * @param {integer} ignore characters before this offset\r\n     */\r\n    function _findTag(src, skip) {\r\n        var from, to, inc;\r\n        from = _find(src, [/<[a-z!\\/]/i, 2], skip);\r\n        if (from < 0) {\r\n            return null;\r\n        }\r\n        if (src.substr(from, 4) === "<!--") {\r\n            // html comments\r\n            to = _find(src, "-->", from + 4);\r\n            inc = 3;\r\n        } else if (src.substr(from, 7).toLowerCase() === "<script") {\r\n            // script tag\r\n            to = _find(src.toLowerCase(), "</script>", from + 7);\r\n            inc = 9;\r\n        } else if (src.substr(from, 6).toLowerCase() === "<style") {\r\n            // style tag\r\n            to = _find(src.toLowerCase(), "</style>", from + 6);\r\n            inc = 8;\r\n        } else {\r\n            to = _find(src, ">", from + 1, true);\r\n            inc = 1;\r\n        }\r\n        if (to < 0) {\r\n            return null;\r\n        }\r\n        return {from: from, length: to + inc - from};\r\n    }\r\n\r\n    /** Extract tag attributes from the given source of a single tag\r\n     * @param {string} source content\r\n     */\r\n    function _extractAttributes(content) {\r\n\r\n        // remove the node name and the closing bracket and optional slash\r\n        content = content.replace(/^<\\S+\\s*/, "");\r\n        content = content.replace(/\\s*\\/?>$/, "");\r\n        if (content.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // go through the items and identify key value pairs split by =\r\n        var index, key, value;\r\n        var attributes = {};\r\n        _findEach(content, [/\\s/, 1], true, undefined, function each(item) {\r\n            index = item.search("=");\r\n            if (index < 0) {\r\n                return;\r\n            }\r\n\r\n            // get the key\r\n            key = item.substr(0, index).trim();\r\n            if (key.length === 0) {\r\n                return;\r\n            }\r\n\r\n            // get the value\r\n            value = item.substr(index + 1).trim();\r\n            value = _removeQuotes(value);\r\n            attributes[key] = value;\r\n        });\r\n\r\n        return attributes;\r\n    }\r\n\r\n    /** Extract the node payload\r\n     * @param {string} source content\r\n     */\r\n    function extractPayload(content) {\r\n        var payload = {};\r\n\r\n        if (content[0] !== "<") {\r\n            // text\r\n            payload.nodeType = 3;\r\n            payload.nodeValue = content;\r\n        } else if (content.substr(0, 4) === "<!--") {\r\n            // comment\r\n            payload.nodeType = 8;\r\n            payload.nodeValue = content.substr(4, content.length - 7);\r\n        } else if (content[1] === "!") {\r\n            // doctype\r\n            payload.nodeType = 10;\r\n        } else {\r\n            // regular element\r\n            payload.nodeType = 1;\r\n            payload.nodeName = /^<([^>\\s]+)/.exec(content)[1].toUpperCase();\r\n            payload.attributes = _extractAttributes(content);\r\n\r\n            // closing node (/ at the beginning)\r\n            if (payload.nodeName[0] === "/") {\r\n                payload.nodeName = payload.nodeName.substr(1);\r\n                payload.closing = true;\r\n            }\r\n\r\n            // closed node (/ at the end)\r\n            if (content[content.length - 2] === "/") {\r\n                payload.closed = true;\r\n            }\r\n\r\n            // Special handling for script/style tag since we\'ve already collected\r\n            // everything up to the end tag.\r\n            if (payload.nodeName === "SCRIPT" || payload.nodeName === "STYLE") {\r\n                payload.closed = true;\r\n            }\r\n        }\r\n        return payload;\r\n    }\r\n\r\n    /** Split the source string into payloads representing individual nodes\r\n     * @param {string} source\r\n     * @param {function(payload)} callback\r\n     */\r\n    // split a string into individual node contents\r\n    function eachNode(src, callback) {\r\n        var index = 0;\r\n        var text, range, length, payload;\r\n        var x = 0;\r\n        while (index < src.length) {\r\n\r\n            // find the next tag\r\n            range = _findTag(src, index);\r\n            if (!range) {\r\n                range = { from: src.length, length: 0 };\r\n            }\r\n\r\n            // add the text before the tag\r\n            length = range.from - index;\r\n            if (length > 0) {\r\n                text = src.substr(index, length);\r\n                if (/\\S/.test(text)) {\r\n                    payload = extractPayload(text);\r\n                    payload.sourceOffset = index;\r\n                    payload.sourceLength = length;\r\n                    callback(payload);\r\n                }\r\n            }\r\n\r\n            // add the tag\r\n            if (range.length > 0) {\r\n                payload = extractPayload(src.substr(range.from, range.length));\r\n                payload.sourceOffset = range.from;\r\n                payload.sourceLength = range.length;\r\n                callback(payload);\r\n            }\r\n\r\n            // advance\r\n            index = range.from + range.length;\r\n        }\r\n    }\r\n\r\n    // Export public functions\r\n    exports.extractPayload = extractPayload;\r\n    exports.eachNode = eachNode;\r\n});\n//# sourceURL=/LiveDevelopment/Agents/DOMHelpers.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $ */\r\n\r\n/**\r\n * DOMNode represents a node in the DOM tree. It is constructed from a payload\r\n * similar to {DOM.Node} and supports all basic tree operations. If a node has\r\n * a nodeId it is registered with the `DOMAgent` via `addNode()`. The node\'s\r\n * sourceOffset and sourceLength is stored as its location and length. Nodes can\r\n * iterated using `each()` or `find()`. `dump` shows the entire tree on the console.\r\n */\r\ndefine(\'LiveDevelopment/Agents/DOMNode\',[\'require\',\'exports\',\'module\',\'LiveDevelopment/Agents/DOMHelpers\'],function DOMNodeModule(require, exports, module) {\r\n    "use strict";\r\n\r\n    var DOMHelpers = require("LiveDevelopment/Agents/DOMHelpers");\r\n\r\n    /** Fill a string to the given length (used for debug output)\r\n     * @param {string} source string\r\n     * @param {integer} length\r\n     * @param {char} fill character\r\n     */\r\n    function _fill(string, length, c) {\r\n        if (c === undefined) {\r\n            c = " ";\r\n        }\r\n        while (string.length < length) {\r\n            string += c;\r\n        }\r\n        return string;\r\n    }\r\n\r\n    /** Construct a find condition (used in `find` and `findParent`)\r\n     * The match can be a callback returning true or false, the node\r\n     * name or the node type.\r\n     * @param {function} or {string} or {number} match criteria\r\n     */\r\n    function _makeFindCondition(match) {\r\n        switch (typeof match) {\r\n        case "function":\r\n            return match;\r\n        case "string":\r\n            return function findCondition(name, node) {\r\n                return node.name === name;\r\n            }.bind(undefined, match.toUpperCase());\r\n        case "number":\r\n            return function findCondition(type, node) {\r\n                return node.type === type;\r\n            }.bind(undefined, match);\r\n        default:\r\n            console.error("Invalid find condition: " + match);\r\n        }\r\n    }\r\n\r\n    /** Constructor\r\n     * @param {DOMAgent} the agent is passed to avoid circular relationships\r\n     * @param {DOM.Node} node payload\r\n     */\r\n    var DOMNode = function DOMNode(agent, payload) {\r\n        this.agent = agent;\r\n        this.children = [];\r\n        this.attributes = {};\r\n\r\n        // set the payload\r\n        if (typeof payload === "string") {\r\n            payload = DOMHelpers.extractPayload(payload);\r\n        }\r\n        if (payload) {\r\n            this.setPayload(payload);\r\n        }\r\n        this.agent.addNode(this);\r\n    };\r\n\r\n    var TYPE_ELEMENT = DOMNode.TYPE_ELEMENT = 1; // element node\r\n    var TYPE_ATTRIBUTE = DOMNode.TYPE_ATTRIBUTE = 2; // attribute node (unused)\r\n    var TYPE_TEXT = DOMNode.TYPE_TEXT = 3; // text node\r\n    var TYPE_COMMENT = DOMNode.TYPE_COMMENT = 8; // comment node <!-- -->\r\n    var TYPE_DOCUMENT = DOMNode.TYPE_DOCUMENT = 9; // document node <!DOCUMENT>\r\n\r\n    /** Remove a node */\r\n    DOMNode.prototype.remove = function remove() {\r\n        this.agent.removeNode(this);\r\n        if (this.parent) {\r\n            this.parent.removeChild(this);\r\n        }\r\n    };\r\n\r\n\r\n    /** Node Payload ***********************************************************/\r\n\r\n    /** Set the node payload\r\n     * @param {DOM.Node} payload\r\n     */\r\n    DOMNode.prototype.setPayload = function setPayload(payload) {\r\n        this.nodeId = payload.nodeId;\r\n        this.type = payload.nodeType;\r\n        if (payload.nodeName) {\r\n            this.name = payload.nodeName;\r\n        }\r\n        if (payload.nodeValue) {\r\n            this.value = payload.nodeValue;\r\n        }\r\n        this.attributes = {};\r\n        if (payload.attributes) {\r\n            var i, k, v;\r\n            for (i = 0; i < payload.attributes.length; i += 2) {\r\n                k = payload.attributes[i];\r\n                v = payload.attributes[i + 1];\r\n                this.attributes[k] = v;\r\n            }\r\n        }\r\n        if (payload.sourceOffset) {\r\n            this.location = payload.sourceOffset;\r\n        }\r\n        if (payload.sourceLength) {\r\n            this.length = payload.sourceLength;\r\n        } else {\r\n            if (this.value) {\r\n                this.length = this.value.length;\r\n            } else if (this.name) {\r\n                this.length = this.name.length + 2;\r\n            }\r\n        }\r\n        if (payload.children) {\r\n            this.setChildrenPayload(payload.children);\r\n        } else if (payload.childNodeCount) {\r\n            this.agent.requestChildNodes(this);\r\n        }\r\n    };\r\n\r\n    /** Create child nodes from the given payload\r\n     * @param [{DOM.Node}] payload of the children\r\n     */\r\n    DOMNode.prototype.setChildrenPayload = function setChildrenPayload(childrenPayload) {\r\n        var i, payload, node;\r\n        for (i in childrenPayload) {\r\n            payload = childrenPayload[i];\r\n            node = new DOMNode(this.agent, payload);\r\n            this.appendChild(node);\r\n        }\r\n    };\r\n\r\n    /** Construct the payload for this node */\r\n    DOMNode.prototype.payload = function payload() {\r\n        var res = { type: this.type };\r\n        if (this.nodeType === TYPE_ELEMENT) {\r\n            res.nodeName = this.name;\r\n        } else {\r\n            res.value = this.value;\r\n        }\r\n        return res;\r\n    };\r\n\r\n    /** Find the next node that matches the given payload\r\n     * @param {DOM.Node} payload\r\n     */\r\n    DOMNode.prototype.findParentForNextNodeMatchingPayload = function findParentForNextNodeMatchingPayload(payload) {\r\n        var parent = this.canHaveChildren() ? this : this.parent;\r\n        while (parent && !parent.matchesPayload(payload)) {\r\n            parent = parent.parent;\r\n        }\r\n        return parent;\r\n    };\r\n\r\n    /** Find the next node that matches the given payload\r\n     * @param {DOM.Node} payload\r\n     */\r\n    DOMNode.prototype.findNextNodeMatchingPayload = function findNextNodeMatchingPayload(payload) {\r\n        var next = this.nextNode();\r\n        while (next && !next.matchesPayload(payload)) {\r\n            next = next.nextNode();\r\n        }\r\n        return next;\r\n    };\r\n\r\n    /** Test if the node matches the given payload\r\n     * @param {DOM.Node} payload\r\n     */\r\n    DOMNode.prototype.matchesPayload = function matchesPayload(payload) {\r\n        var r = false;\r\n        if (this.type === payload.nodeType) {\r\n            switch (this.type) {\r\n            case 1:\r\n                r = this.name === payload.nodeName;\r\n                break;\r\n            case 3:\r\n                // TODO payload.nodeValue\'s HTML Entities must be decoded\r\n                // r = this.value === payload.nodeValue;\r\n                r = true;\r\n                break;\r\n            default:\r\n                r = true;\r\n            }\r\n        }\r\n        // Useful output for debugging this - do not remove\r\n        // console.debug(this.type + "," + this.name + "," + this.value + " = " + payload.nodeType + "," + payload.nodeName + "," + payload.value + " -> " + r);\r\n        return r;\r\n    };\r\n\r\n    /** Resolve the node and retrieve its objectId from the remote debugger */\r\n    DOMNode.prototype.resolve = function resolve() {\r\n        var def = new $.Deferred();\r\n        if (this.objectId) {\r\n            def.resolve(this);\r\n        } else if (!this.nodeId) {\r\n            def.reject();\r\n        } else {\r\n            this.agent.resolveNode(this, function onResolve(res) {\r\n                this.objectId = res.object.objectId;\r\n                def.resolve(this);\r\n            }.bind(this));\r\n        }\r\n        return def.promise();\r\n    };\r\n\r\n\r\n    /** Tree Operations ******************************************************/\r\n\r\n    /** Can the node have children? */\r\n    DOMNode.prototype.canHaveChildren = function canHaveChildren() {\r\n        return (this.type === 1 && !this.closed && !this.closing && this.nodeName !== "LINK");\r\n    };\r\n\r\n    /** Remove a child\r\n     * @param {DOMNode} child node to remove\r\n     */\r\n    DOMNode.prototype.removeChild = function removeChild(node) {\r\n        this.children.splice(this.indexOfChild(node), 1);\r\n        delete node.parent;\r\n    };\r\n\r\n    /** Insert a child node at the given index\r\n     * @param {DOMNode} node to insert\r\n     * @param {integer} optional index (node is appended if missing)\r\n     */\r\n    DOMNode.prototype.insertChildAt = function insertChildAt(node, index) {\r\n        if (node.parent) {\r\n            node.parent.removeChild(node);\r\n        }\r\n        if (!index || index < 0 || index > this.children.length) {\r\n            index = this.children.length;\r\n        }\r\n        this.children.splice(index, 0, node);\r\n        node.parent = this;\r\n        return node;\r\n    };\r\n\r\n    /** Append a child to this node\r\n     * @param {DOMNode} child node to append\r\n     */\r\n    DOMNode.prototype.appendChild = function appendChild(node) {\r\n        return this.insertChildAt(node);\r\n    };\r\n\r\n    /** Insert a child node after the given node\r\n     * @param {DOMNode} child node to insert\r\n     * @param {DOMNode} existing child node\r\n     */\r\n    DOMNode.prototype.insertChildAfter = function insertChildAfter(node, sibling) {\r\n        var index = this.indexOfChild(sibling);\r\n        if (index >= 0) {\r\n            index++;\r\n        }\r\n        return this.insertChildAt(node, index);\r\n    };\r\n\r\n    /** Insert a child node before the given node\r\n     * @param {DOMNode} child node to insert\r\n     * @param {DOMNode} existing child node\r\n     */\r\n    DOMNode.prototype.insertChildBefore = function insertChildBefore(node, sibling) {\r\n        var index = this.indexOfChild(sibling);\r\n        return this.insertChildAt(node, index);\r\n    };\r\n\r\n    /** Determine the index of a child node\r\n     * @param {DOMNode} child node\r\n     */\r\n    DOMNode.prototype.indexOfChild = function indexOfChild(node) {\r\n        if (!node) {\r\n            return -1;\r\n        }\r\n        var i;\r\n        for (i in this.children) {\r\n            if (this.children[i] === node) {\r\n                return parseInt(i, 0);\r\n            }\r\n        }\r\n        return -1;\r\n    };\r\n\r\n    /** Get the previous sibling */\r\n    DOMNode.prototype.previousSibling = function previousSibling() {\r\n        if (!this.parent) {\r\n            return null;\r\n        }\r\n        return this.parent.children[this.parent.indexOfChild(this) - 1];\r\n    };\r\n\r\n    /** Get the next sibling */\r\n    DOMNode.prototype.nextSibling = function nextSibling() {\r\n        if (!this.parent) {\r\n            return null;\r\n        }\r\n        return this.parent.children[this.parent.indexOfChild(this) + 1];\r\n    };\r\n\r\n    /** Get the previous node */\r\n    DOMNode.prototype.previousNode = function previousNode() {\r\n        var node = this.previousSibling();\r\n        if (node) {\r\n            if (node.children.length > 0) {\r\n                node = node.children[node.children.length - 1];\r\n            }\r\n        } else {\r\n            node = this.parent;\r\n        }\r\n        return node;\r\n    };\r\n\r\n    /** Get the next node */\r\n    DOMNode.prototype.nextNode = function nextNode() {\r\n        if (this.children.length > 0) {\r\n            // return the first child\r\n            return this.children[0];\r\n        }\r\n        // return this or any ancestor\'s next sibling\r\n        var node, parent = this;\r\n        while (parent) {\r\n            node = parent.nextSibling();\r\n            if (node) {\r\n                return node;\r\n            }\r\n            parent = parent.parent;\r\n        }\r\n        return null;\r\n    };\r\n\r\n    /** Traverse the tree\r\n     * @param {function({DOM.Node})} called for this node and all descendants\r\n     */\r\n    DOMNode.prototype.each = function each(callback) {\r\n        if (callback(this) === false) {\r\n            return false;\r\n        }\r\n        var i;\r\n        for (i in this.children) {\r\n            if (this.children[i].each(callback) === false) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    };\r\n\r\n    /** Find a node in the tree\r\n     * @param {function} or {string} or {integer} find condition\r\n     */\r\n    DOMNode.prototype.find = function find(match) {\r\n        var findCondition = _makeFindCondition(match);\r\n        var node = null;\r\n        this.each(function each(n) {\r\n            if (findCondition(n)) {\r\n                node = n;\r\n                return false;\r\n            }\r\n        });\r\n        return node;\r\n    };\r\n\r\n    /** Find all nodes with the given find condition\r\n     * @param {function} or {string} or {integer} find condition\r\n     */\r\n    DOMNode.prototype.findAll = function findAll(match) {\r\n        var nodes = [];\r\n        var findCondition = _makeFindCondition(match);\r\n        this.each(function each(node) {\r\n            if (findCondition(node)) {\r\n                nodes.push(node);\r\n            }\r\n        });\r\n        return nodes;\r\n    };\r\n\r\n    /** Iterate over all parent nodes\r\n     * @param {function({DOM.Node})} called for each ancestor\r\n     */\r\n    DOMNode.prototype.eachParent = function eachParent(callback) {\r\n        var node = this.parent;\r\n        while (node) {\r\n            if (callback(node) === false) {\r\n                return;\r\n            }\r\n            node = node.parent;\r\n        }\r\n        return null;\r\n    };\r\n\r\n    /** Find a parent node that matches the find condition\r\n     * @param {function} or {string} or {integer} find condition\r\n     */\r\n    DOMNode.prototype.findParent = function findParent(findCondition) {\r\n        var theParent = null;\r\n        this.eachParent(function each(parent) {\r\n            if (findCondition(parent)) {\r\n                theParent = parent;\r\n                return false;\r\n            }\r\n        });\r\n        return theParent;\r\n    };\r\n\r\n    /** Find the root of the tree */\r\n    DOMNode.prototype.root = function root() {\r\n        var node = this;\r\n        while (node.parent) {\r\n            node = node.parent;\r\n        }\r\n        return node;\r\n    };\r\n\r\n\r\n   /** Node Info ***********************************************************/\r\n\r\n   /** Test if the given location is inside this node\r\n    * @param {integer} location\r\n    * @param {boolean} also include children\r\n    */\r\n    DOMNode.prototype.isAtLocation = function isAtLocation(location, includeChildren) {\r\n        if (includeChildren === undefined) {\r\n            includeChildren = true;\r\n        }\r\n        if (!this.location || location < this.location) {\r\n            return false;\r\n        }\r\n        var to;\r\n        if (includeChildren && this.closeLocation) {\r\n            to = this.closeLocation + this.closeLength;\r\n        } else {\r\n            to = this.location + this.length;\r\n        }\r\n        if (this.type === TYPE_TEXT) {\r\n            to += 1;\r\n        }\r\n        return location < to;\r\n    };\r\n\r\n    /** Test if this node is empty */\r\n    DOMNode.prototype.isEmpty = function isEmpty() {\r\n        return this.type === TYPE_TEXT && /^\\s*$/.test(this.value);\r\n    };\r\n\r\n    /** Debug Output */\r\n    DOMNode.prototype.toString = function toString() {\r\n        var r;\r\n        switch (this.type) {\r\n        case TYPE_ELEMENT:\r\n            r = "<" + this.name + ">";\r\n            break;\r\n        case TYPE_ATTRIBUTE:\r\n            r = "[ATTRIBUTE]";\r\n            break;\r\n        case TYPE_TEXT:\r\n            r = this.value.replace(/\\s+/, " ").substr(0, 40);\r\n            break;\r\n        case TYPE_COMMENT:\r\n            r = "<!--" + this.value.replace(/\\s+/, " ").substr(0, 33) + "-->";\r\n            break;\r\n        case TYPE_DOCUMENT:\r\n            r = "<!DOCTYPE>";\r\n            break;\r\n        }\r\n        return r;\r\n    };\r\n\r\n    /** Detailed Debug Output */\r\n    DOMNode.prototype.dump = function dump(pre) {\r\n        if (pre === undefined) {\r\n            pre = "";\r\n        }\r\n        var r = pre + this.toString();\r\n        if (this.location) {\r\n            r = _fill(r, 60);\r\n            r += " (" + this.location + "," + (this.location + this.length) + ")";\r\n            if (this.closeLocation) {\r\n                r += " (" + this.closeLocation + "," + (this.closeLocation + this.closeLength) + ")";\r\n            }\r\n        }\r\n        if (this.nodeId) {\r\n            r = _fill(r, 80);\r\n            r += " {" + this.nodeId + "}";\r\n        }\r\n        console.info(r);\r\n        pre += ". ";\r\n        var i;\r\n        for (i in this.children) {\r\n            this.children[i].dump(pre);\r\n        }\r\n    };\r\n\r\n    return DOMNode;\r\n});\n//# sourceURL=/LiveDevelopment/Agents/DOMNode.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $, XMLHttpRequest */\r\n\r\n/**\r\n * DOMAgent constructs and maintains a tree of {DOMNode}s that represents the\r\n * rendered DOM tree in the remote browser. Nodes can be accessed by id or\r\n * location (source offset). To update the DOM tree in response to a change of\r\n * the source document (replace [from,to] with text) call\r\n * `applyChange(from, to, text)`.\r\n *\r\n * The DOMAgent triggers `getDocument` once it has loaded\r\n * the document.\r\n */\r\ndefine(\'LiveDevelopment/Agents/DOMAgent\',[\'require\',\'exports\',\'module\',\'LiveDevelopment/Inspector/Inspector\',\'LiveDevelopment/Agents/RemoteAgent\',\'LiveDevelopment/Agents/EditAgent\',\'LiveDevelopment/Agents/DOMNode\',\'LiveDevelopment/Agents/DOMHelpers\'],function DOMAgent(require, exports, module) {\r\n    "use strict";\r\n\r\n    var $exports = $(exports);\r\n\r\n    var Inspector = require("LiveDevelopment/Inspector/Inspector");\r\n    var RemoteAgent = require("LiveDevelopment/Agents/RemoteAgent");\r\n    var EditAgent = require("LiveDevelopment/Agents/EditAgent");\r\n    var DOMNode = require("LiveDevelopment/Agents/DOMNode");\r\n    var DOMHelpers = require("LiveDevelopment/Agents/DOMHelpers");\r\n\r\n    var _load; // {$.Deferred} load promise\r\n    var _idToNode; // {nodeId -> node}\r\n    var _pendingRequests; // {integer} number of pending requests before initial loading is complete\r\n\r\n    /** Get the last node before the given location\r\n     * @param {integer} location\r\n     */\r\n    function nodeBeforeLocation(location) {\r\n        var node;\r\n        exports.root.each(function each(n) {\r\n            if (!n.location || location < n.location) {\r\n                return true;\r\n            }\r\n            if (!node || node.location < n.location) {\r\n                node = n;\r\n            }\r\n        });\r\n        return node;\r\n    }\r\n\r\n    /** Get the element node that encloses the given location\r\n     * @param {location}\r\n     */\r\n    function allNodesAtLocation(location) {\r\n        var nodes = [];\r\n        exports.root.each(function each(n) {\r\n            if (n.type === DOMNode.TYPE_ELEMENT && n.isAtLocation(location)) {\r\n                nodes.push(n);\r\n            }\r\n        });\r\n        return nodes;\r\n    }\r\n\r\n    /** Get the node at the given location\r\n     * @param {location}\r\n     */\r\n    function nodeAtLocation(location) {\r\n        return exports.root.find(function each(n) {\r\n            return n.isAtLocation(location, false);\r\n        });\r\n    }\r\n\r\n    /** Find the node for the given id\r\n     * @param {DOMNode} node\r\n     */\r\n    function nodeWithId(nodeId) {\r\n        return _idToNode[nodeId];\r\n    }\r\n\r\n    /** Update the node index\r\n     * @param {DOMNode} node\r\n     */\r\n    function removeNode(node) {\r\n        if (node.nodeId) {\r\n            delete _idToNode[node.nodeId];\r\n        }\r\n    }\r\n\r\n    /** Update the node index\r\n     * @param {DOMNode} node\r\n     */\r\n    function addNode(node) {\r\n        if (node.nodeId) {\r\n            _idToNode[node.nodeId] = node;\r\n        }\r\n    }\r\n\r\n    /** Request the child nodes for a node\r\n     * @param {DOMNode} node\r\n     */\r\n    function requestChildNodes(node) {\r\n        if (_pendingRequests >= 0) {\r\n            _pendingRequests++;\r\n        }\r\n        Inspector.DOM.requestChildNodes(node.nodeId);\r\n    }\r\n\r\n    /** Resolve a node\r\n     * @param {DOMNode} node\r\n     */\r\n    function resolveNode(node, callback) {\r\n        console.assert(node.nodeId, "Attempted to resolve node without id");\r\n        Inspector.DOM.resolveNode(node.nodeId, callback);\r\n    }\r\n\r\n    /** Eliminate the query string from a URL\r\n     * @param {string} URL\r\n     */\r\n    function _cleanURL(url) {\r\n        var index = url.search(/[#\\?]/);\r\n        if (index >= 0) {\r\n            url = url.substr(0, index);\r\n        }\r\n        return url;\r\n    }\r\n\r\n    /** Map the DOM document to the source text\r\n     * @param {string} source\r\n     */\r\n    function _mapDocumentToSource(source) {\r\n        var node = exports.root;\r\n        DOMHelpers.eachNode(source, function each(payload) {\r\n            if (!node) {\r\n                return true;\r\n            }\r\n            if (payload.closing) {\r\n                var parent = node.findParentForNextNodeMatchingPayload(payload);\r\n                if (!parent) {\r\n                    return console.warn("Matching Parent not at " + payload.sourceOffset + " (" + payload.nodeName + ")");\r\n                }\r\n                parent.closeLocation = payload.sourceOffset;\r\n                parent.closeLength = payload.sourceLength;\r\n            } else {\r\n                var next = node.findNextNodeMatchingPayload(payload);\r\n                if (!next) {\r\n                    return console.warn("Skipping Source Node at " + payload.sourceOffset);\r\n                }\r\n                node = next;\r\n                node.location = payload.sourceOffset;\r\n                node.length = payload.sourceLength;\r\n                if (payload.closed) {\r\n                    node.closed = payload.closed;\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Load the source document and match it with the DOM tree*/\r\n    function _onFinishedLoadingDOM() {\r\n        var request = new XMLHttpRequest();\r\n        request.open("GET", exports.url);\r\n        request.onload = function onLoad() {\r\n            if ((request.status >= 200 && request.status < 300) ||\r\n                    request.status === 304 || request.status === 0) {\r\n                _mapDocumentToSource(request.response);\r\n                _load.resolve();\r\n            } else {\r\n                var msg = "Received status " + request.status + " from XMLHttpRequest while attempting to load source file at " + exports.url;\r\n                _load.reject(msg, { message: msg });\r\n            }\r\n        };\r\n        request.onerror = function onError() {\r\n            var msg = "Could not load source file at " + exports.url;\r\n            _load.reject(msg, { message: msg });\r\n        };\r\n        request.send(null);\r\n    }\r\n\r\n    // WebInspector Event: Page.loadEventFired\r\n    function _onLoadEventFired(event, res) {\r\n        // res = {timestamp}\r\n        Inspector.DOM.getDocument(function onGetDocument(res) {\r\n            $exports.triggerHandler("getDocument", res);\r\n            // res = {root}\r\n            _idToNode = {};\r\n            _pendingRequests = 0;\r\n            exports.root = new DOMNode(exports, res.root);\r\n        });\r\n    }\r\n\r\n    // WebInspector Event: Page.frameNavigated\r\n    function _onFrameNavigated(event, res) {\r\n        // res = {frame}\r\n        if (!res.frame.parentId) {\r\n            exports.url = _cleanURL(res.frame.url);\r\n        }\r\n    }\r\n\r\n     // WebInspector Event: DOM.documentUpdated\r\n    function _onDocumentUpdated(event, res) {\r\n        // res = {}\r\n    }\r\n\r\n    // WebInspector Event: DOM.setChildNodes\r\n    function _onSetChildNodes(event, res) {\r\n        // res = {parentId, nodes}\r\n        var node = nodeWithId(res.parentId);\r\n        node.setChildrenPayload(res.nodes);\r\n        if (_pendingRequests > 0 && --_pendingRequests === 0) {\r\n            _onFinishedLoadingDOM();\r\n        }\r\n    }\r\n\r\n    // WebInspector Event: DOM.childNodeCountUpdated\r\n    function _onChildNodeCountUpdated(event, res) {\r\n        // res = {nodeId, childNodeCount}\r\n        if (res.nodeId > 0) {\r\n            Inspector.DOM.requestChildNodes(res.nodeId);\r\n        }\r\n    }\r\n\r\n    // WebInspector Event: DOM.childNodeInserted\r\n    function _onChildNodeInserted(event, res) {\r\n        // res = {parentNodeId, previousNodeId, node}\r\n        if (res.node.nodeId > 0) {\r\n            var parent = nodeWithId(res.parentNodeId);\r\n            var previousNode = nodeWithId(res.previousNodeId);\r\n            var node = new DOMNode(exports, res.node);\r\n            parent.insertChildAfter(node, previousNode);\r\n        }\r\n    }\r\n\r\n    // WebInspector Event: DOM.childNodeRemoved\r\n    function _onChildNodeRemoved(event, res) {\r\n        // res = {parentNodeId, nodeId}\r\n        if (res.nodeId > 0) {\r\n            var node = nodeWithId(res.nodeId);\r\n            node.remove();\r\n        }\r\n    }\r\n\r\n    /** Apply a change\r\n     * @param {integer} start offset of the change\r\n     * @param {integer} end offset of the change\r\n     * @param {string} change text\r\n     */\r\n    function applyChange(from, to, text) {\r\n        var delta = from - to + text.length;\r\n        var node = nodeAtLocation(from);\r\n\r\n        // insert a text node\r\n        if (!node) {\r\n            if (!(/^\\s*$/).test(text)) {\r\n                console.warn("Inserting nodes not supported.");\r\n                node = nodeBeforeLocation(from);\r\n            }\r\n        } else if (node.type === 3) {\r\n            // update a text node\r\n            var value = node.value.substr(0, from - node.location);\r\n            value += text;\r\n            value += node.value.substr(to - node.location);\r\n            node.value = value;\r\n            if (!EditAgent.isEditing) {\r\n                // only update the DOM if the change was not caused by the edit agent\r\n                Inspector.DOM.setNodeValue(node.nodeId, node.value);\r\n            }\r\n        } else {\r\n            console.warn("Changing non-text nodes not supported.");\r\n        }\r\n\r\n        // adjust the location of all nodes after the change\r\n        if (node) {\r\n            node.length += delta;\r\n            exports.root.each(function each(n) {\r\n                if (n.location > node.location) {\r\n                    n.location += delta;\r\n                }\r\n                if (n.closeLocation !== undefined && n.closeLocation > node.location) {\r\n                    n.closeLocation += delta;\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    /** Initialize the agent */\r\n    function load() {\r\n        _load = new $.Deferred();\r\n        $(Inspector.Page)\r\n            .on("frameNavigated.DOMAgent", _onFrameNavigated)\r\n            .on("loadEventFired.DOMAgent", _onLoadEventFired);\r\n        $(Inspector.DOM)\r\n            .on("documentUpdated.DOMAgent", _onDocumentUpdated)\r\n            .on("setChildNodes.DOMAgent", _onSetChildNodes)\r\n            .on("childNodeCountUpdated.DOMAgent", _onChildNodeCountUpdated)\r\n            .on("childNodeInserted.DOMAgent", _onChildNodeInserted)\r\n            .on("childNodeRemoved.DOMAgent", _onChildNodeRemoved);\r\n        return _load.promise();\r\n    }\r\n\r\n    /** Clean up */\r\n    function unload() {\r\n        $(Inspector.Page).off(".DOMAgent");\r\n        $(Inspector.DOM).off(".DOMAgent");\r\n    }\r\n\r\n    // Export private functions\r\n    exports.nodeBeforeLocation = nodeBeforeLocation;\r\n    exports.allNodesAtLocation = allNodesAtLocation;\r\n    exports.nodeAtLocation = nodeAtLocation;\r\n    exports.nodeWithId = nodeWithId;\r\n    exports.removeNode = removeNode;\r\n    exports.addNode = addNode;\r\n    exports.requestChildNodes = requestChildNodes;\r\n    exports.applyChange = applyChange;\r\n    exports.load = load;\r\n    exports.unload = unload;\r\n});\n//# sourceURL=/LiveDevelopment/Agents/DOMAgent.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $ */\r\n\r\n/**\r\n * HighlightAgent dispatches events for highlight requests from in-browser\r\n * highlight requests, and allows highlighting nodes and rules in the browser.\r\n *\r\n * Trigger "highlight" when a node should be highlighted\r\n */\r\ndefine(\'LiveDevelopment/Agents/HighlightAgent\',[\'require\',\'exports\',\'module\',\'LiveDevelopment/Agents/DOMAgent\',\'LiveDevelopment/Inspector/Inspector\',\'LiveDevelopment/LiveDevelopment\',\'LiveDevelopment/Agents/RemoteAgent\',\'thirdparty/lodash\'],function HighlightAgent(require, exports, module) {\r\n    "use strict";\r\n\r\n    var DOMAgent        = require("LiveDevelopment/Agents/DOMAgent"),\r\n        Inspector       = require("LiveDevelopment/Inspector/Inspector"),\r\n        LiveDevelopment = require("LiveDevelopment/LiveDevelopment"),\r\n        RemoteAgent     = require("LiveDevelopment/Agents/RemoteAgent"),\r\n        _               = require("thirdparty/lodash");\r\n\r\n    var _highlight = {}; // active highlight\r\n\r\n    // Remote Event: Highlight\r\n    function _onRemoteHighlight(event, res) {\r\n        var node;\r\n        if (res.value === "1") {\r\n            node = DOMAgent.nodeWithId(res.nodeId);\r\n        }\r\n        $(exports).triggerHandler("highlight", [node]);\r\n    }\r\n\r\n    /** Hide in-browser highlighting */\r\n    function hide() {\r\n        switch (_highlight.type) {\r\n        case "node":\r\n            Inspector.DOM.hideHighlight();\r\n            break;\r\n        case "css":\r\n            RemoteAgent.call("hideHighlight");\r\n            break;\r\n        }\r\n        _highlight = {};\r\n    }\r\n\r\n    /** Highlight a single node using DOM.highlightNode\r\n     * @param {DOMNode} node\r\n     */\r\n    function node(n) {\r\n        if (!LiveDevelopment.config.experimental) {\r\n            return;\r\n        }\r\n        \r\n        if (!Inspector.config.highlight) {\r\n            return;\r\n        }\r\n\r\n        // go to the parent of a text node\r\n        if (n && n.type === 3) {\r\n            n = n.parent;\r\n        }\r\n\r\n        // node cannot be highlighted\r\n        if (!n || !n.nodeId || n.type !== 1) {\r\n            return hide();\r\n        }\r\n\r\n        // node is already highlighted\r\n        if (_highlight.type === "node" && _highlight.ref === n.nodeId) {\r\n            return;\r\n        }\r\n\r\n        // highlight the node\r\n        _highlight = {type: "node", ref: n.nodeId};\r\n        Inspector.DOM.highlightNode(n.nodeId, Inspector.config.highlightConfig);\r\n    }\r\n\r\n    /** Highlight all nodes affected by a CSS rule\r\n     * @param {string} rule selector\r\n     */\r\n    function rule(name) {\r\n        if (_highlight.ref === name) {\r\n            return;\r\n        }\r\n        hide();\r\n        _highlight = {type: "css", ref: name};\r\n        RemoteAgent.call("highlightRule", name);\r\n    }\r\n    \r\n    /** Highlight all nodes with \'data-brackets-id\' value\r\n     * that matches id, or if id is an array, matches any of the given ids.\r\n     * @param {string|Array<string>} value of the \'data-brackets-id\' to match,\r\n     * or an array of such.\r\n     */\r\n    function domElement(ids) {\r\n        var selector = "";\r\n        if (!Array.isArray(ids)) {\r\n            ids = [ids];\r\n        }\r\n        _.each(ids, function (id) {\r\n            if (selector !== "") {\r\n                selector += ",";\r\n            }\r\n            selector += "[data-brackets-id=\'" + id + "\']";\r\n        });\r\n        rule(selector);\r\n    }\r\n    \r\n    /**\r\n     * Redraw active highlights\r\n     */\r\n    function redraw() {\r\n        RemoteAgent.call("redrawHighlights");\r\n    }\r\n\r\n    /** Initialize the agent */\r\n    function load() {\r\n        if (LiveDevelopment.config.experimental) {\r\n            $(RemoteAgent).on("highlight.HighlightAgent", _onRemoteHighlight);\r\n        }\r\n    }\r\n\r\n    /** Clean up */\r\n    function unload() {\r\n        if (LiveDevelopment.config.experimental) {\r\n            $(RemoteAgent).off(".HighlightAgent");\r\n        }\r\n    }\r\n\r\n    // Export public functions\r\n    exports.hide = hide;\r\n    exports.node = node;\r\n    exports.rule = rule;\r\n    exports.domElement = domElement;\r\n    exports.redraw = redraw;\r\n    exports.load = load;\r\n    exports.unload = unload;\r\n});\n//# sourceURL=/LiveDevelopment/Agents/HighlightAgent.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $ */\r\n\r\n/**\r\n * CSSDocument manages a single CSS source document\r\n *\r\n * __EDITING__\r\n *\r\n * Editing the document will cause the style sheet to be reloaded via the\r\n * CSSAgent, which immediately updates the appearance of the rendered document.\r\n *\r\n * __HIGHLIGHTING__\r\n *\r\n * CSSDocument supports highlighting nodes from the HighlightAgent and\r\n * highlighting all DOMNode corresponding to the rule at the cursor position\r\n * in the editor.\r\n *\r\n * __EVENTS__\r\n *\r\n * CSSDocument dispatches these events:\r\n *\r\n * - deleted -- When the file for the underlying Document has been deleted.\r\n *   The 2nd argument to the listener will be this CSSDocument.\r\n */\r\ndefine(\'LiveDevelopment/Documents/CSSDocument\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'LiveDevelopment/Agents/CSSAgent\',\'language/CSSUtils\',\'editor/EditorManager\',\'LiveDevelopment/Agents/HighlightAgent\',\'LiveDevelopment/Inspector/Inspector\'],function CSSDocumentModule(require, exports, module) {\r\n    "use strict";\r\n\r\n    var _               = require("thirdparty/lodash"),\r\n        CSSAgent        = require("LiveDevelopment/Agents/CSSAgent"),\r\n        CSSUtils        = require("language/CSSUtils"),\r\n        EditorManager   = require("editor/EditorManager"),\r\n        HighlightAgent  = require("LiveDevelopment/Agents/HighlightAgent"),\r\n        Inspector       = require("LiveDevelopment/Inspector/Inspector");\r\n\r\n    /**\r\n     * @constructor\r\n     * @param {!Document} doc The source document from Brackets\r\n     * @param {!Editor} editor The editor for this document\r\n     */\r\n    var CSSDocument = function CSSDocument(doc, editor) {\r\n        this.doc = doc;\r\n\r\n        this._highlight = [];\r\n        this.onHighlight = this.onHighlight.bind(this);\r\n        this.onCursorActivity = this.onCursorActivity.bind(this);\r\n\r\n        // Add a ref to the doc since we\'re listening for change events\r\n        this.doc.addRef();\r\n        this.onChange = this.onChange.bind(this);\r\n        this.onDeleted = this.onDeleted.bind(this);\r\n\r\n        $(this.doc).on("change.CSSDocument", this.onChange);\r\n        $(this.doc).on("deleted.CSSDocument", this.onDeleted);\r\n        \r\n        this.onActiveEditorChange = this.onActiveEditorChange.bind(this);\r\n        $(EditorManager).on("activeEditorChange", this.onActiveEditorChange);\r\n        \r\n        if (editor) {\r\n            // Attach now\r\n            this.attachToEditor(editor);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Get the CSSStyleSheetHeader for this document\r\n     */\r\n    CSSDocument.prototype._getStyleSheetHeader = function () {\r\n        return CSSAgent.styleForURL(this.doc.url);\r\n    };\r\n\r\n    /**\r\n     * CSSStyleSheetBody was removed in protocol 1.1. This method is unused in Brackets 36.\r\n     * Get the browser version of the StyleSheet object\r\n     * @deprecated\r\n     * @return {jQuery.promise}\r\n     */\r\n    CSSDocument.prototype.getStyleSheetFromBrowser = function getStyleSheetFromBrowser() {\r\n        return new $.Deferred().reject().promise();\r\n    };\r\n\r\n    /**\r\n     * Get the browser version of the source\r\n     * @return {jQuery.promise} Promise resolved with the text content of this CSS document\r\n     */\r\n    CSSDocument.prototype.getSourceFromBrowser = function getSourceFromBrowser() {\r\n        function getOnlyValue(obj) {\r\n            var key;\r\n            for (key in obj) {\r\n                if (_.has(obj, key)) {\r\n                    return obj[key];\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n\r\n        var deferred = new $.Deferred(),\r\n            styleSheetHeader = this._getStyleSheetHeader(),\r\n            styleSheet = getOnlyValue(styleSheetHeader);\r\n        \r\n        if (styleSheet) {\r\n            Inspector.CSS.getStyleSheetText(styleSheet.styleSheetId).then(function (res) {\r\n                deferred.resolve(res.text);\r\n            }, deferred.reject);\r\n        } else {\r\n            deferred.reject();\r\n        }\r\n        \r\n        return deferred.promise();\r\n    };\r\n \r\n    /** Close the document */\r\n    CSSDocument.prototype.close = function close() {\r\n        $(this.doc).off(".CSSDocument");\r\n        $(EditorManager).off("activeEditorChange", this.onActiveEditorChange);\r\n        this.doc.releaseRef();\r\n        this.detachFromEditor();\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Update the style sheet text content and redraw highlights\r\n     */\r\n    CSSDocument.prototype._updateBrowser = function () {\r\n        var reloadPromise = CSSAgent.reloadCSSForDocument(this.doc);\r\n\r\n        if (Inspector.config.highlight) {\r\n            reloadPromise.done(HighlightAgent.redraw);\r\n        }\r\n    };\r\n\r\n    CSSDocument.prototype.attachToEditor = function (editor) {\r\n        this.editor = editor;\r\n        \r\n        if (this.editor) {\r\n            $(HighlightAgent).on("highlight", this.onHighlight);\r\n            $(this.editor).on("cursorActivity.CSSDocument", this.onCursorActivity);\r\n            this.updateHighlight();\r\n        }\r\n    };\r\n    \r\n    CSSDocument.prototype.detachFromEditor = function () {\r\n        if (this.editor) {\r\n            HighlightAgent.hide();\r\n            $(HighlightAgent).off("highlight", this.onHighlight);\r\n            $(this.editor).off(".CSSDocument");\r\n            this.onHighlight();\r\n            this.editor = null;\r\n        }\r\n    };\r\n\r\n    CSSDocument.prototype.updateHighlight = function () {\r\n        if (Inspector.config.highlight && this.editor) {\r\n            var editor = this.editor,\r\n                codeMirror = editor._codeMirror,\r\n                selectors = [];\r\n            _.each(this.editor.getSelections(), function (sel) {\r\n                var selector = CSSUtils.findSelectorAtDocumentPos(editor, (sel.reversed ? sel.end : sel.start));\r\n                if (selector) {\r\n                    selectors.push(selector);\r\n                }\r\n            });\r\n            if (selectors.length) {\r\n                HighlightAgent.rule(selectors.join(","));\r\n            } else {\r\n                HighlightAgent.hide();\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Enable instrumented CSS\r\n     * @param enabled {boolean} \r\n     */\r\n    CSSDocument.prototype.setInstrumentationEnabled = function setInstrumentationEnabled(enabled) {\r\n        // no-op\r\n        // "Instrumentation" is always enabled for CSS, we make no modifications\r\n    };\r\n    \r\n    /**\r\n     * Returns true if document edits appear live in the connected browser\r\n     * @return {boolean} \r\n     */\r\n    CSSDocument.prototype.isLiveEditingEnabled = function () {\r\n        return true;\r\n    };\r\n    \r\n    /**\r\n     * Returns a JSON object with HTTP response overrides\r\n     * @return {{body: string}}\r\n     */\r\n    CSSDocument.prototype.getResponseData = function getResponseData(enabled) {\r\n        // Serve up the in-memory text, including any unsaved changes\r\n        return {\r\n            body: this.doc.getText()\r\n        };\r\n    };\r\n\r\n    /** Event Handlers *******************************************************/\r\n\r\n    /** Triggered on cursor activity of the editor */\r\n    CSSDocument.prototype.onCursorActivity = function onCursorActivity(event, editor) {\r\n        this.updateHighlight();\r\n    };\r\n\r\n    /** Triggered whenever the Document is edited */\r\n    CSSDocument.prototype.onChange = function onChange(event, editor, change) {\r\n        this._updateBrowser();\r\n    };\r\n\r\n    /** Triggered if the Document\'s file is deleted */\r\n    CSSDocument.prototype.onDeleted = function onDeleted(event, editor, change) {\r\n        // clear the CSS\r\n        CSSAgent.clearCSSForDocument(this.doc);\r\n\r\n        // shut down, since our Document is now dead\r\n        this.close();\r\n        $(this).triggerHandler("deleted", [this]);\r\n    };\r\n\r\n    /** Triggered when the active editor changes */\r\n    CSSDocument.prototype.onActiveEditorChange = function (event, newActive, oldActive) {\r\n        this.detachFromEditor();\r\n        \r\n        if (newActive && newActive.document === this.doc) {\r\n            this.attachToEditor(newActive);\r\n        }\r\n    };\r\n    \r\n    /** Triggered by the HighlightAgent to highlight a node in the editor */\r\n    CSSDocument.prototype.onHighlight = function onHighlight(event, node) {\r\n        // clear an existing highlight\r\n        var i;\r\n        for (i in this._highlight) {\r\n            this._highlight[i].clear();\r\n        }\r\n        this._highlight = [];\r\n        if (!node || !node.location) {\r\n            return;\r\n        }\r\n\r\n        // WebInspector Command: CSS.getMatchedStylesForNode\r\n        Inspector.CSS.getMatchedStylesForNode(node.nodeId, function onGetMatchesStyles(res) {\r\n            // res = {matchedCSSRules, pseudoElements, inherited}\r\n            var codeMirror = this.editor._codeMirror,\r\n                styleSheetIds = this._getStyleSheetHeader();\r\n\r\n            var i, rule, from, to;\r\n            for (i in res.matchedCSSRules) {\r\n                rule = res.matchedCSSRules[i];\r\n                if (rule.ruleId && styleSheetIds[rule.ruleId.styleSheetId]) {\r\n                    from = codeMirror.posFromIndex(rule.selectorRange.start);\r\n                    to = codeMirror.posFromIndex(rule.style.range.end);\r\n                    this._highlight.push(codeMirror.markText(from, to, { className: "highlight" }));\r\n                }\r\n            }\r\n        }.bind(this));\r\n    };\r\n\r\n    // Export the class\r\n    module.exports = CSSDocument;\r\n});\r\n\n//# sourceURL=/LiveDevelopment/Documents/CSSDocument.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n/**\r\n * CSSPreprocessorDocument manages a single LESS or SASS source document\r\n *\r\n * __HIGHLIGHTING__\r\n *\r\n * CSSPreprocessorDocument supports highlighting all DOMNode corresponding to the rule at \r\n * the cursor position in the editor.\r\n *\r\n */\r\ndefine(\'LiveDevelopment/Documents/CSSPreprocessorDocument\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'language/CSSUtils\',\'editor/EditorManager\',\'LiveDevelopment/Agents/HighlightAgent\',\'LiveDevelopment/Inspector/Inspector\'],function CSSPreprocessorDocumentModule(require, exports, module) {\r\n    "use strict";\r\n\r\n    var _               = require("thirdparty/lodash"),\r\n        CSSUtils        = require("language/CSSUtils"),\r\n        EditorManager   = require("editor/EditorManager"),\r\n        HighlightAgent  = require("LiveDevelopment/Agents/HighlightAgent"),\r\n        Inspector       = require("LiveDevelopment/Inspector/Inspector");\r\n\r\n    /**\r\n     * @constructor\r\n     * @param {!Document} doc The source document from Brackets\r\n     * @param {?Editor} editor The editor for this document. This is not used here since\r\n     *                  we always need to get the active editor for a preprocessor document\r\n     *                  and not the one passed in `editor`.\r\n     */\r\n    var CSSPreprocessorDocument = function CSSPreprocessorDocument(doc, editor) {\r\n        this.doc = doc;\r\n\r\n        this.onCursorActivity = this.onCursorActivity.bind(this);\r\n\r\n        // Add a ref to the doc since we\'re listening for change events\r\n        this.doc.addRef();\r\n        this.onActiveEditorChange = this.onActiveEditorChange.bind(this);\r\n        $(EditorManager).on("activeEditorChange", this.onActiveEditorChange);\r\n        this.onActiveEditorChange(null, EditorManager.getActiveEditor(), null);\r\n    };\r\n\r\n    /** Close the document */\r\n    CSSPreprocessorDocument.prototype.close = function close() {\r\n        $(this.doc).off(".CSSPreprocessorDocument");\r\n        $(EditorManager).off("activeEditorChange", this.onActiveEditorChange);\r\n        this.doc.releaseRef();\r\n        this.detachFromEditor();\r\n    };\r\n    \r\n    /** Return false so edits cause "out of sync" icon to appear */\r\n    CSSPreprocessorDocument.prototype.isLiveEditingEnabled = function () {\r\n        // Normally this isn\'t called since wasURLRequested() returns false for us, but if user\'s\r\n        // page uses less.js to dynamically load LESS files, then it\'ll be true and we\'ll get called.\r\n        return false;\r\n    };\r\n\r\n    CSSPreprocessorDocument.prototype.attachToEditor = function (editor) {\r\n        this.editor = editor;\r\n        \r\n        if (this.editor) {\r\n            $(this.editor).on("cursorActivity.CSSPreprocessorDocument", this.onCursorActivity);\r\n            this.updateHighlight();\r\n        }\r\n    };\r\n    \r\n    CSSPreprocessorDocument.prototype.detachFromEditor = function () {\r\n        if (this.editor) {\r\n            HighlightAgent.hide();\r\n            $(this.editor).off(".CSSPreprocessorDocument");\r\n            this.editor = null;\r\n        }\r\n    };\r\n\r\n    CSSPreprocessorDocument.prototype.updateHighlight = function () {\r\n        if (Inspector.config.highlight && this.editor) {\r\n            var editor = this.editor,\r\n                codeMirror = editor._codeMirror,\r\n                selectors = [];\r\n            _.each(this.editor.getSelections(), function (sel) {\r\n                var selector = CSSUtils.findSelectorAtDocumentPos(editor, (sel.reversed ? sel.end : sel.start));\r\n                if (selector) {\r\n                    selectors.push(selector);\r\n                }\r\n            });\r\n            if (selectors.length) {\r\n                HighlightAgent.rule(selectors.join(","));\r\n            } else {\r\n                HighlightAgent.hide();\r\n            }\r\n        }\r\n    };\r\n    \r\n    /** Event Handlers *******************************************************/\r\n\r\n    /** Triggered on cursor activity of the editor */\r\n    CSSPreprocessorDocument.prototype.onCursorActivity = function onCursorActivity(event, editor) {\r\n        this.updateHighlight();\r\n    };\r\n\r\n    /** Triggered when the active editor changes */\r\n    CSSPreprocessorDocument.prototype.onActiveEditorChange = function (event, newActive, oldActive) {\r\n        this.detachFromEditor();\r\n        \r\n        if (newActive && newActive.document === this.doc) {\r\n            this.attachToEditor(newActive);\r\n        }\r\n    };\r\n    \r\n    // Export the class\r\n    module.exports = CSSPreprocessorDocument;\r\n});\r\n\n//# sourceURL=/LiveDevelopment/Documents/CSSPreprocessorDocument.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n// A simple HTML tokenizer, originally adapted from https://github.com/fb55/htmlparser2\r\n// (MIT-licensed), but with significant customizations for use in HTML live development.\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, continue: true */\r\n/*global define, $ */\r\n/*unittests: HTML Tokenizer*/\r\n\r\ndefine(\'language/HTMLTokenizer\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    \r\n    "use strict";\r\n    var i = 0,\r\n    \r\n        TEXT = i++,\r\n        BEFORE_TAG_NAME = i++, //after <\r\n        IN_TAG_NAME = i++,\r\n        BEFORE_CLOSING_TAG_NAME = i++,\r\n        IN_CLOSING_TAG_NAME = i++,\r\n        AFTER_CLOSING_TAG_NAME = i++,\r\n        AFTER_SELFCLOSE_SLASH = i++,\r\n    \r\n        //attributes\r\n        BEFORE_ATTRIBUTE_NAME = i++,\r\n        AFTER_QUOTED_ATTRIBUTE_VALUE = i++,\r\n        IN_ATTRIBUTE_NAME = i++,\r\n        AFTER_ATTRIBUTE_NAME = i++,\r\n        BEFORE_ATTRIBUTE_VALUE = i++,\r\n        IN_ATTRIBUTE_VALUE_DOUBLE_QUOTES = i++, // "\r\n        IN_ATTRIBUTE_VALUE_SINGLE_QUOTES = i++, // \'\r\n        IN_ATTRIBUTE_VALUE_NO_QUOTES = i++,\r\n    \r\n        //declarations\r\n        BEFORE_DECLARATION = i++, // !\r\n        IN_DECLARATION = i++,\r\n    \r\n        //processing instructions\r\n        IN_PROCESSING_INSTRUCTION = i++, // ?\r\n    \r\n        //comments\r\n        BEFORE_COMMENT = i++,\r\n        IN_COMMENT = i++,\r\n        AFTER_COMMENT_1 = i++,\r\n        AFTER_COMMENT_2 = i++,\r\n    \r\n        //cdata\r\n        BEFORE_CDATA_1 = i++, // [\r\n        BEFORE_CDATA_2 = i++, // C\r\n        BEFORE_CDATA_3 = i++, // D\r\n        BEFORE_CDATA_4 = i++, // A\r\n        BEFORE_CDATA_5 = i++, // T\r\n        BEFORE_CDATA_6 = i++, // A\r\n        IN_CDATA = i++,// [\r\n        AFTER_CDATA_1 = i++, // ]\r\n        AFTER_CDATA_2 = i++, // ]\r\n    \r\n        //special tags\r\n        BEFORE_SPECIAL = i++, //S\r\n        BEFORE_SPECIAL_END = i++,   //S\r\n    \r\n        BEFORE_SCRIPT_1 = i++, //C\r\n        BEFORE_SCRIPT_2 = i++, //R\r\n        BEFORE_SCRIPT_3 = i++, //I\r\n        BEFORE_SCRIPT_4 = i++, //P\r\n        BEFORE_SCRIPT_5 = i++, //T\r\n        AFTER_SCRIPT_1 = i++, //C\r\n        AFTER_SCRIPT_2 = i++, //R\r\n        AFTER_SCRIPT_3 = i++, //I\r\n        AFTER_SCRIPT_4 = i++, //P\r\n        AFTER_SCRIPT_5 = i++, //T\r\n    \r\n        BEFORE_STYLE_1 = i++, //T\r\n        BEFORE_STYLE_2 = i++, //Y\r\n        BEFORE_STYLE_3 = i++, //L\r\n        BEFORE_STYLE_4 = i++, //E\r\n        AFTER_STYLE_1 = i++, //T\r\n        AFTER_STYLE_2 = i++, //Y\r\n        AFTER_STYLE_3 = i++, //L\r\n        AFTER_STYLE_4 = i++; //E\r\n\r\n    /**\r\n     * @private\r\n     * @param {string} c the character to test\r\n     * @return {boolean} true if c is whitespace\r\n     */\r\n    function isWhitespace(c) {\r\n        return c === " " || c === "\\t" || c === "\\r" || c === "\\n";\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * @param {string} c the character to test\r\n     * @return {boolean} true if c is legal in an HTML tag name\r\n     */\r\n    function isLegalInTagName(c) {\r\n        // We allow "-" in tag names since they\'re popular in Angular custom tag names\r\n        // and will be legal in the web components spec.\r\n        return (/[A-Za-z0-9\\-]/).test(c);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * @param {string} c the character to test\r\n     * @return {boolean} true if c is legal in an HTML attribute name\r\n     */\r\n    function isLegalInAttributeName(c) {\r\n        return c !== \'"\' && c !== "\'" && c !== "<" && c !== "=";\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * @param {string} c the character to test\r\n     * @return {boolean} true if c is legal in an unquoted attribute value\r\n     */\r\n    function isLegalInUnquotedAttributeValue(c) {\r\n        return c !== "<" && c !== "=";\r\n    }\r\n    \r\n    function _clonePos(pos, offset) {\r\n        return pos ? { line: pos.line, ch: pos.ch + (offset || 0)} : null;\r\n    }\r\n    \r\n    /**\r\n     * A simple HTML tokenizer. See the description of nextToken() for usage details.\r\n     * @constructor\r\n     * @param {string} text The HTML document to tokenize.\r\n     */\r\n    function Tokenizer(text) {\r\n        this._state = TEXT;\r\n        this._buffer = text;\r\n        this._sectionStart = 0;\r\n        this._sectionStartPos = {line: 0, ch: 0};\r\n        this._index = 0;\r\n        this._indexPos = {line: 0, ch: 0};\r\n        this._special = 0; // 1 for script, 2 for style\r\n        this._token = null;\r\n        this._nextToken = null;\r\n    }\r\n    \r\n    /**\r\n     * Returns the next token in the HTML document, or null if we\'re at the end of the document.\r\n     * @return {?{type: string, contents: string, start: number, end: number}} token The next token, with the following fields:\r\n     *    type: The type of token, one of:\r\n     *          "error" - invalid syntax was found, tokenization aborted. Calling nextToken() again will produce undefined results.\r\n     *          "text" - contents contains the text\r\n     *          "opentagname" - an open tag was started; contents contains the tag name\r\n     *          "attribname" - an attribute was encountered; contents contains the attribute name\r\n     *          "attribvalue" - the value for the previous attribname was encountered; contents contains the (unquoted) value\r\n     *              (Note that attributes like checked and disabled might not have values.)\r\n     *          "opentagend" - the end of an open tag was encountered; contents is unspecified\r\n     *          "selfclosingtag" - a "/>" was encountered indicating that a void element was self-closed; contents is unspecified\r\n     *              (Note that this is optional in HTML; void elements like <img> will end with "opentagend", not "selfclosingtag")\r\n     *          "closetag" - a close tag was encountered; contents contains the tag name\r\n     *          "comment" - a comment was encountered; contents contains the body of the comment\r\n     *          "cdata" - a CDATA block was encountered; contents contains the text inside the block\r\n     *    contents: the contents of the token, as specified above. Note that "opentagend" and "selfclosingtag" really specify positions,\r\n     *          not tokens, and so have no contents.\r\n     *    start: the start index of the token contents within the text, or -1 for "opentagend" and "selfclosingtag"\r\n     *    end: the end index of the token contents within the text, or the position of the boundary for "opentagend" and "selfclosingtag"\r\n     */\r\n    Tokenizer.prototype.nextToken = function () {\r\n        this._token = null;\r\n        \r\n        if (this._nextToken) {\r\n            var result = this._nextToken;\r\n            this._nextToken = null;\r\n            return result;\r\n        }\r\n        \r\n        while (this._index < this._buffer.length && !this._token) {\r\n            var c = this._buffer.charAt(this._index);\r\n            if (this._state === TEXT) {\r\n                if (c === "<") {\r\n                    this._emitTokenIfNonempty("text");\r\n                    this._state = BEFORE_TAG_NAME;\r\n                    this._startSection();\r\n                }\r\n            } else if (this._state === BEFORE_TAG_NAME) {\r\n                if (c === "/") {\r\n                    this._state = BEFORE_CLOSING_TAG_NAME;\r\n                } else if (c === ">" || this._special > 0) {\r\n                    this._state = TEXT;\r\n                } else {\r\n                    if (c === "!") {\r\n                        this._state = BEFORE_DECLARATION;\r\n                        this._startSection(1);\r\n                    } else if (c === "?") {\r\n                        this._state = IN_PROCESSING_INSTRUCTION;\r\n                        this._startSection(1);\r\n                    } else if (c === "s" || c === "S") {\r\n                        this._state = BEFORE_SPECIAL;\r\n                        this._startSection();\r\n                    } else if (!isLegalInTagName(c)) {\r\n                        this._emitSpecialToken("error");\r\n                        break;\r\n                    } else if (!isWhitespace(c)) {\r\n                        this._state = IN_TAG_NAME;\r\n                        this._startSection();\r\n                    }\r\n                }\r\n            } else if (this._state === IN_TAG_NAME) {\r\n                if (c === "/") {\r\n                    this._emitToken("opentagname");\r\n                    this._emitSpecialToken("selfclosingtag", this._index + 2, _clonePos(this._indexPos, 2));\r\n                    this._state = AFTER_SELFCLOSE_SLASH;\r\n                } else if (c === ">") {\r\n                    this._emitToken("opentagname");\r\n                    this._emitSpecialToken("opentagend", this._index + 1, _clonePos(this._indexPos, 1));\r\n                    this._state = TEXT;\r\n                    this._startSection(1);\r\n                } else if (isWhitespace(c)) {\r\n                    this._emitToken("opentagname");\r\n                    this._state = BEFORE_ATTRIBUTE_NAME;\r\n                } else if (!isLegalInTagName(c)) {\r\n                    this._emitSpecialToken("error");\r\n                    break;\r\n                }\r\n            } else if (this._state === BEFORE_CLOSING_TAG_NAME) {\r\n                if (c === ">") {\r\n                    this._state = TEXT;\r\n                } else if (this._special > 0) {\r\n                    if (c === "s" || c === "S") {\r\n                        this._state = BEFORE_SPECIAL_END;\r\n                    } else {\r\n                        this._state = TEXT;\r\n                        continue;\r\n                    }\r\n                } else if (!isLegalInTagName(c)) {\r\n                    this._emitSpecialToken("error");\r\n                    break;\r\n                } else if (!isWhitespace(c)) {\r\n                    this._state = IN_CLOSING_TAG_NAME;\r\n                    this._startSection();\r\n                }\r\n            } else if (this._state === IN_CLOSING_TAG_NAME) {\r\n                if (c === ">") {\r\n                    this._emitToken("closetag");\r\n                    this._state = TEXT;\r\n                    this._startSection(1);\r\n                    this._special = 0;\r\n                } else if (isWhitespace(c)) {\r\n                    this._emitToken("closetag");\r\n                    this._state = AFTER_CLOSING_TAG_NAME;\r\n                    this._special = 0;\r\n                } else if (!isLegalInTagName(c)) {\r\n                    this._emitSpecialToken("error");\r\n                    break;\r\n                }\r\n            } else if (this._state === AFTER_CLOSING_TAG_NAME) {\r\n                if (c === ">") {\r\n                    this._state = TEXT;\r\n                    this._startSection(1);\r\n                } else if (!isWhitespace(c)) {\r\n                    // There must be only whitespace in the closing tag after the name until the ">".\r\n                    this._emitSpecialToken("error");\r\n                    break;\r\n                }\r\n            } else if (this._state === AFTER_SELFCLOSE_SLASH) {\r\n                // Nothing (even whitespace) can come between the / and > of a self-close.\r\n                if (c === ">") {\r\n                    this._state = TEXT;\r\n                    this._startSection(1);\r\n                } else {\r\n                    this._emitSpecialToken("error");\r\n                    break;\r\n                }\r\n    \r\n            /*\r\n            *	attributes\r\n            */\r\n            } else if (this._state === BEFORE_ATTRIBUTE_NAME) {\r\n                if (c === ">") {\r\n                    this._state = TEXT;\r\n                    this._emitSpecialToken("opentagend", this._index + 1, _clonePos(this._indexPos, 1));\r\n                    this._startSection(1);\r\n                } else if (c === "/") {\r\n                    this._emitSpecialToken("selfclosingtag", this._index + 2, _clonePos(this._indexPos, 2));\r\n                    this._state = AFTER_SELFCLOSE_SLASH;\r\n                } else if (!isLegalInAttributeName(c)) {\r\n                    this._emitSpecialToken("error");\r\n                    break;\r\n                } else if (!isWhitespace(c)) {\r\n                    this._state = IN_ATTRIBUTE_NAME;\r\n                    this._startSection();\r\n                }\r\n            } else if (this._state === IN_ATTRIBUTE_NAME) {\r\n                if (c === "=") {\r\n                    this._emitTokenIfNonempty("attribname");\r\n                    this._state = BEFORE_ATTRIBUTE_VALUE;\r\n                } else if (isWhitespace(c)) {\r\n                    this._emitTokenIfNonempty("attribname");\r\n                    this._state = AFTER_ATTRIBUTE_NAME;\r\n                } else if (c === "/" || c === ">") {\r\n                    this._emitTokenIfNonempty("attribname");\r\n                    this._state = BEFORE_ATTRIBUTE_NAME;\r\n                    continue;\r\n                } else if (!isLegalInAttributeName(c)) {\r\n                    this._emitSpecialToken("error");\r\n                    break;\r\n                }\r\n            } else if (this._state === AFTER_ATTRIBUTE_NAME) {\r\n                if (c === "=") {\r\n                    this._state = BEFORE_ATTRIBUTE_VALUE;\r\n                } else if (c === "/" || c === ">") {\r\n                    this._state = BEFORE_ATTRIBUTE_NAME;\r\n                    continue;\r\n                } else if (!isLegalInAttributeName(c)) {\r\n                    this._emitSpecialToken("error");\r\n                    break;\r\n                } else if (!isWhitespace(c)) {\r\n                    this._state = IN_ATTRIBUTE_NAME;\r\n                    this._startSection();\r\n                }\r\n            } else if (this._state === BEFORE_ATTRIBUTE_VALUE) {\r\n                if (c === "\\"") {\r\n                    this._state = IN_ATTRIBUTE_VALUE_DOUBLE_QUOTES;\r\n                    this._startSection(1);\r\n                } else if (c === "\'") {\r\n                    this._state = IN_ATTRIBUTE_VALUE_SINGLE_QUOTES;\r\n                    this._startSection(1);\r\n                } else if (!isLegalInUnquotedAttributeValue(c)) {\r\n                    this._emitSpecialToken("error");\r\n                    break;\r\n                } else if (!isWhitespace(c)) {\r\n                    this._state = IN_ATTRIBUTE_VALUE_NO_QUOTES;\r\n                    this._startSection();\r\n                }\r\n            } else if (this._state === IN_ATTRIBUTE_VALUE_DOUBLE_QUOTES) {\r\n                if (c === "\\"") {\r\n                    this._emitToken("attribvalue");\r\n                    this._state = AFTER_QUOTED_ATTRIBUTE_VALUE;\r\n                }\r\n            } else if (this._state === IN_ATTRIBUTE_VALUE_SINGLE_QUOTES) {\r\n                if (c === "\'") {\r\n                    this._state = AFTER_QUOTED_ATTRIBUTE_VALUE;\r\n                    this._emitToken("attribvalue");\r\n                }\r\n            } else if (this._state === IN_ATTRIBUTE_VALUE_NO_QUOTES) {\r\n                if (c === ">") {\r\n                    this._emitToken("attribvalue");\r\n                    this._emitSpecialToken("opentagend", this._index + 1, _clonePos(this._indexPos, 1));\r\n                    this._state = TEXT;\r\n                    this._startSection(1);\r\n                } else if (isWhitespace(c)) {\r\n                    this._emitToken("attribvalue");\r\n                    this._state = BEFORE_ATTRIBUTE_NAME;\r\n                } else if (!isLegalInUnquotedAttributeValue(c)) {\r\n                    this._emitSpecialToken("error");\r\n                    break;\r\n                }\r\n            } else if (this._state === AFTER_QUOTED_ATTRIBUTE_VALUE) {\r\n                // There must be at least one whitespace between the end of a quoted\r\n                // attribute value and the next attribute, if any.\r\n                if (c === ">") {\r\n                    this._state = TEXT;\r\n                    this._emitSpecialToken("opentagend", this._index + 1, _clonePos(this._indexPos, 1));\r\n                    this._startSection(1);\r\n                } else if (c === "/") {\r\n                    this._emitSpecialToken("selfclosingtag", this._index + 2, _clonePos(this._indexPos, 2));\r\n                    this._state = AFTER_SELFCLOSE_SLASH;\r\n                } else if (isWhitespace(c)) {\r\n                    this._state = BEFORE_ATTRIBUTE_NAME;\r\n                } else {\r\n                    this._emitSpecialToken("error");\r\n                    break;\r\n                }\r\n    \r\n            /*\r\n            *	declarations\r\n            */\r\n            } else if (this._state === BEFORE_DECLARATION) {\r\n                if (c === "[") {\r\n                    this._state = BEFORE_CDATA_1;\r\n                } else if (c === "-") {\r\n                    this._state = BEFORE_COMMENT;\r\n                } else {\r\n                    this._state = IN_DECLARATION;\r\n                }\r\n            } else if (this._state === IN_DECLARATION) {\r\n                if (c === ">") {\r\n                    this._emitToken("declaration");\r\n                    this._state = TEXT;\r\n                    this._startSection(1);\r\n                }\r\n            \r\n    \r\n            /*\r\n            *	processing instructions\r\n            */\r\n            } else if (this._state === IN_PROCESSING_INSTRUCTION) {\r\n                if (c === ">") {\r\n                    this._emitToken("processinginstruction");\r\n                    this._state = TEXT;\r\n                    this._startSection(1);\r\n                }\r\n            \r\n    \r\n            /*\r\n            *	comments\r\n            */\r\n            } else if (this._state === BEFORE_COMMENT) {\r\n                if (c === "-") {\r\n                    this._state = IN_COMMENT;\r\n                    this._startSection(1);\r\n                } else {\r\n                    this._state = IN_DECLARATION;\r\n                }\r\n            } else if (this._state === IN_COMMENT) {\r\n                if (c === "-") {\r\n                    this._state = AFTER_COMMENT_1;\r\n                }\r\n            } else if (this._state === AFTER_COMMENT_1) {\r\n                if (c === "-") {\r\n                    this._state = AFTER_COMMENT_2;\r\n                } else {\r\n                    this._state = IN_COMMENT;\r\n                }\r\n            } else if (this._state === AFTER_COMMENT_2) {\r\n                if (c === ">") {\r\n                    //remove 2 trailing chars\r\n                    // It should be okay to just decrement the char position by 2 because we know neither of the previous\r\n                    // characters is a newline.\r\n                    this._emitToken("comment", this._index - 2, _clonePos(this._indexPos, -2));\r\n                    this._state = TEXT;\r\n                    this._startSection(1);\r\n                } else if (c !== "-") {\r\n                    this._state = IN_COMMENT;\r\n                }\r\n                // else: stay in AFTER_COMMENT_2 (`--->`)\r\n            \r\n    \r\n            /*\r\n            *	cdata\r\n            */\r\n            } else if (this._state === BEFORE_CDATA_1) {\r\n                if (c === "C") {\r\n                    this._state = BEFORE_CDATA_2;\r\n                } else {\r\n                    this._state = IN_DECLARATION;\r\n                }\r\n            } else if (this._state === BEFORE_CDATA_2) {\r\n                if (c === "D") {\r\n                    this._state = BEFORE_CDATA_3;\r\n                } else {\r\n                    this._state = IN_DECLARATION;\r\n                }\r\n            } else if (this._state === BEFORE_CDATA_3) {\r\n                if (c === "A") {\r\n                    this._state = BEFORE_CDATA_4;\r\n                } else {\r\n                    this._state = IN_DECLARATION;\r\n                }\r\n            } else if (this._state === BEFORE_CDATA_4) {\r\n                if (c === "T") {\r\n                    this._state = BEFORE_CDATA_5;\r\n                } else {\r\n                    this._state = IN_DECLARATION;\r\n                }\r\n            } else if (this._state === BEFORE_CDATA_5) {\r\n                if (c === "A") {\r\n                    this._state = BEFORE_CDATA_6;\r\n                } else {\r\n                    this._state = IN_DECLARATION;\r\n                }\r\n            } else if (this._state === BEFORE_CDATA_6) {\r\n                if (c === "[") {\r\n                    this._state = IN_CDATA;\r\n                    this._startSection(1);\r\n                } else {\r\n                    this._state = IN_DECLARATION;\r\n                }\r\n            } else if (this._state === IN_CDATA) {\r\n                if (c === "]") {\r\n                    this._state = AFTER_CDATA_1;\r\n                }\r\n            } else if (this._state === AFTER_CDATA_1) {\r\n                if (c === "]") {\r\n                    this._state = AFTER_CDATA_2;\r\n                } else {\r\n                    this._state = IN_CDATA;\r\n                }\r\n            } else if (this._state === AFTER_CDATA_2) {\r\n                if (c === ">") {\r\n                    //remove 2 trailing chars\r\n                    // It should be okay to just decrement the char position by 2 because we know neither of the previous\r\n                    // characters is a newline.\r\n                    this._emitToken("cdata", this._index - 2, _clonePos(this._indexPos, -2));\r\n                    this._state = TEXT;\r\n                    this._startSection(1);\r\n                } else if (c !== "]") {\r\n                    this._state = IN_CDATA;\r\n                }\r\n                //else: stay in AFTER_CDATA_2 (`]]]>`)\r\n            \r\n    \r\n            /*\r\n            * special tags\r\n            */\r\n            } else if (this._state === BEFORE_SPECIAL) {\r\n                if (c === "c" || c === "C") {\r\n                    this._state = BEFORE_SCRIPT_1;\r\n                } else if (c === "t" || c === "T") {\r\n                    this._state = BEFORE_STYLE_1;\r\n                } else {\r\n                    this._state = IN_TAG_NAME;\r\n                    continue; //consume the token again\r\n                }\r\n            } else if (this._state === BEFORE_SPECIAL_END) {\r\n                if (this._special === 1 && (c === "c" || c === "C")) {\r\n                    this._state = AFTER_SCRIPT_1;\r\n                } else if (this._special === 2 && (c === "t" || c === "T")) {\r\n                    this._state = AFTER_STYLE_1;\r\n                } else {\r\n                    this._state = TEXT;\r\n                }\r\n            \r\n    \r\n            /*\r\n            * script\r\n            */\r\n            } else if (this._state === BEFORE_SCRIPT_1) {\r\n                if (c === "r" || c === "R") {\r\n                    this._state = BEFORE_SCRIPT_2;\r\n                } else {\r\n                    this._state = IN_TAG_NAME;\r\n                    continue; //consume the token again\r\n                }\r\n            } else if (this._state === BEFORE_SCRIPT_2) {\r\n                if (c === "i" || c === "I") {\r\n                    this._state = BEFORE_SCRIPT_3;\r\n                } else {\r\n                    this._state = IN_TAG_NAME;\r\n                    continue; //consume the token again\r\n                }\r\n            } else if (this._state === BEFORE_SCRIPT_3) {\r\n                if (c === "p" || c === "P") {\r\n                    this._state = BEFORE_SCRIPT_4;\r\n                } else {\r\n                    this._state = IN_TAG_NAME;\r\n                    continue; //consume the token again\r\n                }\r\n            } else if (this._state === BEFORE_SCRIPT_4) {\r\n                if (c === "t" || c === "T") {\r\n                    this._state = BEFORE_SCRIPT_5;\r\n                } else {\r\n                    this._state = IN_TAG_NAME;\r\n                    continue; //consume the token again\r\n                }\r\n            } else if (this._state === BEFORE_SCRIPT_5) {\r\n                if (c === "/" || c === ">" || isWhitespace(c)) {\r\n                    this._special = 1;\r\n                }\r\n                this._state = IN_TAG_NAME;\r\n                continue; //consume the token again\r\n            } else if (this._state === AFTER_SCRIPT_1) {\r\n                if (c === "r" || c === "R") {\r\n                    this._state = AFTER_SCRIPT_2;\r\n                } else {\r\n                    this._state = TEXT;\r\n                }\r\n            } else if (this._state === AFTER_SCRIPT_2) {\r\n                if (c === "i" || c === "I") {\r\n                    this._state = AFTER_SCRIPT_3;\r\n                } else {\r\n                    this._state = TEXT;\r\n                }\r\n            } else if (this._state === AFTER_SCRIPT_3) {\r\n                if (c === "p" || c === "P") {\r\n                    this._state = AFTER_SCRIPT_4;\r\n                } else {\r\n                    this._state = TEXT;\r\n                }\r\n            } else if (this._state === AFTER_SCRIPT_4) {\r\n                if (c === "t" || c === "T") {\r\n                    this._state = AFTER_SCRIPT_5;\r\n                } else {\r\n                    this._state = TEXT;\r\n                }\r\n            } else if (this._state === AFTER_SCRIPT_5) {\r\n                if (c === ">" || isWhitespace(c)) {\r\n                    this._state = IN_CLOSING_TAG_NAME;\r\n                    this._startSection(-6);\r\n                    continue; //reconsume the token\r\n                } else {\r\n                    this._state = TEXT;\r\n                }\r\n            \r\n    \r\n            /*\r\n            * style\r\n            */\r\n            } else if (this._state === BEFORE_STYLE_1) {\r\n                if (c === "y" || c === "Y") {\r\n                    this._state = BEFORE_STYLE_2;\r\n                } else {\r\n                    this._state = IN_TAG_NAME;\r\n                    continue; //consume the token again\r\n                }\r\n            } else if (this._state === BEFORE_STYLE_2) {\r\n                if (c === "l" || c === "L") {\r\n                    this._state = BEFORE_STYLE_3;\r\n                } else {\r\n                    this._state = IN_TAG_NAME;\r\n                    continue; //consume the token again\r\n                }\r\n            } else if (this._state === BEFORE_STYLE_3) {\r\n                if (c === "e" || c === "E") {\r\n                    this._state = BEFORE_STYLE_4;\r\n                } else {\r\n                    this._state = IN_TAG_NAME;\r\n                    continue; //consume the token again\r\n                }\r\n            } else if (this._state === BEFORE_STYLE_4) {\r\n                if (c === "/" || c === ">" || isWhitespace(c)) {\r\n                    this._special = 2;\r\n                }\r\n                this._state = IN_TAG_NAME;\r\n                continue; //consume the token again\r\n            } else if (this._state === AFTER_STYLE_1) {\r\n                if (c === "y" || c === "Y") {\r\n                    this._state = AFTER_STYLE_2;\r\n                } else {\r\n                    this._state = TEXT;\r\n                }\r\n            } else if (this._state === AFTER_STYLE_2) {\r\n                if (c === "l" || c === "L") {\r\n                    this._state = AFTER_STYLE_3;\r\n                } else {\r\n                    this._state = TEXT;\r\n                }\r\n            } else if (this._state === AFTER_STYLE_3) {\r\n                if (c === "e" || c === "E") {\r\n                    this._state = AFTER_STYLE_4;\r\n                } else {\r\n                    this._state = TEXT;\r\n                }\r\n            } else if (this._state === AFTER_STYLE_4) {\r\n                if (c === ">" || isWhitespace(c)) {\r\n                    this._state = IN_CLOSING_TAG_NAME;\r\n                    this._startSection(-5);\r\n                    continue; //reconsume the token\r\n                } else {\r\n                    this._state = TEXT;\r\n                }\r\n            } else {\r\n                console.error("HTMLTokenizer: Encountered unknown state");\r\n                this._emitSpecialToken("error");\r\n                break;\r\n            }\r\n\r\n            if (c === "\\n") {\r\n                this._indexPos.line++;\r\n                this._indexPos.ch = 0;\r\n            } else {\r\n                this._indexPos.ch++;\r\n            }\r\n            this._index++;\r\n        }\r\n        \r\n        if (this._index === this._buffer.length && this._state !== TEXT) {\r\n            // We hit EOF in the middle of processing something else.\r\n            this._emitSpecialToken("error");\r\n        }\r\n        return this._token;\r\n    };\r\n    \r\n    Tokenizer.prototype._startSection = function (offset) {\r\n        offset = offset || 0;\r\n        this._sectionStart = this._index + offset;\r\n        \r\n        // Normally it wouldn\'t be safe to assume that we can just add the offset to the\r\n        // character position, because there might be a newline, which would require us to\r\n        // move to the next line. However, in all the cases where this is called, we are\r\n        // adjusting for characters that we know are not newlines.\r\n        this._sectionStartPos = _clonePos(this._indexPos, offset);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Extract the portion of the buffer since _sectionStart and set it to be the next token we return\r\n     * from `nextToken()`. If there\'s already a _token, we stuff it in _nextToken instead.\r\n     * @param {string} type The token\'s type (see documentation for `nextToken()`)\r\n     * @param {number} index If specified, the index to use as the end of the token; uses this._index if not specified\r\n     */\r\n    Tokenizer.prototype._setToken = function (type, index, indexPos) {\r\n        if (index === undefined) {\r\n            index = this._index;\r\n        }\r\n        if (indexPos === undefined) {\r\n            indexPos = this._indexPos;\r\n        }\r\n        var token = {\r\n            type: type,\r\n            contents: this._sectionStart === -1 ? "" : this._buffer.substring(this._sectionStart, index),\r\n            start: this._sectionStart,\r\n            end: index,\r\n            startPos: _clonePos(this._sectionStartPos),\r\n            endPos: _clonePos(indexPos)\r\n        };\r\n        if (this._token) {\r\n            // Queue this token to be emitted next. In theory it would be more general to have\r\n            // an arbitrary-length queue, but currently we only ever emit at most two tokens in a\r\n            // single pass through the tokenization loop.\r\n            if (this._nextToken) {\r\n                console.error("HTMLTokenizer: Tried to emit more than two tokens in a single call");\r\n            }\r\n            this._nextToken = token;\r\n        } else {\r\n            this._token = token;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Sets the token to be returned from `nextToken()` and resets the section start to an invalid value.\r\n     * this._sectionStart should be set to a valid value before the next call to one of the `_emit` methods.\r\n     * @param {string} type The token\'s type (see documentation for `nextToken()`)\r\n     * @param {number} index If specified, the index to use as the end of the token; uses this._index if not specified\r\n     */\r\n    Tokenizer.prototype._emitToken = function (type, index, indexPos) {\r\n        this._setToken(type, index, indexPos);\r\n        this._sectionStart = -1;\r\n        this._sectionStartPos = null;\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Like `_emitToken()`, but used for special tokens that don\'t have real content (like opentagend and selfclosingtag).\r\n     * @param {string} type The token\'s type (see documentation for `nextToken()`)\r\n     * @param {number} index If specified, the index to use as the end of the token; uses this._index if not specified\r\n     */\r\n    Tokenizer.prototype._emitSpecialToken = function (type, index, indexPos) {\r\n        // Force the section start to be -1, since these tokens don\'t have meaningful content--they\'re\r\n        // just marking particular boundaries we care about (end of an open tag or a self-closing tag).\r\n        this._sectionStart = -1;\r\n        this._sectionStartPos = null;\r\n        this._emitToken(type, index, indexPos);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Like `_emitToken()`, but only emits a token if there is actually content in it. Note that this still\r\n     * resets this._sectionStart to an invalid value even if there is no content, so a new section must be\r\n     * started before the next `_emit`.\r\n     * @param {string} type The token\'s type (see documentation for `nextToken()`)\r\n     */\r\n    Tokenizer.prototype._emitTokenIfNonempty = function (type) {\r\n        if (this._index > this._sectionStart) {\r\n            this._setToken(type);\r\n        }\r\n        this._sectionStart = -1;\r\n        this._sectionStartPos = null;\r\n    };\r\n    \r\n    exports.Tokenizer = Tokenizer;\r\n});\n//# sourceURL=/language/HTMLTokenizer.js'),eval("/* Public Domain MurmurHash3 implementation. Altered to have AMD header and function wrapper. */\r\n\r\ndefine('thirdparty/murmurhash3_gc',['require','exports','module'],function (require, exports, module) {\r\n\r\n/*\r\n *  The MurmurHash3 algorithm was created by Austin Appleby.  This JavaScript port was authored\r\n *  by Peter Zotov (based on Java port by Yonik Seeley) and is placed into the public domain.\r\n *  The author hereby disclaims copyright to this source code.\r\n *\r\n *  This produces exactly the same hash values as the final C++ version of MurmurHash3 and\r\n *  is thus suitable for producing the same hash values across platforms.\r\n *\r\n *  There are two versions of this hash implementation. First interprets the string as a\r\n *  sequence of bytes, ignoring most significant byte of each codepoint. The second one\r\n *  interprets the string as a UTF-16 codepoint sequence, and appends each 16-bit codepoint\r\n *  to the hash independently. The latter mode was not written to be compatible with\r\n *  any other implementation, but it should offer better performance for JavaScript-only\r\n *  applications.\r\n *\r\n *  See http://github.com/whitequark/murmurhash3-js for future updates to this file.\r\n */\r\n\r\nvar MurmurHash3 = {\r\n	mul32: function(m, n) {\r\n		var nlo = n & 0xffff;\r\n		var nhi = n - nlo;\r\n		return ((nhi * m | 0) + (nlo * m | 0)) | 0;\r\n	},\r\n\r\n	hashBytes: function(data, len, seed) {\r\n		var c1 = 0xcc9e2d51, c2 = 0x1b873593;\r\n\r\n		var h1 = seed;\r\n		var roundedEnd = len & ~0x3;\r\n\r\n		for (var i = 0; i < roundedEnd; i += 4) {\r\n			var k1 = (data.charCodeAt(i)     & 0xff)        |\r\n				((data.charCodeAt(i + 1) & 0xff) << 8)  |\r\n				((data.charCodeAt(i + 2) & 0xff) << 16) |\r\n				((data.charCodeAt(i + 3) & 0xff) << 24);\r\n\r\n			k1 = this.mul32(k1, c1);\r\n			k1 = ((k1 & 0x1ffff) << 15) | (k1 >>> 17);  // ROTL32(k1,15);\r\n			k1 = this.mul32(k1, c2);\r\n\r\n			h1 ^= k1;\r\n			h1 = ((h1 & 0x7ffff) << 13) | (h1 >>> 19);  // ROTL32(h1,13);\r\n			h1 = (h1 * 5 + 0xe6546b64) | 0;\r\n		}\r\n\r\n		k1 = 0;\r\n\r\n		switch(len % 4) {\r\n			case 3:\r\n				k1 = (data.charCodeAt(roundedEnd + 2) & 0xff) << 16;\r\n				// fallthrough\r\n			case 2:\r\n				k1 |= (data.charCodeAt(roundedEnd + 1) & 0xff) << 8;\r\n				// fallthrough\r\n			case 1:\r\n				k1 |= (data.charCodeAt(roundedEnd) & 0xff);\r\n				k1 = this.mul32(k1, c1);\r\n				k1 = ((k1 & 0x1ffff) << 15) | (k1 >>> 17);  // ROTL32(k1,15);\r\n				k1 = this.mul32(k1, c2);\r\n				h1 ^= k1;\r\n		}\r\n\r\n		// finalization\r\n		h1 ^= len;\r\n\r\n		// fmix(h1);\r\n		h1 ^= h1 >>> 16;\r\n		h1  = this.mul32(h1, 0x85ebca6b);\r\n		h1 ^= h1 >>> 13;\r\n		h1  = this.mul32(h1, 0xc2b2ae35);\r\n		h1 ^= h1 >>> 16;\r\n\r\n		return h1;\r\n	},\r\n\r\n	hashString: function(data, len, seed) {\r\n		var c1 = 0xcc9e2d51, c2 = 0x1b873593;\r\n\r\n		var h1 = seed;\r\n		var roundedEnd = len & ~0x1;\r\n\r\n		for (var i = 0; i < roundedEnd; i += 2) {\r\n			var k1 = data.charCodeAt(i) | (data.charCodeAt(i + 1) << 16);\r\n\r\n			k1 = this.mul32(k1, c1);\r\n			k1 = ((k1 & 0x1ffff) << 15) | (k1 >>> 17);  // ROTL32(k1,15);\r\n			k1 = this.mul32(k1, c2);\r\n\r\n			h1 ^= k1;\r\n			h1 = ((h1 & 0x7ffff) << 13) | (h1 >>> 19);  // ROTL32(h1,13);\r\n			h1 = (h1 * 5 + 0xe6546b64) | 0;\r\n		}\r\n\r\n		if((len % 2) == 1) {\r\n			k1 = data.charCodeAt(roundedEnd);\r\n			k1 = this.mul32(k1, c1);\r\n			k1 = ((k1 & 0x1ffff) << 15) | (k1 >>> 17);  // ROTL32(k1,15);\r\n			k1 = this.mul32(k1, c2);\r\n			h1 ^= k1;\r\n		}\r\n\r\n		// finalization\r\n		h1 ^= (len << 1);\r\n\r\n		// fmix(h1);\r\n		h1 ^= h1 >>> 16;\r\n		h1  = this.mul32(h1, 0x85ebca6b);\r\n		h1 ^= h1 >>> 13;\r\n		h1  = this.mul32(h1, 0xc2b2ae35);\r\n		h1 ^= h1 >>> 16;\r\n\r\n		return h1;\r\n	}\r\n};\r\n\r\nif(typeof module !== \"undefined\" && typeof module.exports !== \"undefined\") {\r\n	module.exports = MurmurHash3;\r\n}\r\n});\n//# sourceURL=/thirdparty/murmurhash3_gc.js"),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n/*unittests: HTML Instrumentation*/\r\n\r\ndefine(\'language/HTMLSimpleDOM\',[\'require\',\'exports\',\'module\',\'document/DocumentManager\',\'language/HTMLTokenizer\',\'thirdparty/murmurhash3_gc\',\'utils/PerfUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var DocumentManager = require("document/DocumentManager"),\r\n        Tokenizer       = require("language/HTMLTokenizer").Tokenizer,\r\n        MurmurHash3     = require("thirdparty/murmurhash3_gc"),\r\n        PerfUtils       = require("utils/PerfUtils");\r\n    \r\n    var seed = Math.floor(Math.random() * 65535);\r\n    \r\n    var tagID = 1;\r\n    \r\n    /**\r\n     * A list of tags whose start causes any of a given set of immediate parent\r\n     * tags to close. This mostly comes from the HTML5 spec section on omitted close tags:\r\n     * http://www.w3.org/html/wg/drafts/html/master/syntax.html#optional-tags\r\n     * This doesn\'t handle general content model violations.\r\n     */\r\n    var openImpliesClose = {\r\n        li      : { li: true },\r\n        dt      : { dd: true, dt: true },\r\n        dd      : { dd: true, dt: true },\r\n        address : { p: true },\r\n        article : { p: true },\r\n        aside   : { p: true },\r\n        blockquote : { p: true },\r\n        dir     : { p: true },\r\n        div     : { p: true },\r\n        dl      : { p: true },\r\n        fieldset: { p: true },\r\n        footer  : { p: true },\r\n        form    : { p: true },\r\n        h1      : { p: true },\r\n        h2      : { p: true },\r\n        h3      : { p: true },\r\n        h4      : { p: true },\r\n        h5      : { p: true },\r\n        h6      : { p: true },\r\n        header  : { p: true },\r\n        hgroup  : { p: true },\r\n        hr      : { p: true },\r\n        main    : { p: true },\r\n        menu    : { p: true },\r\n        nav     : { p: true },\r\n        ol      : { p: true },\r\n        p       : { p: true },\r\n        pre     : { p: true },\r\n        section : { p: true },\r\n        table   : { p: true },\r\n        ul      : { p: true },\r\n        rt      : { rp: true, rt: true },\r\n        rp      : { rp: true, rt: true },\r\n        optgroup: { optgroup: true, option: true },\r\n        option  : { option: true },\r\n        tbody   : { thead: true, tbody: true, tfoot: true },\r\n        tfoot   : { tbody: true },\r\n        tr      : { tr: true, th: true, td: true },\r\n        th      : { th: true, td: true },\r\n        td      : { thead: true, th: true, td: true },\r\n        body    : { head: true, link: true, script: true }\r\n    };\r\n\r\n    /**\r\n     * A list of tags that are self-closing (do not contain other elements).\r\n     * Mostly taken from http://www.w3.org/html/wg/drafts/html/master/syntax.html#void-elements\r\n     */\r\n    var voidElements = {\r\n        area: true,\r\n        base: true,\r\n        basefont: true,\r\n        br: true,\r\n        col: true,\r\n        command: true,\r\n        embed: true,\r\n        frame: true,\r\n        hr: true,\r\n        img: true,\r\n        input: true,\r\n        isindex: true,\r\n        keygen: true,\r\n        link: true,\r\n        menuitem: true,\r\n        meta: true,\r\n        param: true,\r\n        source: true,\r\n        track: true,\r\n        wbr: true\r\n    };\r\n    \r\n    /**\r\n     * A SimpleNode represents one node in a SimpleDOM tree. Each node can have\r\n     * any set of properties on it, though there are a couple of assumptions made.\r\n     * Elements will have `children` and `attributes` properties. Text nodes will have a `content`\r\n     * property. All Elements will have a `tagID` and text nodes *can* have one.\r\n     *\r\n     * @constructor\r\n     *\r\n     * @param {Object} properties the properties provided will be set on the new object.\r\n     */\r\n    function SimpleNode(properties) {\r\n        $.extend(this, properties);\r\n    }\r\n    \r\n    SimpleNode.prototype = {\r\n        \r\n        /**\r\n         * Updates signatures used to optimize the number of comparisons done during\r\n         * diffing. This is important to call if you change:\r\n         *\r\n         * * children\r\n         * * child node attributes\r\n         * * text content of a text node\r\n         * * child node text\r\n         */\r\n        update: function () {\r\n            if (this.isElement()) {\r\n                var i,\r\n                    subtreeHashes = "",\r\n                    childHashes = "",\r\n                    child;\r\n                for (i = 0; i < this.children.length; i++) {\r\n                    child = this.children[i];\r\n                    if (child.isElement()) {\r\n                        childHashes += String(child.tagID);\r\n                        subtreeHashes += String(child.tagID) + child.attributeSignature + child.subtreeSignature;\r\n                    } else {\r\n                        childHashes += child.textSignature;\r\n                        subtreeHashes += child.textSignature;\r\n                    }\r\n                }\r\n                this.childSignature = MurmurHash3.hashString(childHashes, childHashes.length, seed);\r\n                this.subtreeSignature = MurmurHash3.hashString(subtreeHashes, subtreeHashes.length, seed);\r\n            } else {\r\n                this.textSignature = MurmurHash3.hashString(this.content, this.content.length, seed);\r\n            }\r\n        },\r\n        \r\n        /**\r\n         * Updates the signature of this node\'s attributes. Call this after making attribute changes.\r\n         */\r\n        updateAttributeSignature: function () {\r\n            var attributeString = JSON.stringify(this.attributes);\r\n            this.attributeSignature = MurmurHash3.hashString(attributeString, attributeString.length, seed);\r\n        },\r\n        \r\n        /**\r\n         * Is this node an element node?\r\n         *\r\n         * @return {bool} true if it is an element\r\n         */\r\n        isElement: function () {\r\n            return !!this.children;\r\n        },\r\n        \r\n        /**\r\n         * Is this node a text node?\r\n         *\r\n         * @return {bool} true if it is text\r\n         */\r\n        isText: function () {\r\n            return !this.children;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     *\r\n     * Generates a synthetic ID for text nodes. These IDs are only used\r\n     * for convenience when reading a SimpleDOM that is dumped to the console.\r\n     *\r\n     * @param {Object} textNode new node for which we are generating an ID\r\n     * @return {string} ID for the node\r\n     */\r\n    function getTextNodeID(textNode) {\r\n        var childIndex = textNode.parent.children.indexOf(textNode);\r\n        if (childIndex === 0) {\r\n            return textNode.parent.tagID + ".0";\r\n        }\r\n        return textNode.parent.children[childIndex - 1].tagID + "t";\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     *\r\n     * Adds two {line, ch}-style positions, returning a new pos.\r\n     */\r\n    function _addPos(pos1, pos2) {\r\n        return {line: pos1.line + pos2.line, ch: (pos2.line === 0 ? pos1.ch + pos2.ch : pos2.ch)};\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     *\r\n     * Offsets the character offset of the given {line, ch} pos by the given amount and returns a new\r\n     * pos. Not for general purpose use as it does not account for line boundaries.\r\n     */\r\n    function _offsetPos(pos, offset) {\r\n        return {line: pos.line, ch: pos.ch + offset};\r\n    }\r\n    \r\n    /**\r\n     * A Builder creates a SimpleDOM tree of SimpleNode objects representing the\r\n     * "important" contents of an HTML document. It does not include things like comments.\r\n     * The nodes include information about their position in the text provided.\r\n     * \r\n     * @constructor\r\n     *\r\n     * @param {string} text The text to parse\r\n     * @param {?int} startOffset starting offset in the text\r\n     * @param {?{line: int, ch: int}} startOffsetPos line/ch position in the text\r\n     */\r\n    function Builder(text, startOffset, startOffsetPos) {\r\n        this.stack = [];\r\n        this.text = text;\r\n        this.t = new Tokenizer(text);\r\n        this.currentTag = null;\r\n        this.startOffset = startOffset || 0;\r\n        this.startOffsetPos = startOffsetPos || {line: 0, ch: 0};\r\n    }\r\n\r\n    Builder.prototype._logError = function (token) {\r\n        var error       = { token: token },\r\n            startPos    = token ? (token.startPos || token.endPos) : this.startOffsetPos,\r\n            endPos      = token ? token.endPos : this.startOffsetPos;\r\n        \r\n        error.startPos = _addPos(this.startOffsetPos, startPos);\r\n        error.endPos = _addPos(this.startOffsetPos, endPos);\r\n\r\n        if (!this.errors) {\r\n            this.errors = [];\r\n        }\r\n\r\n        this.errors.push(error);\r\n    };\r\n    \r\n    /**\r\n     * Builds the SimpleDOM.\r\n     *\r\n     * @param {?bool} strict if errors are detected, halt and return null\r\n     * @param {?Object} markCache a cache that can be used in ID generation (is passed to `getID`)\r\n     * @return {SimpleNode} root of tree or null if parsing failed\r\n     */\r\n    Builder.prototype.build = function (strict, markCache) {\r\n        var self = this;\r\n        var token, lastClosedTag, lastTextNode, lastIndex = 0;\r\n        var stack = this.stack;\r\n        var attributeName = null;\r\n        var nodeMap = {};\r\n                \r\n        markCache = markCache || {};\r\n        \r\n        // Start timers for building full and partial DOMs.\r\n        // Appropriate timer is used, and the other is discarded.\r\n        var timerBuildFull = "HTMLInstr. Build DOM Full";\r\n        var timerBuildPart = "HTMLInstr. Build DOM Partial";\r\n        PerfUtils.markStart([timerBuildFull, timerBuildPart]);\r\n        \r\n        function closeTag(endIndex, endPos) {\r\n            lastClosedTag = stack[stack.length - 1];\r\n            stack.pop();\r\n            lastClosedTag.update();\r\n            \r\n            lastClosedTag.end = self.startOffset + endIndex;\r\n            lastClosedTag.endPos = _addPos(self.startOffsetPos, endPos);\r\n        }\r\n        \r\n        while ((token = this.t.nextToken()) !== null) {\r\n            // lastTextNode is used to glue text nodes together\r\n            // If the last node we saw was text but this one is not, then we\'re done gluing.\r\n            // If this node is a comment, we might still encounter more text.\r\n            if (token.type !== "text" && token.type !== "comment" && lastTextNode) {\r\n                lastTextNode = null;\r\n            }\r\n            \r\n            if (token.type === "error") {\r\n                PerfUtils.finalizeMeasurement(timerBuildFull);  // discard\r\n                PerfUtils.addMeasurement(timerBuildPart);       // use\r\n                this._logError(token);\r\n                return null;\r\n            } else if (token.type === "opentagname") {\r\n                var newTagName = token.contents.toLowerCase(),\r\n                    newTag;\r\n                \r\n                if (openImpliesClose.hasOwnProperty(newTagName)) {\r\n                    var closable = openImpliesClose[newTagName];\r\n                    while (stack.length > 0 && closable.hasOwnProperty(stack[stack.length - 1].tag)) {\r\n                        // Close the previous tag at the start of this tag.\r\n                        // Adjust backwards for the < before the tag name.\r\n                        closeTag(token.start - 1, _offsetPos(token.startPos, -1));\r\n                    }\r\n                }\r\n                \r\n                newTag = new SimpleNode({\r\n                    tag: token.contents.toLowerCase(),\r\n                    children: [],\r\n                    attributes: {},\r\n                    parent: (stack.length ? stack[stack.length - 1] : null),\r\n                    start: this.startOffset + token.start - 1,\r\n                    startPos: _addPos(this.startOffsetPos, _offsetPos(token.startPos, -1)) // ok because we know the previous char was a "<"\r\n                });\r\n                newTag.tagID = this.getID(newTag, markCache);\r\n                \r\n                // During undo in particular, it\'s possible that tag IDs may be reused and\r\n                // the marks in the document may be misleading. If a tag ID has been reused,\r\n                // we apply a new tag ID to ensure that our edits come out correctly.\r\n                if (nodeMap[newTag.tagID]) {\r\n                    newTag.tagID = this.getNewID();\r\n                }\r\n                \r\n                nodeMap[newTag.tagID] = newTag;\r\n                if (newTag.parent) {\r\n                    newTag.parent.children.push(newTag);\r\n                }\r\n                this.currentTag = newTag;\r\n                \r\n                if (voidElements.hasOwnProperty(newTag.tag)) {\r\n                    // This is a self-closing element.\r\n                    newTag.update();\r\n                } else {\r\n                    stack.push(newTag);\r\n                }\r\n            } else if (token.type === "opentagend" || token.type === "selfclosingtag") {\r\n                // TODO: disallow <p/>?\r\n                if (this.currentTag) {\r\n                    if (token.type === "selfclosingtag" && stack.length && stack[stack.length - 1] === this.currentTag) {\r\n                        // This must have been a self-closing tag that we didn\'t identify as a void element\r\n                        // (e.g. an SVG tag). Pop it off the stack as if we had encountered its close tag.\r\n                        closeTag(token.end, token.endPos);\r\n                    } else {\r\n                        // We\'re ending an open tag. Record the end of the open tag as the end of the\r\n                        // range. (If we later find a close tag for this tag, the end will get overwritten\r\n                        // with the end of the close tag. In the case of a self-closing tag, we should never\r\n                        // encounter that.)\r\n                        // Note that we don\'t need to update the signature here because the signature only\r\n                        // relies on the tag name and ID, and isn\'t affected by the tag\'s attributes, so\r\n                        // the signature we calculated when creating the tag is still the same. If we later\r\n                        // find a close tag for this tag, we\'ll update the signature to account for its\r\n                        // children at that point (in the next "else" case).\r\n                        this.currentTag.end = this.startOffset + token.end;\r\n                        this.currentTag.endPos = _addPos(this.startOffsetPos, token.endPos);\r\n                        lastClosedTag = this.currentTag;\r\n                        this.currentTag.updateAttributeSignature();\r\n                        this.currentTag = null;\r\n                    }\r\n                }\r\n            } else if (token.type === "closetag") {\r\n                // If this is a self-closing element, ignore the close tag.\r\n                var closeTagName = token.contents.toLowerCase();\r\n                if (!voidElements.hasOwnProperty(closeTagName)) {\r\n                    // Find the topmost item on the stack that matches. If we can\'t find one, assume\r\n                    // this is just a dangling closing tag and ignore it.\r\n                    var i;\r\n                    for (i = stack.length - 1; i >= 0; i--) {\r\n                        if (stack[i].tag === closeTagName) {\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (strict && i !== stack.length - 1) {\r\n                        // If we\'re in strict mode, treat unbalanced tags as invalid.\r\n                        PerfUtils.finalizeMeasurement(timerBuildFull);\r\n                        PerfUtils.addMeasurement(timerBuildPart);\r\n                        this._logError(token);\r\n                        return null;\r\n                    }\r\n                    if (i >= 0) {\r\n                        do {\r\n                            // For all tags we\'re implicitly closing (before we hit the matching tag), we want the\r\n                            // implied end to be the beginning of the close tag (which is two characters, "</", before\r\n                            // the start of the tagname). For the actual tag we\'re explicitly closing, we want the\r\n                            // implied end to be the end of the close tag (which is one character, ">", after the end of\r\n                            // the tagname).\r\n                            if (stack.length === i + 1) {\r\n                                closeTag(token.end + 1, _offsetPos(token.endPos, 1));\r\n                            } else {\r\n                                closeTag(token.start - 2, _offsetPos(token.startPos, -2));\r\n                            }\r\n                        } while (stack.length > i);\r\n                    } else {\r\n                        // If we\'re in strict mode, treat unmatched close tags as invalid. Otherwise\r\n                        // we just silently ignore them.\r\n                        if (strict) {\r\n                            PerfUtils.finalizeMeasurement(timerBuildFull);\r\n                            PerfUtils.addMeasurement(timerBuildPart);\r\n                            this._logError(token);\r\n                            return null;\r\n                        }\r\n                    }\r\n                }\r\n            } else if (token.type === "attribname") {\r\n                attributeName = token.contents.toLowerCase();\r\n                // Set the value to the empty string in case this is an empty attribute. If it\'s not,\r\n                // it will get overwritten by the attribvalue later.\r\n                this.currentTag.attributes[attributeName] = "";\r\n            } else if (token.type === "attribvalue" && attributeName !== null) {\r\n                this.currentTag.attributes[attributeName] = token.contents;\r\n                attributeName = null;\r\n            } else if (token.type === "text") {\r\n                if (stack.length) {\r\n                    var parent = stack[stack.length - 1];\r\n                    var newNode;\r\n                    \r\n                    // Check to see if we\'re continuing a previous text.\r\n                    if (lastTextNode) {\r\n                        newNode = lastTextNode;\r\n                        newNode.content += token.contents;\r\n                    } else {\r\n                        newNode = new SimpleNode({\r\n                            parent: stack[stack.length - 1],\r\n                            content: token.contents\r\n                        });\r\n                        parent.children.push(newNode);\r\n                        newNode.tagID = getTextNodeID(newNode);\r\n                        nodeMap[newNode.tagID] = newNode;\r\n                        lastTextNode = newNode;\r\n                    }\r\n                    \r\n                    newNode.update();\r\n                }\r\n            }\r\n            lastIndex = token.end;\r\n        }\r\n        \r\n        // If we have any tags hanging open (e.g. html or body), fail the parse if we\'re in strict mode,\r\n        // otherwise close them at the end of the document.\r\n        if (stack.length) {\r\n            if (strict) {\r\n                PerfUtils.finalizeMeasurement(timerBuildFull);\r\n                PerfUtils.addMeasurement(timerBuildPart);\r\n                this._logError(token);\r\n                return null;\r\n            } else {\r\n                // Manually compute the position of the end of the text (we can\'t rely on the\r\n                // tokenizer for this since it may not get to the very end)\r\n                // TODO: should probably make the tokenizer get to the end...\r\n                var lines = this.text.split("\\n"),\r\n                    lastPos = {line: lines.length - 1, ch: lines[lines.length - 1].length};\r\n                while (stack.length) {\r\n                    closeTag(this.text.length, lastPos);\r\n                }\r\n            }\r\n        }\r\n        \r\n        var dom = lastClosedTag;\r\n        if (!dom) {\r\n            // This can happen if the document has no nontrivial content, or if the user tries to\r\n            // have something at the root other than the HTML tag. In all such cases, we treat the\r\n            // document as invalid.\r\n            this._logError(token);\r\n            return null;\r\n        }\r\n        \r\n        dom.nodeMap = nodeMap;\r\n        PerfUtils.addMeasurement(timerBuildFull);       // use\r\n        PerfUtils.finalizeMeasurement(timerBuildPart);  // discard\r\n        \r\n        return dom;\r\n    };\r\n    \r\n    /**\r\n     * Returns a new tag ID.\r\n     *\r\n     * @return {int} unique tag ID\r\n     */\r\n    Builder.prototype.getNewID = function () {\r\n        return tagID++;\r\n    };\r\n    \r\n    /**\r\n     * Returns the best tag ID for the new tag object given. \r\n     * The default implementation just calls `getNewID`\r\n     * and returns a unique ID.\r\n     *\r\n     * @param {Object} newTag tag object to potentially inspect to choose an ID\r\n     * @return {int} unique tag ID\r\n     */\r\n    Builder.prototype.getID = Builder.prototype.getNewID;\r\n    \r\n    /**\r\n     * Builds a SimpleDOM from the text provided. If `strict` mode is true, parsing\r\n     * will halt as soon as any error is seen and null will be returned.\r\n     *\r\n     * @param {string} text Text of document to parse\r\n     * @param {bool} strict True for strict parsing\r\n     * @return {SimpleNode} root of tree or null if strict failed\r\n     */\r\n    function build(text, strict) {\r\n        var builder = new Builder(text);\r\n        return builder.build(strict);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     *\r\n     * Generates a string version of a SimpleDOM for debugging purposes.\r\n     *\r\n     * @param {SimpleNode} root root of the tree\r\n     * @return {string} Text version of the tree.\r\n     */\r\n    function _dumpDOM(root) {\r\n        var result = "",\r\n            indent = "";\r\n        \r\n        function walk(node) {\r\n            if (node.tag) {\r\n                result += indent + "TAG " + node.tagID + " " + node.tag + " " + JSON.stringify(node.attributes) + "\\n";\r\n            } else {\r\n                result += indent + "TEXT " + (node.tagID || "- ") + node.content + "\\n";\r\n            }\r\n            if (node.isElement()) {\r\n                indent += "  ";\r\n                node.children.forEach(walk);\r\n                indent = indent.slice(2);\r\n            }\r\n        }\r\n        walk(root);\r\n        \r\n        return result;\r\n    }\r\n    \r\n    // Public API\r\n    exports.build                       = build;\r\n    exports.Builder                     = Builder;\r\n    exports.SimpleNode                  = SimpleNode;\r\n    \r\n    // Private API\r\n    exports._dumpDOM                    = _dumpDOM;\r\n    exports._offsetPos                  = _offsetPos;\r\n    exports._getTextNodeID              = getTextNodeID;\r\n    exports._seed                       = seed;\r\n});\n//# sourceURL=/language/HTMLSimpleDOM.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n/*unittests: HTML Instrumentation*/\r\n\r\ndefine(\'language/HTMLDOMDiff\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    /**\r\n     * @private\r\n     *\r\n     * Determines the changes made to attributes and generates edits for those changes.\r\n     *\r\n     * @param {SimpleNode} oldNode node from old tree\r\n     * @param {SimpleNode} newNode node from new tree\r\n     * @return {Array.<Object>} list of edits to mutate attributes from the old node to the new\r\n     */\r\n    function generateAttributeEdits(oldNode, newNode) {\r\n        // shallow copy the old attributes object so that we can modify it\r\n        var oldAttributes = $.extend({}, oldNode.attributes),\r\n            newAttributes = newNode.attributes,\r\n            edits = [];\r\n        \r\n        Object.keys(newAttributes).forEach(function (attributeName) {\r\n            if (oldAttributes[attributeName] !== newAttributes[attributeName]) {\r\n                var type = oldAttributes.hasOwnProperty(attributeName) ? "attrChange" : "attrAdd";\r\n                edits.push({\r\n                    type: type,\r\n                    tagID: oldNode.tagID,\r\n                    attribute: attributeName,\r\n                    value: newAttributes[attributeName]\r\n                });\r\n            }\r\n            delete oldAttributes[attributeName];\r\n        });\r\n        \r\n        Object.keys(oldAttributes).forEach(function (attributeName) {\r\n            edits.push({\r\n                type: "attrDelete",\r\n                tagID: oldNode.tagID,\r\n                attribute: attributeName\r\n            });\r\n        });\r\n        \r\n        return edits;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     *\r\n     * Retrieve the parent tag ID of a SimpleDOM node.\r\n     *\r\n     * @param {Object} node SimpleDOM node for which to look up parent ID\r\n     * @return {int?} ID or null if there is no parent\r\n     */\r\n    function getParentID(node) {\r\n        return node.parent && node.parent.tagID;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     *\r\n     * When the main loop (see below) determines that something has changed with\r\n     * an element\'s immediate children, it calls this function to create edit\r\n     * operations for those changes.\r\n     *\r\n     * This adds to the edit list in place and does not return anything.\r\n     *\r\n     * @param {?Object} oldParent SimpleDOM node for the previous state of this element, null/undefined if the element is new\r\n     * @param {Object} newParent SimpleDOM node for the current state of the element\r\n     */\r\n    var generateChildEdits = function (oldParent, oldNodeMap, newParent, newNodeMap) {\r\n        /*jslint continue: true */\r\n        \r\n        var newIndex = 0,\r\n            oldIndex = 0,\r\n            newChildren = newParent.children,\r\n            oldChildren = oldParent ? oldParent.children : [],\r\n            newChild,\r\n            oldChild,\r\n            newEdits = [],\r\n            newEdit,\r\n            textAfterID,\r\n            edits = [],\r\n            moves = [],\r\n            newElements = [];\r\n        \r\n        /**\r\n         * We initially put new edit objects into the `newEdits` array so that we\r\n         * can fix them up with proper positioning information. This function is\r\n         * responsible for doing that fixup.\r\n         *\r\n         * The `beforeID` that appears in many edits tells the browser to make the\r\n         * change before the element with the given ID. In other words, an\r\n         * elementInsert with a `beforeID` of 32 would result in something like\r\n         * `parentElement.insertBefore(newChildElement, _queryBracketsID(32))`\r\n         *\r\n         * Many new edits are captured in the `newEdits` array so that a suitable\r\n         * `beforeID` can be added to them before they are added to the main edits\r\n         * list. This function sets the `beforeID` on any pending edits and adds\r\n         * them to the main list.\r\n         *\r\n         * If this item is not being deleted, then it will be used as the `afterID`\r\n         * for text edits that follow.\r\n         *\r\n         * @param {int} beforeID ID to set on the pending edits\r\n         * @param {boolean} isBeingDeleted true if the given item is being deleted. If so,\r\n         *     we can\'t use it as the `afterID` for future edits--whatever previous item\r\n         *     was set as the `textAfterID` is still okay.\r\n         */\r\n        var finalizeNewEdits = function (beforeID, isBeingDeleted) {\r\n            newEdits.forEach(function (edit) {\r\n                // elementDeletes don\'t need any positioning information\r\n                if (edit.type !== "elementDelete") {\r\n                    edit.beforeID = beforeID;\r\n                }\r\n            });\r\n            edits.push.apply(edits, newEdits);\r\n            newEdits = [];\r\n            \r\n            // If the item we made this set of edits relative to\r\n            // is being deleted, we can\'t use it as the afterID for future\r\n            // edits. It\'s okay to just keep the previous afterID, since\r\n            // this node will no longer be in the tree by the time we get\r\n            // to any future edit that needs an afterID.\r\n            if (!isBeingDeleted) {\r\n                textAfterID = beforeID;\r\n            }\r\n        };\r\n        \r\n        /**\r\n         * If the current element was not in the old DOM, then we will create\r\n         * an elementInsert edit for it.\r\n         *\r\n         * If the element was in the old DOM, this will return false and the\r\n         * main loop will either spot this element later in the child list\r\n         * or the element has been moved.\r\n         *\r\n         * @return {boolean} true if an elementInsert was created\r\n         */\r\n        var addElementInsert = function () {\r\n            if (!oldNodeMap[newChild.tagID]) {\r\n                newEdit = {\r\n                    type: "elementInsert",\r\n                    tag: newChild.tag,\r\n                    tagID: newChild.tagID,\r\n                    parentID: newChild.parent.tagID,\r\n                    attributes: newChild.attributes\r\n                };\r\n                \r\n                newEdits.push(newEdit);\r\n                \r\n                // This newly inserted node needs to have edits generated for its\r\n                // children, so we add it to the queue.\r\n                newElements.push(newChild);\r\n                \r\n                // A textInsert edit that follows this elementInsert should use\r\n                // this element\'s ID.\r\n                textAfterID = newChild.tagID;\r\n                \r\n                // new element means we need to move on to compare the next\r\n                // of the current tree with the one from the old tree that we\r\n                // just compared\r\n                newIndex++;\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        \r\n        /**\r\n         * If the old element that we\'re looking at does not appear in the new\r\n         * DOM, that means it was deleted and we\'ll create an elementDelete edit.\r\n         *\r\n         * If the element is in the new DOM, then this will return false and\r\n         * the main loop with either spot this node later on or the element\r\n         * has been moved.\r\n         *\r\n         * @return {boolean} true if elementDelete was generated\r\n         */\r\n        var addElementDelete = function () {\r\n            if (!newNodeMap[oldChild.tagID]) {\r\n                // We can finalize existing edits relative to this node *before* it\'s\r\n                // deleted.\r\n                finalizeNewEdits(oldChild.tagID, true);\r\n                \r\n                newEdit = {\r\n                    type: "elementDelete",\r\n                    tagID: oldChild.tagID\r\n                };\r\n                newEdits.push(newEdit);\r\n                \r\n                // deleted element means we need to move on to compare the next\r\n                // of the old tree with the one from the current tree that we\r\n                // just compared\r\n                oldIndex++;\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        \r\n        /**\r\n         * Adds a textInsert edit for a newly created text node.\r\n         */\r\n        var addTextInsert = function () {\r\n            newEdit = {\r\n                type: "textInsert",\r\n                content: newChild.content,\r\n                parentID: newChild.parent.tagID\r\n            };\r\n            \r\n            // text changes will generally have afterID and beforeID, but we make\r\n            // special note if it\'s the first child.\r\n            if (textAfterID) {\r\n                newEdit.afterID = textAfterID;\r\n            } else {\r\n                newEdit.firstChild = true;\r\n            }\r\n            newEdits.push(newEdit);\r\n            \r\n            // The text node is in the new tree, so we move to the next new tree item\r\n            newIndex++;\r\n        };\r\n        \r\n        /**\r\n         * Finds the previous child of the new tree.\r\n         *\r\n         * @return {?Object} previous child or null if there wasn\'t one\r\n         */\r\n        var prevNode = function () {\r\n            if (newIndex > 0) {\r\n                return newParent.children[newIndex - 1];\r\n            }\r\n            return null;\r\n        };\r\n        \r\n        /**\r\n         * Adds a textDelete edit for text node that is not in the new tree.\r\n         * Note that we actually create a textReplace rather than a textDelete\r\n         * if the previous node in current tree was a text node. We do this because\r\n         * text nodes are not individually addressable and a delete event would\r\n         * end up clearing out both that previous text node that we want to keep\r\n         * and this text node that we want to eliminate. Instead, we just log\r\n         * a textReplace which will result in the deletion of this node and\r\n         * the maintaining of the old content.\r\n         */\r\n        var addTextDelete = function () {\r\n            var prev = prevNode();\r\n            if (prev && !prev.children) {\r\n                newEdit = {\r\n                    type: "textReplace",\r\n                    content: prev.content\r\n                };\r\n            } else {\r\n                newEdit = {\r\n                    type: "textDelete"\r\n                };\r\n            }\r\n            \r\n            // When elements are deleted or moved from the old set of children, you\r\n            // can end up with multiple text nodes in a row. A single textReplace edit\r\n            // will take care of those (and will contain all of the right content since\r\n            // the text nodes between elements in the new DOM are merged together).\r\n            // The check below looks to see if we\'re already in the process of adding\r\n            // a textReplace edit following the same element.\r\n            var previousEdit = newEdits.length > 0 && newEdits[newEdits.length - 1];\r\n            if (previousEdit && previousEdit.type === "textReplace" &&\r\n                    previousEdit.afterID === textAfterID) {\r\n                oldIndex++;\r\n                return;\r\n            }\r\n            \r\n            newEdit.parentID = oldChild.parent.tagID;\r\n            \r\n            // If there was only one child previously, we just pass along\r\n            // textDelete/textReplace with the parentID and the browser will\r\n            // clear all of the children\r\n            if (oldChild.parent.children.length === 1) {\r\n                newEdits.push(newEdit);\r\n            } else {\r\n                if (textAfterID) {\r\n                    newEdit.afterID = textAfterID;\r\n                }\r\n                newEdits.push(newEdit);\r\n            }\r\n            \r\n            // This text appeared in the old tree but not the new one, so we\r\n            // increment the old children counter.\r\n            oldIndex++;\r\n        };\r\n        \r\n        /**\r\n         * Adds an elementMove edit if the parent has changed between the old and new trees. \r\n         * These are fairly infrequent and generally occur if you make a change across \r\n         * tag boundaries.\r\n         *\r\n         * @return {boolean} true if an elementMove was generated\r\n         */\r\n        var addElementMove = function () {\r\n            \r\n            // This check looks a little strange, but it suits what we\'re trying\r\n            // to do: as we\'re walking through the children, a child node that has moved\r\n            // from one parent to another will be found but would look like some kind\r\n            // of insert. The check that we\'re doing here is looking up the current\r\n            // child\'s ID in the *old* map and seeing if this child used to have a \r\n            // different parent.\r\n            var possiblyMovedElement = oldNodeMap[newChild.tagID];\r\n            if (possiblyMovedElement &&\r\n                    newParent.tagID !== getParentID(possiblyMovedElement)) {\r\n                newEdit = {\r\n                    type: "elementMove",\r\n                    tagID: newChild.tagID,\r\n                    parentID: newChild.parent.tagID\r\n                };\r\n                moves.push(newEdit.tagID);\r\n                newEdits.push(newEdit);\r\n                \r\n                // this element in the new tree was a move to this spot, so we can move\r\n                // on to the next child in the new tree.\r\n                newIndex++;\r\n                return true;\r\n            }\r\n            return false;\r\n        };\r\n        \r\n        /**\r\n         * Looks to see if the element in the old tree has moved by checking its\r\n         * current and former parents.\r\n         *\r\n         * @return {boolean} true if the element has moved\r\n         */\r\n        var hasMoved = function (oldChild) {\r\n            var oldChildInNewTree = newNodeMap[oldChild.tagID];\r\n            \r\n            return oldChild.children && oldChildInNewTree && getParentID(oldChild) !== getParentID(oldChildInNewTree);\r\n        };\r\n        \r\n        // Loop through the current and old children, comparing them one by one.\r\n        while (newIndex < newChildren.length && oldIndex < oldChildren.length) {\r\n            newChild = newChildren[newIndex];\r\n            \r\n            // Check to see if the currentChild has been reparented from somewhere \r\n            // else in the old tree\r\n            if (newChild.children && addElementMove()) {\r\n                continue;\r\n            }\r\n            \r\n            oldChild = oldChildren[oldIndex];\r\n            \r\n            // Check to see if the oldChild has been moved to another parent.\r\n            // If it has, we deal with it on the other side (see above)\r\n            if (hasMoved(oldChild)) {\r\n                oldIndex++;\r\n                continue;\r\n            }\r\n            \r\n            if (newChild.isElement() || oldChild.isElement()) {\r\n                \r\n                if (newChild.isElement() && oldChild.isText()) {\r\n                    addTextDelete();\r\n                    \r\n                    // If this element is new, add it and move to the next child\r\n                    // in the current tree. Otherwise, we\'ll compare this same\r\n                    // current element with the next old element on the next pass\r\n                    // through the loop.\r\n                    addElementInsert();\r\n                \r\n                } else if (oldChild.isElement() && newChild.isText()) {\r\n                    // If the old child has *not* been deleted, we assume that we\'ve\r\n                    // inserted some text and will still encounter the old node\r\n                    if (!addElementDelete()) {\r\n                        addTextInsert();\r\n                    }\r\n                \r\n                // both children are elements\r\n                } else {\r\n                    if (newChild.tagID !== oldChild.tagID) {\r\n                        \r\n                        // First, check to see if we\'re deleting an element.\r\n                        // If we are, get rid of that element and restart our comparison\r\n                        // logic with the same element from the new tree and the next one\r\n                        // from the old tree.\r\n                        if (!addElementDelete()) {\r\n                            // Since we\'re not deleting and these elements don\'t match up, we\r\n                            // must have a new element. Add an elementInsert (and log a problem\r\n                            // if no insert works.)\r\n                            if (!addElementInsert()) {\r\n                                console.error("HTML Instrumentation: This should not happen. Two elements have different tag IDs and there was no insert/delete. This generally means there was a reordering of elements.");\r\n                                newIndex++;\r\n                                oldIndex++;\r\n                            }\r\n                        }\r\n                    \r\n                    // There has been no change in the tag we\'re looking at.\r\n                    } else {\r\n                        // Since this element hasn\'t moved, it is a suitable "beforeID"\r\n                        // for the edits we\'ve logged.\r\n                        finalizeNewEdits(oldChild.tagID, false);\r\n                        newIndex++;\r\n                        oldIndex++;\r\n                    }\r\n                }\r\n            \r\n            // We know we\'re comparing two texts. Just match up their signatures.\r\n            } else {\r\n                if (newChild.textSignature !== oldChild.textSignature) {\r\n                    newEdit = {\r\n                        type: "textReplace",\r\n                        content: newChild.content,\r\n                        parentID: newChild.parent.tagID\r\n                    };\r\n                    if (textAfterID) {\r\n                        newEdit.afterID = textAfterID;\r\n                    }\r\n                    newEdits.push(newEdit);\r\n                }\r\n                \r\n                // Either we\'ve done a text replace or both sides matched. In either\r\n                // case we\'re ready to move forward among both the old and new children.\r\n                newIndex++;\r\n                oldIndex++;\r\n            }\r\n        }\r\n        \r\n        // At this point, we\'ve used up all of the children in at least one of the\r\n        // two sets of children.\r\n        \r\n        /**\r\n         * Take care of any remaining children in the old tree.\r\n         */\r\n        while (oldIndex < oldChildren.length) {\r\n            oldChild = oldChildren[oldIndex];\r\n            \r\n            // Check for an element that has moved\r\n            if (hasMoved(oldChild)) {\r\n                // This element has moved, so we skip it on this side (the move\r\n                // is handled on the new tree side).\r\n                oldIndex++;\r\n            \r\n            // is this an element? if so, delete it\r\n            } else if (oldChild.isElement()) {\r\n                if (!addElementDelete()) {\r\n                    console.error("HTML Instrumentation: failed to add elementDelete for remaining element in the original DOM. This should not happen.", oldChild);\r\n                    oldIndex++;\r\n                }\r\n            \r\n            // must be text. delete that.\r\n            } else {\r\n                addTextDelete();\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Take care of the remaining children in the new tree.\r\n         */\r\n        while (newIndex < newChildren.length) {\r\n            newChild = newChildren[newIndex];\r\n            \r\n            // Is this an element?\r\n            if (newChild.isElement()) {\r\n                \r\n                // Look to see if the element has moved here.\r\n                if (!addElementMove()) {\r\n                    // Not a move, so we insert this element.\r\n                    if (!addElementInsert()) {\r\n                        console.error("HTML Instrumentation: failed to add elementInsert for remaining element in the updated DOM. This should not happen.");\r\n                        newIndex++;\r\n                    }\r\n                }\r\n            \r\n            // not a new element, so it must be new text.\r\n            } else {\r\n                addTextInsert();\r\n            }\r\n        }\r\n        \r\n        /**\r\n         * Finalize remaining edits. For inserts and moves, we can set the `lastChild`\r\n         * flag and the browser can simply use `appendChild` to add these items.\r\n         */\r\n        newEdits.forEach(function (edit) {\r\n            if (edit.type === "textInsert" || edit.type === "elementInsert" || edit.type === "elementMove") {\r\n                edit.lastChild = true;\r\n                delete edit.firstChild;\r\n                delete edit.afterID;\r\n            }\r\n        });\r\n        edits.push.apply(edits, newEdits);\r\n        \r\n        return {\r\n            edits: edits,\r\n            moves: moves,\r\n            newElements: newElements\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Generate a list of edits that will mutate oldNode to look like newNode.\r\n     * Currently, there are the following possible edit operations:\r\n     *\r\n     * * elementInsert\r\n     * * elementDelete\r\n     * * elementMove\r\n     * * textInsert\r\n     * * textDelete\r\n     * * textReplace\r\n     * * attrDelete\r\n     * * attrChange\r\n     * * attrAdd\r\n     * * rememberNodes (a special instruction that reflects the need to hang on to moved nodes)\r\n     *\r\n     * @param {Object} oldNode SimpleDOM node with the original content\r\n     * @param {Object} newNode SimpleDOM node with the new content\r\n     * @return {Array.{Object}} list of edit operations\r\n     */\r\n    function domdiff(oldNode, newNode) {\r\n        var queue = [],\r\n            edits = [],\r\n            moves = [],\r\n            newElement,\r\n            oldElement,\r\n            oldNodeMap = oldNode ? oldNode.nodeMap : {},\r\n            newNodeMap = newNode.nodeMap;\r\n        \r\n        /**\r\n         * Adds elements to the queue for generateChildEdits.\r\n         * Only elements (and not text nodes) are added. New nodes (ones that aren\'t in the\r\n         * old nodeMap), are not added here because they will be added when generateChildEdits\r\n         * creates the elementInsert edit.\r\n         */\r\n        var queuePush = function (node) {\r\n            if (node.children && oldNodeMap[node.tagID]) {\r\n                queue.push(node);\r\n            }\r\n        };\r\n        \r\n        /**\r\n         * Aggregates the child edits in the proper data structures.\r\n         *\r\n         * @param {Object} delta edits, moves and newElements to add\r\n         */\r\n        var addEdits = function (delta) {\r\n            edits.push.apply(edits, delta.edits);\r\n            moves.push.apply(moves, delta.moves);\r\n            queue.push.apply(queue, delta.newElements);\r\n        };\r\n        \r\n        // Start at the root of the current tree.\r\n        queue.push(newNode);\r\n        \r\n        do {\r\n            newElement = queue.pop();\r\n            oldElement = oldNodeMap[newElement.tagID];\r\n            \r\n            // Do we need to compare elements?\r\n            if (oldElement) {\r\n                \r\n                // Are attributes different?\r\n                if (newElement.attributeSignature !== oldElement.attributeSignature) {\r\n                    // generate attribute edits\r\n                    edits.push.apply(edits, generateAttributeEdits(oldElement, newElement));\r\n                }\r\n                \r\n                // Has there been a change to this node\'s immediate children?\r\n                if (newElement.childSignature !== oldElement.childSignature) {\r\n                    addEdits(generateChildEdits(oldElement, oldNodeMap, newElement, newNodeMap));\r\n                }\r\n                \r\n                // If there\'s a change farther down in the tree, add the children to the queue.\r\n                // If not, we can skip that whole subtree.\r\n                if (newElement.subtreeSignature !== oldElement.subtreeSignature) {\r\n                    newElement.children.forEach(queuePush);\r\n                }\r\n            \r\n            // This is a new element, so go straight to generating child edits (which will\r\n            // create the appropriate Insert edits).\r\n            } else {\r\n                // If this is the root (html) tag, we need to manufacture an insert for it here,\r\n                // because it isn\'t the child of any other node. The browser-side code doesn\'t\r\n                // care about parentage/positioning in this case, and will handle just setting the \r\n                // ID on the existing implied HTML tag in the browser without actually creating it.\r\n                if (!newElement.parent) {\r\n                    edits.push({\r\n                        type: "elementInsert",\r\n                        tag: newElement.tag,\r\n                        tagID: newElement.tagID,\r\n                        parentID: null,\r\n                        attributes: newElement.attributes\r\n                    });\r\n                }\r\n                \r\n                addEdits(generateChildEdits(null, oldNodeMap, newElement, newNodeMap));\r\n            }\r\n        } while (queue.length);\r\n        \r\n        // Special handling for moves: add edits to the beginning of the list so that\r\n        // moved nodes are set aside to ensure that they remain available at the time of their\r\n        // move.\r\n        if (moves.length > 0) {\r\n            edits.unshift({\r\n                type: "rememberNodes",\r\n                tagIDs: moves\r\n            });\r\n        }\r\n        \r\n        return edits;\r\n    }\r\n    \r\n    // Public API\r\n    exports.domdiff = domdiff;\r\n});\n//# sourceURL=/language/HTMLDOMDiff.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n/*unittests: HTML Instrumentation*/\r\n\r\n/**\r\n * HTMLInstrumentation\r\n *\r\n * This module contains functions for "instrumenting" html code so that we can track\r\n * the relationship of source code to DOM nodes in the browser. This functionality is\r\n * used by both live highlighting and live HTML editing.\r\n *\r\n * During live HTML development, the HTML source code is parsed to identify tag boundaries.\r\n * Each tag is assigned an ID which is stored in markers that are inserted into the editor.\r\n * These IDs are also included in "data-brackets-id" attributes that are inserted in the\r\n * HTML code that\'s served to the browser via the Live Development server.\r\n *\r\n * The primary function for that functionality is generateInstrumentedHTML(). This does just \r\n * what it says - it will read the HTML content in the doc and generate instrumented code by \r\n * injecting "data-brackets-id" attributes. Additionally, it caches the parsed DOM for use\r\n * by future updates.\r\n *\r\n * As the user makes edits in the editor, we determine how the DOM structure should change\r\n * based on the edits to the source code; those edits are generated by getUnappliedEditList().\r\n * HTMLDocument (in LiveDevelopment) takes those edits and sends them to the browser (via\r\n * RemoteFunctions) so that the DOM structure in the live preview can be updated accordingly.\r\n *\r\n * There are also helper functions for returning the tagID associated with a specified\r\n * position in the document--this is used in live highlighting.\r\n */\r\ndefine(\'language/HTMLInstrumentation\',[\'require\',\'exports\',\'module\',\'document/DocumentManager\',\'./HTMLSimpleDOM\',\'./HTMLDOMDiff\',\'utils/PerfUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var DocumentManager = require("document/DocumentManager"),\r\n        HTMLSimpleDOM   = require("./HTMLSimpleDOM"),\r\n        HTMLDOMDiff     = require("./HTMLDOMDiff"),\r\n        PerfUtils       = require("utils/PerfUtils");\r\n    \r\n    var allowIncremental = true;\r\n    \r\n    // Hash of scanned documents. Key is the full path of the doc. Value is an object\r\n    // with two properties: timestamp and dom. Timestamp is the document timestamp,\r\n    // dom is the root node of a simple DOM tree.\r\n    var _cachedValues = {};\r\n\r\n    /** \r\n     * @private\r\n     * Removes the cached information (DOM, timestamp, etc.) used by HTMLInstrumentation\r\n     * for the given document.\r\n     * @param {$.Event} event (unused)\r\n     * @param {Document} document The document to clear from the cache.\r\n     */\r\n    function _removeDocFromCache(evt, document) {\r\n        if (_cachedValues.hasOwnProperty(document.file.fullPath)) {\r\n            delete _cachedValues[document.file.fullPath];\r\n            $(document).off(".htmlInstrumentation");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Checks if two CodeMirror-style {line, ch} positions are equal.\r\n     * @param {{line: number, ch: number}} pos1\r\n     * @param {{line: number, ch: number}} pos2\r\n     * @return {boolean} true if pos1 and pos2 are equal. Fails if either of them is falsy.\r\n     */\r\n    function _posEq(pos1, pos2) {\r\n        return pos1 && pos2 && pos1.line === pos2.line && pos1.ch === pos2.ch;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Filters the given marks to find the ones that correspond to instrumented tags,\r\n     * sorts them by their starting position, and looks up and/or stores their ranges \r\n     * in the given markCache.\r\n     * @param {Array} marks An array of mark objects returned by CodeMirror.\r\n     * @param {Object} markCache An object that maps tag IDs to {mark, range} objects.\r\n     *     If a mark in the marks array is already in the cache, we use the cached range info,\r\n     *     otherwise we look up its range in CodeMirror and store it in the cache.\r\n     * @return {Array.<{mark: Object, range: {line: number, ch: number}}>} The filtered and\r\n     *     sorted array of mark info objects (each of which contains the mark and its range,\r\n     *     so the range doesn\'t need to be looked up again).\r\n     */\r\n    function _getSortedTagMarks(marks, markCache) {\r\n        marks = marks.filter(function (mark) {\r\n            return !!mark.tagID;\r\n        }).map(function (mark) {\r\n            // All marks should exist since we just got them from CodeMirror.\r\n            if (!markCache[mark.tagID]) {\r\n                markCache[mark.tagID] = {mark: mark, range: mark.find()};\r\n            }\r\n            return markCache[mark.tagID];\r\n        });\r\n        marks.sort(function (mark1, mark2) {\r\n            return (mark1.range.from.line === mark2.range.from.line ?\r\n                    mark1.range.from.ch - mark2.range.from.ch :\r\n                    mark1.range.from.line - mark2.range.from.line);\r\n        });\r\n        \r\n        return marks;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Finds the mark for the DOM node at the given position in the editor.\r\n     * @param {Editor} editor The editor containing the instrumented document.\r\n     * @param {{line: number, ch: number}} pos The position to find the DOM marker for.\r\n     * @param {boolean} preferParent If true, and the pos is at one or the other edge of the\r\n     *     innermost marked range, return the immediately enclosing mark instead.\r\n     * @param {Object=} markCache An optional cache to look up positions of existing\r\n     *     markers. (This avoids calling the find() operation on marks multiple times, \r\n     *     which is expensive.)\r\n     * @return {Object} The CodeMirror mark object that represents the DOM node at the\r\n     *     given position.\r\n     */\r\n    function _getMarkerAtDocumentPos(editor, pos, preferParent, markCache) {\r\n        var i, marks, match;\r\n        \r\n        markCache = markCache || {};\r\n        marks = _getSortedTagMarks(editor._codeMirror.findMarksAt(pos), markCache);\r\n        if (!marks.length) {\r\n            return null;\r\n        }\r\n        \r\n        // The mark with the latest start is the innermost one.\r\n        match = marks[marks.length - 1];\r\n        if (preferParent) {\r\n            // If the match is exactly at the edge of the range and preferParent is set,\r\n            // we want to pop upwards.\r\n            if (_posEq(match.range.from, pos) || _posEq(match.range.to, pos)) {\r\n                if (marks.length > 1) {\r\n                    match = marks[marks.length - 2];\r\n                } else {\r\n                    // We must be outside the root, so there\'s no containing tag.\r\n                    match = null;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return match.mark;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Dumps the current list of mark ranges for instrumented tags to the console. Used for debugging.\r\n     * @param {Editor} editor The editor to find the mark ranges for.\r\n     * @param {Object=} nodeMap If specified, a map of tag IDs to DOM nodes, used so we can indicate which tag name\r\n     *     the DOM thinks corresponds to the given mark.\r\n     */\r\n    function _dumpMarks(editor, nodeMap) {\r\n        var markCache = {},\r\n            marks = _getSortedTagMarks(editor._codeMirror.getAllMarks(), markCache);\r\n        marks.forEach(function (markInfo) {\r\n            var mark = markInfo.mark,\r\n                range = markInfo.range;\r\n            console.log("<" + nodeMap[mark.tagID].tag + "> (" + mark.tagID + ") " +\r\n                        range.from.line + ":" + range.from.ch + " - " + range.to.line + ":" + range.to.ch);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Get the instrumented tagID at the specified position. Returns -1 if\r\n     * there are no instrumented tags at the location.\r\n     * The _markText() function must be called before calling this function.\r\n     *\r\n     * NOTE: This function is "private" for now (has a leading underscore), since\r\n     * the API is likely to change in the future.\r\n     *\r\n     * @param {Editor} editor The editor to scan. \r\n     * @param {{line: number, ch: number}} pos The position to find the DOM marker for.\r\n     * @param {Object=} markCache An optional cache to look up positions of existing\r\n     *     markers. (This avoids calling the find() operation on marks multiple times, \r\n     *     which is expensive.)\r\n     * @return {number} tagID at the specified position, or -1 if there is no tag\r\n     */\r\n    function _getTagIDAtDocumentPos(editor, pos, markCache) {\r\n        var match = _getMarkerAtDocumentPos(editor, pos, false, markCache);\r\n\r\n        return (match) ? match.tagID : -1;\r\n    }\r\n    \r\n    /**\r\n     * Recursively walks the SimpleDOM starting at node and marking\r\n     * all tags in the CodeMirror instance. The more useful interface\r\n     * is the _markTextFromDOM function which clears existing marks\r\n     * before calling this function to create new ones.\r\n     *\r\n     * @param {CodeMirror} cm CodeMirror instance in which to mark tags\r\n     * @param {Object} node SimpleDOM node to use as the root for marking\r\n     */\r\n    function _markTags(cm, node) {\r\n        node.children.forEach(function (childNode) {\r\n            if (childNode.isElement()) {\r\n                _markTags(cm, childNode);\r\n            }\r\n        });\r\n        var mark = cm.markText(node.startPos, node.endPos);\r\n        mark.tagID = node.tagID;\r\n    }\r\n    \r\n    /**\r\n     * Clears the marks from the document and creates new ones.\r\n     *\r\n     * @param {Editor} editor Editor object holding this document\r\n     * @param {Object} dom SimpleDOM root object that contains the parsed structure\r\n     */\r\n    function _markTextFromDOM(editor, dom) {\r\n        var cm = editor._codeMirror;\r\n        \r\n        // Remove existing marks\r\n        var marks = cm.getAllMarks();\r\n        cm.operation(function () {\r\n            marks.forEach(function (mark) {\r\n                if (mark.hasOwnProperty("tagID")) {\r\n                    mark.clear();\r\n                }\r\n            });\r\n        });\r\n                \r\n        // Mark\r\n        _markTags(cm, dom);\r\n    }\r\n    \r\n    /**\r\n     * Subclass of HTMLSimpleDOM.Builder that builds an updated DOM after changes have been made,\r\n     * and maps nodes from the new DOM to the old DOM by tag ID. For non-structural edits, avoids reparsing\r\n     * the whole editor. Also updates marks in the editor based on the new DOM state.\r\n     *\r\n     * @constructor\r\n     * @param {Object} previousDOM The root of the HTMLSimpleDOM tree representing a previous state of the DOM.\r\n     * @param {Editor} editor The editor containing the instrumented HTML.\r\n     * @param {Array=} changeList An optional array of CodeMirror change records representing the\r\n     *     edits the user made in the editor since previousDOM was built. If provided, and the\r\n     *     edits are not structural, DOMUpdater will do a fast incremental reparse. If not provided,\r\n     *     or if one of the edits changes the DOM structure, DOMUpdater will reparse the whole DOM.\r\n     */\r\n    function DOMUpdater(previousDOM, editor, changeList) {\r\n        var text, startOffset = 0, startOffsetPos;\r\n\r\n        this.isIncremental = false;\r\n        \r\n        function isDangerousEdit(text) {\r\n            // We don\'t consider & dangerous since entities only affect text content, not\r\n            // overall DOM structure.\r\n            return (/[<>\\/=\\"\\\']/).test(text);\r\n        }\r\n        \r\n        // If there\'s more than one change, be conservative and assume we have to do a full reparse.\r\n        if (changeList && changeList.length === 1) {\r\n            // If the inserted or removed text doesn\'t have any characters that could change the\r\n            // structure of the DOM (e.g. by adding or removing a tag boundary), then we can do\r\n            // an incremental reparse of just the parent tag containing the edit. This should just\r\n            // be the marked range that contains the beginning of the edit range, since that position\r\n            // isn\'t changed by the edit.\r\n            var change = changeList[0];\r\n            if (!isDangerousEdit(change.text) && !isDangerousEdit(change.removed)) {\r\n                // If the edit is right at the beginning or end of a tag, we want to be conservative\r\n                // and use the parent as the edit range.\r\n                var startMark = _getMarkerAtDocumentPos(editor, change.from, true);\r\n                if (startMark) {\r\n                    var range = startMark.find();\r\n                    if (range) {\r\n                        text = editor._codeMirror.getRange(range.from, range.to);\r\n                        this.changedTagID = startMark.tagID;\r\n                        startOffsetPos = range.from;\r\n                        startOffset = editor._codeMirror.indexFromPos(startOffsetPos);\r\n                        this.isIncremental = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (!this.changedTagID) {\r\n            // We weren\'t able to incrementally update, so just rebuild and diff everything.\r\n            text = editor.document.getText();\r\n        }\r\n        \r\n        HTMLSimpleDOM.Builder.call(this, text, startOffset, startOffsetPos);\r\n        this.editor = editor;\r\n        this.cm = editor._codeMirror;\r\n        this.previousDOM = previousDOM;\r\n    }\r\n    \r\n    DOMUpdater.prototype = Object.create(HTMLSimpleDOM.Builder.prototype);\r\n    \r\n    /**\r\n     * @private\r\n     * Returns true if the given node has an ancestor whose tagID is the given ID.\r\n     * @param {Object} node A node from an HTMLSimpleDOM structure.\r\n     * @param {number} id The ID of the tag to check for.\r\n     * @return {boolean} true if the node has an ancestor with that ID.\r\n     */\r\n    function _hasAncestorWithID(node, id) {\r\n        var ancestor = node.parent;\r\n        while (ancestor && ancestor.tagID !== id) {\r\n            ancestor = ancestor.parent;\r\n        }\r\n        return !!ancestor;\r\n    }\r\n    \r\n    /**\r\n     * Overrides the `getID` method to return the tag ID from the document. If a viable tag\r\n     * ID cannot be found in the document marks, then a new ID is returned. This will also\r\n     * assign a new ID if the tag changed between the previous and current versions of this\r\n     * node.\r\n     *\r\n     * @param {Object} newTag tag object for the current element\r\n     * @return {int} best ID\r\n     */\r\n    DOMUpdater.prototype.getID = function (newTag, markCache) {\r\n        // Get the mark at the start of the tagname (not before the beginning of the tag, because that\'s\r\n        // actually inside the parent).\r\n        var currentTagID = _getTagIDAtDocumentPos(this.editor, HTMLSimpleDOM._offsetPos(newTag.startPos, 1), markCache);\r\n        \r\n        // If the new tag is in an unmarked range, or the marked range actually corresponds to an\r\n        // ancestor tag, then this must be a newly inserted tag, so give it a new tag ID.\r\n        if (currentTagID === -1 || _hasAncestorWithID(newTag, currentTagID)) {\r\n            currentTagID = this.getNewID();\r\n        } else {\r\n            // If the tag has changed between the previous DOM and the new one, we assign a new ID\r\n            // so that the old tag will be deleted and the new one inserted.\r\n            var oldNode = this.previousDOM.nodeMap[currentTagID];\r\n            if (!oldNode || oldNode.tag !== newTag.tag) {\r\n                currentTagID = this.getNewID();\r\n            }\r\n        }\r\n        return currentTagID;\r\n    };\r\n    \r\n    /**\r\n     * Updates the CodeMirror marks in the editor to reflect the new bounds of nodes in\r\n     * the given nodeMap.\r\n     * @param {Object} nodeMap The node map from the new DOM.\r\n     * @param {Object} markCache The cache of existing mark ranges built during the latest parse.\r\n     */\r\n    DOMUpdater.prototype._updateMarkedRanges = function (nodeMap, markCache) {\r\n        // FUTURE: this is somewhat inefficient (getting all the marks involves passing linearly through\r\n        // the document once), but it doesn\'t seem to be a hotspot right now.\r\n        var updateIDs = Object.keys(nodeMap),\r\n            cm = this.cm,\r\n            marks = cm.getAllMarks();\r\n        \r\n        cm.operation(function () {\r\n            marks.forEach(function (mark) {\r\n                if (mark.hasOwnProperty("tagID") && nodeMap[mark.tagID]) {\r\n                    var node = nodeMap[mark.tagID],\r\n                        markInfo = markCache[mark.tagID];\r\n                    // If the mark\'s bounds already match, avoid destroying and recreating the mark,\r\n                    // since that incurs some overhead.\r\n                    if (!(markInfo && _posEq(markInfo.range.from, node.startPos) && _posEq(markInfo.range.to, node.endPos))) {\r\n                        mark.clear();\r\n                        mark = cm.markText(node.startPos, node.endPos);\r\n                        mark.tagID = node.tagID;\r\n                    }\r\n                    updateIDs.splice(updateIDs.indexOf(String(node.tagID)), 1);\r\n                }\r\n            });\r\n            \r\n            // Any remaining updateIDs are new.\r\n            updateIDs.forEach(function (id) {\r\n                var node = nodeMap[id], mark;\r\n                if (node.isElement()) {\r\n                    mark = cm.markText(node.startPos, node.endPos);\r\n                    mark.tagID = Number(id);\r\n                }\r\n            });\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Creates a map from tagIDs to nodes in the given HTMLSimpleDOM subtree and\r\n     * stores it on the root.\r\n     * @param {Object} root The root of an HTMLSimpleDOM tree.\r\n     */\r\n    DOMUpdater.prototype._buildNodeMap = function (root) {\r\n        var nodeMap = {};\r\n        \r\n        function walk(node) {\r\n            if (node.tagID) {\r\n                nodeMap[node.tagID] = node;\r\n            }\r\n            if (node.isElement()) {\r\n                node.children.forEach(walk);\r\n            }\r\n        }\r\n        \r\n        walk(root);\r\n        root.nodeMap = nodeMap;\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Removes all nodes deleted between the oldSubtree and the newSubtree from the given nodeMap,\r\n     * and clears marks associated with those nodes.\r\n     * @param {Object} nodeMap The nodeMap to update to remove deleted items.\r\n     * @param {Object} oldSubtreeMap The nodeMap for the original subtree (which should be a subset of the\r\n     *     first nodeMap).\r\n     * @param {Object} newSubtreeMap The nodeMap for the new subtree.\r\n     */\r\n    DOMUpdater.prototype._handleDeletions = function (nodeMap, oldSubtreeMap, newSubtreeMap) {\r\n        var deletedIDs = [];\r\n        Object.keys(oldSubtreeMap).forEach(function (key) {\r\n            if (!newSubtreeMap.hasOwnProperty(key)) {\r\n                deletedIDs.push(key);\r\n                delete nodeMap[key];\r\n            }\r\n        });\r\n        \r\n        if (deletedIDs.length) {\r\n            // FUTURE: would be better to cache the mark for each node. Also, could\r\n            // conceivably combine this with _updateMarkedRanges().\r\n            var marks = this.cm.getAllMarks();\r\n            marks.forEach(function (mark) {\r\n                if (mark.hasOwnProperty("tagID") && deletedIDs.indexOf(mark.tagID) !== -1) {\r\n                    mark.clear();\r\n                }\r\n            });\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Reparses the document (or a portion of it if we can do it incrementally).\r\n     * Note that in an incremental update, the old DOM is actually mutated (the new\r\n     * subtree is swapped in for the old subtree).\r\n     * @return {?{newDOM: Object, oldSubtree: Object, newSubtree: Object}} newDOM is\r\n     *      the full new DOM. For a full update, oldSubtree is the full old DOM \r\n     *      and newSubtree is the same as newDOM; for an incremental update,\r\n     *      oldSubtree is the portion of the old tree that was reparsed,\r\n     *      newSubtree is the updated version, and newDOM is actually the same\r\n     *      as the original DOM (with newSubtree swapped in for oldSubtree).\r\n     *      If the document can\'t be parsed due to invalid HTML, returns null.\r\n     */\r\n    DOMUpdater.prototype.update = function () {\r\n        var markCache = {},\r\n            newSubtree = this.build(true, markCache),\r\n            result = {\r\n                // default result if we didn\'t identify a changed portion\r\n                newDOM: newSubtree,\r\n                oldSubtree: this.previousDOM,\r\n                newSubtree: newSubtree\r\n            };\r\n        \r\n        if (!newSubtree) {\r\n            return null;\r\n        }\r\n\r\n        if (this.changedTagID) {\r\n            // Find the old subtree that\'s going to get swapped out.\r\n            var oldSubtree = this.previousDOM.nodeMap[this.changedTagID],\r\n                parent = oldSubtree.parent;\r\n            \r\n            // If we didn\'t have a parent, then the whole tree changed anyway, so\r\n            // we\'ll just return the default result.\r\n            if (parent) {\r\n                var childIndex = parent.children.indexOf(oldSubtree);\r\n                if (childIndex === -1) {\r\n                    // This should never happen...\r\n                    console.error("DOMUpdater.update(): couldn\'t locate old subtree in tree");\r\n                } else {\r\n                    // Swap the new subtree in place of the old subtree.\r\n                    oldSubtree.parent = null;\r\n                    newSubtree.parent = parent;\r\n                    parent.children[childIndex] = newSubtree;\r\n                    \r\n                    // Overwrite any node mappings in the parent DOM with the\r\n                    // mappings for the new subtree. We keep the nodeMap around\r\n                    // on the new subtree so that the differ can use it later.\r\n                    $.extend(this.previousDOM.nodeMap, newSubtree.nodeMap);\r\n                    \r\n                    // Update marked ranges for all items in the new subtree.\r\n                    this._updateMarkedRanges(newSubtree.nodeMap, markCache);\r\n                    \r\n                    // Build a local nodeMap for the old subtree so the differ can\r\n                    // use it.\r\n                    this._buildNodeMap(oldSubtree);\r\n                    \r\n                    // Clean up the info for any deleted nodes that are no longer in\r\n                    // the new tree.\r\n                    this._handleDeletions(this.previousDOM.nodeMap, oldSubtree.nodeMap, newSubtree.nodeMap);\r\n                    \r\n                    // Update the signatures for all parents of the new subtree.\r\n                    var curParent = parent;\r\n                    while (curParent) {\r\n                        curParent.update();\r\n                        curParent = curParent.parent;\r\n                    }\r\n                    \r\n                    result.newDOM = this.previousDOM;\r\n                    result.oldSubtree = oldSubtree;\r\n                }\r\n            }\r\n        } else {\r\n            _markTextFromDOM(this.editor, result.newDOM);\r\n        }\r\n        \r\n        return result;\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Builds a new DOM for the current state of the editor, diffs it against the\r\n     * previous DOM, and generates a DOM edit list that can be used to replay the\r\n     * diffs in the browser.\r\n     * @param {Object} previousDOM The HTMLSimpleDOM corresponding to the previous state of the editor.\r\n     *     Note that in the case of an incremental edit, this will be mutated to create the new DOM\r\n     *     (by swapping out the subtree corresponding to the changed portion).\r\n     * @param {Editor} editor The editor containing the instrumented HTML.\r\n     * @param {Array=} changeList If specified, a CodeMirror changelist reflecting all the\r\n     *     text changes in the editor since previousDOM was built. If specified, we will\r\n     *     attempt to do an incremental update (although we might fall back to a full update\r\n     *     in various cases). If not specified, we will always do a full update.\r\n     * @return {{dom: Object, edits: Array}} The new DOM representing the current state of the\r\n     *     editor, and an array of edits that can be applied to update the browser (see\r\n     *     HTMLDOMDiff for more information on the edit format).\r\n     */\r\n    function _updateDOM(previousDOM, editor, changeList) {\r\n        if (!allowIncremental) {\r\n            changeList = undefined;\r\n        }\r\n        var updater = new DOMUpdater(previousDOM, editor, changeList);\r\n        var result = updater.update();\r\n        if (!result) {\r\n            return { errors: updater.errors };\r\n        }\r\n        \r\n        var edits = HTMLDOMDiff.domdiff(result.oldSubtree, result.newSubtree);\r\n        \r\n        // We\'re done with the nodeMap that was added to the subtree by the updater.\r\n        if (result.newSubtree !== result.newDOM) {\r\n            delete result.newSubtree.nodeMap;\r\n        }\r\n        \r\n        return {\r\n            dom: result.newDOM,\r\n            edits: edits,\r\n            _wasIncremental: updater.isIncremental // for unit tests only\r\n        };\r\n    }\r\n    \r\n    /**\r\n     * Calculates the DOM edits that are needed to update the browser from the state the\r\n     * editor was in the last time that scanDocument(), getInstrumentedHTML(), or\r\n     * getUnappliedEditList() was called (whichever is most recent). Caches this state so\r\n     * it can be used as the base state for the next getUnappliedEditList().\r\n     *\r\n     * For simple text edits, this update is done quickly and incrementally. For structural\r\n     * edits (edits that change the DOM structure or add/remove attributes), the update\r\n     * requires a full reparse. \r\n     *\r\n     * If the document currently contains invalid HTML, no edits will be generated until \r\n     * getUnappliedEditList() is called when the document is valid, at which point the edits \r\n     * will reflect all the changes needed to catch the browser up with all the edits \r\n     * made while the document was invalid.\r\n     *\r\n     * @param {Editor} editor The editor containing the instrumented HTML\r\n     * @param {Array} changeList A CodeMirror change list describing the text changes made\r\n     *     in the editor since the last update. If specified, we will attempt to do an\r\n     *     incremental update.\r\n     * @return {Array} edits A list of edits to apply in the browser. See HTMLDOMDiff for\r\n     *     more information on the format of these edits.\r\n     */\r\n    function getUnappliedEditList(editor, changeList) {\r\n        var cachedValue = _cachedValues[editor.document.file.fullPath];\r\n        \r\n        // We might not have a previous DOM if the document was empty before this edit.\r\n        if (!cachedValue || !cachedValue.dom || _cachedValues[editor.document.file.fullPath].invalid) {\r\n            // We were in an invalid state, so do a full rebuild.\r\n            changeList = null;\r\n        }\r\n        \r\n        var result = _updateDOM(cachedValue && cachedValue.dom, editor, changeList);\r\n        \r\n        if (!result.errors) {\r\n            _cachedValues[editor.document.file.fullPath] = {\r\n                timestamp: editor.document.diskTimestamp,\r\n                dom: result.dom,\r\n                dirty: false\r\n            };\r\n            return { edits: result.edits };\r\n        } else {\r\n            if (cachedValue) {\r\n                cachedValue.invalid = true;\r\n            }\r\n            return { errors: result.errors };\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Add SimpleDOMBuilder metadata to browser DOM tree JSON representation\r\n     * @param {Object} root\r\n     */\r\n    function _processBrowserSimpleDOM(browserRoot, editorRootTagID) {\r\n        var nodeMap         = {},\r\n            root;\r\n        \r\n        function _processElement(elem) {\r\n            elem.tagID = elem.attributes["data-brackets-id"];\r\n            \r\n            // remove data-brackets-id attribute for diff\r\n            delete elem.attributes["data-brackets-id"];\r\n            \r\n            elem.children.forEach(function (child) {\r\n                // set parent\r\n                child.parent = elem;\r\n                \r\n                if (child.isElement()) {\r\n                    _processElement(child);\r\n                } else if (child.isText()) {\r\n                    child.update();\r\n                    child.tagID = HTMLSimpleDOM.getTextNodeID(child);\r\n                    \r\n                    nodeMap[child.tagID] = child;\r\n                }\r\n            });\r\n            \r\n            elem.update();\r\n            \r\n            nodeMap[elem.tagID] = elem;\r\n\r\n            // Choose the root element based on the root tag in the editor.\r\n            // The browser may insert html, head and body elements if missing.\r\n            if (elem.tagID === editorRootTagID) {\r\n                root = elem;\r\n            }\r\n        }\r\n        \r\n        _processElement(browserRoot);\r\n\r\n        root = root || browserRoot;\r\n        root.nodeMap = nodeMap;\r\n\r\n        return root;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Diff the browser DOM with the in-editor DOM\r\n     * @param {Editor} editor\r\n     * @param {Object} browserSimpleDOM\r\n     */\r\n    function _getBrowserDiff(editor, browserSimpleDOM) {\r\n        var cachedValue = _cachedValues[editor.document.file.fullPath],\r\n            editorRoot  = cachedValue.dom,\r\n            browserRoot;\r\n        \r\n        browserRoot = _processBrowserSimpleDOM(browserSimpleDOM, editorRoot.tagID);\r\n        \r\n        return {\r\n            diff    : HTMLDOMDiff.domdiff(editorRoot, browserRoot),\r\n            browser : browserRoot,\r\n            editor  : editorRoot\r\n        };\r\n    }\r\n    \r\n    $(DocumentManager).on("beforeDocumentDelete", _removeDocFromCache);\r\n    \r\n    /**\r\n     * Parses the document, returning an HTMLSimpleDOM structure and caching it as the\r\n     * initial state of the document. Will return a cached copy of the DOM if the\r\n     * document hasn\'t changed since the last time scanDocument was called.\r\n     *\r\n     * This is called by generateInstrumentedHTML(), but it can be useful to call it\r\n     * ahead of time so the DOM is cached and doesn\'t need to be rescanned when the\r\n     * instrumented HTML is requested by the browser.\r\n     *\r\n     * @param {Document} doc The doc to scan. \r\n     * @return {Object} Root DOM node of the document.\r\n     */\r\n    function scanDocument(doc) {\r\n        if (!_cachedValues.hasOwnProperty(doc.file.fullPath)) {\r\n            $(doc).on("change.htmlInstrumentation", function () {\r\n                if (_cachedValues[doc.file.fullPath]) {\r\n                    _cachedValues[doc.file.fullPath].dirty = true;\r\n                }\r\n            });\r\n            \r\n            // Assign to cache, but don\'t set a value yet\r\n            _cachedValues[doc.file.fullPath] = null;\r\n        }\r\n        \r\n        var cachedValue = _cachedValues[doc.file.fullPath];\r\n        if (!doc.isDirty && cachedValue && !cachedValue.dirty && cachedValue.timestamp === doc.diskTimestamp) {\r\n            return cachedValue.dom;\r\n        }\r\n        \r\n        var text = doc.getText(),\r\n            dom = HTMLSimpleDOM.build(text);\r\n        \r\n        if (dom) {\r\n            // Cache results\r\n            _cachedValues[doc.file.fullPath] = {\r\n                timestamp: doc.diskTimestamp,\r\n                dom: dom,\r\n                dirty: false\r\n            };\r\n        }\r\n        \r\n        return dom;\r\n    }\r\n    \r\n    /**\r\n     * Generate instrumented HTML for the specified editor\'s document, and mark the associated tag \r\n     * ranges in the editor. Each tag has a "data-brackets-id" attribute with a unique ID for its \r\n     * value. For example, "<div>" becomes something like "<div data-brackets-id=\'45\'>". The attribute \r\n     * value is just a number that is guaranteed to be unique. \r\n     *\r\n     * Also stores marks in the given editor that correspond to the tag ranges. These marks are used\r\n     * to track the DOM structure for in-browser highlighting and live HTML updating.\r\n     *\r\n     * This only needs to be done once on load of a document. As the document is edited in memory,\r\n     * the instrumentation is kept up to date via the diffs and edits that are generated on change\r\n     * events. Call this again only if you want to do a full re-sync of the editor\'s DOM state.\r\n     *\r\n     * @param {Editor} editor The editor whose document we\'re instrumenting, and which we should\r\n     *     mark ranges in.\r\n     * @return {string} instrumented html content\r\n     */\r\n    function generateInstrumentedHTML(editor) {\r\n        var doc = editor.document,\r\n            dom = scanDocument(doc),\r\n            orig = doc.getText(),\r\n            gen = "",\r\n            lastIndex = 0;\r\n        \r\n        if (!dom) {\r\n            return null;\r\n        }\r\n        \r\n        // Ensure that the marks in the editor are up to date with respect to the given DOM.\r\n        _markTextFromDOM(editor, dom);\r\n        \r\n        // Walk through the dom nodes and insert the \'data-brackets-id\' attribute at the\r\n        // end of the open tag        \r\n        function walk(node) {\r\n            if (node.tag) {\r\n                var attrText = " data-brackets-id=\'" + node.tagID + "\'";\r\n                \r\n                // Insert the attribute as the first attribute in the tag.\r\n                var insertIndex = node.start + node.tag.length + 1;\r\n                gen += orig.substr(lastIndex, insertIndex - lastIndex) + attrText;\r\n                lastIndex = insertIndex;\r\n            }\r\n            \r\n            if (node.isElement()) {\r\n                node.children.forEach(walk);\r\n            }\r\n        }\r\n        \r\n        walk(dom);\r\n        gen += orig.substr(lastIndex);\r\n        \r\n        return gen;\r\n    }\r\n    \r\n    /**\r\n     * Mark the text for the specified editor. Either scanDocument() or \r\n     * generateInstrumentedHTML() must be called before this function\r\n     * is called.\r\n     *\r\n     * NOTE: This function is "private" for now (has a leading underscore), since\r\n     * the API is likely to change in the future.\r\n     *\r\n     * @param {Editor} editor The editor whose text should be marked.\r\n     * @return none\r\n     */\r\n    function _markText(editor) {\r\n        var cache = _cachedValues[editor.document.file.fullPath],\r\n            dom = cache && cache.dom;\r\n        \r\n        if (!dom) {\r\n            console.error("Couldn\'t find the dom for " + editor.document.file.fullPath);\r\n            return;\r\n        }\r\n        \r\n        _markTextFromDOM(editor, dom);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Clear the DOM cache. For unit testing only.\r\n     */\r\n    function _resetCache() {\r\n        _cachedValues = {};\r\n    }\r\n\r\n    // private methods\r\n    exports._markText                   = _markText;\r\n    exports._getMarkerAtDocumentPos     = _getMarkerAtDocumentPos;\r\n    exports._getTagIDAtDocumentPos      = _getTagIDAtDocumentPos;\r\n    exports._markTextFromDOM            = _markTextFromDOM;\r\n    exports._updateDOM                  = _updateDOM;\r\n    exports._allowIncremental           = allowIncremental;\r\n    exports._getBrowserDiff             = _getBrowserDiff;\r\n    exports._resetCache                 = _resetCache;\r\n    \r\n    // public API\r\n    exports.scanDocument                = scanDocument;\r\n    exports.generateInstrumentedHTML    = generateInstrumentedHTML;\r\n    exports.getUnappliedEditList        = getUnappliedEditList;\r\n});\r\n\n//# sourceURL=/language/HTMLInstrumentation.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $, brackets */\r\n\r\n/**\r\n * HTMLDocument manages a single HTML source document\r\n *\r\n * __EDITING__\r\n *\r\n * Editing the document will cause the corresponding node to be updated\r\n * by calling `applyChanges` on the DOMAgent. This will only work for\r\n * altering text nodes and will break when attempting to change DOM elements\r\n * or inserting or deleting nodes.\r\n *\r\n * __HIGHLIGHTING__\r\n *\r\n * HTMLDocument supports highlighting nodes from the HighlightAgent and\r\n * highlighting the DOMNode corresponding to the cursor position in the\r\n * editor.\r\n */\r\ndefine(\'LiveDevelopment/Documents/HTMLDocument\',[\'require\',\'exports\',\'module\',\'document/DocumentManager\',\'LiveDevelopment/Agents/DOMAgent\',\'editor/EditorManager\',\'LiveDevelopment/Agents/HighlightAgent\',\'language/HTMLInstrumentation\',\'LiveDevelopment/Inspector/Inspector\',\'LiveDevelopment/LiveDevelopment\',\'utils/PerfUtils\',\'LiveDevelopment/Agents/RemoteAgent\',\'utils/StringUtils\',\'thirdparty/lodash\'],function HTMLDocumentModule(require, exports, module) {\r\n    "use strict";\r\n\r\n    var DocumentManager     = require("document/DocumentManager"),\r\n        DOMAgent            = require("LiveDevelopment/Agents/DOMAgent"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        HighlightAgent      = require("LiveDevelopment/Agents/HighlightAgent"),\r\n        HTMLInstrumentation = require("language/HTMLInstrumentation"),\r\n        Inspector           = require("LiveDevelopment/Inspector/Inspector"),\r\n        LiveDevelopment     = require("LiveDevelopment/LiveDevelopment"),\r\n        PerfUtils           = require("utils/PerfUtils"),\r\n        RemoteAgent         = require("LiveDevelopment/Agents/RemoteAgent"),\r\n        StringUtils         = require("utils/StringUtils"),\r\n        _                   = require("thirdparty/lodash");\r\n\r\n    /**\r\n     * @constructor\r\n     * @param {!Document} doc The source document from Brackets\r\n     * @param {!Editor} editor The editor for this document\r\n     */\r\n    var HTMLDocument = function HTMLDocument(doc, editor) {\r\n        var self = this;\r\n\r\n        this.doc = doc;\r\n        if (this.doc) {\r\n            this.doc.addRef();\r\n        }\r\n\r\n        this.editor = editor;\r\n        this._instrumentationEnabled = false;\r\n        \r\n        this._onActiveEditorChange = this._onActiveEditorChange.bind(this);\r\n        $(EditorManager).on("activeEditorChange", this._onActiveEditorChange);\r\n        \r\n        // Attach now\r\n        this.attachToEditor(editor);\r\n    };\r\n    \r\n    /**\r\n     * Enable or disable instrumented HTML\r\n     * @param {boolean} enabled Whether to enable or disable\r\n     */\r\n    HTMLDocument.prototype.setInstrumentationEnabled = function setInstrumentationEnabled(enabled) {\r\n        if (enabled && !this._instrumentationEnabled && this.editor) {\r\n            HTMLInstrumentation.scanDocument(this.doc);\r\n            HTMLInstrumentation._markText(this.editor);\r\n        }\r\n        \r\n        this._instrumentationEnabled = enabled;\r\n    };\r\n    \r\n    /**\r\n     * Returns true if document edits appear live in the connected browser\r\n     * @return {boolean} \r\n     */\r\n    HTMLDocument.prototype.isLiveEditingEnabled = function () {\r\n        return this._instrumentationEnabled;\r\n    };\r\n    \r\n    /**\r\n     * Returns a JSON object with HTTP response overrides\r\n     * @param {boolean} enabled (Unused)\r\n     * @return {{body: string}}\r\n     */\r\n    HTMLDocument.prototype.getResponseData = function getResponseData(enabled) {\r\n        var body;\r\n        if (this._instrumentationEnabled && this.editor) {\r\n            body = HTMLInstrumentation.generateInstrumentedHTML(this.editor);\r\n        }\r\n        \r\n        return {\r\n            body: body || this.doc.getText()\r\n        };\r\n    };\r\n\r\n    /**\r\n     * Close the document\r\n     */\r\n    HTMLDocument.prototype.close = function close() {\r\n        if (this.editor) {\r\n            $(this.editor).off(".HTMLDocument");\r\n        }\r\n\r\n        if (this.doc) {\r\n            this.doc.releaseRef();\r\n        }\r\n\r\n        $(EditorManager).off("activeEditorChange", this._onActiveEditorChange);\r\n\r\n        // Experimental code\r\n        if (LiveDevelopment.config.experimental) {\r\n            // Force highlight teardown\r\n            this._onHighlight();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Attach new editor\r\n     * @param {!Editor} editor The editor for this document\r\n     */\r\n    HTMLDocument.prototype.attachToEditor = function (editor) {\r\n        var self = this;\r\n        this.editor = editor;\r\n        \r\n        // Performance optimization to use closures instead of Function.bind()\r\n        // to improve responsiveness during cursor movement and keyboard events\r\n        $(this.editor).on("cursorActivity.HTMLDocument", function (event, editor) {\r\n            self._onCursorActivity(event, editor);\r\n        });\r\n\r\n        $(this.editor).on("change.HTMLDocument", function (event, editor, change) {\r\n            self._onChange(event, editor, change);\r\n        });\r\n\r\n        $(this.editor).on("beforeDestroy.HTMLDocument", function (event, editor) {\r\n            self._onDestroy(event, editor);\r\n        });\r\n        \r\n        // Experimental code\r\n        if (LiveDevelopment.config.experimental) {\r\n            $(HighlightAgent).on("highlight.HTMLDocument", function (event, node) {\r\n                self._onHighlight(event, node);\r\n            });\r\n        }\r\n\r\n        if (this._instrumentationEnabled) {\r\n            // Update instrumentation for new editor\r\n            HTMLInstrumentation.scanDocument(this.doc);\r\n            HTMLInstrumentation._markText(this.editor);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Detach current editor\r\n     */\r\n    HTMLDocument.prototype.detachFromEditor = function () {\r\n        if (this.editor) {\r\n            HighlightAgent.hide();\r\n            $(this.editor).off(".HTMLDocument");\r\n            this._removeHighlight();\r\n            this.editor = null;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Update the highlight\r\n     */\r\n    HTMLDocument.prototype.updateHighlight = function () {\r\n        var editor = this.editor,\r\n            codeMirror = editor._codeMirror,\r\n            ids = [];\r\n        if (Inspector.config.highlight) {\r\n            _.each(this.editor.getSelections(), function (sel) {\r\n                var tagID = HTMLInstrumentation._getTagIDAtDocumentPos(\r\n                    editor,\r\n                    sel.reversed ? sel.end : sel.start\r\n                );\r\n                if (tagID !== -1) {\r\n                    ids.push(tagID);\r\n                }\r\n            });\r\n            \r\n            if (!ids.length) {\r\n                HighlightAgent.hide();\r\n            } else {\r\n                HighlightAgent.domElement(ids);\r\n            }\r\n        }\r\n    };\r\n\r\n    /** Event Handlers *******************************************************/\r\n\r\n    /**\r\n     * Triggered on cursor activity by the editor\r\n     * @param {$.Event} event Event\r\n     * @param {!Editor} editor The editor for this document\r\n     */\r\n    HTMLDocument.prototype._onCursorActivity = function (event, editor) {\r\n        if (this.editor !== editor) {\r\n            return;\r\n        }\r\n        this.updateHighlight();\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * For the given editor change, compare the resulting browser DOM with the\r\n     * in-editor DOM. If there are any diffs, a warning is logged to the\r\n     * console along with each diff.\r\n     * @param {Object} change CodeMirror editor change data\r\n     */\r\n    HTMLDocument.prototype._compareWithBrowser = function (change) {\r\n        var self = this;\r\n        \r\n        RemoteAgent.call("getSimpleDOM").done(function (res) {\r\n            var browserSimpleDOM = JSON.parse(res.result.value),\r\n                edits,\r\n                node,\r\n                result;\r\n            \r\n            try {\r\n                result = HTMLInstrumentation._getBrowserDiff(self.editor, browserSimpleDOM);\r\n            } catch (err) {\r\n                console.error("Error comparing in-browser DOM to in-editor DOM");\r\n                console.error(err.stack);\r\n                return;\r\n            }\r\n            \r\n            edits = result.diff.filter(function (delta) {\r\n                // ignore textDelete in html root element\r\n                node = result.browser.nodeMap[delta.parentID];\r\n                \r\n                if (node && node.tag === "html" && delta.type === "textDelete") {\r\n                    return false;\r\n                }\r\n                \r\n                return true;\r\n            });\r\n            \r\n            if (edits.length > 0) {\r\n                console.warn("Browser DOM does not match after change: " + JSON.stringify(change));\r\n                \r\n                edits.forEach(function (delta) {\r\n                    console.log(delta);\r\n                });\r\n            }\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Triggered when the editor is being destroyed\r\n     * @param {$.Event} event Event\r\n     * @param {!Editor} editor The editor being destroyed\r\n     */\r\n    HTMLDocument.prototype._onDestroy = function (event, editor) {\r\n        if (this.editor === editor) {\r\n            this.detachFromEditor();\r\n        }\r\n    };\r\n    \r\n    \r\n    /**\r\n     * Triggered on change by the editor\r\n     * @param {$.Event} event Event\r\n     * @param {!Editor} editor The editor for this document\r\n     * @param {Object} change CodeMirror editor change data\r\n     */\r\n    HTMLDocument.prototype._onChange = function (event, editor, change) {\r\n        // Make sure LiveHTML is turned on\r\n        if (!this._instrumentationEnabled) {\r\n            return;\r\n        }\r\n\r\n        // Apply DOM edits is async, so previous PerfUtils timer may still be\r\n        // running. PerfUtils does not support running multiple timers with same\r\n        // name, so do not start another timer in this case.\r\n        var perfTimerName   = "HTMLDocument applyDOMEdits",\r\n            isNestedTimer   = PerfUtils.isActive(perfTimerName);\r\n        if (!isNestedTimer) {\r\n            PerfUtils.markStart(perfTimerName);\r\n        }\r\n        \r\n        // Only handles attribute changes currently.\r\n        // TODO: text changes should be easy to add\r\n        // TODO: if new tags are added, need to instrument them\r\n        var self                = this,\r\n            result              = HTMLInstrumentation.getUnappliedEditList(editor, change),\r\n            applyEditsPromise;\r\n        \r\n        if (result.edits) {\r\n            applyEditsPromise = RemoteAgent.call("applyDOMEdits", result.edits);\r\n    \r\n            applyEditsPromise.always(function () {\r\n                if (!isNestedTimer) {\r\n                    PerfUtils.addMeasurement(perfTimerName);\r\n                }\r\n            });\r\n        }\r\n\r\n        this.errors = result.errors || [];\r\n        $(this).triggerHandler("statusChanged", [this]);\r\n        \r\n        // Debug-only: compare in-memory vs. in-browser DOM\r\n        // edit this file or set a conditional breakpoint at the top of this function:\r\n        //     "this._debug = true, false"\r\n        if (this._debug) {\r\n            console.log("Edits applied to browser were:");\r\n            console.log(JSON.stringify(result.edits, null, 2));\r\n            applyEditsPromise.done(function () {\r\n                self._compareWithBrowser(change);\r\n            });\r\n        }\r\n        \r\n//        var marker = HTMLInstrumentation._getMarkerAtDocumentPos(\r\n//            this.editor,\r\n//            editor.getCursorPos()\r\n//        );\r\n//\r\n//        if (marker && marker.tagID) {\r\n//            var range   = marker.find(),\r\n//                text    = marker.doc.getRange(range.from, range.to);\r\n//\r\n//            // HACK maintain ID\r\n//            text = text.replace(">", " data-brackets-id=\'" + marker.tagID + "\'>");\r\n//\r\n//            // FIXME incorrectly replaces body elements with content only, missing body element\r\n//            RemoteAgent.remoteElement(marker.tagID).replaceWith(text);\r\n//        }\r\n\r\n        // if (!this.editor) {\r\n        //     return;\r\n        // }\r\n        // var codeMirror = this.editor._codeMirror;\r\n        // while (change) {\r\n        //     var from = codeMirror.indexFromPos(change.from);\r\n        //     var to = codeMirror.indexFromPos(change.to);\r\n        //     var text = change.text.join("\\n");\r\n        //     DOMAgent.applyChange(from, to, text);\r\n        //     change = change.next;\r\n        // }\r\n    };\r\n\r\n    /**\r\n     * Triggered when the active editor changes\r\n     * @param {$.Event} event Event\r\n     * @param {!Editor} newActive The new active editor\r\n     * @param {!Editor} oldActive The old active editor\r\n     */\r\n    HTMLDocument.prototype._onActiveEditorChange = function (event, newActive, oldActive) {\r\n        this.detachFromEditor();\r\n        \r\n        if (newActive && newActive.document === this.doc) {\r\n            this.attachToEditor(newActive);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Triggered by the HighlightAgent to highlight a node in the editor\r\n     * @param {$.Event} event Event\r\n     * @param {DOMElement} node Element to highlight\r\n     */\r\n    HTMLDocument.prototype._onHighlight = function (event, node) {\r\n        this._removeHighlight();\r\n        if (!node || !node.location || !this.editor) {\r\n            return;\r\n        }\r\n\r\n        var codeMirror = this.editor._codeMirror;\r\n        var to, from = codeMirror.posFromIndex(node.location);\r\n        if (node.closeLocation) {\r\n            to = node.closeLocation + node.closeLength;\r\n        } else {\r\n            to = node.location + node.length;\r\n        }\r\n\r\n        to = codeMirror.posFromIndex(to);\r\n        this._highlight = codeMirror.markText(from, to, { className: "highlight" });\r\n    };\r\n\r\n    /**\r\n     * Remove all highlighting\r\n     */\r\n    HTMLDocument.prototype._removeHighlight = function () {\r\n        if (this._highlight) {\r\n            this._highlight.clear();\r\n            this._highlight = null;\r\n        }\r\n    };\r\n\r\n    // Export the class\r\n    module.exports = HTMLDocument;\r\n});\n//# sourceURL=/LiveDevelopment/Documents/HTMLDocument.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $ */\r\n\r\n/**\r\n * JSDocument manages a single JavaScript source document\r\n *\r\n * __EDITING__\r\n *\r\n * Editing the document will cause the script to be reloaded via the\r\n * ScriptAgent, which updates the implementation of all functions without\r\n * loosing any state. To support redrawing canvases, jQuery must be loaded\r\n * and a rerender method must be attached to every canvas that clears and\r\n * renders the canvas.\r\n *\r\n * __HIGHLIGHTING__\r\n *\r\n * JSDocument supports highlighting nodes from the HighlightAgent. Support\r\n * for highlighting the nodes that were created / touched by the current\r\n * line is missing.\r\n */\r\ndefine(\'LiveDevelopment/Documents/JSDocument\',[\'require\',\'exports\',\'module\',\'LiveDevelopment/Inspector/Inspector\',\'LiveDevelopment/Agents/ScriptAgent\',\'LiveDevelopment/Agents/HighlightAgent\'],function JSDocumentModule(require, exports, module) {\r\n    "use strict";\r\n\r\n    var Inspector = require("LiveDevelopment/Inspector/Inspector");\r\n    var ScriptAgent = require("LiveDevelopment/Agents/ScriptAgent");\r\n    var HighlightAgent = require("LiveDevelopment/Agents/HighlightAgent");\r\n\r\n    /**\r\n     * @constructor\r\n     * @param {!Document} doc The source document from Brackets\r\n     * @param {!Editor} editor The editor for this document\r\n     */\r\n    var JSDocument = function JSDocument(doc, editor) {\r\n        if (!editor) {\r\n            return;\r\n        }\r\n        this.doc = doc;\r\n        this.editor = editor;\r\n        this.onHighlight = this.onHighlight.bind(this);\r\n        this.onChange = this.onChange.bind(this);\r\n        this.onCursorActivity = this.onCursorActivity.bind(this);\r\n        $(HighlightAgent).on("highlight", this.onHighlight);\r\n        $(this.editor).on("change", this.onChange);\r\n        $(this.editor).on("cursorActivity", this.onCursorActivity);\r\n        this.onCursorActivity();\r\n    };\r\n\r\n    /** Close the document */\r\n    JSDocument.prototype.close = function close() {\r\n        if (!this.editor) {\r\n            return;\r\n        }\r\n        $(HighlightAgent).off("highlight", this.onHighlight);\r\n        $(this.editor).off("change", this.onChange);\r\n        $(this.editor).off("cursorActivity", this.onCursorActivity);\r\n        this.onHighlight();\r\n    };\r\n\r\n    JSDocument.prototype.script = function script() {\r\n        return ScriptAgent.scriptForURL(this.doc.url);\r\n    };\r\n\r\n\r\n    /** Event Handlers *******************************************************/\r\n\r\n    /** Triggered on cursor activity by the editor */\r\n    JSDocument.prototype.onCursorActivity = function onCursorActivity(event, editor) {\r\n    };\r\n\r\n    /** Triggered on change by the editor */\r\n    JSDocument.prototype.onChange = function onChange(event, editor, change) {\r\n        var src = this.doc.getText();\r\n        Inspector.Debugger.setScriptSource(this.script().scriptId, src, function onSetScriptSource(res) {\r\n            Inspector.Runtime.evaluate("if($)$(\\"canvas\\").each(function(i,e){if(e.rerender)e.rerender()})");\r\n        }.bind(this));\r\n    };\r\n\r\n    /** Triggered by the HighlightAgent to highlight a node in the editor */\r\n    JSDocument.prototype.onHighlight = function onHighlight(event, node) {\r\n        // clear an existing highlight\r\n        var codeMirror = this.editor._codeMirror;\r\n        var i;\r\n        for (i in this._highlight) {\r\n            codeMirror.removeLineClass(this._highlight[i], "wrap", "highlight");\r\n        }\r\n        this._highlight = [];\r\n        if (!node || !node.trace) {\r\n            return;\r\n        }\r\n\r\n        // go through the trace and find highlight the lines of this script\r\n        var scriptId = this.script().scriptId;\r\n        var callFrame, line;\r\n        for (i in node.trace) {\r\n            callFrame = node.trace[i];\r\n            if (callFrame.location && callFrame.location.scriptId === scriptId) {\r\n                line = callFrame.location.lineNumber;\r\n                codeMirror.addLineClass(line, "wrap", "highlight");\r\n                this._highlight.push(line);\r\n            }\r\n        }\r\n    };\r\n\r\n    // Export the class\r\n    module.exports = JSDocument;\r\n});\n//# sourceURL=/LiveDevelopment/Documents/JSDocument.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $ */\r\n\r\n/**\r\n * ConsoleAgent forwards all console message from the remote console to the\r\n * local console.\r\n */\r\ndefine(\'LiveDevelopment/Agents/ConsoleAgent\',[\'require\',\'exports\',\'module\',\'LiveDevelopment/Inspector/Inspector\'],function ConsoleAgent(require, exports, module) {\r\n    "use strict";\r\n\r\n    var Inspector = require("LiveDevelopment/Inspector/Inspector");\r\n\r\n    var _lastMessage; // {Console.ConsoleMessage} the last received message\r\n\r\n    /** Log a remote message to the local console\r\n     * @param {Console.ConsoleMessage} message\r\n     */\r\n    function _log(message) {\r\n        var level = message.level;\r\n        if (level === "warning") {\r\n            level = "warn";\r\n        }\r\n        var text = "ConsoleAgent: " + message.text;\r\n        if (message.url) {\r\n            text += " (url: " + message.url + ")";\r\n        }\r\n        if (message.stackTrace) {\r\n            var callFrame = message.stackTrace[0];\r\n            text += " in " + callFrame.functionName + ":" + callFrame.columnNumber;\r\n        }\r\n        console[level](text);\r\n    }\r\n\r\n    // WebInspector Event: Console.messageAdded\r\n    function _onMessageAdded(event, res) {\r\n        // res = {message}\r\n        _lastMessage = res.message;\r\n        _log(_lastMessage);\r\n    }\r\n\r\n    // WebInspector Event: Console.messageRepeatCountUpdated\r\n    function _onMessageRepeatCountUpdated(event, res) {\r\n        // res = {count}\r\n        if (_lastMessage) {\r\n            _log(_lastMessage);\r\n        }\r\n    }\r\n\r\n    // WebInspector Event: Console.messagesCleared\r\n    function _onMessagesCleared(event, res) {\r\n        // res = {}\r\n    }\r\n    \r\n    /**\r\n     * Enable the inspector Console domain\r\n     * @return {jQuery.Promise} A promise resolved when the Console.enable() command is successful.\r\n     */\r\n    function enable() {\r\n        return Inspector.Console.enable();\r\n    }\r\n\r\n    /** Initialize the agent */\r\n    function load() {\r\n        $(Inspector.Console)\r\n            .on("messageAdded.ConsoleAgent", _onMessageAdded)\r\n            .on("messageRepeatCountUpdated.ConsoleAgent", _onMessageRepeatCountUpdated)\r\n            .on("messagesCleared.ConsoleAgent", _onMessagesCleared);\r\n    }\r\n\r\n    /** Clean up */\r\n    function unload() {\r\n        $(Inspector.Console).off(".ConsoleAgent");\r\n    }\r\n\r\n    // Export public functions\r\n    exports.enable = enable;\r\n    exports.load = load;\r\n    exports.unload = unload;\r\n});\n//# sourceURL=/LiveDevelopment/Agents/ConsoleAgent.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $ */\r\n\r\n/**\r\n * NetworkAgent tracks all resources loaded by the remote debugger. Use\r\n * `wasURLRequested(url)` to query whether a resource was loaded.\r\n */\r\ndefine(\'LiveDevelopment/Agents/NetworkAgent\',[\'require\',\'exports\',\'module\',\'LiveDevelopment/Inspector/Inspector\'],function NetworkAgent(require, exports, module) {\r\n    "use strict";\r\n\r\n    var Inspector = require("LiveDevelopment/Inspector/Inspector");\r\n\r\n    var _urlRequested = {}; // url -> request info\r\n\r\n    /** Return the URL without the query string\r\n     * @param {string} URL\r\n     */\r\n    function _urlWithoutQueryString(url) {\r\n        var index = url.search(/[#\\?]/);\r\n        if (index >= 0) {\r\n            url = url.substr(0, index);\r\n        }\r\n        return url;\r\n    }\r\n\r\n    /** Return the resource information for a given URL\r\n     * @param {string} url\r\n     */\r\n    function wasURLRequested(url) {\r\n        return _urlRequested && _urlRequested[url];\r\n    }\r\n\r\n    function _logURL(url) {\r\n        _urlRequested[_urlWithoutQueryString(url)] = true;\r\n    }\r\n\r\n    // WebInspector Event: Network.requestWillBeSent\r\n    function _onRequestWillBeSent(event, res) {\r\n        // res = {requestId, frameId, loaderId, documentURL, request, timestamp, initiator, stackTrace, redirectResponse}\r\n        _logURL(res.request.url);\r\n    }\r\n\r\n    function _reset() {\r\n        _urlRequested = {};\r\n    }\r\n\r\n    // WebInspector Event: Page.frameNavigated\r\n    function _onFrameNavigated(event, res) {\r\n        // res = {frame}\r\n        // Clear log when navigating to a new page, but not if an iframe was loaded\r\n        if (!res.frame.parentId) {\r\n            _reset();\r\n        }\r\n        _logURL(res.frame.url);\r\n    }\r\n    \r\n    /**\r\n     * Enable the inspector Network domain\r\n     * @return {jQuery.Promise} A promise resolved when the Network.enable() command is successful.\r\n     */\r\n    function enable() {\r\n        return Inspector.Network.enable();\r\n    }\r\n\r\n    /** Initialize the agent */\r\n    function load() {\r\n        $(Inspector.Page).on("frameNavigated.NetworkAgent", _onFrameNavigated);\r\n        $(Inspector.Network).on("requestWillBeSent.NetworkAgent", _onRequestWillBeSent);\r\n    }\r\n\r\n    /** Unload the agent */\r\n    function unload() {\r\n        _reset();\r\n        $(Inspector.Page).off(".NetworkAgent");\r\n        $(Inspector.Network).off(".NetworkAgent");\r\n    }\r\n\r\n    // Export public functions\r\n    exports.wasURLRequested = wasURLRequested;\r\n    exports.enable = enable;\r\n    exports.load = load;\r\n    exports.unload = unload;\r\n});\r\n\n//# sourceURL=/LiveDevelopment/Agents/NetworkAgent.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global define, $, brackets, window, open */\r\n\r\n/**\r\n * LiveDevelopment manages the Inspector, all Agents, and the active LiveDocument\r\n *\r\n * __STARTING__\r\n *\r\n * To start a session call `open`. This will read the currentDocument from brackets,\r\n * launch the LiveBrowser (currently Chrome) with the remote debugger port open,\r\n * establish the Inspector connection to the remote debugger, and finally load all\r\n * agents.\r\n *\r\n * __STOPPING__\r\n *\r\n * To stop a session call `close`. This will close the active browser window,\r\n * disconnect the Inspector, unload all agents, and clean up.\r\n *\r\n * __STATUS__\r\n *\r\n * Status updates are dispatched as `statusChange` jQuery events. The status\r\n * is passed as the first parameter and the reason for the change as the second\r\n * parameter. Currently only the "Inactive" status supports the reason parameter.\r\n * The status codes are:\r\n *\r\n *     -1: Error\r\n *      0: Inactive\r\n *      1: Connecting to the remote debugger\r\n *      2: Loading agents\r\n *      3: Active\r\n *      4: Out of sync\r\n *\r\n * The reason codes are:\r\n * - null (Unknown reason)\r\n * - "explicit_close" (LiveDevelopment.close() was called)\r\n * - "navigated_away" (The browser changed to a location outside of the project)\r\n * - "detached_target_closed" (The tab or window was closed)\r\n * - "detached_replaced_with_devtools" (The developer tools were opened in the browser)\r\n */\r\ndefine(\'LiveDevelopment/LiveDevelopment\',[\'require\',\'exports\',\'module\',\'utils/Global\',\'thirdparty/lodash\',\'utils/Async\',\'widgets/Dialogs\',\'widgets/DefaultDialogs\',\'document/DocumentManager\',\'editor/EditorManager\',\'LiveDevelopment/Servers/FileServer\',\'filesystem/FileSystemError\',\'file/FileUtils\',\'LiveDevelopment/LiveDevServerManager\',\'view/MainViewManager\',\'utils/NativeApp\',\'preferences/PreferencesDialogs\',\'project/ProjectManager\',\'strings\',\'utils/StringUtils\',\'LiveDevelopment/Servers/UserServer\',\'LiveDevelopment/Inspector/Inspector\',\'LiveDevelopment/Documents/CSSDocument\',\'LiveDevelopment/Documents/CSSPreprocessorDocument\',\'LiveDevelopment/Documents/HTMLDocument\',\'LiveDevelopment/Documents/JSDocument\',\'LiveDevelopment/Agents/CSSAgent\',\'LiveDevelopment/Agents/ConsoleAgent\',\'LiveDevelopment/Agents/RemoteAgent\',\'LiveDevelopment/Agents/NetworkAgent\',\'LiveDevelopment/Agents/DOMAgent\',\'LiveDevelopment/Agents/ScriptAgent\',\'LiveDevelopment/Agents/HighlightAgent\',\'LiveDevelopment/Agents/GotoAgent\',\'LiveDevelopment/Agents/EditAgent\'],function LiveDevelopment(require, exports, module) {\r\n    "use strict";\r\n\r\n    require("utils/Global");\r\n\r\n    var _ = require("thirdparty/lodash");\r\n\r\n    // Status Codes\r\n    var STATUS_ERROR          = exports.STATUS_ERROR          = -1;\r\n    var STATUS_INACTIVE       = exports.STATUS_INACTIVE       =  0;\r\n    var STATUS_CONNECTING     = exports.STATUS_CONNECTING     =  1;\r\n    var STATUS_LOADING_AGENTS = exports.STATUS_LOADING_AGENTS =  2;\r\n    var STATUS_ACTIVE         = exports.STATUS_ACTIVE         =  3;\r\n    var STATUS_OUT_OF_SYNC    = exports.STATUS_OUT_OF_SYNC    =  4;\r\n    var STATUS_SYNC_ERROR     = exports.STATUS_SYNC_ERROR     =  5;\r\n\r\n    var Async                = require("utils/Async"),\r\n        Dialogs              = require("widgets/Dialogs"),\r\n        DefaultDialogs       = require("widgets/DefaultDialogs"),\r\n        DocumentManager      = require("document/DocumentManager"),\r\n        EditorManager        = require("editor/EditorManager"),\r\n        FileServer           = require("LiveDevelopment/Servers/FileServer").FileServer,\r\n        FileSystemError      = require("filesystem/FileSystemError"),\r\n        FileUtils            = require("file/FileUtils"),\r\n        LiveDevServerManager = require("LiveDevelopment/LiveDevServerManager"),\r\n        MainViewManager      = require("view/MainViewManager"),\r\n        NativeApp            = require("utils/NativeApp"),\r\n        PreferencesDialogs   = require("preferences/PreferencesDialogs"),\r\n        ProjectManager       = require("project/ProjectManager"),\r\n        Strings              = require("strings"),\r\n        StringUtils          = require("utils/StringUtils"),\r\n        UserServer           = require("LiveDevelopment/Servers/UserServer").UserServer;\r\n\r\n    // Inspector\r\n    var Inspector       = require("LiveDevelopment/Inspector/Inspector");\r\n\r\n    // Documents\r\n    var CSSDocument     = require("LiveDevelopment/Documents/CSSDocument"),\r\n        CSSPreprocessorDocument = require("LiveDevelopment/Documents/CSSPreprocessorDocument"),\r\n        HTMLDocument    = require("LiveDevelopment/Documents/HTMLDocument"),\r\n        JSDocument      = require("LiveDevelopment/Documents/JSDocument");\r\n    \r\n    // Document errors\r\n    var SYNC_ERROR_CLASS = "live-preview-sync-error";\r\n\r\n    // Agents\r\n    var CSSAgent = require("LiveDevelopment/Agents/CSSAgent");\r\n    \r\n    var agents = {\r\n        "console"   : require("LiveDevelopment/Agents/ConsoleAgent"),\r\n        "remote"    : require("LiveDevelopment/Agents/RemoteAgent"),\r\n        "network"   : require("LiveDevelopment/Agents/NetworkAgent"),\r\n        "dom"       : require("LiveDevelopment/Agents/DOMAgent"),\r\n        "css"       : CSSAgent,\r\n        "script"    : require("LiveDevelopment/Agents/ScriptAgent"),\r\n        "highlight" : require("LiveDevelopment/Agents/HighlightAgent"),\r\n        "goto"      : require("LiveDevelopment/Agents/GotoAgent"),\r\n        "edit"      : require("LiveDevelopment/Agents/EditAgent")\r\n    };\r\n\r\n    // construct path to launch.html\r\n    // window location is can be one of the following:\r\n    // Installed:                /path/to/Brackets.app/Contents/www/index.html\r\n    // Installed, dev:           /path/to/Brackets.app/Contents/dev/src/index.html\r\n    // Installed, dev, test:     /path/to/Brackets.app/Contents/dev/test/SpecRunner.html\r\n    // Arbitrary git repo:       /path/to/brackets/src/index.html\r\n    // Arbitrary git repo, test: /path/to/brackets/test/SpecRunner.html\r\n    var launcherUrl = window.location.pathname;\r\n\r\n    // special case for test/SpecRunner.html since we can\'t tell how requirejs\r\n    // baseUrl is configured dynamically\r\n    launcherUrl = launcherUrl.replace("/test/SpecRunner.html", "/src/index.html");\r\n\r\n    launcherUrl = launcherUrl.substr(0, launcherUrl.lastIndexOf("/")) + "/LiveDevelopment/launch.html";\r\n    launcherUrl = window.location.origin + launcherUrl;\r\n\r\n    // Some agents are still experimental, so we don\'t enable them all by default\r\n    // However, extensions can enable them by calling enableAgent().\r\n    // This object is used as a set (thus all properties have the value \'true\').\r\n    // Property names should match property names in the \'agents\' object.\r\n    var _enabledAgentNames = {\r\n        "console"   : true,\r\n        "remote"    : true,\r\n        "network"   : true,\r\n        "css"       : true,\r\n        "highlight" : true\r\n    };\r\n\r\n    /**\r\n     * Store the names (matching property names in the \'agent\' object) of agents that we\'ve loaded\r\n     * @type {string}\r\n     */\r\n    var _loadedAgentNames = [];\r\n\r\n    /**\r\n     * Live Preview current Document info\r\n     * @type {HTMLDocument}\r\n     */\r\n    var _liveDocument;\r\n    \r\n    /**\r\n     * Related Live Documents\r\n     * @type {Object.<string: (HTMLDocument|CSSDocument)>}\r\n     */\r\n    var _relatedDocuments = {};\r\n    \r\n    /**\r\n     * Promise returned for each call to open()\r\n     * @type {jQuery.Deferred}\r\n     */\r\n    var _openDeferred;\r\n    \r\n    /**\r\n     * Promise returned for each call to close()\r\n     * @type {jQuery.Deferred}\r\n     */\r\n    var _closeDeferred;\r\n\r\n    // Disallow re-entrancy of loadAgents()\r\n    var _loadAgentsPromise;\r\n    \r\n    /**\r\n     * Current live preview server\r\n     * @type {BaseServer}\r\n     */\r\n    var _server;\r\n\r\n    function _isPromisePending(promise) {\r\n        return promise && promise.state() === "pending";\r\n    }\r\n    \r\n    function _isHtmlFileExt(ext) {\r\n        return (FileUtils.isStaticHtmlFileExt(ext) ||\r\n                (ProjectManager.getBaseUrl() && FileUtils.isServerHtmlFileExt(ext)));\r\n    }\r\n\r\n    /** Get the current document from the document manager\r\n     * _adds extension, url and root to the document\r\n     */\r\n    function _getCurrentDocument() {\r\n        return DocumentManager.getCurrentDocument();\r\n    }\r\n\r\n    /** Determine which document class should be used for a given document\r\n     * @param {Document} document\r\n     */\r\n    function _classForDocument(doc) {\r\n        switch (doc.getLanguage().getId()) {\r\n        case "less":\r\n        case "scss":\r\n            return CSSPreprocessorDocument;\r\n        case "css":\r\n            return CSSDocument;\r\n        case "javascript":\r\n            return exports.config.experimental ? JSDocument : null;\r\n        }\r\n\r\n        if (_isHtmlFileExt(doc.file.fullPath)) {\r\n            return HTMLDocument;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function getLiveDocForPath(path) {\r\n        if (!_server) {\r\n            return undefined;\r\n        }\r\n        \r\n        return _server.get(path);\r\n    }\r\n    \r\n    function getLiveDocForEditor(editor) {\r\n        if (!editor) {\r\n            return null;\r\n        }\r\n        return getLiveDocForPath(editor.document.file.fullPath);\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Clears errors from line number gutter (line class)\r\n     * @param {HTMLDocument|CSSDocument} liveDocument\r\n     */\r\n    function _doClearErrors(liveDocument) {\r\n        var lineHandle;\r\n        \r\n        if (!liveDocument.editor ||\r\n                !liveDocument._errorLineHandles ||\r\n                !liveDocument._errorLineHandles.length) {\r\n            return;\r\n        }\r\n        \r\n        liveDocument.editor._codeMirror.operation(function () {\r\n            while (true) {\r\n                // Iterate over all lines that were previously marked with an error\r\n                lineHandle = liveDocument._errorLineHandles.pop();\r\n                \r\n                if (!lineHandle) {\r\n                    break;\r\n                }\r\n                \r\n                liveDocument.editor._codeMirror.removeLineClass(lineHandle, "wrap", SYNC_ERROR_CLASS);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Close a live document\r\n     */\r\n    function _closeDocument(liveDocument) {\r\n        _doClearErrors(liveDocument);\r\n        liveDocument.close();\r\n        \r\n        if (liveDocument.editor) {\r\n            $(liveDocument.editor).off(".livedev");\r\n        }\r\n        \r\n        $(liveDocument).off(".livedev");\r\n    }\r\n    \r\n    /**\r\n     * Removes the given CSS/JSDocument from _relatedDocuments. Signals that the\r\n     * given file is no longer associated with the HTML document that is live (e.g.\r\n     * if the related file has been deleted on disk).\r\n     */\r\n    function _closeRelatedDocument(liveDoc) {\r\n        if (_relatedDocuments[liveDoc.doc.url]) {\r\n            delete _relatedDocuments[liveDoc.doc.url];\r\n        }\r\n            \r\n        if (_server) {\r\n            _server.remove(liveDoc);\r\n        }\r\n        \r\n        _closeDocument(liveDoc);\r\n    }\r\n    \r\n    /**\r\n     * Update the status. Triggers a statusChange event.\r\n     * @param {number} status new status\r\n     * @param {?string} closeReason Optional string key suffix to display to\r\n     *     user when closing the live development connection (see LIVE_DEV_* keys)\r\n     */\r\n    function _setStatus(status, closeReason) {\r\n        // Don\'t send a notification when the status didn\'t actually change\r\n        if (status === exports.status) {\r\n            return;\r\n        }\r\n        \r\n        exports.status = status;\r\n        \r\n        var reason = status === STATUS_INACTIVE ? closeReason : null;\r\n        $(exports).triggerHandler("statusChange", [status, reason]);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Event handler for live document errors. Displays error status in the editor gutter.\r\n     * @param {$.Event} event\r\n     * @param {HTMLDocument|CSSDocument} liveDocument\r\n     * @param {Array.<{token: SimpleNode, startPos: Pos, endPos: Pos}>} errors \r\n     */\r\n    function _handleLiveDocumentStatusChanged(liveDocument) {\r\n        var startLine,\r\n            endLine,\r\n            lineInfo,\r\n            i,\r\n            lineHandle,\r\n            status = (liveDocument.errors.length) ? STATUS_SYNC_ERROR : STATUS_ACTIVE;\r\n\r\n        _setStatus(status);\r\n        \r\n        if (!liveDocument.editor) {\r\n            return;\r\n        }\r\n\r\n        // Buffer addLineClass DOM changes in a CodeMirror operation\r\n        liveDocument.editor._codeMirror.operation(function () {\r\n            // Remove existing errors before marking new ones\r\n            _doClearErrors(liveDocument);\r\n            \r\n            liveDocument._errorLineHandles = liveDocument._errorLineHandles || [];\r\n    \r\n            liveDocument.errors.forEach(function (error) {\r\n                startLine = error.startPos.line;\r\n                endLine = error.endPos.line;\r\n                \r\n                for (i = startLine; i < endLine + 1; i++) {\r\n                    lineHandle = liveDocument.editor._codeMirror.addLineClass(i, "wrap", SYNC_ERROR_CLASS);\r\n                    liveDocument._errorLineHandles.push(lineHandle);\r\n                }\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Close all live documents\r\n     */\r\n    function _closeDocuments() {\r\n        if (_liveDocument) {\r\n            _closeDocument(_liveDocument);\r\n            _liveDocument = undefined;\r\n        }\r\n        \r\n        Object.keys(_relatedDocuments).forEach(function (url) {\r\n            _closeDocument(_relatedDocuments[url]);\r\n            delete _relatedDocuments[url];\r\n        });\r\n        \r\n        // Clear all documents from request filtering\r\n        if (_server) {\r\n            _server.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Create a live version of a Brackets document\r\n     * @param {Document} doc Current document\r\n     * @param {Editor} editor Current editor\r\n     * @return {?(HTMLDocument|CSSDocument)}\r\n     */\r\n    function _createDocument(doc, editor) {\r\n        var DocClass        = _classForDocument(doc),\r\n            liveDocument    = new DocClass(doc, editor);\r\n\r\n        if (!DocClass) {\r\n            return null;\r\n        }\r\n\r\n        $(liveDocument).on("statusChanged.livedev", function () {\r\n            _handleLiveDocumentStatusChanged(liveDocument);\r\n        });\r\n\r\n        return liveDocument;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Initialize `_liveDocument`.\r\n     * @param {Document} doc Current document\r\n     */\r\n    function _createLiveDocumentForFrame(doc) {\r\n        // create live document\r\n        doc._ensureMasterEditor();\r\n        _liveDocument = _createDocument(doc, doc._masterEditor);\r\n        _server.add(_liveDocument);\r\n    }\r\n    \r\n    /** Enable an agent. Takes effect next time a connection is made. Does not affect\r\n     *  current live development sessions.\r\n     *\r\n     *  @param {string} name of agent to enable\r\n     */\r\n    function enableAgent(name) {\r\n        if (agents.hasOwnProperty(name) && !_enabledAgentNames.hasOwnProperty(name)) {\r\n            _enabledAgentNames[name] = true;\r\n        }\r\n    }\r\n\r\n    /** Disable an agent. Takes effect next time a connection is made. Does not affect\r\n     *  current live development sessions.\r\n     *\r\n     *  @param {string} name of agent to disable\r\n     */\r\n    function disableAgent(name) {\r\n        if (_enabledAgentNames.hasOwnProperty(name)) {\r\n            delete _enabledAgentNames[name];\r\n        }\r\n    }\r\n\r\n    /** Documents are considered to be out-of-sync if they are dirty and\r\n     *  do not have "update while editing" support\r\n     * @param {Document} doc\r\n     */\r\n    function _docIsOutOfSync(doc) {\r\n        var docClass    = _classForDocument(doc),\r\n            liveDoc     = _server && _server.get(doc.file.fullPath),\r\n            isLiveEditingEnabled = liveDoc && liveDoc.isLiveEditingEnabled();\r\n\r\n        return doc.isDirty && !isLiveEditingEnabled;\r\n    }\r\n    \r\n    /** Triggered by Inspector.error */\r\n    function _onError(event, error, msgData) {\r\n        var message;\r\n        \r\n        // Sometimes error.message is undefined\r\n        if (!error.message) {\r\n            console.warn("Expected a non-empty string in error.message, got this instead:", error.message);\r\n            message = JSON.stringify(error);\r\n        } else {\r\n            message = error.message;\r\n        }\r\n\r\n        // Remove "Uncaught" from the beginning to avoid the inspector popping up\r\n        if (message && message.substr(0, 8) === "Uncaught") {\r\n            message = message.substr(9);\r\n        }\r\n\r\n        // Additional information, like exactly which parameter could not be processed.\r\n        var data = error.data;\r\n        if (Array.isArray(data)) {\r\n            message += "\\n" + data.join("\\n");\r\n        }\r\n\r\n        // Show the message, but include the error object for further information (e.g. error code)\r\n        console.error(message, error, msgData);\r\n    }\r\n    \r\n    function _styleSheetAdded(event, url) {\r\n        var path = _server && _server.urlToPath(url),\r\n            exists = !!_relatedDocuments[url];\r\n\r\n        // path may be null if loading an external stylesheet.\r\n        // Also, the stylesheet may already exist and be reported as added twice\r\n        // due to Chrome reporting added/removed events after incremental changes\r\n        // are pushed to the browser\r\n        if (!path || exists) {\r\n            return;\r\n        }\r\n\r\n        var docPromise = DocumentManager.getDocumentForPath(path);\r\n\r\n        docPromise.done(function (doc) {\r\n            if ((_classForDocument(doc) === CSSDocument ||\r\n                    _classForDocument(doc) === CSSPreprocessorDocument) &&\r\n                    (!_liveDocument || (doc !== _liveDocument.doc))) {\r\n                // The doc may already have an editor (e.g. starting live preview from an css file),\r\n                // so pass the editor if any\r\n                var liveDoc = _createDocument(doc, doc._masterEditor);\r\n                if (liveDoc) {\r\n                    _server.add(liveDoc);\r\n                    _relatedDocuments[doc.url] = liveDoc;\r\n\r\n                    $(liveDoc).on("deleted.livedev", function (event, liveDoc) {\r\n                        _closeRelatedDocument(liveDoc);\r\n                    });\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Unload the agents */\r\n    function unloadAgents() {\r\n        _loadedAgentNames.forEach(function (name) {\r\n            agents[name].unload();\r\n        });\r\n        _loadedAgentNames = [];\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Invoke a no-arg method on an inspector agent\r\n     * @param {string} name Agent name\r\n     * @param {stirng} methodName Method name to call on the agent\r\n     */\r\n    function _invokeAgentMethod(name, methodName) {\r\n        var oneAgentPromise;\r\n\r\n        if (agents[name] && agents[name][methodName]) {\r\n            oneAgentPromise = agents[name][methodName].call();\r\n        }\r\n\r\n        if (!oneAgentPromise) {\r\n            oneAgentPromise = new $.Deferred().resolve().promise();\r\n        } else {\r\n            oneAgentPromise.fail(function () {\r\n                console.error(methodName + " failed on agent", name);\r\n            });\r\n        }\r\n\r\n        return oneAgentPromise;\r\n    }\r\n\r\n    function getEnabledAgents() {\r\n        var enabledAgents;\r\n\r\n        // Select agents to use\r\n        if (exports.config.experimental) {\r\n            // load all agents\r\n            enabledAgents = agents;\r\n        } else {\r\n            // load only enabled agents\r\n            enabledAgents = _enabledAgentNames;\r\n        }\r\n        \r\n        return Object.keys(enabledAgents);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Setup agents that need inspector domains enabled before loading\r\n     */\r\n    function _enableAgents() {\r\n        // enable agents in parallel\r\n        return Async.doInParallel(\r\n            getEnabledAgents(),\r\n            function (name) {\r\n                return _invokeAgentMethod(name, "enable");\r\n            },\r\n            true\r\n        );\r\n    }\r\n\r\n    /** Load the agents */\r\n    function loadAgents() {\r\n        // If we\'re already loading agents return same promise\r\n        if (_loadAgentsPromise) {\r\n            return _loadAgentsPromise;\r\n        }\r\n        \r\n        var result = new $.Deferred(),\r\n            promises = [],\r\n            enableAgentsPromise,\r\n            allAgentsPromise;\r\n        \r\n        _loadAgentsPromise = result.promise();\r\n\r\n        _setStatus(STATUS_LOADING_AGENTS);\r\n\r\n        // load agents in parallel\r\n        allAgentsPromise = Async.doInParallel(\r\n            getEnabledAgents(),\r\n            function (name) {\r\n                return _invokeAgentMethod(name, "load").done(function () {\r\n                    _loadedAgentNames.push(name);\r\n                });\r\n            },\r\n            true\r\n        );\r\n\r\n        // wrap agent loading with a timeout\r\n        allAgentsPromise = Async.withTimeout(allAgentsPromise, 10000);\r\n\r\n        allAgentsPromise.done(function () {\r\n            var doc = (_liveDocument) ? _liveDocument.doc : null;\r\n\r\n            if (doc) {\r\n                var status = STATUS_ACTIVE;\r\n\r\n                if (_docIsOutOfSync(doc)) {\r\n                    status = STATUS_OUT_OF_SYNC;\r\n                }\r\n                \r\n                _setStatus(status);\r\n                result.resolve();\r\n            } else {\r\n                result.reject();\r\n            }\r\n        });\r\n\r\n        allAgentsPromise.fail(result.reject);\r\n        \r\n        _loadAgentsPromise\r\n            .fail(function () {\r\n                // show error loading live dev dialog\r\n                _setStatus(STATUS_ERROR);\r\n\r\n                Dialogs.showModalDialog(\r\n                    Dialogs.DIALOG_ID_ERROR,\r\n                    Strings.LIVE_DEVELOPMENT_ERROR_TITLE,\r\n                    Strings.LIVE_DEV_LOADING_ERROR_MESSAGE\r\n                );\r\n            })\r\n            .always(function () {\r\n                _loadAgentsPromise = null;\r\n            });\r\n\r\n        return _loadAgentsPromise;\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Determine an index file that can be used to start Live Development.\r\n     * This function will inspect all files in a project to find the closest index file\r\n     * available for currently opened document. We are searching for these files:\r\n     *  - index.html\r\n     *  - index.htm\r\n     * \r\n     * If the project is configured with a custom base url for live developmment, then\r\n     * the list of possible index files is extended to contain these index files too:\r\n     *  - index.php\r\n     *  - index.php3\r\n     *  - index.php4\r\n     *  - index.php5\r\n     *  - index.phtm\r\n     *  - index.phtml\r\n     *  - index.cfm\r\n     *  - index.cfml\r\n     *  - index.asp\r\n     *  - index.aspx\r\n     *  - index.jsp\r\n     *  - index.jspx\r\n     *  - index.shm\r\n     *  - index.shml\r\n     * \r\n     * If a file was found, the promise will be resolved with the full path to this file. If no file\r\n     * was found in the whole project tree, the promise will be resolved with null.\r\n     * \r\n     * @return {jQuery.Promise} A promise that is resolved with a full path\r\n     * to a file if one could been determined, or null if there was no suitable index\r\n     * file.\r\n     */\r\n    function _getInitialDocFromCurrent() {\r\n        var doc = _getCurrentDocument(),\r\n            refPath,\r\n            i;\r\n\r\n        // TODO: FileUtils.getParentFolder()\r\n        function getParentFolder(path) {\r\n            return path.substring(0, path.lastIndexOf(\'/\', path.length - 2) + 1);\r\n        }\r\n\r\n        function getFilenameWithoutExtension(filename) {\r\n            var index = filename.lastIndexOf(".");\r\n            return index === -1 ? filename : filename.slice(0, index);\r\n        }\r\n\r\n        // Is the currently opened document already a file we can use for Live Development?\r\n        if (doc) {\r\n            refPath = doc.file.fullPath;\r\n            if (FileUtils.isStaticHtmlFileExt(refPath) || FileUtils.isServerHtmlFileExt(refPath)) {\r\n                return new $.Deferred().resolve(doc);\r\n            }\r\n        }\r\n\r\n        var result = new $.Deferred();\r\n\r\n        var baseUrl = ProjectManager.getBaseUrl(),\r\n            hasOwnServerForLiveDevelopment = (baseUrl && baseUrl.length);\r\n\r\n        ProjectManager.getAllFiles().done(function (allFiles) {\r\n            var projectRoot = ProjectManager.getProjectRoot().fullPath,\r\n                containingFolder,\r\n                indexFileFound = false,\r\n                stillInProjectTree = true;\r\n            \r\n            if (refPath) {\r\n                containingFolder = FileUtils.getDirectoryPath(refPath);\r\n            } else {\r\n                containingFolder = projectRoot;\r\n            }\r\n            \r\n            var filteredFiltered = allFiles.filter(function (item) {\r\n                var parent = getParentFolder(item.fullPath);\r\n                \r\n                return (containingFolder.indexOf(parent) === 0);\r\n            });\r\n            \r\n            var filterIndexFile = function (fileInfo) {\r\n                if (fileInfo.fullPath.indexOf(containingFolder) === 0) {\r\n                    if (getFilenameWithoutExtension(fileInfo.name) === "index") {\r\n                        if (hasOwnServerForLiveDevelopment) {\r\n                            if ((FileUtils.isServerHtmlFileExt(fileInfo.name)) ||\r\n                                    (FileUtils.isStaticHtmlFileExt(fileInfo.name))) {\r\n                                return true;\r\n                            }\r\n                        } else if (FileUtils.isStaticHtmlFileExt(fileInfo.name)) {\r\n                            return true;\r\n                        }\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                }\r\n            };\r\n\r\n            while (!indexFileFound && stillInProjectTree) {\r\n                i = _.findIndex(filteredFiltered, filterIndexFile);\r\n\r\n                // We found no good match\r\n                if (i === -1) {\r\n                    // traverse the directory tree up one level\r\n                    containingFolder = getParentFolder(containingFolder);\r\n                    // Are we still inside the project?\r\n                    if (containingFolder.indexOf(projectRoot) === -1) {\r\n                        stillInProjectTree = false;\r\n                    }\r\n                } else {\r\n                    indexFileFound = true;\r\n                }\r\n            }\r\n\r\n            if (i !== -1) {\r\n                DocumentManager.getDocumentForPath(filteredFiltered[i].fullPath).then(result.resolve, result.resolve);\r\n                return;\r\n            }\r\n            \r\n            result.resolve(null);\r\n        });\r\n\r\n        return result.promise();\r\n    }\r\n\r\n    /**\r\n     * If the current editor is for a CSS preprocessor file, then add it to the style sheet \r\n     * so that we can track cursor positions in the editor to show live preview highlighting.\r\n     * For normal CSS we only do highlighting from files we know for sure are referenced by the \r\n     * current live preview document, but for preprocessors we just assume that any preprocessor \r\n     * file you edit is probably related to the live preview.\r\n     *\r\n     * @param {Event} event (unused)\r\n     * @param {Editor} current Current editor\r\n     * @param {Editor} previous Previous editor\r\n     *\r\n     */\r\n    function onActiveEditorChange(event, current, previous) {\r\n        if (previous && previous.document &&\r\n                FileUtils.isCSSPreprocessorFile(previous.document.file.fullPath)) {\r\n            var prevDocUrl = _server && _server.pathToUrl(previous.document.file.fullPath);\r\n            \r\n            if (_relatedDocuments && _relatedDocuments[prevDocUrl]) {\r\n                _closeRelatedDocument(_relatedDocuments[prevDocUrl]);\r\n            }\r\n        }\r\n        if (current && current.document &&\r\n                FileUtils.isCSSPreprocessorFile(current.document.file.fullPath)) {\r\n            var docUrl = _server && _server.pathToUrl(current.document.file.fullPath);\r\n            _styleSheetAdded(null, docUrl);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * While still connected to the Inspector, do cleanup for agents,\r\n     * documents and server.\r\n     * @param {boolean} doCloseWindow Use true to close the window/tab in the browser\r\n     * @return {jQuery.Promise} A promise that is always resolved\r\n     */\r\n    function _doInspectorDisconnect(doCloseWindow) {\r\n        var closePromise,\r\n            deferred    = new $.Deferred(),\r\n            connected   = Inspector.connected();\r\n\r\n        $(EditorManager).off("activeEditorChange", onActiveEditorChange);\r\n        \r\n        $(Inspector.Page).off(".livedev");\r\n        $(Inspector).off(".livedev");\r\n\r\n        // Wait if agents are loading\r\n        if (_loadAgentsPromise) {\r\n            _loadAgentsPromise.always(unloadAgents);\r\n        } else {\r\n            unloadAgents();\r\n        }\r\n        \r\n        // Close live documents \r\n        _closeDocuments();\r\n        \r\n        if (_server) {\r\n            // Stop listening for requests when disconnected\r\n            _server.stop();\r\n\r\n            // Dispose server\r\n            _server = null;\r\n        }\r\n\r\n        if (doCloseWindow && connected) {\r\n            closePromise = Inspector.Runtime.evaluate("window.open(\'\', \'_self\').close();");\r\n\r\n            // Add a timeout to continue cleanup if Inspector does not respond\r\n            closePromise = Async.withTimeout(closePromise, 5000);\r\n        } else {\r\n            closePromise = new $.Deferred().resolve();\r\n        }\r\n\r\n        // Disconnect WebSocket if connected\r\n        closePromise.always(function () {\r\n            if (Inspector.connected()) {\r\n                Inspector.disconnect().always(deferred.resolve);\r\n            } else {\r\n                deferred.resolve();\r\n            }\r\n        });\r\n\r\n        return deferred.promise();\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Close the connection and the associated window asynchronously\r\n     * @param {boolean} doCloseWindow Use true to close the window/tab in the browser\r\n     * @param {?string} reason Optional string key suffix to display to user (see LIVE_DEV_* keys)\r\n     * @return {jQuery.Promise} Always return a resolved promise once the connection is closed\r\n     */\r\n    function _close(doCloseWindow, reason) {\r\n        if (_closeDeferred) {\r\n            return _closeDeferred;\r\n        } else {\r\n            _closeDeferred = new $.Deferred();\r\n            _closeDeferred.always(function () {\r\n                _closeDeferred = null;\r\n            });\r\n        }\r\n\r\n        var promise = _closeDeferred.promise();\r\n\r\n        /*\r\n         * Finish closing the live development connection, including setting\r\n         * the status accordingly.\r\n         */\r\n        function cleanup() {\r\n            // Need to do this in order to trigger the corresponding CloseLiveBrowser cleanups required on \r\n            // the native Mac side\r\n            var closeDeferred = (brackets.platform === "mac") ? NativeApp.closeLiveBrowser() : $.Deferred().resolve();\r\n            closeDeferred.done(function () {\r\n                _setStatus(STATUS_INACTIVE, reason || "explicit_close");\r\n                _closeDeferred.resolve();\r\n            }).fail(function (err) {\r\n                if (err) {\r\n                    reason +=  " (" + err + ")";\r\n                }\r\n                _setStatus(STATUS_INACTIVE, reason || "explicit_close");\r\n                _closeDeferred.resolve();\r\n            });\r\n        }\r\n        \r\n        if (_isPromisePending(_openDeferred)) {\r\n            // Reject calls to open if requests are still pending\r\n            _openDeferred.reject();\r\n        }\r\n\r\n        if (exports.status === STATUS_INACTIVE) {\r\n            // Ignore close if status is inactive\r\n            _closeDeferred.resolve();\r\n        } else {\r\n            _doInspectorDisconnect(doCloseWindow).always(cleanup);\r\n        }\r\n        \r\n        return promise;\r\n    }\r\n\r\n    // WebInspector Event: Page.frameNavigated\r\n    function _onFrameNavigated(event, res) {\r\n        // res = {frame}\r\n        var url = res.frame.url,\r\n            baseUrl,\r\n            baseUrlRegExp;\r\n\r\n        // Only check domain of root frame (with undefined parentId)\r\n        if (res.frame.parentId) {\r\n            return;\r\n        }\r\n\r\n        // Any local file is OK\r\n        if (url.match(/^file:\\/\\//i) || !_server) {\r\n            return;\r\n        }\r\n\r\n        // Need base url to build reg exp\r\n        baseUrl = _server.getBaseUrl();\r\n        if (!baseUrl) {\r\n            return;\r\n        }\r\n\r\n        // Test that url is within site\r\n        baseUrlRegExp = new RegExp("^" + StringUtils.regexEscape(baseUrl), "i");\r\n        if (!url.match(baseUrlRegExp)) {\r\n            // No longer in site, so terminate live dev, but don\'t close browser window\r\n            _close(false, "navigated_away");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Triggered by unexpected Inspector disconnect event\r\n     */\r\n    function _onDisconnect(event) {\r\n        _close(false, "closed_unknown_reason");\r\n    }\r\n\r\n    function _onDetached(event, res) {\r\n        var closeReason;\r\n\r\n        if (res && res.reason) {\r\n            // Get the explanation from res.reason, e.g. "replaced_with_devtools", "target_closed", "canceled_by_user"\r\n            // Examples taken from https://chromiumcodereview.appspot.com/10947037/patch/12001/13004\r\n            // However, the link refers to the Chrome Extension API, it may not apply 100% to the Inspector API\r\n            // Prefix with "detached_" to create a quasi-namespace for Chrome\'s reasons\r\n            closeReason = "detached_" + res.reason;\r\n        }\r\n\r\n        _close(false, closeReason);\r\n    }\r\n\r\n    /**\r\n     * Unload and reload agents\r\n     * @return {jQuery.Promise} Resolves once the agents are loaded\r\n     */\r\n    function reconnect() {\r\n        if (_loadAgentsPromise) {\r\n            // Agents are already loading, so don\'t unload\r\n            return _loadAgentsPromise;\r\n        }\r\n\r\n        unloadAgents();\r\n        \r\n        // Clear any existing related documents before we reload the agents.\r\n        // We need to recreate them for the reloaded document due to some\r\n        // desirable side-effects (see #7606). Eventually, we should simplify\r\n        // the way we get that behavior.\r\n        _.forOwn(_relatedDocuments, function (relatedDoc) {\r\n            _closeRelatedDocument(relatedDoc);\r\n        });\r\n\r\n        return loadAgents();\r\n    }\r\n\r\n    /** reload the live preview */\r\n    function reload() {\r\n        // Unload and reload agents before reloading the page\r\n        // Some agents (e.g. DOMAgent and RemoteAgent) require us to\r\n        // navigate to the page first before loading can complete.\r\n        // To accomodate this, we load all agents (in reconnect())\r\n        // and navigate in parallel.\r\n        reconnect();\r\n\r\n        // Reload HTML page\r\n        Inspector.Page.reload();\r\n    }\r\n\r\n    /**\r\n     * Close the connection and the associated window asynchronously\r\n     * @return {jQuery.Promise} Resolves once the connection is closed\r\n     */\r\n    function close() {\r\n        return _close(true);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Create a promise that resolves when the interstitial page has\r\n     * finished loading.\r\n     * \r\n     * @return {jQuery.Promise} Resolves once page is loaded\r\n     */\r\n    function _waitForInterstitialPageLoad() {\r\n        var deferred    = $.Deferred(),\r\n            keepPolling = true,\r\n            timer       = window.setTimeout(function () {\r\n                keepPolling = false;\r\n                deferred.reject();\r\n            }, 10000); // 10 seconds\r\n        \r\n        /* \r\n         * Asynchronously check to see if the interstitial page has\r\n         * finished loading; if not, check again until timing out.\r\n         */\r\n        function pollInterstitialPage() {\r\n            if (keepPolling && Inspector.connected()) {\r\n                Inspector.Runtime.evaluate("window.isBracketsLiveDevelopmentInterstitialPageLoaded", function (response) {\r\n                    var result = response.result;\r\n                    \r\n                    if (result.type === "boolean" && result.value) {\r\n                        window.clearTimeout(timer);\r\n                        deferred.resolve();\r\n                    } else {\r\n                        window.setTimeout(pollInterstitialPage, 100);\r\n                    }\r\n                });\r\n            } else {\r\n                deferred.reject();\r\n            }\r\n        }\r\n        \r\n        pollInterstitialPage();\r\n        return deferred.promise();\r\n    }\r\n        \r\n    /**\r\n     * @private\r\n     * Load agents and navigate to the target document once the \r\n     * interstitial page has finished loading.\r\n     */\r\n    function _onInterstitialPageLoad() {\r\n\r\n        Inspector.Runtime.evaluate("window.navigator.userAgent", function (uaResponse) {\r\n            Inspector.setUserAgent(uaResponse.result.value);\r\n        });\r\n\r\n        // Domains for some agents must be enabled first before loading\r\n        var enablePromise = Inspector.Page.enable().then(_enableAgents);\r\n        \r\n        enablePromise.done(function () {\r\n            // Some agents (e.g. DOMAgent and RemoteAgent) require us to\r\n            // navigate to the page first before loading can complete.\r\n            // To accomodate this, we load all agents and navigate in\r\n            // parallel.\r\n\r\n            // resolve/reject the open() promise after agents complete\r\n            loadAgents().then(_openDeferred.resolve, _openDeferred.reject);\r\n\r\n            _getInitialDocFromCurrent().done(function (doc) {\r\n                if (doc && _liveDocument) {\r\n                    if (doc !== _liveDocument.doc) {\r\n                        _createLiveDocumentForFrame(doc);\r\n                    }\r\n\r\n                    // Navigate from interstitial to the document\r\n                    // Fires a frameNavigated event\r\n                    if (_server) {\r\n                        Inspector.Page.navigate(_server.pathToUrl(doc.file.fullPath));\r\n                    } else {\r\n                        console.error("LiveDevelopment._onInterstitialPageLoad(): No server active");\r\n                    }\r\n                } else {\r\n                    // Unlikely that we would get to this state where\r\n                    // a connection is in process but there is no current\r\n                    // document\r\n                    close();\r\n                }\r\n            });\r\n        });\r\n    }\r\n    \r\n    /** Triggered by Inspector.connect */\r\n    function _onConnect(event) {\r\n        // When the browser navigates away from the primary live document\r\n        $(Inspector.Page).on("frameNavigated.livedev", _onFrameNavigated);\r\n\r\n        // When the Inspector WebSocket disconnects unexpectedely\r\n        $(Inspector).on("disconnect.livedev", _onDisconnect);\r\n		\r\n        _waitForInterstitialPageLoad()\r\n            .fail(function () {\r\n                close();\r\n\r\n                Dialogs.showModalDialog(\r\n                    DefaultDialogs.DIALOG_ID_ERROR,\r\n                    Strings.LIVE_DEVELOPMENT_ERROR_TITLE,\r\n                    Strings.LIVE_DEV_LOADING_ERROR_MESSAGE\r\n                );\r\n            })\r\n            .done(_onInterstitialPageLoad);\r\n    }\r\n\r\n    function _showWrongDocError() {\r\n        Dialogs.showModalDialog(\r\n            DefaultDialogs.DIALOG_ID_ERROR,\r\n            Strings.LIVE_DEVELOPMENT_ERROR_TITLE,\r\n            Strings.LIVE_DEV_NEED_HTML_MESSAGE\r\n        );\r\n        _openDeferred.reject();\r\n    }\r\n\r\n    function _showLiveDevServerNotReadyError() {\r\n        Dialogs.showModalDialog(\r\n            DefaultDialogs.DIALOG_ID_ERROR,\r\n            Strings.LIVE_DEVELOPMENT_ERROR_TITLE,\r\n            Strings.LIVE_DEV_SERVER_NOT_READY_MESSAGE\r\n        );\r\n        _openDeferred.reject();\r\n    }\r\n    \r\n    function _openInterstitialPage() {\r\n        var browserStarted  = false,\r\n            retryCount      = 0;\r\n        \r\n        // Open the live browser if the connection fails, retry 3 times\r\n        Inspector.connectToURL(launcherUrl).fail(function onConnectFail(err) {\r\n            if (err === "CANCEL") {\r\n                _openDeferred.reject(err);\r\n                return;\r\n            }\r\n\r\n            if (retryCount > 3) {\r\n                _setStatus(STATUS_ERROR);\r\n\r\n                var dialogPromise = Dialogs.showModalDialog(\r\n                    DefaultDialogs.DIALOG_ID_LIVE_DEVELOPMENT,\r\n                    Strings.LIVE_DEVELOPMENT_RELAUNCH_TITLE,\r\n                    Strings.LIVE_DEVELOPMENT_ERROR_MESSAGE,\r\n                    [\r\n                        {\r\n                            className: Dialogs.DIALOG_BTN_CLASS_LEFT,\r\n                            id:        Dialogs.DIALOG_BTN_CANCEL,\r\n                            text:      Strings.CANCEL\r\n                        },\r\n                        {\r\n                            className: Dialogs.DIALOG_BTN_CLASS_PRIMARY,\r\n                            id:        Dialogs.DIALOG_BTN_OK,\r\n                            text:      Strings.RELAUNCH_CHROME\r\n                        }\r\n                    ]\r\n                );\r\n\r\n                dialogPromise.done(function (id) {\r\n                    if (id === Dialogs.DIALOG_BTN_OK) {\r\n                        // User has chosen to reload Chrome, quit the running instance\r\n                        _setStatus(STATUS_INACTIVE);\r\n                        _close()\r\n                            .done(function () {\r\n                                browserStarted = false;\r\n                                // Continue to use _openDeferred\r\n                                open(true);\r\n                            })\r\n                            .fail(function (err) {\r\n                                // Report error?\r\n                                _setStatus(STATUS_ERROR);\r\n                                browserStarted = false;\r\n                                _openDeferred.reject("CLOSE_LIVE_BROWSER");\r\n                            });\r\n                    } else {\r\n                        _close()\r\n                            .done(function () {\r\n                                browserStarted = false;\r\n                                _openDeferred.reject("CANCEL");\r\n                            })\r\n                            .fail(function (err) {\r\n                                // Report error?\r\n                                _setStatus(STATUS_ERROR);\r\n                                browserStarted = false;\r\n                                _openDeferred.reject("CLOSE_LIVE_BROWSER");\r\n                            });\r\n                    }\r\n                });\r\n\r\n                return;\r\n            }\r\n            retryCount++;\r\n\r\n            if (!browserStarted && exports.status !== STATUS_ERROR) {\r\n                NativeApp.openLiveBrowser(\r\n                    launcherUrl,\r\n                    true        // enable remote debugging\r\n                )\r\n                    .done(function () {\r\n                        browserStarted = true;\r\n                    })\r\n                    .fail(function (err) {\r\n                        var message;\r\n\r\n                        _setStatus(STATUS_ERROR);\r\n                        if (err === FileSystemError.NOT_FOUND) {\r\n                            message = Strings.ERROR_CANT_FIND_CHROME;\r\n                        } else {\r\n                            message = StringUtils.format(Strings.ERROR_LAUNCHING_BROWSER, err);\r\n                        }\r\n                        \r\n                        // Append a message to direct users to the troubleshooting page.\r\n                        if (message) {\r\n                            message += " " + StringUtils.format(Strings.LIVE_DEVELOPMENT_TROUBLESHOOTING, brackets.config.troubleshoot_url);\r\n                        }\r\n\r\n                        Dialogs.showModalDialog(\r\n                            DefaultDialogs.DIALOG_ID_ERROR,\r\n                            Strings.ERROR_LAUNCHING_BROWSER_TITLE,\r\n                            message\r\n                        );\r\n\r\n                        _openDeferred.reject("OPEN_LIVE_BROWSER");\r\n                    });\r\n            }\r\n                \r\n            if (exports.status !== STATUS_ERROR) {\r\n                window.setTimeout(function retryConnect() {\r\n                    Inspector.connectToURL(launcherUrl).fail(onConnectFail);\r\n                }, 3000);\r\n            }\r\n        });\r\n    }\r\n\r\n    // helper function that actually does the launch once we are sure we have\r\n    // a doc and the server for that doc is up and running.\r\n    function _doLaunchAfterServerReady(initialDoc) {\r\n        // update status\r\n        _setStatus(STATUS_CONNECTING);\r\n        _createLiveDocumentForFrame(initialDoc);\r\n\r\n        // start listening for requests\r\n        _server.start();\r\n\r\n        // Install a one-time event handler when connected to the launcher page\r\n        $(Inspector).one("connect", _onConnect);\r\n        \r\n        // open browser to the interstitial page to prepare for loading agents\r\n        _openInterstitialPage();\r\n        \r\n        // Once all agents loaded (see _onInterstitialPageLoad()), begin Live Highlighting for preprocessor documents\r\n        _openDeferred.done(function () {\r\n            // Setup activeEditorChange event listener so that we can track cursor positions in\r\n            // CSS preprocessor files and perform live preview highlighting on all elements with\r\n            // the current selector in the preprocessor file.\r\n            $(EditorManager).on("activeEditorChange", onActiveEditorChange);\r\n\r\n            // Explicitly trigger onActiveEditorChange so that live preview highlighting\r\n            // can be set up for the preprocessor files.\r\n            onActiveEditorChange(null, EditorManager.getActiveEditor(), null);\r\n        });\r\n    }\r\n    \r\n    function _prepareServer(doc) {\r\n        var deferred = new $.Deferred(),\r\n            showBaseUrlPrompt = false;\r\n        \r\n        _server = LiveDevServerManager.getServer(doc.file.fullPath);\r\n\r\n        // Optionally prompt for a base URL if no server was found but the\r\n        // file is a known server file extension\r\n        showBaseUrlPrompt = !exports.config.experimental && !_server &&\r\n            FileUtils.isServerHtmlFileExt(doc.file.fullPath);\r\n\r\n        if (showBaseUrlPrompt) {\r\n            // Prompt for a base URL\r\n            PreferencesDialogs.showProjectPreferencesDialog("", Strings.LIVE_DEV_NEED_BASEURL_MESSAGE)\r\n                .done(function (id) {\r\n                    if (id === Dialogs.DIALOG_BTN_OK && ProjectManager.getBaseUrl()) {\r\n                        // If base url is specifed, then re-invoke _prepareServer() to continue\r\n                        _prepareServer(doc).then(deferred.resolve, deferred.reject);\r\n                    } else {\r\n                        deferred.reject();\r\n                    }\r\n                });\r\n        } else if (_server) {\r\n            // Startup the server\r\n            var readyPromise = _server.readyToServe();\r\n            if (!readyPromise) {\r\n                _showLiveDevServerNotReadyError();\r\n                deferred.reject();\r\n            } else {\r\n                readyPromise.then(deferred.resolve, function () {\r\n                    _showLiveDevServerNotReadyError();\r\n                    deferred.reject();\r\n                });\r\n            }\r\n        } else {\r\n            // No server found\r\n            deferred.reject();\r\n        }\r\n        \r\n        return deferred.promise();\r\n    }\r\n\r\n    /**\r\n     * Open the Connection and go live\r\n     *\r\n     * @param {!boolean} restart  true if relaunching and _openDeferred already exists\r\n     * @return {jQuery.Promise} Resolves once live preview is open\r\n     */\r\n    function open(restart) {\r\n        // If close() is still pending, wait for close to finish before opening\r\n        if (_isPromisePending(_closeDeferred)) {\r\n            return _closeDeferred.then(function () {\r\n                return open(restart);\r\n            });\r\n        }\r\n\r\n        if (!restart) {\r\n            // Return existing promise if it is still pending\r\n            if (_isPromisePending(_openDeferred)) {\r\n                return _openDeferred;\r\n            } else {\r\n                _openDeferred = new $.Deferred();\r\n                _openDeferred.always(function () {\r\n                    _openDeferred = null;\r\n                });\r\n            }\r\n        }\r\n        \r\n        // TODO: need to run _onFileChanged() after load if doc != currentDocument here? Maybe not, since activeEditorChange\r\n        // doesn\'t trigger it, while inline editors can still cause edits in doc other than currentDoc...\r\n        _getInitialDocFromCurrent().done(function (doc) {\r\n            var prepareServerPromise = (doc && _prepareServer(doc)) || new $.Deferred().reject(),\r\n                otherDocumentsInWorkingFiles;\r\n\r\n            if (doc && !doc._masterEditor) {\r\n                otherDocumentsInWorkingFiles = MainViewManager.getWorkingSet(MainViewManager.ALL_PANES).length;\r\n                MainViewManager.addToWorkingSet(MainViewManager.ACTIVE_PANE, doc.file);\r\n\r\n                if (!otherDocumentsInWorkingFiles) {\r\n                    MainViewManager._edit(MainViewManager.ACTIVE_PANE, doc);\r\n                }\r\n            }\r\n\r\n            // wait for server (StaticServer, Base URL or file:)\r\n            prepareServerPromise\r\n                .done(function () {\r\n                    _doLaunchAfterServerReady(doc);\r\n                })\r\n                .fail(function () {\r\n                    _showWrongDocError();\r\n                });\r\n        });\r\n\r\n        return _openDeferred.promise();\r\n    }\r\n    \r\n    /** Enable highlighting */\r\n    function showHighlight() {\r\n        var doc = getLiveDocForEditor(EditorManager.getActiveEditor());\r\n        \r\n        if (doc && doc.updateHighlight) {\r\n            doc.updateHighlight();\r\n        }\r\n    }\r\n\r\n    /** Hide any active highlighting */\r\n    function hideHighlight() {\r\n        if (Inspector.connected() && agents.highlight) {\r\n            agents.highlight.hide();\r\n        }\r\n    }\r\n    \r\n    /** Redraw highlights **/\r\n    function redrawHighlight() {\r\n        if (Inspector.connected() && agents.highlight) {\r\n            agents.highlight.redraw();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * MainViewManager.currentFileChange event handler. \r\n     */\r\n    function _onFileChanged() {\r\n        var doc = _getCurrentDocument();\r\n        \r\n        if (!doc || !Inspector.connected()) {\r\n            return;\r\n        }\r\n        \r\n        // close the current session and begin a new session if the current\r\n        // document changes to an HTML document that was not loaded yet\r\n        var docUrl = _server && _server.pathToUrl(doc.file.fullPath),\r\n            wasRequested = agents.network && agents.network.wasURLRequested(docUrl),\r\n            isViewable = exports.config.experimental || (_server && _server.canServe(doc.file.fullPath));\r\n        \r\n        if (!wasRequested && isViewable) {\r\n            // Update status\r\n            _setStatus(STATUS_CONNECTING);\r\n\r\n            // clear live doc and related docs\r\n            _closeDocuments();\r\n\r\n            // create new live doc\r\n            _createLiveDocumentForFrame(doc);\r\n\r\n            // Navigate to the new page within this site. Agents must handle\r\n            // frameNavigated event to clear any saved state.\r\n            Inspector.Page.navigate(docUrl).then(function () {\r\n                _setStatus(STATUS_ACTIVE);\r\n            }, function () {\r\n                _close(false, "closed_unknown_reason");\r\n            });\r\n        } else if (wasRequested) {\r\n            // Update highlight\r\n            showHighlight();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Triggered by a documentSaved event from DocumentManager.\r\n     * @param {$.Event} event\r\n     * @param {Document} doc\r\n     */\r\n    function _onDocumentSaved(event, doc) {\r\n        if (!Inspector.connected() || !_server) {\r\n            return;\r\n        }\r\n        \r\n        var absolutePath            = doc.file.fullPath,\r\n            liveDocument            = absolutePath && _server.get(absolutePath),\r\n            liveEditingEnabled      = liveDocument && liveDocument.isLiveEditingEnabled  && liveDocument.isLiveEditingEnabled();\r\n        \r\n        // Skip reload if the saved document has live editing enabled\r\n        if (liveEditingEnabled) {\r\n            return;\r\n        }\r\n        \r\n        var documentUrl     = _server.pathToUrl(absolutePath),\r\n            wasRequested    = agents.network && agents.network.wasURLRequested(documentUrl);\r\n        \r\n        if (wasRequested) {\r\n            reload();\r\n        }\r\n    }\r\n\r\n    /** Triggered by a change in dirty flag from the DocumentManager */\r\n    function _onDirtyFlagChange(event, doc) {\r\n        if (doc && Inspector.connected() &&\r\n                _server && agents.network && agents.network.wasURLRequested(_server.pathToUrl(doc.file.fullPath))) {\r\n            // Set status to out of sync if dirty. Otherwise, set it to active status.\r\n            _setStatus(_docIsOutOfSync(doc) ? STATUS_OUT_OF_SYNC : STATUS_ACTIVE);\r\n        }\r\n    }\r\n\r\n    function getCurrentProjectServerConfig() {\r\n        return {\r\n            baseUrl: ProjectManager.getBaseUrl(),\r\n            pathResolver: ProjectManager.makeProjectRelativeIfPossible,\r\n            root: ProjectManager.getProjectRoot().fullPath\r\n        };\r\n    }\r\n    \r\n    function _createUserServer() {\r\n        return new UserServer(getCurrentProjectServerConfig());\r\n    }\r\n    \r\n    function _createFileServer() {\r\n        return new FileServer(getCurrentProjectServerConfig());\r\n    }\r\n\r\n    /** Initialize the LiveDevelopment Session */\r\n    function init(theConfig) {\r\n        exports.config = theConfig;\r\n        \r\n        $(Inspector).on("error", _onError);\r\n        $(Inspector.Inspector).on("detached", _onDetached);\r\n\r\n        // Only listen for styleSheetAdded\r\n        // We may get interim added/removed events when pushing incremental updates\r\n        $(CSSAgent).on("styleSheetAdded.livedev", _styleSheetAdded);\r\n        \r\n        $(MainViewManager)\r\n            .on("currentFileChange", _onFileChanged);\r\n        $(DocumentManager)\r\n            .on("documentSaved", _onDocumentSaved)\r\n            .on("dirtyFlagChange", _onDirtyFlagChange);\r\n        $(ProjectManager)\r\n            .on("beforeProjectClose beforeAppClose", close);\r\n        \r\n        // Register user defined server provider\r\n        LiveDevServerManager.registerServer({ create: _createUserServer }, 99);\r\n        LiveDevServerManager.registerServer({ create: _createFileServer }, 0);\r\n\r\n        // Initialize exports.status\r\n        _setStatus(STATUS_INACTIVE);\r\n    }\r\n\r\n    function _getServer() {\r\n        return _server;\r\n    }\r\n\r\n    function getServerBaseUrl() {\r\n        return _server && _server.getBaseUrl();\r\n    }\r\n\r\n\r\n\r\n    // For unit testing\r\n    exports.launcherUrl               = launcherUrl;\r\n    exports._getServer                = _getServer;\r\n    exports._getInitialDocFromCurrent = _getInitialDocFromCurrent;\r\n\r\n    // Export public functions\r\n    exports.agents              = agents;\r\n    exports.open                = open;\r\n    exports.close               = close;\r\n    exports.reconnect           = reconnect;\r\n    exports.reload              = reload;\r\n    exports.enableAgent         = enableAgent;\r\n    exports.disableAgent        = disableAgent;\r\n    exports.getLiveDocForPath   = getLiveDocForPath;\r\n    exports.showHighlight       = showHighlight;\r\n    exports.hideHighlight       = hideHighlight;\r\n    exports.redrawHighlight     = redrawHighlight;\r\n    exports.init                = init;\r\n    exports.getCurrentProjectServerConfig = getCurrentProjectServerConfig;\r\n    exports.getServerBaseUrl    = getServerBaseUrl;\r\n});\r\n\n//# sourceURL=/LiveDevelopment/LiveDevelopment.js'),eval("define('text!LiveDevelopment/main.less',[],function () { return '/*\\r\\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\\r\\n *  \\r\\n * Permission is hereby granted, free of charge, to any person obtaining a\\r\\n * copy of this software and associated documentation files (the \"Software\"), \\r\\n * to deal in the Software without restriction, including without limitation \\r\\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \\r\\n * and/or sell copies of the Software, and to permit persons to whom the \\r\\n * Software is furnished to do so, subject to the following conditions:\\r\\n *  \\r\\n * The above copyright notice and this permission notice shall be included in\\r\\n * all copies or substantial portions of the Software.\\r\\n *  \\r\\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \\r\\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \\r\\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \\r\\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \\r\\n * DEALINGS IN THE SOFTWARE.\\r\\n * \\r\\n */\\r\\n\\r\\n\\r\\n.CodeMirror {\\r\\n    .highlight {\\r\\n        background: #ecc;\\r\\n    }\\r\\n    .flash {\\r\\n       -webkit-animation: flash 1s;\\r\\n    }\\r\\n}\\r\\n  \\r\\n@-webkit-keyframes flash {\\r\\n    from {\\r\\n        background: #ecc;\\r\\n    }\\r\\n    to {\\r\\n        background: inherit;\\r\\n    }\\r\\n}';});\n\n//# sourceURL=/text!LiveDevelopment/main.less"),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, forin: true, maxerr: 50, regexp: true */\r\n/*global brackets, define, $, less, window */\r\n\r\n/**\r\n * main integrates LiveDevelopment into Brackets\r\n *\r\n * This module creates two menu items:\r\n *\r\n *  "Go Live": open or close a Live Development session and visualize the status\r\n *  "Highlight": toggle source highlighting\r\n */\r\ndefine(\'LiveDevelopment/main\',[\'require\',\'exports\',\'module\',\'document/DocumentManager\',\'command/Commands\',\'utils/AppInit\',\'LiveDevelopment/LiveDevelopment\',\'LiveDevelopment/Inspector/Inspector\',\'command/CommandManager\',\'preferences/PreferencesManager\',\'widgets/Dialogs\',\'widgets/DefaultDialogs\',\'utils/UrlParams\',\'strings\',\'utils/ExtensionUtils\',\'utils/StringUtils\',\'text!LiveDevelopment/main.less\'],function main(require, exports, module) {\r\n    "use strict";\r\n\r\n    var DocumentManager     = require("document/DocumentManager"),\r\n        Commands            = require("command/Commands"),\r\n        AppInit             = require("utils/AppInit"),\r\n        LiveDevelopment     = require("LiveDevelopment/LiveDevelopment"),\r\n        Inspector           = require("LiveDevelopment/Inspector/Inspector"),\r\n        CommandManager      = require("command/CommandManager"),\r\n        PreferencesManager  = require("preferences/PreferencesManager"),\r\n        Dialogs             = require("widgets/Dialogs"),\r\n        DefaultDialogs      = require("widgets/DefaultDialogs"),\r\n        UrlParams           = require("utils/UrlParams").UrlParams,\r\n        Strings             = require("strings"),\r\n        ExtensionUtils      = require("utils/ExtensionUtils"),\r\n        StringUtils         = require("utils/StringUtils");\r\n\r\n    var params = new UrlParams();\r\n    var config = {\r\n        experimental: false, // enable experimental features\r\n        debug: true, // enable debug output and helpers\r\n        autoconnect: false, // go live automatically after startup?\r\n        highlight: true, // enable highlighting?\r\n        highlightConfig: { // the highlight configuration for the Inspector\r\n            borderColor:  {r: 255, g: 229, b: 153, a: 0.66},\r\n            contentColor: {r: 111, g: 168, b: 220, a: 0.55},\r\n            marginColor:  {r: 246, g: 178, b: 107, a: 0.66},\r\n            paddingColor: {r: 147, g: 196, b: 125, a: 0.66},\r\n            showInfo: true\r\n        }\r\n    };\r\n    var _checkMark = "✓"; // Check mark character\r\n    // Status labels/styles are ordered: error, not connected, progress1, progress2, connected.\r\n    var _statusTooltip = [\r\n        Strings.LIVE_DEV_STATUS_TIP_NOT_CONNECTED,\r\n        Strings.LIVE_DEV_STATUS_TIP_NOT_CONNECTED,\r\n        Strings.LIVE_DEV_STATUS_TIP_PROGRESS1,\r\n        Strings.LIVE_DEV_STATUS_TIP_PROGRESS2,\r\n        Strings.LIVE_DEV_STATUS_TIP_CONNECTED,\r\n        Strings.LIVE_DEV_STATUS_TIP_OUT_OF_SYNC,\r\n        Strings.LIVE_DEV_STATUS_TIP_SYNC_ERROR\r\n    ];\r\n\r\n    var _statusStyle = ["warning", "", "info", "info", "success", "out-of-sync", "sync-error"];  // Status indicator\'s CSS class\r\n    var _allStatusStyles = _statusStyle.join(" ");\r\n\r\n    var _$btnGoLive; // reference to the GoLive button\r\n    var _$btnHighlight; // reference to the HighlightButton\r\n\r\n    /** Load Live Development LESS Style */\r\n    function _loadStyles() {\r\n        var lessText    = require("text!LiveDevelopment/main.less"),\r\n            parser      = new less.Parser();\r\n        \r\n        parser.parse(lessText, function onParse(err, tree) {\r\n            console.assert(!err, err);\r\n            ExtensionUtils.addEmbeddedStyleSheet(tree.toCSS());\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Change the appearance of a button. Omit text to remove any extra text; omit style to return to default styling;\r\n     * omit tooltip to leave tooltip unchanged.\r\n     */\r\n    function _setLabel($btn, text, style, tooltip) {\r\n        // Clear text/styles from previous status\r\n        $("span", $btn).remove();\r\n        $btn.removeClass(_allStatusStyles);\r\n\r\n        // Set text/styles for new status\r\n        if (text && text.length > 0) {\r\n            $("<span class=\\"label\\">")\r\n                .addClass(style)\r\n                .text(text)\r\n                .appendTo($btn);\r\n        } else {\r\n            $btn.addClass(style);\r\n        }\r\n\r\n        if (tooltip) {\r\n            $btn.attr("title", tooltip);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Toggles LiveDevelopment and synchronizes the state of UI elements that reports LiveDevelopment status\r\n     *\r\n     * Stop Live Dev when in an active state (ACTIVE, OUT_OF_SYNC, SYNC_ERROR).\r\n     * Start Live Dev when in an inactive state (ERROR, INACTIVE).\r\n     * Do nothing when in a connecting state (CONNECTING, LOADING_AGENTS).\r\n     */\r\n    function _handleGoLiveCommand() {\r\n        if (LiveDevelopment.status >= LiveDevelopment.STATUS_ACTIVE) {\r\n            LiveDevelopment.close();\r\n        } else if (LiveDevelopment.status <= LiveDevelopment.STATUS_INACTIVE) {\r\n            if (!params.get("skipLiveDevelopmentInfo") && !PreferencesManager.getViewState("livedev.afterFirstLaunch")) {\r\n                PreferencesManager.setViewState("livedev.afterFirstLaunch", "true");\r\n                Dialogs.showModalDialog(\r\n                    DefaultDialogs.DIALOG_ID_INFO,\r\n                    Strings.LIVE_DEVELOPMENT_INFO_TITLE,\r\n                    Strings.LIVE_DEVELOPMENT_INFO_MESSAGE\r\n                ).done(function (id) {\r\n                    LiveDevelopment.open();\r\n                });\r\n            } else {\r\n                LiveDevelopment.open();\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Called on status change */\r\n    function _showStatusChangeReason(reason) {\r\n        // Destroy the previous twipsy (options are not updated otherwise)\r\n        _$btnGoLive.twipsy("hide").removeData("twipsy");\r\n        \r\n        // If there was no reason or the action was an explicit request by the user, don\'t show a twipsy\r\n        if (!reason || reason === "explicit_close") {\r\n            return;\r\n        }\r\n\r\n        // Translate the reason\r\n        var translatedReason = Strings["LIVE_DEV_" + reason.toUpperCase()];\r\n        if (!translatedReason) {\r\n            translatedReason = StringUtils.format(Strings.LIVE_DEV_CLOSED_UNKNOWN_REASON, reason);\r\n        }\r\n        \r\n        // Configure the twipsy\r\n        var options = {\r\n            placement: "left",\r\n            trigger: "manual",\r\n            autoHideDelay: 5000,\r\n            title: function () {\r\n                return translatedReason;\r\n            }\r\n        };\r\n\r\n        // Show the twipsy with the explanation\r\n        _$btnGoLive.twipsy(options).twipsy("show");\r\n    }\r\n    \r\n    /** Create the menu item "Go Live" */\r\n    function _setupGoLiveButton() {\r\n        _$btnGoLive = $("#toolbar-go-live");\r\n        _$btnGoLive.click(function onGoLive() {\r\n            _handleGoLiveCommand();\r\n        });\r\n        $(LiveDevelopment).on("statusChange", function statusChange(event, status, reason) {\r\n            // status starts at -1 (error), so add one when looking up name and style\r\n            // See the comments at the top of LiveDevelopment.js for details on the\r\n            // various status codes.\r\n            _setLabel(_$btnGoLive, null, _statusStyle[status + 1], _statusTooltip[status + 1]);\r\n            _showStatusChangeReason(reason);\r\n            if (config.autoconnect) {\r\n                window.sessionStorage.setItem("live.enabled", status === 3);\r\n            }\r\n        });\r\n\r\n        // Initialize tooltip for \'not connected\' state\r\n        _setLabel(_$btnGoLive, null, _statusStyle[1], _statusTooltip[1]);\r\n    }\r\n    \r\n    /** Maintains state of the Live Preview menu item */\r\n    function _setupGoLiveMenu() {\r\n        $(LiveDevelopment).on("statusChange", function statusChange(event, status) {\r\n            // Update the checkmark next to \'Live Preview\' menu item\r\n            // Add checkmark when status is STATUS_ACTIVE; otherwise remove it\r\n            CommandManager.get(Commands.FILE_LIVE_FILE_PREVIEW).setChecked(status === LiveDevelopment.STATUS_ACTIVE);\r\n            CommandManager.get(Commands.FILE_LIVE_HIGHLIGHT).setEnabled(status === LiveDevelopment.STATUS_ACTIVE);\r\n        });\r\n    }\r\n\r\n    function _updateHighlightCheckmark() {\r\n        CommandManager.get(Commands.FILE_LIVE_HIGHLIGHT).setChecked(config.highlight);\r\n    }\r\n    \r\n    function _handlePreviewHighlightCommand() {\r\n        config.highlight = !config.highlight;\r\n        _updateHighlightCheckmark();\r\n        if (config.highlight) {\r\n            LiveDevelopment.showHighlight();\r\n        } else {\r\n            LiveDevelopment.hideHighlight();\r\n        }\r\n        PreferencesManager.setViewState("livedev.highlight", config.highlight);\r\n    }\r\n    \r\n    /** Setup window references to useful LiveDevelopment modules */\r\n    function _setupDebugHelpers() {\r\n        window.ld = LiveDevelopment;\r\n        window.i = Inspector;\r\n        window.report = function report(params) { window.params = params; console.info(params); };\r\n    }\r\n\r\n    /** force reload the live preview */\r\n    function _handleReloadLivePreviewCommand() {\r\n        if (LiveDevelopment.status >= LiveDevelopment.STATUS_ACTIVE) {\r\n            LiveDevelopment.reload();\r\n        }\r\n    }\r\n\r\n    /** Initialize LiveDevelopment */\r\n    AppInit.appReady(function () {\r\n        params.parse();\r\n\r\n        Inspector.init(config);\r\n        LiveDevelopment.init(config);\r\n        _loadStyles();\r\n        _setupGoLiveButton();\r\n        _setupGoLiveMenu();\r\n\r\n        _updateHighlightCheckmark();\r\n        \r\n        if (config.debug) {\r\n            _setupDebugHelpers();\r\n        }\r\n\r\n        // trigger autoconnect\r\n        if (config.autoconnect &&\r\n                window.sessionStorage.getItem("live.enabled") === "true" &&\r\n                DocumentManager.getCurrentDocument()) {\r\n            _handleGoLiveCommand();\r\n        }\r\n        \r\n        // Redraw highlights when window gets focus. This ensures that the highlights\r\n        // will be in sync with any DOM changes that may have occurred.\r\n        $(window).focus(function () {\r\n            if (Inspector.connected() && config.highlight) {\r\n                LiveDevelopment.redrawHighlight();\r\n            }\r\n        });\r\n    });\r\n    \r\n    // init prefs\r\n    PreferencesManager.stateManager.definePreference("livedev.highlight", "boolean", true)\r\n        .on("change", function () {\r\n            config.highlight = PreferencesManager.getViewState("livedev.highlight");\r\n            _updateHighlightCheckmark();\r\n        });\r\n    \r\n    PreferencesManager.convertPreferences(module, {\r\n        "highlight": "user livedev.highlight",\r\n        "afterFirstLaunch": "user livedev.afterFirstLaunch"\r\n    }, true);\r\n    \r\n    config.highlight = PreferencesManager.getViewState("livedev.highlight");\r\n   \r\n    // init commands\r\n    CommandManager.register(Strings.CMD_LIVE_FILE_PREVIEW,  Commands.FILE_LIVE_FILE_PREVIEW, _handleGoLiveCommand);\r\n    CommandManager.register(Strings.CMD_LIVE_HIGHLIGHT, Commands.FILE_LIVE_HIGHLIGHT, _handlePreviewHighlightCommand);\r\n    CommandManager.register(Strings.CMD_RELOAD_LIVE_PREVIEW, Commands.CMD_RELOAD_LIVE_PREVIEW, _handleReloadLivePreviewCommand);\r\n    CommandManager.get(Commands.FILE_LIVE_HIGHLIGHT).setEnabled(false);\r\n\r\n    // Export public functions\r\n});\r\n\n//# sourceURL=/LiveDevelopment/main.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\ndefine(\'utils/NodeDomain\',[\'require\',\'exports\',\'module\',\'utils/NodeConnection\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var NodeConnection = require("utils/NodeConnection");\r\n    \r\n    // Used to remove all listeners at once when the connection drops\r\n    var EVENT_NAMESPACE = ".NodeDomainEvent";\r\n    \r\n    /**\r\n     * Provides a simple abstraction for executing the commands of a single\r\n     * domain loaded via a NodeConnection. Automatically handles connection\r\n     * management and domain loading, and exposes each command in the domain as\r\n     * a promise-returning method that can safely be called regardless of the\r\n     * current status of the underlying connection. Example usage:\r\n     * \r\n     *     var myDomain = new NodeDomain("someDomain", "/path/to/SomeDomainDef.js"),\r\n     *         $result = myDomain.exec("someCommand", arg1, arg2);\r\n     *     \r\n     *     $result.done(function (value) {\r\n     *         // the command succeeded!\r\n     *     });\r\n     *     \r\n     *     $result.fail(function (err) {\r\n     *         // the command failed; act accordingly!\r\n     *     });\r\n     * \r\n     * To handle domain events, just listen for the event on the domain:\r\n     * \r\n     *     $(myDomain).on("someEvent", someHandler);\r\n     * \r\n     * @constructor\r\n     * @param {string} domainName Name of the registered Node Domain\r\n     * @param {string} domainPath Full path of the JavaScript Node domain specification\r\n     */\r\n    function NodeDomain(domainName, domainPath) {\r\n        var connection = new NodeConnection();\r\n        \r\n        this.connection = connection;\r\n        this._domainName = domainName;\r\n        this._domainPath = domainPath;\r\n        this._domainLoaded = false;\r\n        this._load = this._load.bind(this);\r\n        this._connectionPromise = connection.connect(true)\r\n            .then(this._load);\r\n        \r\n        $(connection).on("close", function (event, promise) {\r\n            $(this.connection).off(EVENT_NAMESPACE);\r\n            this._domainLoaded = false;\r\n            this._connectionPromise = promise.then(this._load);\r\n        }.bind(this));\r\n    }\r\n    \r\n    /** \r\n     * The underlying Node connection object for this domain.\r\n     * \r\n     * @type {NodeConnection} \r\n     */\r\n    NodeDomain.prototype.connection = null;\r\n\r\n    /**\r\n     * A promise that is resolved once the NodeConnection is connected and the\r\n     * domain has been loaded.\r\n     * \r\n     * @type {?jQuery.Promise}\r\n     * @private\r\n     */\r\n    NodeDomain.prototype._connectionPromise = null;\r\n    \r\n    /**\r\n     * The name of this domain.\r\n     * \r\n     * @type {string}\r\n     * @private\r\n     */\r\n    NodeDomain.prototype._domainName = null;\r\n    \r\n    /**\r\n     * The path at which the Node definition of this domain resides.\r\n     * \r\n     * @type {string}\r\n     * @private\r\n     */\r\n    NodeDomain.prototype._domainPath = null;\r\n    \r\n    /**\r\n     * Whether or not the domain has been successfully loaded.\r\n     * \r\n     * @type {boolean}\r\n     * @private\r\n     */\r\n    NodeDomain.prototype._domainLoaded = false;\r\n    \r\n    /**\r\n     * Loads the domain via the underlying connection object and exposes the\r\n     * domain\'s commands as methods on this object. Assumes the underlying\r\n     * connection has already been opened.\r\n     * \r\n     * @return {jQuery.Promise} Resolves once the domain is been loaded.\r\n     * @private\r\n     */\r\n    NodeDomain.prototype._load = function () {\r\n        var connection = this.connection;\r\n        return connection.loadDomains(this._domainPath, true)\r\n            .done(function () {\r\n                this._domainLoaded = true;\r\n                this._connectionPromise = null;\r\n                \r\n                var eventNames = Object.keys(connection.domainEvents[this._domainName]);\r\n                eventNames.forEach(function (domainEvent) {\r\n                    var connectionEvent = this._domainName + ":" + domainEvent + EVENT_NAMESPACE;\r\n                    \r\n                    $(connection).on(connectionEvent, function () {\r\n                        var params = Array.prototype.slice.call(arguments, 1);\r\n                        $(this).triggerHandler(domainEvent, params);\r\n                    }.bind(this));\r\n                }, this);\r\n            }.bind(this))\r\n            .fail(function (err) {\r\n                console.error("[NodeDomain] Error loading domain \\"" + this._domainName + "\\": " + err);\r\n            }.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * Synchronously determine whether the domain is ready; i.e., whether the\r\n     * connection is open and the domain is loaded.\r\n     * \r\n     * @return {boolean} Whether or not the domain is currently ready.\r\n     */\r\n    NodeDomain.prototype.ready = function () {\r\n        return this._domainLoaded && this.connection.connected();\r\n    };\r\n    \r\n    /**\r\n     * Get a promise that resolves when the connection is open and the domain\r\n     * is loaded.\r\n     *\r\n     * @return {jQuery.Promise}\r\n     */\r\n    NodeDomain.prototype.promise = function () {\r\n        if (this._connectionPromise) {\r\n            return this._connectionPromise;\r\n        } else {\r\n            var deferred = new $.Deferred();\r\n            \r\n            if (this.ready()) {\r\n                deferred.resolve();\r\n            } else {\r\n                deferred.reject();\r\n            }\r\n            \r\n            return deferred.promise();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Applies the named command from the domain to a list of parameters, which\r\n     * are passed as extra arguments to this method. If the connection is open\r\n     * and the domain is loaded, the function is applied immediately. Otherwise\r\n     * the function is applied as soon as the connection has been opened and the\r\n     * domain has finished loading.\r\n     * \r\n     * @param {string} name The name of the domain command to execute\r\n     * @return {jQuery.Promise} Resolves with the result of the command\r\n     */\r\n    NodeDomain.prototype.exec = function (name) {\r\n        var connection = this.connection,\r\n            params = Array.prototype.slice.call(arguments, 1),\r\n            execConnected = function () {\r\n                var domain  = connection.domains[this._domainName],\r\n                    fn      = domain && domain[name],\r\n                    execResult;\r\n        \r\n                if (fn) {\r\n                    execResult = fn.apply(domain, params);\r\n                } else {\r\n                    execResult = new $.Deferred().reject().promise();\r\n                }\r\n                return execResult;\r\n            }.bind(this);\r\n        \r\n        var result;\r\n        if (this.ready()) {\r\n            result = execConnected();\r\n        } else if (this._connectionPromise) {\r\n            result = this._connectionPromise.then(execConnected);\r\n        } else {\r\n            result = new $.Deferred.reject().promise();\r\n        }\r\n        return result;\r\n    };\r\n        \r\n    module.exports = NodeDomain;\r\n});\r\n\n//# sourceURL=/utils/NodeDomain.js'),eval("/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the \"Software\"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\n/**\r\n *  Utilities functions related to color matching\r\n *\r\n */\r\ndefine('utils/ColorUtils',['require','exports','module'],function (require, exports, module) {\r\n    \"use strict\";\r\n    \r\n    /**\r\n     * Regular expression that matches reasonably well-formed colors in hex format (3 or 6 digits),\r\n     * rgb()/rgba() function format, hsl()/hsla() function format,\r\n     * or color name format according CSS Color Module Level 3 (http://www.w3.org/TR/css3-color/).\r\n     * @const @type {RegExp}\r\n     */\r\n    var COLOR_REGEX = /#[a-f0-9]{6}\\b|#[a-f0-9]{3}\\b|\\brgb\\(\\s*(?:[0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*(?:[0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*(?:[0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\b\\s*\\)|\\brgb\\(\\s*(?:[0-9]{1,2}%|100%)\\s*,\\s*(?:[0-9]{1,2}%|100%)\\s*,\\s*(?:[0-9]{1,2}%|100%)\\s*\\)|\\brgba\\(\\s*(?:[0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*(?:[0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*(?:[0-9]{1,2}|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\b\\s*,\\s*(?:1|1\\.0|0|0?\\.[0-9]{1,3})\\s*\\)|\\brgba\\(\\s*(?:[0-9]{1,2}%|100%)\\s*,\\s*(?:[0-9]{1,2}%|100%)\\s*,\\s*(?:[0-9]{1,2}%|100%)\\s*,\\s*(?:1|1\\.0|0|0?\\.[0-9]{1,3})\\s*\\)|\\bhsl\\(\\s*(?:[0-9]{1,3})\\b\\s*,\\s*(?:[0-9]{1,2}|100)\\b%\\s*,\\s*(?:[0-9]{1,2}|100)\\b%\\s*\\)|\\bhsla\\(\\s*(?:[0-9]{1,3})\\b\\s*,\\s*(?:[0-9]{1,2}|100)\\b%\\s*,\\s*(?:[0-9]{1,2}|100)\\b%\\s*,\\s*(?:1|1\\.0|0|0?\\.[0-9]{1,3})\\s*\\)|\\baliceblue\\b|\\bantiquewhite\\b|\\baqua\\b|\\baquamarine\\b|\\bazure\\b|\\bbeige\\b|\\bbisque\\b|\\bblack\\b|\\bblanchedalmond\\b|\\bblue\\b|\\bblueviolet\\b|\\bbrown\\b|\\bburlywood\\b|\\bcadetblue\\b|\\bchartreuse\\b|\\bchocolate\\b|\\bcoral\\b|\\bcornflowerblue\\b|\\bcornsilk\\b|\\bcrimson\\b|\\bcyan\\b|\\bdarkblue\\b|\\bdarkcyan\\b|\\bdarkgoldenrod\\b|\\bdarkgray\\b|\\bdarkgreen\\b|\\bdarkgrey\\b|\\bdarkkhaki\\b|\\bdarkmagenta\\b|\\bdarkolivegreen\\b|\\bdarkorange\\b|\\bdarkorchid\\b|\\bdarkred\\b|\\bdarksalmon\\b|\\bdarkseagreen\\b|\\bdarkslateblue\\b|\\bdarkslategray\\b|\\bdarkslategrey\\b|\\bdarkturquoise\\b|\\bdarkviolet\\b|\\bdeeppink\\b|\\bdeepskyblue\\b|\\bdimgray\\b|\\bdimgrey\\b|\\bdodgerblue\\b|\\bfirebrick\\b|\\bfloralwhite\\b|\\bforestgreen\\b|\\bfuchsia\\b|\\bgainsboro\\b|\\bghostwhite\\b|\\bgold\\b|\\bgoldenrod\\b|\\bgray\\b|\\bgreen\\b|\\bgreenyellow\\b|\\bgrey\\b|\\bhoneydew\\b|\\bhotpink\\b|\\bindianred\\b|\\bindigo\\b|\\bivory\\b|\\bkhaki\\b|\\blavender\\b|\\blavenderblush\\b|\\blawngreen\\b|\\blemonchiffon\\b|\\blightblue\\b|\\blightcoral\\b|\\blightcyan\\b|\\blightgoldenrodyellow\\b|\\blightgray\\b|\\blightgreen\\b|\\blightgrey\\b|\\blightpink\\b|\\blightsalmon\\b|\\blightseagreen\\b|\\blightskyblue\\b|\\blightslategray\\b|\\blightslategrey\\b|\\blightsteelblue\\b|\\blightyellow\\b|\\blime\\b|\\blimegreen\\b|\\blinen\\b|\\bmagenta\\b|\\bmaroon\\b|\\bmediumaquamarine\\b|\\bmediumblue\\b|\\bmediumorchid\\b|\\bmediumpurple\\b|\\bmediumseagreen\\b|\\bmediumslateblue\\b|\\bmediumspringgreen\\b|\\bmediumturquoise\\b|\\bmediumvioletred\\b|\\bmidnightblue\\b|\\bmintcream\\b|\\bmistyrose\\b|\\bmoccasin\\b|\\bnavajowhite\\b|\\bnavy\\b|\\boldlace\\b|\\bolive\\b|\\bolivedrab\\b|\\borange\\b|\\borangered\\b|\\borchid\\b|\\bpalegoldenrod\\b|\\bpalegreen\\b|\\bpaleturquoise\\b|\\bpalevioletred\\b|\\bpapayawhip\\b|\\bpeachpuff\\b|\\bperu\\b|\\bpink\\b|\\bplum\\b|\\bpowderblue\\b|\\bpurple\\b|\\bred\\b|\\brosybrown\\b|\\broyalblue\\b|\\bsaddlebrown\\b|\\bsalmon\\b|\\bsandybrown\\b|\\bseagreen\\b|\\bseashell\\b|\\bsienna\\b|\\bsilver\\b|\\bskyblue\\b|\\bslateblue\\b|\\bslategray\\b|\\bslategrey\\b|\\bsnow\\b|\\bspringgreen\\b|\\bsteelblue\\b|\\btan\\b|\\bteal\\b|\\bthistle\\b|\\btomato\\b|\\bturquoise\\b|\\bviolet\\b|\\bwheat\\b|\\bwhite\\b|\\bwhitesmoke\\b|\\byellow\\b|\\byellowgreen\\b/gi;\r\n\r\n    // Define public API\r\n    exports.COLOR_REGEX = COLOR_REGEX;\r\n});\r\n\n//# sourceURL=/utils/ColorUtils.js"),eval('define(\'text!htmlContent/problems-panel.html\',[],function () { return \'<div id="problems-panel" class="bottom-panel vert-resizable top-resizer">\\r\\n    <div class="toolbar simple-toolbar-layout">\\r\\n        <div class="title"><!-- filled in programmatically --></div>\\r\\n        <a href="#" class="close">&times;</a>\\r\\n    </div>\\r\\n    <div class="table-container resizable-content"></div>\\r\\n</div>\';});\n\n//# sourceURL=/text!htmlContent/problems-panel.html'),eval('define(\'text!htmlContent/problems-panel-table.html\',[],function () { return \'<table class="bottom-panel-table table table-striped table-condensed row-highlight">\\r\\n    <tbody>\\r\\n        {{#reportList}}\\r\\n        <tr class="inspector-section">\\r\\n            <td colspan="3"><span class="disclosure-triangle expanded"></span>{{providerName}} ({{results.length}})</td>\\r\\n        </tr>\\r\\n        {{#results}}\\r\\n        <tr>\\r\\n            <td class="line-number" data-character="{{pos.ch}}">{{friendlyLine}}</td>\\r\\n            <td class="line-text">{{message}}</td>\\r\\n            <td class="line-snippet">{{codeSnippet}}</td>\\r\\n        </tr>\\r\\n        {{/results}}\\r\\n        {{/reportList}}\\r\\n    </tbody>\\r\\n</table>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/problems-panel-table.html'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4 */\r\n/*global define, $, Mustache, brackets */\r\n\r\n/**\r\n * Manages linters and other code inspections on a per-language basis. Provides a UI and status indicator for\r\n * the resulting errors/warnings.\r\n *\r\n * Currently, inspection providers are only invoked on the current file and only when it is opened, switched to,\r\n * or saved. But in the future, inspectors may be invoked as part of a global scan, at intervals while typing, etc.\r\n * Currently, results are only displayed in a bottom panel list and in a status bar icon. But in the future,\r\n * results may also be displayed inline in the editor (as gutter markers, squiggly underlines, etc.).\r\n * In the future, support may also be added for error/warning providers that cannot process a single file at a time\r\n * (e.g. a full-project compiler).\r\n */\r\ndefine(\'language/CodeInspection\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'command/Commands\',\'view/WorkspaceManager\',\'command/CommandManager\',\'document/DocumentManager\',\'editor/EditorManager\',\'view/MainViewManager\',\'file/FileUtils\',\'language/LanguageManager\',\'preferences/PreferencesManager\',\'utils/PerfUtils\',\'strings\',\'utils/StringUtils\',\'utils/AppInit\',\'utils/Resizer\',\'widgets/StatusBar\',\'utils/Async\',\'text!htmlContent/problems-panel.html\',\'text!htmlContent/problems-panel-table.html\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var _ = require("thirdparty/lodash");\r\n\r\n    // Load dependent modules\r\n    var Commands                = require("command/Commands"),\r\n        WorkspaceManager        = require("view/WorkspaceManager"),\r\n        CommandManager          = require("command/CommandManager"),\r\n        DocumentManager         = require("document/DocumentManager"),\r\n        EditorManager           = require("editor/EditorManager"),\r\n        MainViewManager         = require("view/MainViewManager"),\r\n        FileUtils               = require("file/FileUtils"),\r\n        LanguageManager         = require("language/LanguageManager"),\r\n        PreferencesManager      = require("preferences/PreferencesManager"),\r\n        PerfUtils               = require("utils/PerfUtils"),\r\n        Strings                 = require("strings"),\r\n        StringUtils             = require("utils/StringUtils"),\r\n        AppInit                 = require("utils/AppInit"),\r\n        Resizer                 = require("utils/Resizer"),\r\n        StatusBar               = require("widgets/StatusBar"),\r\n        Async                   = require("utils/Async"),\r\n        PanelTemplate           = require("text!htmlContent/problems-panel.html"),\r\n        ResultsTemplate         = require("text!htmlContent/problems-panel-table.html");\r\n    \r\n    var INDICATOR_ID = "status-inspection";\r\n\r\n    /** Values for problem\'s \'type\' property */\r\n    var Type = {\r\n        /** Unambiguous error, such as a syntax error */\r\n        ERROR: "problem_type_error",\r\n        /** Maintainability issue, probable error / bad smell, etc. */\r\n        WARNING: "problem_type_warning",\r\n        /** Inspector unable to continue, code too complex for static analysis, etc. Not counted in error/warning tally. */\r\n        META: "problem_type_meta"\r\n    };\r\n\r\n    /**\r\n     * Constants for the preferences defined in this file.\r\n     */\r\n    var PREF_ENABLED = "enabled",\r\n        PREF_COLLAPSED = "collapsed",\r\n        PREF_ASYNC_TIMEOUT = "asyncTimeout";\r\n    \r\n    var prefs = PreferencesManager.getExtensionPrefs("linting");\r\n    \r\n    PreferencesManager.convertPreferences(module, {\r\n        "enabled": "user linting.enabled",\r\n        "collapsed": "user linting.collapsed"\r\n    });\r\n    \r\n    /**\r\n     * When disabled, the errors panel is closed and the status bar icon is grayed out.\r\n     * Takes precedence over _collapsed.\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    var _enabled = false;\r\n\r\n    /**\r\n     * When collapsed, the errors panel is closed but the status bar icon is kept up to date.\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    var _collapsed = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {$.Element}\r\n     */\r\n    var $problemsPanel;\r\n\r\n    /**\r\n     * @private\r\n     * @type {$.Element}\r\n     */\r\n    var $problemsPanelTable;\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    var _gotoEnabled = false;\r\n\r\n    /**\r\n     * @private\r\n     * @type {{languageId:string, Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):Object}>}}\r\n     */\r\n    var _providers = {};\r\n\r\n    /**\r\n     * @private\r\n     * @type {boolean}\r\n     */\r\n    var _hasErrors;\r\n    \r\n    /**\r\n     * Promise of the returned by the last call to inspectFile or null if linting is disabled. Used to prevent any stale promises\r\n     * to cause updates of the UI.\r\n     *\r\n     * @private\r\n     * @type {$.Promise}\r\n     */\r\n    var _currentPromise = null;\r\n\r\n    /**\r\n     * Enable or disable the "Go to First Error" command\r\n     * @param {boolean} gotoEnabled Whether it is enabled.\r\n     */\r\n    function setGotoEnabled(gotoEnabled) {\r\n        CommandManager.get(Commands.NAVIGATE_GOTO_FIRST_PROBLEM).setEnabled(gotoEnabled);\r\n        _gotoEnabled = gotoEnabled;\r\n    }\r\n\r\n    function _unregisterAll() {\r\n        _providers = {};\r\n    }\r\n\r\n    /**\r\n     * Returns a list of provider for given file path, if available.\r\n     * Decision is made depending on the file extension.\r\n     *\r\n     * @param {!string} filePath\r\n     * @return ?{Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):?{errors:!Array, aborted:boolean}}>} provider\r\n     */\r\n    function getProvidersForPath(filePath) {\r\n        return _providers[LanguageManager.getLanguageForPath(filePath).getId()];\r\n    }\r\n\r\n    /**\r\n     * Runs a file inspection over passed file. Uses the given list of providers if specified, otherwise uses\r\n     * the set of providers that are registered for the file\'s language.\r\n     * This method doesn\'t update the Brackets UI, just provides inspection results.\r\n     * These results will reflect any unsaved changes present in the file if currently open.\r\n     * \r\n     * The Promise yields an array of provider-result pair objects (the result is the return value of the\r\n     * provider\'s scanFile() - see register() for details). The result object may be null if there were no\r\n     * errors from that provider.\r\n     * If there are no providers registered for this file, the Promise yields null instead.\r\n     *\r\n     * @param {!File} file File that will be inspected for errors.\r\n     * @param {?Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):?{errors:!Array, aborted:boolean}}>} providerList\r\n     * @return {$.Promise} a jQuery promise that will be resolved with ?Array.<{provider:Object, result: ?{errors:!Array, aborted:boolean}}>\r\n     */\r\n    function inspectFile(file, providerList) {\r\n        var response = new $.Deferred(),\r\n            results = [];\r\n\r\n        providerList = (providerList || getProvidersForPath(file.fullPath)) || [];\r\n\r\n        if (!providerList.length) {\r\n            response.resolve(null);\r\n            return response.promise();\r\n        }\r\n        \r\n        DocumentManager.getDocumentText(file)\r\n            .done(function (fileText) {\r\n                var perfTimerInspector = PerfUtils.markStart("CodeInspection:\\t" + file.fullPath),\r\n                    masterPromise;\r\n\r\n                masterPromise = Async.doInParallel(providerList, function (provider) {\r\n                    var perfTimerProvider = PerfUtils.markStart("CodeInspection \'" + provider.name + "\':\\t" + file.fullPath),\r\n                        runPromise = new $.Deferred();\r\n                    \r\n                    runPromise.done(function (scanResult) {\r\n                        results.push({provider: provider, result: scanResult});\r\n                    });\r\n                    \r\n                    if (provider.scanFileAsync) {\r\n                        window.setTimeout(function () {\r\n                            // timeout error\r\n                            var errTimeout = {\r\n                                pos: { line: -1, col: 0},\r\n                                message: StringUtils.format(Strings.LINTER_TIMED_OUT, provider.name, prefs.get(PREF_ASYNC_TIMEOUT)),\r\n                                type: Type.ERROR\r\n                            };\r\n                            runPromise.resolve({errors: [errTimeout]});\r\n                        }, prefs.get(PREF_ASYNC_TIMEOUT));\r\n                        provider.scanFileAsync(fileText, file.fullPath)\r\n                            .done(function (scanResult) {\r\n                                PerfUtils.addMeasurement(perfTimerProvider);\r\n                                runPromise.resolve(scanResult);\r\n                            })\r\n                            .fail(function (err) {\r\n                                var errError = {\r\n                                    pos: {line: -1, col: 0},\r\n                                    message: StringUtils.format(Strings.LINTER_FAILED, provider.name, err),\r\n                                    type: Type.ERROR\r\n                                };\r\n                                console.error("[CodeInspection] Provider " + provider.name + " (async) failed: " + err);\r\n                                runPromise.resolve({errors: [errError]});\r\n                            });\r\n                    } else {\r\n                        try {\r\n                            var scanResult = provider.scanFile(fileText, file.fullPath);\r\n                            PerfUtils.addMeasurement(perfTimerProvider);\r\n                            runPromise.resolve(scanResult);\r\n                        } catch (err) {\r\n                            var errError = {\r\n                                pos: {line: -1, col: 0},\r\n                                message: StringUtils.format(Strings.LINTER_FAILED, provider.name, err),\r\n                                type: Type.ERROR\r\n                            };\r\n                            console.error("[CodeInspection] Provider " + provider.name + " (sync) threw an error: " + err);\r\n                            runPromise.resolve({errors: [errError]});\r\n                        }\r\n                    }\r\n                    return runPromise.promise();\r\n\r\n                }, false);\r\n                \r\n                masterPromise.then(function () {\r\n                    // sync async may have pushed results in different order, restore the original order\r\n                    results.sort(function (a, b) {\r\n                        return providerList.indexOf(a.provider) - providerList.indexOf(b.provider);\r\n                    });\r\n                    PerfUtils.addMeasurement(perfTimerInspector);\r\n                    response.resolve(results);\r\n                });\r\n\r\n            })\r\n            .fail(function (err) {\r\n                console.error("[CodeInspection] Could not read file for inspection: " + file.fullPath);\r\n                response.reject(err);\r\n            });\r\n\r\n        return response.promise();\r\n    }\r\n\r\n    /**\r\n     * Update the title of the problem panel and the tooltip of the status bar icon. The title and the tooltip will\r\n     * change based on the number of problems reported and how many provider reported problems.\r\n     * \r\n     * @param {Number} numProblems - total number of problems across all providers\r\n     * @param {Array.<{name:string, scanFileAsync:?function(string, string):!{$.Promise}, scanFile:?function(string, string):Object}>} providersReportingProblems - providers that reported problems\r\n     * @param {boolean} aborted - true if any provider returned a result with the \'aborted\' flag set\r\n     */\r\n    function updatePanelTitleAndStatusBar(numProblems, providersReportingProblems, aborted) {\r\n        var message, tooltip;\r\n\r\n        if (providersReportingProblems.length === 1) {\r\n            // don\'t show a header if there is only one provider available for this file type\r\n            $problemsPanelTable.find(".inspector-section").hide();\r\n\r\n            if (numProblems === 1 && !aborted) {\r\n                message = StringUtils.format(Strings.SINGLE_ERROR, providersReportingProblems[0].name);\r\n            } else {\r\n                if (aborted) {\r\n                    numProblems += "+";\r\n                }\r\n\r\n                message = StringUtils.format(Strings.MULTIPLE_ERRORS, providersReportingProblems[0].name, numProblems);\r\n            }\r\n        } else if (providersReportingProblems.length > 1) {\r\n            $problemsPanelTable.find(".inspector-section").show();\r\n\r\n            if (aborted) {\r\n                numProblems += "+";\r\n            }\r\n\r\n            message = StringUtils.format(Strings.ERRORS_PANEL_TITLE_MULTIPLE, numProblems);\r\n        } else {\r\n            return;\r\n        }\r\n\r\n        $problemsPanel.find(".title").text(message);\r\n        tooltip = StringUtils.format(Strings.STATUSBAR_CODE_INSPECTION_TOOLTIP, message);\r\n        StatusBar.updateIndicator(INDICATOR_ID, true, "inspection-errors", tooltip);\r\n    }\r\n\r\n    /**\r\n     * Run inspector applicable to current document. Updates status bar indicator and refreshes error list in\r\n     * bottom panel. Does not run if inspection is disabled or if a providerName is given and does not\r\n     * match the current doc\'s provider name.\r\n     * \r\n     * @param {?string} providerName name of the provider that is requesting a run\r\n     */\r\n    function run() {\r\n        if (!_enabled) {\r\n            _hasErrors = false;\r\n            _currentPromise = null;\r\n            Resizer.hide($problemsPanel);\r\n            StatusBar.updateIndicator(INDICATOR_ID, true, "inspection-disabled", Strings.LINT_DISABLED);\r\n            setGotoEnabled(false);\r\n            return;\r\n        }\r\n\r\n        var currentDoc = DocumentManager.getCurrentDocument(),\r\n            providerList = currentDoc && getProvidersForPath(currentDoc.file.fullPath);\r\n\r\n        if (providerList && providerList.length) {\r\n            var numProblems = 0;\r\n            var aborted = false;\r\n            var allErrors = [];\r\n            var html;\r\n            var providersReportingProblems = [];\r\n\r\n            // run all the providers registered for this file type\r\n            (_currentPromise = inspectFile(currentDoc.file, providerList)).then(function (results) {\r\n                // check if promise has not changed while inspectFile was running\r\n                if (this !== _currentPromise) {\r\n                    return;\r\n                }\r\n                \r\n                // how many errors in total?\r\n                var errors = results.reduce(function (a, item) { return a + (item.result ? item.result.errors.length : 0); }, 0);\r\n\r\n                _hasErrors = Boolean(errors);\r\n\r\n                if (!errors) {\r\n                    Resizer.hide($problemsPanel);\r\n\r\n                    var message = Strings.NO_ERRORS_MULTIPLE_PROVIDER;\r\n                    if (providerList.length === 1) {\r\n                        message = StringUtils.format(Strings.NO_ERRORS, providerList[0].name);\r\n                    }\r\n\r\n                    StatusBar.updateIndicator(INDICATOR_ID, true, "inspection-valid", message);\r\n\r\n                    setGotoEnabled(false);\r\n                    return;\r\n                }\r\n\r\n                var perfTimerDOM = PerfUtils.markStart("ProblemsPanel render:\\t" + currentDoc.file.fullPath);\r\n                \r\n                // Augment error objects with additional fields needed by Mustache template\r\n                results.forEach(function (inspectionResult) {\r\n                    var provider = inspectionResult.provider;\r\n\r\n                    if (inspectionResult.result) {\r\n                        inspectionResult.result.errors.forEach(function (error) {\r\n                            // some inspectors don\'t always provide a line number or report a negative line number\r\n                            if (!isNaN(error.pos.line) &&\r\n                                    (error.pos.line + 1) > 0 &&\r\n                                    (error.codeSnippet = currentDoc.getLine(error.pos.line)) !== undefined) {\r\n                                error.friendlyLine = error.pos.line + 1;\r\n                                error.codeSnippet = error.codeSnippet.substr(0, Math.min(175, error.codeSnippet.length));  // limit snippet width\r\n                            }\r\n                            \r\n                            if (error.type !== Type.META) {\r\n                                numProblems++;\r\n                            }\r\n                        });\r\n\r\n                        // if the code inspector was unable to process the whole file, we keep track to show a different status\r\n                        if (inspectionResult.result.aborted) {\r\n                            aborted = true;\r\n                        }\r\n\r\n                        if (inspectionResult.result.errors.length) {\r\n                            allErrors.push({\r\n                                providerName: provider.name,\r\n                                results:      inspectionResult.result.errors\r\n                            });\r\n\r\n                            providersReportingProblems.push(provider);\r\n                        }\r\n                    }\r\n                });\r\n                \r\n                // Update results table\r\n                html = Mustache.render(ResultsTemplate, {reportList: allErrors});\r\n                \r\n                $problemsPanelTable\r\n                    .empty()\r\n                    .append(html)\r\n                    .scrollTop(0);  // otherwise scroll pos from previous contents is remembered\r\n\r\n                if (!_collapsed) {\r\n                    Resizer.show($problemsPanel);\r\n                }\r\n\r\n                updatePanelTitleAndStatusBar(numProblems, providersReportingProblems, aborted);\r\n                setGotoEnabled(true);\r\n\r\n                PerfUtils.addMeasurement(perfTimerDOM);\r\n            });\r\n\r\n        } else {\r\n            // No provider for current file\r\n            _hasErrors = false;\r\n            _currentPromise = null;\r\n            Resizer.hide($problemsPanel);\r\n            var language = currentDoc && LanguageManager.getLanguageForPath(currentDoc.file.fullPath);\r\n            if (language) {\r\n                StatusBar.updateIndicator(INDICATOR_ID, true, "inspection-disabled", StringUtils.format(Strings.NO_LINT_AVAILABLE, language.getName()));\r\n            } else {\r\n                StatusBar.updateIndicator(INDICATOR_ID, true, "inspection-disabled", Strings.NOTHING_TO_LINT);\r\n            }\r\n            setGotoEnabled(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The provider is passed the text of the file and its fullPath. Providers should not assume\r\n     * that the file is open (i.e. DocumentManager.getOpenDocumentForPath() may return null) or\r\n     * that the file on disk matches the text given (file may have unsaved changes).\r\n     * \r\n     * Registering any provider for the "javascript" language automatically unregisters the built-in\r\n     * Brackets JSLint provider. This is a temporary convenience until UI exists for disabling\r\n     * registered providers.\r\n     * \r\n     * Providers implement scanFile() if results are available synchronously, or scanFileAsync() if results\r\n     * may require an async wait (if both are implemented, scanFile() is ignored). scanFileAsync() returns\r\n     * a {$.Promise} object resolved with the same type of value as scanFile() is expected to return.\r\n     * Rejecting the promise is treated as an internal error in the provider.\r\n     * \r\n     * @param {string} languageId\r\n     * @param {{name:string, scanFileAsync:?function(string, string):!{$.Promise},\r\n     *         scanFile:?function(string, string):?{errors:!Array, aborted:boolean}}} provider\r\n     *\r\n     * Each error is: { pos:{line,ch}, endPos:?{line,ch}, message:string, type:?Type }\r\n     * If type is unspecified, Type.WARNING is assumed.\r\n     * If no errors found, return either null or an object with a zero-length `errors` array.\r\n     */\r\n    function register(languageId, provider) {\r\n        if (!_providers[languageId]) {\r\n            _providers[languageId] = [];\r\n        }\r\n        \r\n        if (languageId === "javascript") {\r\n            // This is a special case to enable extension provider to replace the JSLint provider\r\n            // in favor of their own implementation\r\n            _.remove(_providers[languageId], function (registeredProvider) {\r\n                return registeredProvider.name === "JSLint";\r\n            });\r\n        }\r\n        \r\n        _providers[languageId].push(provider);\r\n        \r\n        run();  // in case a file of this type is open currently\r\n    }\r\n\r\n    /**\r\n     * Update DocumentManager listeners.\r\n     */\r\n    function updateListeners() {\r\n        if (_enabled) {\r\n            // register our event listeners\r\n            $(MainViewManager)\r\n                .on("currentFileChange.codeInspection", function () {\r\n                    run();\r\n                });\r\n            $(DocumentManager)\r\n                .on("currentDocumentLanguageChanged.codeInspection", function () {\r\n                    run();\r\n                })\r\n                .on("documentSaved.codeInspection documentRefreshed.codeInspection", function (event, document) {\r\n                    if (document === DocumentManager.getCurrentDocument()) {\r\n                        run();\r\n                    }\r\n                });\r\n        } else {\r\n            $(DocumentManager).off(".codeInspection");\r\n            $(MainViewManager).off(".codeInspection");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable or disable all inspection.\r\n     * @param {?boolean} enabled Enabled state. If omitted, the state is toggled.\r\n     * @param {?boolean} doNotSave true if the preference should not be saved to user settings. This is generally for events triggered by project-level settings.\r\n     */\r\n    function toggleEnabled(enabled, doNotSave) {\r\n        if (enabled === undefined) {\r\n            enabled = !_enabled;\r\n        }\r\n        \r\n        // Take no action when there is no change.\r\n        if (enabled === _enabled) {\r\n            return;\r\n        }\r\n        \r\n        _enabled = enabled;\r\n\r\n        CommandManager.get(Commands.VIEW_TOGGLE_INSPECTION).setChecked(_enabled);\r\n        updateListeners();\r\n        if (!doNotSave) {\r\n            prefs.set(PREF_ENABLED, _enabled);\r\n            prefs.save();\r\n        }\r\n    \r\n        // run immediately\r\n        run();\r\n    }\r\n\r\n    /**\r\n     * Toggle the collapsed state for the panel. This explicitly collapses the panel (as opposed to\r\n     * the auto collapse due to files with no errors & filetypes with no provider). When explicitly\r\n     * collapsed, the panel will not reopen automatically on switch files or save.\r\n     *\r\n     * @param {?boolean} collapsed Collapsed state. If omitted, the state is toggled.\r\n     * @param {?boolean} doNotSave true if the preference should not be saved to user settings. This is generally for events triggered by project-level settings.\r\n     */\r\n    function toggleCollapsed(collapsed, doNotSave) {\r\n        if (collapsed === undefined) {\r\n            collapsed = !_collapsed;\r\n        }\r\n        \r\n        if (collapsed === _collapsed) {\r\n            return;\r\n        }\r\n\r\n        _collapsed = collapsed;\r\n        if (!doNotSave) {\r\n            prefs.set(PREF_COLLAPSED, _collapsed);\r\n            prefs.save();\r\n        }\r\n        \r\n        if (_collapsed) {\r\n            Resizer.hide($problemsPanel);\r\n        } else {\r\n            if (_hasErrors) {\r\n                Resizer.show($problemsPanel);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Command to go to the first Error/Warning */\r\n    function handleGotoFirstProblem() {\r\n        run();\r\n        if (_gotoEnabled) {\r\n            $problemsPanel.find("tr:not(.inspector-section)").first().trigger("click");\r\n        }\r\n    }\r\n\r\n    // Register command handlers\r\n    CommandManager.register(Strings.CMD_VIEW_TOGGLE_INSPECTION, Commands.VIEW_TOGGLE_INSPECTION,        toggleEnabled);\r\n    CommandManager.register(Strings.CMD_GOTO_FIRST_PROBLEM,     Commands.NAVIGATE_GOTO_FIRST_PROBLEM,   handleGotoFirstProblem);\r\n    \r\n    // Register preferences\r\n    prefs.definePreference(PREF_ENABLED, "boolean", brackets.config["linting.enabled_by_default"])\r\n        .on("change", function (e, data) {\r\n            toggleEnabled(prefs.get(PREF_ENABLED), true);\r\n        });\r\n    \r\n    prefs.definePreference(PREF_COLLAPSED, "boolean", false)\r\n        .on("change", function (e, data) {\r\n            toggleCollapsed(prefs.get(PREF_COLLAPSED), true);\r\n        });\r\n    \r\n    prefs.definePreference(PREF_ASYNC_TIMEOUT, "number", 10000);\r\n    \r\n    // Initialize items dependent on HTML DOM\r\n    AppInit.htmlReady(function () {\r\n        // Create bottom panel to list error details\r\n        var panelHtml = Mustache.render(PanelTemplate, Strings);\r\n        var resultsPanel = WorkspaceManager.createBottomPanel("errors", $(panelHtml), 100);\r\n        $problemsPanel = $("#problems-panel");\r\n\r\n        var $selectedRow;\r\n        $problemsPanelTable = $problemsPanel.find(".table-container")\r\n            .on("click", "tr", function (e) {\r\n                if ($selectedRow) {\r\n                    $selectedRow.removeClass("selected");\r\n                }\r\n\r\n                $selectedRow  = $(e.currentTarget);\r\n                $selectedRow.addClass("selected");\r\n\r\n                // This is a inspector title row, expand/collapse on click\r\n                if ($selectedRow.hasClass("inspector-section")) {\r\n                    // Clicking the inspector title section header collapses/expands result rows\r\n                    $selectedRow.nextUntil(".inspector-section").toggle();\r\n\r\n                    var $triangle = $(".disclosure-triangle", $selectedRow);\r\n                    $triangle.toggleClass("expanded").toggleClass("collapsed");\r\n                } else {\r\n                    // This is a problem marker row, show the result on click\r\n                    // Grab the required position data\r\n                    var lineTd    = $selectedRow.find(".line-number");\r\n                    var line      = parseInt(lineTd.text(), 10) - 1;  // convert friendlyLine back to pos.line\r\n                    // if there is no line number available, don\'t do anything\r\n                    if (!isNaN(line)) {\r\n                        var character = lineTd.data("character");\r\n    \r\n                        var editor = EditorManager.getCurrentFullEditor();\r\n                        editor.setCursorPos(line, character, true);\r\n                        MainViewManager.focusActivePane();\r\n                    }\r\n                }\r\n            });\r\n\r\n        $("#problems-panel .close").click(function () {\r\n            toggleCollapsed(true);\r\n        });\r\n\r\n        // Status bar indicator - icon & tooltip updated by run()\r\n        var statusIconHtml = Mustache.render("<div id=\\"status-inspection\\">&nbsp;</div>", Strings);\r\n        StatusBar.addIndicator(INDICATOR_ID, $(statusIconHtml), true, "", "", "status-indent");\r\n\r\n        $("#status-inspection").click(function () {\r\n            // Clicking indicator toggles error panel, if any errors in current file\r\n            if (_hasErrors) {\r\n                toggleCollapsed();\r\n            }\r\n        });\r\n\r\n        // Set initial UI state\r\n        toggleEnabled(prefs.get(PREF_ENABLED), true);\r\n        toggleCollapsed(prefs.get(PREF_COLLAPSED), true);\r\n    });\r\n\r\n    // Testing\r\n    exports._unregisterAll          = _unregisterAll;\r\n    exports._PREF_ASYNC_TIMEOUT     = PREF_ASYNC_TIMEOUT;\r\n\r\n    // Public API\r\n    exports.register       = register;\r\n    exports.Type           = Type;\r\n    exports.toggleEnabled  = toggleEnabled;\r\n    exports.inspectFile    = inspectFile;\r\n    exports.requestRun     = run;\r\n});\r\n\n//# sourceURL=/language/CodeInspection.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window */\r\n\r\n/**\r\n * Manages parts of the status bar related to the current editor\'s state.\r\n */\r\ndefine(\'editor/EditorStatusBar\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'utils/AnimationUtils\',\'utils/AppInit\',\'widgets/DropdownButton\',\'editor/EditorManager\',\'view/MainViewManager\',\'editor/Editor\',\'file/FileUtils\',\'utils/KeyEvent\',\'language/LanguageManager\',\'preferences/PreferencesManager\',\'widgets/StatusBar\',\'strings\',\'utils/StringUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    // Load dependent modules\r\n    var _                            = require("thirdparty/lodash"),\r\n        AnimationUtils               = require("utils/AnimationUtils"),\r\n        AppInit                      = require("utils/AppInit"),\r\n        DropdownButton               = require("widgets/DropdownButton").DropdownButton,\r\n        EditorManager                = require("editor/EditorManager"),\r\n        MainViewManager     = require("view/MainViewManager"),\r\n        Editor                       = require("editor/Editor").Editor,\r\n        FileUtils                    = require("file/FileUtils"),\r\n        KeyEvent                     = require("utils/KeyEvent"),\r\n        LanguageManager              = require("language/LanguageManager"),\r\n        PreferencesManager           = require("preferences/PreferencesManager"),\r\n        StatusBar                    = require("widgets/StatusBar"),\r\n        Strings                      = require("strings"),\r\n        StringUtils                  = require("utils/StringUtils");\r\n    \r\n    /* StatusBar indicators */\r\n    var languageSelect, // this is a DropdownButton instance\r\n        $cursorInfo,\r\n        $fileInfo,\r\n        $indentType,\r\n        $indentWidthLabel,\r\n        $indentWidthInput,\r\n        $statusOverwrite;\r\n    \r\n    /** Special list item for the \'set as default\' gesture in language switcher dropdown */\r\n    var LANGUAGE_SET_AS_DEFAULT = {};\r\n    \r\n    \r\n    /**\r\n     * Determine string based on count\r\n     * @param {number} number Count\r\n     * @param {string} singularStr Singular string\r\n     * @param {string} pluralStr Plural string\r\n     * @return {string} Proper string to use for count\r\n     */\r\n    function _formatCountable(number, singularStr, pluralStr) {\r\n        return StringUtils.format(number > 1 ? pluralStr : singularStr, number);\r\n    }\r\n    \r\n    /**\r\n     * Update file mode\r\n     * @param {Editor} editor Current editor\r\n     */\r\n    function _updateLanguageInfo(editor) {\r\n        var doc = editor.document,\r\n            lang = doc.getLanguage();\r\n        \r\n        // Ensure width isn\'t left locked by a previous click of the dropdown (which may not have resulted in a "change" event at the time)\r\n        languageSelect.$button.css("width", "auto");\r\n        // Setting Untitled documents to non-text mode isn\'t supported yet, so disable the switcher in that case for now\r\n        languageSelect.$button.prop("disabled", doc.isUntitled());\r\n        // Show the current language as button title\r\n        languageSelect.$button.text(lang.getName());\r\n    }\r\n    \r\n    /**\r\n     * Update file information\r\n     * @param {Editor} editor Current editor\r\n     */\r\n    function _updateFileInfo(editor) {\r\n        var lines = editor.lineCount();\r\n        $fileInfo.text(_formatCountable(lines, Strings.STATUSBAR_LINE_COUNT_SINGULAR, Strings.STATUSBAR_LINE_COUNT_PLURAL));\r\n    }\r\n    \r\n    /**\r\n     * Update indent type and size\r\n     * @param {string} fullPath Path to file in current editor\r\n     */\r\n    function _updateIndentType(fullPath) {\r\n        var indentWithTabs = Editor.getUseTabChar(fullPath);\r\n        $indentType.text(indentWithTabs ? Strings.STATUSBAR_TAB_SIZE : Strings.STATUSBAR_SPACES);\r\n        $indentType.attr("title", indentWithTabs ? Strings.STATUSBAR_INDENT_TOOLTIP_SPACES : Strings.STATUSBAR_INDENT_TOOLTIP_TABS);\r\n        $indentWidthLabel.attr("title", indentWithTabs ? Strings.STATUSBAR_INDENT_SIZE_TOOLTIP_TABS : Strings.STATUSBAR_INDENT_SIZE_TOOLTIP_SPACES);\r\n    }\r\n\r\n    /**\r\n     * Get indent size based on type\r\n     * @param {string} fullPath Path to file in current editor\r\n     * @return {number} Indent size\r\n     */\r\n    function _getIndentSize(fullPath) {\r\n        return Editor.getUseTabChar(fullPath) ? Editor.getTabSize(fullPath) : Editor.getSpaceUnits(fullPath);\r\n    }\r\n    \r\n    /**\r\n     * Update indent size\r\n     * @param {string} fullPath Path to file in current editor\r\n     */\r\n    function _updateIndentSize(fullPath) {\r\n        var size = _getIndentSize(fullPath);\r\n        $indentWidthLabel.text(size);\r\n        $indentWidthInput.val(size);\r\n    }\r\n    \r\n    /**\r\n     * Toggle indent type\r\n     */\r\n    function _toggleIndentType() {\r\n        var current = EditorManager.getActiveEditor(),\r\n            fullPath = current && current.document.file.fullPath;\r\n\r\n        Editor.setUseTabChar(!Editor.getUseTabChar(fullPath), fullPath);\r\n        _updateIndentType(fullPath);\r\n        _updateIndentSize(fullPath);\r\n    }\r\n    \r\n    /**\r\n     * Update cursor(s)/selection(s) information\r\n     * @param {Event} event (unused)\r\n     * @param {Editor} editor Current editor\r\n     */\r\n    function _updateCursorInfo(event, editor) {\r\n        editor = editor || EditorManager.getActiveEditor();\r\n\r\n        // compute columns, account for tab size\r\n        var cursor = editor.getCursorPos(true);\r\n        \r\n        var cursorStr = StringUtils.format(Strings.STATUSBAR_CURSOR_POSITION, cursor.line + 1, cursor.ch + 1);\r\n        \r\n        var sels = editor.getSelections(),\r\n            selStr = "";\r\n\r\n        if (sels.length > 1) {\r\n            selStr = StringUtils.format(Strings.STATUSBAR_SELECTION_MULTIPLE, sels.length);\r\n        } else if (editor.hasSelection()) {\r\n            var sel = sels[0];\r\n            if (sel.start.line !== sel.end.line) {\r\n                var lines = sel.end.line - sel.start.line + 1;\r\n                if (sel.end.ch === 0) {\r\n                    lines--;  // end line is exclusive if ch is 0, inclusive otherwise\r\n                }\r\n                selStr = _formatCountable(lines, Strings.STATUSBAR_SELECTION_LINE_SINGULAR, Strings.STATUSBAR_SELECTION_LINE_PLURAL);\r\n            } else {\r\n                var cols = editor.getColOffset(sel.end) - editor.getColOffset(sel.start);  // end ch is exclusive always\r\n                selStr = _formatCountable(cols, Strings.STATUSBAR_SELECTION_CH_SINGULAR, Strings.STATUSBAR_SELECTION_CH_PLURAL);\r\n            }\r\n        }\r\n        $cursorInfo.text(cursorStr + selStr);\r\n    }\r\n    \r\n    /**\r\n     * Change indent size\r\n     * @param {string} fullPath Path to file in current editor\r\n     * @param {string} value Size entered into status bar \r\n     */\r\n    function _changeIndentWidth(fullPath, value) {\r\n        $indentWidthLabel.removeClass("hidden");\r\n        $indentWidthInput.addClass("hidden");\r\n        \r\n        // remove all event handlers from the input field\r\n        $indentWidthInput.off("blur keyup");\r\n        \r\n        // restore focus to the editor\r\n        MainViewManager.focusActivePane();\r\n        \r\n        var valInt = parseInt(value, 10);\r\n        if (Editor.getUseTabChar(fullPath)) {\r\n            if (!Editor.setTabSize(valInt, fullPath)) {\r\n                return;     // validation failed\r\n            }\r\n        } else {\r\n            if (!Editor.setSpaceUnits(valInt, fullPath)) {\r\n                return;     // validation failed\r\n            }\r\n        }\r\n\r\n        // update indicator\r\n        _updateIndentSize(fullPath);\r\n\r\n        // column position may change when tab size changes\r\n        _updateCursorInfo();\r\n    }\r\n    \r\n    /**\r\n     * Update insert/overwrite label\r\n     * @param {Event} event (unused)\r\n     * @param {Editor} editor Current editor\r\n     * @param {string} newstate New overwrite state\r\n     * @param {boolean=} doNotAnimate True if state should not be animated\r\n     */\r\n    function _updateOverwriteLabel(event, editor, newstate, doNotAnimate) {\r\n        if ($statusOverwrite.text() === (newstate ? Strings.STATUSBAR_OVERWRITE : Strings.STATUSBAR_INSERT)) {\r\n            // label already up-to-date\r\n            return;\r\n        }\r\n\r\n        $statusOverwrite.text(newstate ? Strings.STATUSBAR_OVERWRITE : Strings.STATUSBAR_INSERT);\r\n\r\n        if (!doNotAnimate) {\r\n            AnimationUtils.animateUsingClass($statusOverwrite[0], "flash", 1500);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Update insert/overwrite indicator\r\n     * @param {Event} event (unused)\r\n     */\r\n    function _updateEditorOverwriteMode(event) {\r\n        var editor = EditorManager.getActiveEditor(),\r\n            newstate = !editor._codeMirror.state.overwrite;\r\n\r\n        // update label with no transition\r\n        _updateOverwriteLabel(event, editor, newstate, true);\r\n        editor.toggleOverwrite(newstate);\r\n    }\r\n    \r\n    /**\r\n     * Initialize insert/overwrite indicator\r\n     * @param {Editor} currentEditor Current editor\r\n     */\r\n    function _initOverwriteMode(currentEditor) {\r\n        currentEditor.toggleOverwrite($statusOverwrite.text() === Strings.STATUSBAR_OVERWRITE);\r\n        $statusOverwrite.attr("title", Strings.STATUSBAR_INSOVR_TOOLTIP);\r\n    }\r\n    \r\n    /**\r\n     * Handle active editor change event\r\n     * @param {Event} event (unused)\r\n     * @param {Editor} current Current editor\r\n     * @param {Editor} previous Previous editor \r\n     */\r\n    function _onActiveEditorChange(event, current, previous) {\r\n        if (previous) {\r\n            $(previous).off(".statusbar");\r\n            $(previous.document).off(".statusbar");\r\n            previous.document.releaseRef();\r\n        }\r\n        \r\n        if (!current) {\r\n            StatusBar.hideAllPanes();\r\n        } else {\r\n            var fullPath = current.document.file.fullPath;\r\n            StatusBar.showAllPanes();\r\n            \r\n            $(current).on("cursorActivity.statusbar", _updateCursorInfo);\r\n            $(current).on("optionChange.statusbar", function () {\r\n                _updateIndentType(fullPath);\r\n                _updateIndentSize(fullPath);\r\n            });\r\n            $(current).on("change.statusbar", function () {\r\n                // async update to keep typing speed smooth\r\n                window.setTimeout(function () { _updateFileInfo(current); }, 0);\r\n            });\r\n            $(current).on("overwriteToggle.statusbar", _updateOverwriteLabel);\r\n            \r\n            current.document.addRef();\r\n            $(current.document).on("languageChanged.statusbar", function () {\r\n                _updateLanguageInfo(current);\r\n            });\r\n            \r\n            _updateCursorInfo(null, current);\r\n            _updateLanguageInfo(current);\r\n            _updateFileInfo(current);\r\n            _initOverwriteMode(current);\r\n            _updateIndentType(fullPath);\r\n            _updateIndentSize(fullPath);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Populate the languageSelect DropdownButton\'s menu with all registered Languages\r\n     */\r\n    function _populateLanguageDropdown() {\r\n        // Get all non-binary languages\r\n        var languages = _.values(LanguageManager.getLanguages()).filter(function (language) {\r\n            return !language.isBinary();\r\n        });\r\n        \r\n        // sort dropdown alphabetically\r\n        languages.sort(function (a, b) {\r\n            return a.getName().toLowerCase().localeCompare(b.getName().toLowerCase());\r\n        });\r\n        \r\n        languageSelect.items = languages;\r\n        \r\n        // Add option to top of menu for persisting the override\r\n        languageSelect.items.unshift("---");\r\n        languageSelect.items.unshift(LANGUAGE_SET_AS_DEFAULT);\r\n    }\r\n    \r\n    /**\r\n     * Initialize\r\n     */\r\n    function _init() {\r\n        \r\n        $cursorInfo         = $("#status-cursor");\r\n        $fileInfo           = $("#status-file");\r\n        $indentType         = $("#indent-type");\r\n        $indentWidthLabel   = $("#indent-width-label");\r\n        $indentWidthInput   = $("#indent-width-input");\r\n        $statusOverwrite    = $("#status-overwrite");\r\n        \r\n        languageSelect      = new DropdownButton("", [], function (item, index) {\r\n            var document = EditorManager.getActiveEditor().document,\r\n                defaultLang = LanguageManager.getLanguageForPath(document.file.fullPath, true);\r\n            \r\n            if (item === LANGUAGE_SET_AS_DEFAULT) {\r\n                var label = _.escape(StringUtils.format(Strings.STATUSBAR_SET_DEFAULT_LANG, FileUtils.getSmartFileExtension(document.file.fullPath)));\r\n                return { html: label, enabled: document.getLanguage() !== defaultLang };\r\n            }\r\n            \r\n            var html = _.escape(item.getName());\r\n            \r\n            // Show indicators for currently selected & default languages for the current file\r\n            if (item === defaultLang) {\r\n                html += " <span class=\'default-language\'>" + Strings.STATUSBAR_DEFAULT_LANG + "</span>";\r\n            }\r\n            if (item === document.getLanguage()) {\r\n                html = "<span class=\'checked-language\'></span>" + html;\r\n            }\r\n            return html;\r\n        });\r\n        \r\n        languageSelect.dropdownExtraClasses = "dropdown-status-bar";\r\n        languageSelect.$button.addClass("btn-status-bar");\r\n        $("#status-language").append(languageSelect.$button);\r\n        languageSelect.$button.attr("title", Strings.STATUSBAR_LANG_TOOLTIP);\r\n        \r\n        // indentation event handlers\r\n        $indentType.on("click", _toggleIndentType);\r\n        $indentWidthLabel\r\n            .on("click", function () {\r\n                // update the input value before displaying\r\n                var current = EditorManager.getActiveEditor();\r\n                $indentWidthInput.val(_getIndentSize(current));\r\n\r\n                $indentWidthLabel.addClass("hidden");\r\n                $indentWidthInput.removeClass("hidden");\r\n                $indentWidthInput.focus();\r\n        \r\n                $indentWidthInput\r\n                    .on("blur", function () {\r\n                        _changeIndentWidth(current, $indentWidthInput.val());\r\n                    })\r\n                    .on("keyup", function (event) {\r\n                        if (event.keyCode === KeyEvent.DOM_VK_RETURN) {\r\n                            $indentWidthInput.blur();\r\n                        } else if (event.keyCode === KeyEvent.DOM_VK_ESCAPE) {\r\n                            _changeIndentWidth(current, false);\r\n                        }\r\n                    });\r\n            });\r\n\r\n        $indentWidthInput.focus(function () { $indentWidthInput.select(); });\r\n\r\n        // Language select change handler\r\n        $(languageSelect).on("select", function (e, lang) {\r\n            var document = EditorManager.getActiveEditor().document,\r\n                fullPath = document.file.fullPath;\r\n            \r\n            if (lang === LANGUAGE_SET_AS_DEFAULT) {\r\n                // Set file\'s current language in preferences as a file extension override (only enabled if not default already)\r\n                var fileExtensionMap = PreferencesManager.get("language.fileExtensions");\r\n                fileExtensionMap[FileUtils.getSmartFileExtension(fullPath)] = document.getLanguage().getId();\r\n                PreferencesManager.set("language.fileExtensions", fileExtensionMap);\r\n                \r\n            } else {\r\n                // Set selected language as a path override for just this one file (not persisted)\r\n                var defaultLang = LanguageManager.getLanguageForPath(fullPath, true);\r\n                // if default language selected, pass null to clear the override\r\n                LanguageManager.setLanguageOverrideForPath(fullPath, lang === defaultLang ? null : lang);\r\n            }\r\n        });\r\n\r\n        $statusOverwrite.on("click", _updateEditorOverwriteMode);\r\n    }\r\n\r\n    // Initialize: status bar focused listener\r\n    $(EditorManager).on("activeEditorChange", _onActiveEditorChange);\r\n    \r\n    AppInit.htmlReady(_init);\r\n    AppInit.appReady(function () {\r\n        // Populate language switcher with all languages after startup; update it later if this set changes\r\n        _populateLanguageDropdown();\r\n        $(LanguageManager).on("languageAdded languageModified", _populateLanguageDropdown);\r\n        _onActiveEditorChange(null, EditorManager.getActiveEditor(), null);\r\n        StatusBar.show();\r\n    });\r\n});\r\n\n//# sourceURL=/editor/EditorStatusBar.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\n\r\n/**\r\n * Text-editing commands that apply to whichever Editor is currently focused\r\n */\r\ndefine(\'editor/EditorCommandHandlers\',[\'require\',\'exports\',\'module\',\'command/Commands\',\'strings\',\'command/CommandManager\',\'editor/EditorManager\',\'utils/StringUtils\',\'utils/TokenUtils\',\'thirdparty/CodeMirror2/lib/codemirror\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    // Load dependent modules\r\n    var Commands           = require("command/Commands"),\r\n        Strings            = require("strings"),\r\n        CommandManager     = require("command/CommandManager"),\r\n        EditorManager      = require("editor/EditorManager"),\r\n        StringUtils        = require("utils/StringUtils"),\r\n        TokenUtils         = require("utils/TokenUtils"),\r\n        CodeMirror         = require("thirdparty/CodeMirror2/lib/codemirror"),\r\n        _                  = require("thirdparty/lodash");\r\n    \r\n    /**\r\n     * List of constants\r\n     */\r\n    var DIRECTION_UP    = -1;\r\n    var DIRECTION_DOWN  = +1;\r\n        \r\n    /**\r\n     * @private\r\n     * Creates special regular expressions that matches the line prefix but not the block prefix or suffix\r\n     * @param {!string} lineSyntax  a line comment prefix\r\n     * @param {!string} blockSyntax  a block comment prefix or suffix\r\n     * @return {RegExp}\r\n     */\r\n    function _createSpecialLineExp(lineSyntax, blockSyntax) {\r\n        var i, character,\r\n            subExps   = [],\r\n            prevChars = "";\r\n        \r\n        for (i = lineSyntax.length; i < blockSyntax.length; i++) {\r\n            character = blockSyntax.charAt(i);\r\n            subExps.push(prevChars + "[^" + StringUtils.regexEscape(character) + "]");\r\n            if (prevChars) {\r\n                subExps.push(prevChars + "$");\r\n            }\r\n            prevChars += character;\r\n        }\r\n        return new RegExp("^\\\\s*" + StringUtils.regexEscape(lineSyntax) + "($|" + subExps.join("|") + ")");\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Creates regular expressions for multiple line comment prefixes\r\n     * @param {!Array.<string>} prefixes  the line comment prefixes\r\n     * @param {string=} blockPrefix  the block comment prefix\r\n     * @param {string=} blockSuffix  the block comment suffix\r\n     * @return {Array.<RegExp>}\r\n     */\r\n    function _createLineExpressions(prefixes, blockPrefix, blockSuffix) {\r\n        var lineExp = [], escapedPrefix, nothingPushed;\r\n        \r\n        prefixes.forEach(function (prefix) {\r\n            escapedPrefix = StringUtils.regexEscape(prefix);\r\n            nothingPushed = true;\r\n            \r\n            if (blockPrefix && blockPrefix.indexOf(prefix) === 0) {\r\n                lineExp.push(_createSpecialLineExp(prefix, blockPrefix));\r\n                nothingPushed = false;\r\n            }\r\n            if (blockSuffix && blockPrefix !== blockSuffix && blockSuffix.indexOf(prefix) === 0) {\r\n                lineExp.push(_createSpecialLineExp(prefix, blockSuffix));\r\n                nothingPushed = false;\r\n            }\r\n            if (nothingPushed) {\r\n                lineExp.push(new RegExp("^\\\\s*" + escapedPrefix));\r\n            }\r\n        });\r\n        return lineExp;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Returns true if any regular expression matches the given string\r\n     * @param {!string} string  where to look\r\n     * @param {!Array.<RegExp>} expressions  what to look\r\n     * @return {boolean}\r\n     */\r\n    function _matchExpressions(string, expressions) {\r\n        return expressions.some(function (exp) {\r\n            return string.match(exp);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Returns the line comment prefix that best matches the string. Since there might be line comment prefixes\r\n     * that are prefixes of other line comment prefixes, it searches through all and returns the longest line\r\n     * comment prefix that matches the string.\r\n     * @param {!string} string  where to look\r\n     * @param {!Array.<RegExp>} expressions  the line comment regular expressions\r\n     * @param {!Array.<string>} prefixes  the line comment prefixes\r\n     * @return {string}\r\n     */\r\n    function _getLinePrefix(string, expressions, prefixes) {\r\n        var result = null;\r\n        expressions.forEach(function (exp, index) {\r\n            if (string.match(exp) && ((result && result.length < prefixes[index].length) || !result)) {\r\n                result = prefixes[index];\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Searches between startLine and endLine to check if there is at least one line commented with a line comment, and\r\n     * skips all the block comments.\r\n     * @param {!Editor} editor\r\n     * @param {!number} startLine  valid line inside the document\r\n     * @param {!number} endLine  valid line inside the document\r\n     * @param {!Array.<RegExp>} lineExp  an array of line comment prefixes regular expressions\r\n     * @return {boolean} true if there is at least one uncommented line\r\n     */\r\n    function _containsNotLineComment(editor, startLine, endLine, lineExp) {\r\n        var i, line,\r\n            containsNotLineComment = false;\r\n        \r\n        for (i = startLine; i <= endLine; i++) {\r\n            line = editor.document.getLine(i);\r\n            // A line is commented out if it starts with 0-N whitespace chars, then a line comment prefix\r\n            if (line.match(/\\S/) && !_matchExpressions(line, lineExp)) {\r\n                containsNotLineComment = true;\r\n                break;\r\n            }\r\n        }\r\n        return containsNotLineComment;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Generates an edit that adds or removes line-comment tokens to all the lines in the selected range,\r\n     * preserving selection and cursor position. Applies to currently focused Editor. The given selection\r\n     * must already be a line selection in the form returned by `Editor.convertToLineSelections()`.\r\n     * \r\n     * If all non-whitespace lines are already commented out, then we uncomment; otherwise we comment\r\n     * out. Commenting out adds the prefix at column 0 of every line. Uncommenting removes the first prefix\r\n     * on each line (if any - empty lines might not have one).\r\n     *\r\n     * @param {!Editor} editor\r\n     * @param {!Array.<string>} prefixes, e.g. ["//"]\r\n     * @param {string=} blockPrefix, e.g. "<!--"\r\n     * @param {string=} blockSuffix, e.g. "-->"\r\n     * @param {!Editor} editor The editor to edit within.\r\n     * @param {!{selectionForEdit: {start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}, \r\n     *           selectionsToTrack: Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>}}\r\n     *      lineSel A line selection as returned from `Editor.convertToLineSelections()`. `selectionForEdit` is the selection to perform\r\n     *      the line comment operation on, and `selectionsToTrack` are a set of selections associated with this line that need to be\r\n     *      tracked through the edit.\r\n     * @return {{edit: {text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}|Array.<{text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}>,\r\n     *                  selection: {start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}|\r\n     *                  Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}}\r\n     *      An edit description suitable for including in the edits array passed to `Document.doMultipleEdits()`.\r\n     */\r\n    function _getLineCommentPrefixEdit(editor, prefixes, blockPrefix, blockSuffix, lineSel) {\r\n        var doc         = editor.document,\r\n            sel         = lineSel.selectionForEdit,\r\n            trackedSels = lineSel.selectionsToTrack,\r\n            lineExp     = _createLineExpressions(prefixes, blockPrefix, blockSuffix),\r\n            startLine   = sel.start.line,\r\n            endLine     = sel.end.line,\r\n            editGroup   = [];\r\n\r\n        // In full-line selection, cursor pos is start of next line - but don\'t want to modify that line\r\n        if (sel.end.ch === 0) {\r\n            endLine--;\r\n        }\r\n\r\n        // Decide if we\'re commenting vs. un-commenting\r\n        // Are there any non-blank lines that aren\'t commented out? (We ignore blank lines because\r\n        // some editors like Sublime don\'t comment them out)\r\n        var i, line, prefix, commentI,\r\n            containsNotLineComment = _containsNotLineComment(editor, startLine, endLine, lineExp),\r\n            updateSelection        = false;\r\n        \r\n        if (containsNotLineComment) {\r\n            // Comment out - prepend the first prefix to each line\r\n            for (i = startLine; i <= endLine; i++) {\r\n                editGroup.push({text: prefixes[0], start: {line: i, ch: 0}});\r\n            }\r\n\r\n            // Make sure tracked selections include the prefix that was added at start of range\r\n            _.each(trackedSels, function (trackedSel) {\r\n                if (trackedSel.start.ch === 0 && CodeMirror.cmpPos(trackedSel.start, trackedSel.end) !== 0) {\r\n                    trackedSel.start = {line: trackedSel.start.line, ch: 0};\r\n                    trackedSel.end = {line: trackedSel.end.line, ch: (trackedSel.end.line === endLine ? trackedSel.end.ch + prefixes[0].length : 0)};\r\n                } else {\r\n                    trackedSel.isBeforeEdit = true;\r\n                }\r\n            });\r\n        } else {\r\n            // Uncomment - remove the prefix on each line (if any)\r\n            for (i = startLine; i <= endLine; i++) {\r\n                line   = doc.getLine(i);\r\n                prefix = _getLinePrefix(line, lineExp, prefixes);\r\n\r\n                if (prefix) {\r\n                    commentI = line.indexOf(prefix);\r\n                    editGroup.push({text: "", start: {line: i, ch: commentI}, end: {line: i, ch: commentI + prefix.length}});\r\n                }\r\n            }\r\n            _.each(trackedSels, function (trackedSel) {\r\n                trackedSel.isBeforeEdit = true;\r\n            });\r\n        }\r\n        return {edit: editGroup, selection: trackedSels};\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Given a token context it will search backwards to determine if the given token is part of a block comment\r\n     * that doesn\'t start at the initial token. This is used to know if a line comment is part of a block comment\r\n     * or if a block delimiter is the prefix or suffix, by passing a token context at that position. Since the\r\n     * token context will be moved backwards a lot, it is better to pass a new context.\r\n     * \r\n     * @param {!{editor:{CodeMirror}, pos:{ch:{number}, line:{number}}, token:{object}}} ctx  token context\r\n     * @param {!string} prefix  the block comment prefix\r\n     * @param {!string} suffix  the block comment suffix\r\n     * @param {!RegExp} prefixExp  a block comment prefix regular expression\r\n     * @param {!RegExp} suffixExp  a block comment suffix regular expression\r\n     * @param {!Array.<RegExp>} lineExp  an array of line comment prefixes regular expressions\r\n     * @return {boolean}\r\n     */\r\n    function _isPrevTokenABlockComment(ctx, prefix, suffix, prefixExp, suffixExp, lineExp) {\r\n        // Start searching from the previous token\r\n        var result = TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx);\r\n        \r\n        // Look backwards until we find a none line comment token\r\n        while (result && _matchExpressions(ctx.token.string, lineExp)) {\r\n            result = TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx);\r\n        }\r\n        \r\n        // If we are now in a block comment token\r\n        if (result && ctx.token.type === "comment") {\r\n            // If it doesnt matches either prefix or suffix, we know is a block comment\r\n            if (!ctx.token.string.match(prefixExp) && !ctx.token.string.match(suffixExp)) {\r\n                return true;\r\n            // We found a line with just a block comment delimiter, but we can\'t tell which one it is, so we will\r\n            // keep searching recursively and return the opposite value\r\n            } else if (prefix === suffix && ctx.token.string.length === prefix.length) {\r\n                return !_isPrevTokenABlockComment(ctx, prefix, suffix, prefixExp, suffixExp, lineExp);\r\n            // We can just now the result by checking if the string matches the prefix\r\n            } else {\r\n                return ctx.token.string.match(prefixExp);\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n\r\n    /**\r\n     * Generates an edit that adds or removes block-comment tokens to the selection, preserving selection\r\n     * and cursor position. Applies to the currently focused Editor.\r\n     * \r\n     * If the selection is inside a block-comment or one block-comment is inside or partially inside the selection\r\n     * it will uncomment, otherwise it will comment out, unless if there are multiple block comments inside the selection,\r\n     * where it does nothing.\r\n     * Commenting out adds the prefix before the selection and the suffix after.\r\n     * Uncommenting removes them.\r\n     * \r\n     * If all the lines inside the selection are line-comment and if the selection is not inside a block-comment, it will\r\n     * line uncomment all the lines, otherwise it will block comment/uncomment. In the first case, we return null to\r\n     * indicate to the caller that it needs to handle this selection as a line comment.\r\n     *\r\n     * @param {!Editor} editor\r\n     * @param {!string} prefix, e.g. "<!--"\r\n     * @param {!string} suffix, e.g. "-->"\r\n     * @param {!Array.<string>} linePrefixes, e.g. ["//"]\r\n     * @param {!{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}} sel\r\n     *      The selection to block comment/uncomment.\r\n     * @param {?Array.<{!{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}}>} selectionsToTrack\r\n     *      An array of selections that should be tracked through this edit.\r\n     * @return {{edit: {text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}|Array.<{text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}>,\r\n     *                  selection: {start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}|\r\n     *                  Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}}\r\n     *      An edit description suitable for including in the edits array passed to `Document.doMultipleEdits()`.\r\n     */\r\n    function _getBlockCommentPrefixSuffixEdit(editor, prefix, suffix, linePrefixes, sel, selectionsToTrack) {\r\n        var doc            = editor.document,\r\n            ctx            = TokenUtils.getInitialContext(editor._codeMirror, {line: sel.start.line, ch: sel.start.ch}),\r\n            selEndIndex    = editor.indexFromPos(sel.end),\r\n            lineExp        = _createLineExpressions(linePrefixes, prefix, suffix),\r\n            prefixExp      = new RegExp("^" + StringUtils.regexEscape(prefix), "g"),\r\n            suffixExp      = new RegExp(StringUtils.regexEscape(suffix) + "$", "g"),\r\n            prefixPos      = null,\r\n            suffixPos      = null,\r\n            commentAtStart = true,\r\n            isBlockComment = false,\r\n            canComment     = false,\r\n            invalidComment = false,\r\n            lineUncomment  = false,\r\n            result         = true,\r\n            editGroup      = [],\r\n            edit;\r\n        \r\n        var searchCtx, atSuffix, suffixEnd, initialPos, endLine;\r\n        \r\n        if (!selectionsToTrack) {\r\n            // Track the original selection.\r\n            selectionsToTrack = [_.cloneDeep(sel)];\r\n        }\r\n        \r\n        // First move the context to the first none white-space token\r\n        if (!ctx.token.type && !/\\S/.test(ctx.token.string)) {\r\n            result = TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx);\r\n        }\r\n        \r\n        // Next, move forwards until we find a comment inside the selection\r\n        while (result && ctx.token.type !== "comment") {\r\n            result = TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx) && editor.indexFromPos(ctx.pos) <= selEndIndex;\r\n            commentAtStart = false;\r\n        }\r\n        \r\n        // We are now in a comment, lets check if it is a block or a line comment\r\n        if (result && ctx.token.type === "comment") {\r\n            // This token might be at a line comment, but we can\'t be sure yet\r\n            if (_matchExpressions(ctx.token.string, lineExp)) {\r\n                // If the token starts at ch 0 with no starting white spaces, then this might be a block comment or a line\r\n                // comment over the whole line, and if we found this comment at the start of the selection, we need to search\r\n                // backwards until we get can tell if we are in a block or a line comment\r\n                if (ctx.token.start === 0 && !ctx.token.string.match(/^\\\\s*/) && commentAtStart) {\r\n                    searchCtx      = TokenUtils.getInitialContext(editor._codeMirror, {line: ctx.pos.line, ch: ctx.token.start});\r\n                    isBlockComment = _isPrevTokenABlockComment(searchCtx, prefix, suffix, prefixExp, suffixExp, lineExp);\r\n                \r\n                // If not, we already know that is a line comment\r\n                } else {\r\n                    isBlockComment = false;\r\n                }\r\n                \r\n            // If it was not a line comment, it has to be a block comment\r\n            } else {\r\n                isBlockComment = true;\r\n                \r\n                // If we are in a line that only has a prefix or a suffix and the prefix and suffix are the same string,\r\n                // lets find first if this is a prefix or suffix and move the context position to the inside of the block comment.\r\n                // This means that the token will be anywere inside the block comment, including the lines with the delimiters.\r\n                // This is required so that later we can find the prefix by moving backwards and the suffix by moving forwards.\r\n                if (ctx.token.string === prefix && prefix === suffix) {\r\n                    searchCtx = TokenUtils.getInitialContext(editor._codeMirror, {line: ctx.pos.line, ch: ctx.token.start});\r\n                    atSuffix  = _isPrevTokenABlockComment(searchCtx, prefix, suffix, prefixExp, suffixExp, lineExp);\r\n                    if (atSuffix) {\r\n                        TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx);\r\n                    } else {\r\n                        TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx);\r\n                    }\r\n                }\r\n            }\r\n            \r\n            if (isBlockComment) {\r\n                // Save the initial position to start searching for the suffix from here\r\n                initialPos = _.cloneDeep(ctx.pos);\r\n                \r\n                // Find the position of the start of the prefix\r\n                result = true;\r\n                while (result && !ctx.token.string.match(prefixExp)) {\r\n                    result = TokenUtils.moveSkippingWhitespace(TokenUtils.movePrevToken, ctx);\r\n                }\r\n                prefixPos = result && {line: ctx.pos.line, ch: ctx.token.start};\r\n                \r\n                // Restore the context at the initial position to find the position of the start of the suffix,\r\n                // but only when we found the prefix alone in one line\r\n                if (ctx.token.string === prefix && prefix === suffix) {\r\n                    ctx = TokenUtils.getInitialContext(editor._codeMirror, _.cloneDeep(initialPos));\r\n                }\r\n                \r\n                while (result && !ctx.token.string.match(suffixExp)) {\r\n                    result = TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx);\r\n                }\r\n                suffixPos = result && {line: ctx.pos.line, ch: ctx.token.end - suffix.length};\r\n                \r\n                // Lets check if there are more comments in the selection. We do nothing if there is one\r\n                do {\r\n                    result = TokenUtils.moveSkippingWhitespace(TokenUtils.moveNextToken, ctx) &&\r\n                        editor.indexFromPos(ctx.pos) <= selEndIndex;\r\n                } while (result && !ctx.token.string.match(prefixExp));\r\n                invalidComment = result && !!ctx.token.string.match(prefixExp);\r\n                \r\n                // Make sure we didn\'t search so far backward or forward that we actually found a block comment\r\n                // that\'s entirely before or after the selection.\r\n                suffixEnd = suffixPos && { line: suffixPos.line, ch: suffixPos.ch + suffix.length };\r\n                if ((suffixEnd && CodeMirror.cmpPos(sel.start, suffixEnd) > 0) || (prefixPos && CodeMirror.cmpPos(sel.end, prefixPos) < 0)) {\r\n                    canComment = true;\r\n                }\r\n\r\n            } else {\r\n                // In full-line selection, cursor pos is at the start of next line - but don\'t want to modify that line\r\n                endLine = sel.end.line;\r\n                if (sel.end.ch === 0 && editor.hasSelection()) {\r\n                    endLine--;\r\n                }\r\n                // Find if all the lines are line-commented.\r\n                if (!_containsNotLineComment(editor, sel.start.line, endLine, lineExp)) {\r\n                    lineUncomment = true;\r\n                } else {\r\n                    canComment = true;\r\n                }\r\n            }\r\n        // If not, we can comment\r\n        } else {\r\n            canComment = true;\r\n        }\r\n\r\n\r\n        // Make the edit\r\n        if (invalidComment) {\r\n            // We don\'t want to do an edit, but we still want to track selections associated with it.\r\n            edit = {edit: [], selection: selectionsToTrack};\r\n\r\n        } else if (lineUncomment) {\r\n            // Return a null edit. This is a signal to the caller that we should delegate to the\r\n            // line commenting code. We don\'t want to just generate the edit here, because the edit\r\n            // might need to be coalesced with other line-uncomment edits generated by cursors on the\r\n            // same line.\r\n            edit = null;\r\n\r\n        } else {\r\n            // Comment out - add the suffix to the start and the prefix to the end.\r\n            if (canComment) {\r\n                var completeLineSel = sel.start.ch === 0 && sel.end.ch === 0 && sel.start.line < sel.end.line;\r\n                if (completeLineSel) {\r\n                    editGroup.push({text: suffix + "\\n", start: sel.end});\r\n                    editGroup.push({text: prefix + "\\n", start: sel.start});\r\n                } else {\r\n                    editGroup.push({text: suffix, start: sel.end});\r\n                    editGroup.push({text: prefix, start: sel.start});\r\n                }\r\n\r\n                // Correct the tracked selections. We can\'t just use the default selection fixup,\r\n                // because it will push the end of the selection past the inserted content. Also,\r\n                // it\'s possible that we have to deal with tracked selections that might be outside\r\n                // the bounds of the edit.\r\n                _.each(selectionsToTrack, function (trackedSel) {\r\n                    function updatePosForEdit(pos) {\r\n                        // First adjust for the suffix insertion. Don\'t adjust\r\n                        // positions that are exactly at the suffix insertion point.\r\n                        if (CodeMirror.cmpPos(pos, sel.end) > 0) {\r\n                            if (completeLineSel) {\r\n                                pos.line++;\r\n                            } else if (pos.line === sel.end.line) {\r\n                                pos.ch += suffix.length;\r\n                            }\r\n                        }\r\n                        // Now adjust for the prefix insertion. In this case, we do\r\n                        // want to adjust positions that are exactly at the insertion \r\n                        // point.\r\n                        if (CodeMirror.cmpPos(pos, sel.start) >= 0) {\r\n                            if (completeLineSel) {\r\n                                // Just move the line down.\r\n                                pos.line++;\r\n                            } else if (pos.line === sel.start.line) {\r\n                                pos.ch += prefix.length;\r\n                            }\r\n                        }\r\n                    }\r\n                    \r\n                    updatePosForEdit(trackedSel.start);\r\n                    updatePosForEdit(trackedSel.end);\r\n                });\r\n\r\n            // Uncomment - remove prefix and suffix.\r\n            } else {\r\n                // Find if the prefix and suffix are at the ch 0 and if they are the only thing in the line.\r\n                // If both are found we assume that a complete line selection comment added new lines, so we remove them.\r\n                var line          = doc.getLine(prefixPos.line).trim(),\r\n                    prefixAtStart = prefixPos.ch === 0 && prefix.length === line.length,\r\n                    suffixAtStart = false;\r\n                \r\n                if (suffixPos) {\r\n                    line = doc.getLine(suffixPos.line).trim();\r\n                    suffixAtStart = suffixPos.ch === 0 && suffix.length === line.length;\r\n                }\r\n\r\n                // Remove the suffix if there is one\r\n                if (suffixPos) {\r\n                    if (prefixAtStart && suffixAtStart) {\r\n                        editGroup.push({text: "", start: suffixPos, end: {line: suffixPos.line + 1, ch: 0}});\r\n                    } else {\r\n                        editGroup.push({text: "", start: suffixPos, end: {line: suffixPos.line, ch: suffixPos.ch + suffix.length}});\r\n                    }\r\n                }\r\n\r\n                // Remove the prefix\r\n                if (prefixAtStart && suffixAtStart) {\r\n                    editGroup.push({text: "", start: prefixPos, end: {line: prefixPos.line + 1, ch: 0}});\r\n                } else {\r\n                    editGroup.push({text: "", start: prefixPos, end: {line: prefixPos.line, ch: prefixPos.ch + prefix.length}});\r\n                }\r\n\r\n                // Don\'t fix up the tracked selections here - let the edit fix them up.\r\n                _.each(selectionsToTrack, function (trackedSel) {\r\n                    trackedSel.isBeforeEdit = true;\r\n                });\r\n            }\r\n\r\n            edit = {edit: editGroup, selection: selectionsToTrack};\r\n        }\r\n        \r\n        return edit;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Generates an edit that adds or removes block-comment tokens to the selection, preserving selection\r\n     * and cursor position. Applies to the currently focused Editor. The selection must already be a\r\n     * line selection in the form returned by `Editor.convertToLineSelections()`.\r\n     * \r\n     * The implementation uses blockCommentPrefixSuffix, with the exception of the case where\r\n     * there is no selection on a uncommented and not empty line. In this case the whole lines gets\r\n     * commented in a block-comment.\r\n     *\r\n     * @param {!Editor} editor\r\n     * @param {!String} prefix\r\n     * @param {!String} suffix\r\n     * @param {!{selectionForEdit: {start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}, \r\n     *           selectionsToTrack: Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, reversed:boolean, primary:boolean}>}}\r\n     *      lineSel A line selection as returned from `Editor.convertToLineSelections()`. `selectionForEdit` is the selection to perform\r\n     *      the line comment operation on, and `selectionsToTrack` are a set of selections associated with this line that need to be\r\n     *      tracked through the edit.\r\n     * @return {{edit: {text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}|Array.<{text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}>,\r\n     *                  selection: {start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}|\r\n     *                  Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}}\r\n     *      An edit description suitable for including in the edits array passed to `Document.doMultipleEdits()`.\r\n     */\r\n    function _getLineCommentPrefixSuffixEdit(editor, prefix, suffix, lineSel) {\r\n        var sel             = lineSel.selectionForEdit,\r\n            selStart        = sel.start,\r\n            selEnd          = sel.end,\r\n            edit;\r\n        \r\n        // For one-line selections, we shrink the selection to exclude the trailing newline.\r\n        if (sel.end.line === sel.start.line + 1 && sel.end.ch === 0) {\r\n            sel.end = {line: sel.start.line, ch: editor.document.getLine(sel.start.line).length};\r\n        }\r\n        \r\n        // Now just run the standard block comment code, but make sure to track any associated selections\r\n        // that were subsumed into this line selection.\r\n        return _getBlockCommentPrefixSuffixEdit(editor, prefix, suffix, [], sel, lineSel.selectionsToTrack);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Generates an array of edits for toggling line comments on the given selections.\r\n     *\r\n     * @param {!Editor} editor The editor to edit within.\r\n     * @param {Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}\r\n     *      selections The selections we want to line-comment.\r\n     * @return {Array.<{edit: {text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}|Array.<{text: string, start:{line: number, ch: number}, end:?{line: number, ch: number}}>,\r\n     *                  selection: {start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}|\r\n     *                  Array.<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean, isBeforeEdit: boolean}>}>}\r\n     *      An array of edit descriptions suitable for including in the edits array passed to `Document.doMultipleEdits()`.\r\n     */\r\n    function _getLineCommentEdits(editor, selections) {\r\n        // We need to expand line selections in order to coalesce cursors on the same line, but we\r\n        // don\'t want to merge adjacent line selections.\r\n        var lineSelections = editor.convertToLineSelections(selections, { mergeAdjacent: false }),\r\n            edits = [];\r\n        _.each(lineSelections, function (lineSel) {\r\n            var sel = lineSel.selectionForEdit,\r\n                mode = editor.getModeForRange(sel.start, sel.end),\r\n                edit;\r\n            if (mode) {\r\n                var language = editor.document.getLanguage().getLanguageForMode(mode.name || mode);\r\n\r\n                if (language.hasLineCommentSyntax()) {\r\n                    edit = _getLineCommentPrefixEdit(editor, language.getLineCommentPrefixes(), language.getBlockCommentPrefix(), language.getBlockCommentSuffix(), lineSel);\r\n                } else if (language.hasBlockCommentSyntax()) {\r\n                    edit = _getLineCommentPrefixSuffixEdit(editor, language.getBlockCommentPrefix(), language.getBlockCommentSuffix(), lineSel);\r\n                }\r\n            }\r\n            if (!edit) {\r\n                // Even if we didn\'t want to do an edit, we still need to track the selection.\r\n                edit = {selection: lineSel.selectionsToTrack};\r\n            }\r\n            edits.push(edit);\r\n        });\r\n        return edits;\r\n    }\r\n    \r\n    /**\r\n     * Invokes a language-specific line-comment/uncomment handler\r\n     * @param {?Editor} editor If unspecified, applies to the currently focused editor\r\n     */\r\n    function lineComment(editor) {\r\n        editor = editor || EditorManager.getFocusedEditor();\r\n        if (!editor) {\r\n            return;\r\n        }\r\n        \r\n        editor.setSelections(editor.document.doMultipleEdits(_getLineCommentEdits(editor, editor.getSelections())));\r\n    }\r\n    \r\n    /**\r\n     * Invokes a language-specific block-comment/uncomment handler\r\n     * @param {?Editor} editor If unspecified, applies to the currently focused editor\r\n     */\r\n    function blockComment(editor) {\r\n        editor = editor || EditorManager.getFocusedEditor();\r\n        if (!editor) {\r\n            return;\r\n        }\r\n        \r\n        var edits = [],\r\n            lineCommentSels = [];\r\n        _.each(editor.getSelections(), function (sel) {\r\n            var mode = editor.getModeForRange(sel.start, sel.end),\r\n                edit = {edit: [], selection: [sel]}; // default edit in case we don\'t have a mode for this selection\r\n            if (mode) {\r\n                var language = editor.document.getLanguage().getLanguageForMode(mode.name || mode);\r\n\r\n                if (language.hasBlockCommentSyntax()) {\r\n                    // getLineCommentPrefixes always return an array, and will be empty if no line comment syntax is defined\r\n                    edit = _getBlockCommentPrefixSuffixEdit(editor, language.getBlockCommentPrefix(), language.getBlockCommentSuffix(),\r\n                                                            language.getLineCommentPrefixes(), sel);\r\n                    if (!edit) {\r\n                        // This is only null if the block comment code found that the selection is within a line-commented line.\r\n                        // Add this to the list of line-comment selections we need to handle. Since edit is null, we\'ll skip\r\n                        // pushing anything onto the edit list for this selection.\r\n                        lineCommentSels.push(sel);\r\n                    }\r\n                }\r\n            }\r\n            if (edit) {\r\n                edits.push(edit);\r\n            }\r\n        });\r\n        \r\n        // Handle any line-comment edits. It\'s okay if these are out-of-order with the other edits, since\r\n        // they shouldn\'t overlap, and `doMultipleEdits()` will take care of sorting the edits so the\r\n        // selections can be tracked appropriately.\r\n        edits.push.apply(edits, _getLineCommentEdits(editor, lineCommentSels));\r\n        \r\n        editor.setSelections(editor.document.doMultipleEdits(edits));\r\n    }\r\n        \r\n    /**\r\n     * Duplicates the selected text, or current line if no selection. The cursor/selection is left\r\n     * on the second copy.\r\n     */\r\n    function duplicateText(editor) {\r\n        editor = editor || EditorManager.getFocusedEditor();\r\n        if (!editor) {\r\n            return;\r\n        }\r\n\r\n        var selections = editor.getSelections(),\r\n            delimiter = "",\r\n            edits = [],\r\n            rangeSels = [],\r\n            cursorSels = [],\r\n            doc = editor.document;\r\n\r\n        // When there are multiple selections, we want to handle all the cursors first (duplicating\r\n        // their lines), then all the ranges (duplicating the ranges).\r\n        _.each(selections, function (sel) {\r\n            if (CodeMirror.cmpPos(sel.start, sel.end) === 0) {\r\n                cursorSels.push(sel);\r\n            } else {\r\n                rangeSels.push(sel);\r\n            }\r\n        });\r\n        \r\n        var cursorLineSels = editor.convertToLineSelections(cursorSels);\r\n        _.each(cursorLineSels, function (lineSel, index) {\r\n            var sel = lineSel.selectionForEdit;\r\n            if (sel.end.line === editor.lineCount()) {\r\n                delimiter = "\\n";\r\n            }\r\n            // Don\'t need to explicitly track selections since we are doing the edits in such a way that\r\n            // the existing selections will get appropriately updated.\r\n            edits.push({edit: {text: doc.getRange(sel.start, sel.end) + delimiter, start: sel.start }});\r\n        });\r\n        _.each(rangeSels, function (sel) {\r\n            edits.push({edit: {text: doc.getRange(sel.start, sel.end), start: sel.start }});\r\n        });\r\n\r\n        doc.doMultipleEdits(edits);\r\n    }\r\n\r\n    /**\r\n     * Deletes the current line if there is no selection or the lines for the selection\r\n     * (removing the end of line too)\r\n     */\r\n    function deleteCurrentLines(editor) {\r\n        editor = editor || EditorManager.getFocusedEditor();\r\n        if (!editor) {\r\n            return;\r\n        }\r\n        \r\n        // Walk the selections, calculating the deletion edits we need to do as we go;\r\n        // document.doMultipleEdits() will take care of adjusting the edit locations when\r\n        // it actually performs the edits.\r\n        var doc = editor.document,\r\n            from,\r\n            to,\r\n            lineSelections = editor.convertToLineSelections(editor.getSelections()),\r\n            edits = [];\r\n        \r\n        _.each(lineSelections, function (lineSel, index) {\r\n            var sel = lineSel.selectionForEdit,\r\n                selStartLine = sel.start.line;\r\n\r\n            from = sel.start;\r\n            to = sel.end; // this is already at the beginning of the line after the last selected line\r\n            if (to.line === editor.getLastVisibleLine() + 1) {\r\n                // Instead of deleting the newline after the last line, delete the newline\r\n                // before the beginning of the line--unless this is the entire visible content \r\n                // of the editor, in which case just delete the line content.\r\n                if (from.line > editor.getFirstVisibleLine()) {\r\n                    from.line -= 1;\r\n                    from.ch = doc.getLine(from.line).length;\r\n                }\r\n                to.line -= 1;\r\n                to.ch = doc.getLine(to.line).length;\r\n            }\r\n\r\n            // We don\'t need to track the original selections, since they\'ll get collapsed as\r\n            // part of the various deletions that occur.\r\n            edits.push({edit: {text: "", start: from, end: to}});\r\n        });\r\n        doc.doMultipleEdits(edits);\r\n    }\r\n    \r\n    /**\r\n     * Moves the selected text, or current line if no selection. The cursor/selection \r\n     * moves with the line/lines.\r\n     * @param {Editor} editor - target editor\r\n     * @param {Number} direction - direction of the move (-1,+1) => (Up,Down)\r\n     */\r\n    function moveLine(editor, direction) {\r\n        editor = editor || EditorManager.getFocusedEditor();\r\n        if (!editor) {\r\n            return;\r\n        }\r\n        \r\n        var doc             = editor.document,\r\n            lineSelections  = editor.convertToLineSelections(editor.getSelections()),\r\n            isInlineWidget  = !!EditorManager.getFocusedInlineWidget(),\r\n            firstLine       = editor.getFirstVisibleLine(),\r\n            lastLine        = editor.getLastVisibleLine(),\r\n            totalLines      = editor.lineCount(),\r\n            lineLength      = 0,\r\n            edits           = [],\r\n            newSels         = [],\r\n            pos             = {};\r\n        \r\n        _.each(lineSelections, function (lineSel) {\r\n            var sel = lineSel.selectionForEdit,\r\n                editGroup = [];\r\n\r\n            // Make the move\r\n            switch (direction) {\r\n            case DIRECTION_UP:\r\n                if (sel.start.line !== firstLine) {\r\n                    var prevText = doc.getRange({ line: sel.start.line - 1, ch: 0 }, sel.start);\r\n\r\n                    if (sel.end.line === lastLine + 1) {\r\n                        if (isInlineWidget) {\r\n                            prevText   = prevText.substring(0, prevText.length - 1);\r\n                            lineLength = doc.getLine(sel.end.line - 1).length;\r\n                            editGroup.push({text: "\\n", start: { line: sel.end.line - 1, ch: lineLength }});\r\n                        } else {\r\n                            prevText = "\\n" + prevText.substring(0, prevText.length - 1);\r\n                        }\r\n                    }\r\n\r\n                    editGroup.push({text: "", start: { line: sel.start.line - 1, ch: 0 }, end: sel.start});\r\n                    editGroup.push({text: prevText, start: { line: sel.end.line - 1, ch: 0 }});\r\n\r\n                    // Make sure CodeMirror hasn\'t expanded the selection to include\r\n                    // the line we inserted below.\r\n                    _.each(lineSel.selectionsToTrack, function (originalSel) {\r\n                        originalSel.start.line--;\r\n                        originalSel.end.line--;\r\n                    });\r\n\r\n                    edits.push({edit: editGroup, selection: lineSel.selectionsToTrack});\r\n                }\r\n                break;\r\n            case DIRECTION_DOWN:\r\n                if (sel.end.line <= lastLine) {\r\n                    var nextText      = doc.getRange(sel.end, { line: sel.end.line + 1, ch: 0 }),\r\n                        deletionStart = sel.end;\r\n\r\n                    if (sel.end.line === lastLine) {\r\n                        if (isInlineWidget) {\r\n                            if (sel.end.line === totalLines - 1) {\r\n                                nextText += "\\n";\r\n                            }\r\n                            lineLength = doc.getLine(sel.end.line - 1).length;\r\n                            editGroup.push({text: "\\n", start: { line: sel.end.line, ch: doc.getLine(sel.end.line).length }});\r\n                        } else {\r\n                            nextText     += "\\n";\r\n                            deletionStart = { line: sel.end.line - 1, ch: doc.getLine(sel.end.line - 1).length };\r\n                        }\r\n                    }\r\n\r\n                    editGroup.push({text: "", start: deletionStart, end: { line: sel.end.line + 1, ch: 0 }});\r\n                    if (lineLength) {\r\n                        editGroup.push({text: "", start: { line: sel.end.line - 1, ch: lineLength }, end: { line: sel.end.line, ch: 0 }});\r\n                    }\r\n                    editGroup.push({text: nextText, start: { line: sel.start.line, ch: 0 }});\r\n                    \r\n                    // In this case, we don\'t need to track selections, because the edits are done in such a way that\r\n                    // the existing selections will automatically be updated properly by CodeMirror as it does the edits.\r\n                    edits.push({edit: editGroup});\r\n                }\r\n                break;\r\n            }\r\n        });\r\n\r\n        // Make sure selections are correct and primary selection is scrolled into view\r\n        if (edits.length) {\r\n            newSels = doc.doMultipleEdits(edits);\r\n\r\n            pos.ch = 0;\r\n\r\n            if (direction === DIRECTION_UP) {\r\n                editor.setSelections(newSels);\r\n                pos.line = editor.getSelection().start.line;\r\n            } else if (direction === DIRECTION_DOWN) {\r\n                pos.line = editor.getSelection().end.line;\r\n            } else {\r\n                console.error("EditorCommandHandler.moveLine() called with invalid argument \'direction\' = %d", direction);\r\n                pos = null;\r\n            }\r\n\r\n            editor._codeMirror.scrollIntoView(pos);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Moves the selected text, or current line if no selection, one line up. The cursor/selection \r\n     * moves with the line/lines.\r\n     */\r\n    function moveLineUp(editor) {\r\n        moveLine(editor, DIRECTION_UP);\r\n    }\r\n    \r\n    /**\r\n     * Moves the selected text, or current line if no selection, one line down. The cursor/selection \r\n     * moves with the line/lines.\r\n     */\r\n    function moveLineDown(editor) {\r\n        moveLine(editor, DIRECTION_DOWN);\r\n    }\r\n\r\n    /**\r\n     * Inserts a new and smart indented line above/below the selected text, or current line if no selection.\r\n     * The cursor is moved in the new line.\r\n     * @param {Editor} editor - target editor\r\n     * @param {Number} direction - direction where to place the new line (-1,+1) => (Up,Down)\r\n     */\r\n    function openLine(editor, direction) {\r\n        editor = editor || EditorManager.getFocusedEditor();\r\n        if (!editor) {\r\n            return;\r\n        }\r\n        \r\n        var selections     = editor.getSelections(),\r\n            isInlineWidget = !!EditorManager.getFocusedInlineWidget(),\r\n            lastLine       = editor.getLastVisibleLine(),\r\n            doc            = editor.document,\r\n            edits          = [],\r\n            newSelections,\r\n            line;\r\n        \r\n        // First, insert all the newlines (skipping multiple selections on the same line), \r\n        // then indent them all. (We can\'t easily do them all at once, because doMultipleEdits()\r\n        // won\'t do the indentation for us, but we want its help tracking any selection changes\r\n        // as the result of the edits.)\r\n        \r\n        // Note that we don\'t just use `editor.getLineSelections()` here because we don\'t actually want\r\n        // to coalesce adjacent selections - we just want to ignore dupes.\r\n        \r\n        doc.batchOperation(function () {\r\n            _.each(selections, function (sel, index) {\r\n                if (index === 0 ||\r\n                        (direction === DIRECTION_UP && sel.start.line > selections[index - 1].start.line) ||\r\n                        (direction === DIRECTION_DOWN && sel.end.line > selections[index - 1].end.line)) {\r\n                    // Insert the new line\r\n                    switch (direction) {\r\n                    case DIRECTION_UP:\r\n                        line = sel.start.line;\r\n                        break;\r\n                    case DIRECTION_DOWN:\r\n                        line = sel.end.line;\r\n                        if (!(CodeMirror.cmpPos(sel.start, sel.end) !== 0 && sel.end.ch === 0)) {\r\n                            // If not linewise selection\r\n                            line++;\r\n                        }\r\n                        break;\r\n                    }\r\n\r\n                    var insertPos;\r\n                    if (line > lastLine && isInlineWidget) {\r\n                        insertPos = {line: line - 1, ch: doc.getLine(line - 1).length};\r\n                    } else {\r\n                        insertPos = {line: line, ch: 0};\r\n                    }\r\n                    // We want the selection after this edit to be right before the \\n we just inserted.\r\n                    edits.push({edit: {text: "\\n", start: insertPos}, selection: {start: insertPos, end: insertPos, primary: sel.primary}});\r\n                } else {\r\n                    // We just want to discard this selection, since we\'ve already operated on the\r\n                    // same line and it would just collapse to the same location. But if this was\r\n                    // primary, make sure the last selection we did operate on ends up as primary.\r\n                    if (sel.primary) {\r\n                        edits[edits.length - 1].selections[0].primary = true;\r\n                    }\r\n                }\r\n            });\r\n            newSelections = doc.doMultipleEdits(edits, "+input");\r\n            \r\n            // Now indent each added line (which doesn\'t mess up any line numbers, and\r\n            // we\'re going to set the character offset to the last position on each line anyway).\r\n            _.each(newSelections, function (sel) {\r\n                // This is a bit of a hack. The document is the one that batches operations, but we want\r\n                // to use CodeMirror\'s "smart indent" operation. So we need to use the document\'s own backing editor\'s\r\n                // CodeMirror to do the indentation. A better way to fix this would be to expose this\r\n                // operation on Document, but I\'m not sure we want to sign up for that as a public API.\r\n                doc._masterEditor._codeMirror.indentLine(sel.start.line, "smart", true);\r\n                sel.start.ch = null; // last character on line\r\n                sel.end = sel.start;\r\n            });\r\n        });\r\n        editor.setSelections(newSelections);\r\n    }\r\n\r\n    /**\r\n     * Inserts a new and smart indented line above the selected text, or current line if no selection.\r\n     * The cursor is moved in the new line.\r\n     * @param {Editor} editor - target editor\r\n     */\r\n    function openLineAbove(editor) {\r\n        openLine(editor, DIRECTION_UP);\r\n    }\r\n\r\n    /**\r\n     * Inserts a new and smart indented line below the selected text, or current line if no selection.\r\n     * The cursor is moved in the new line.\r\n     * @param {Editor} editor - target editor\r\n     */\r\n    function openLineBelow(editor) {\r\n        openLine(editor, DIRECTION_DOWN);\r\n    }\r\n\r\n    /**\r\n     * Indent a line of text if no selection. Otherwise, indent all lines in selection.\r\n     */\r\n    function indentText() {\r\n        var editor = EditorManager.getFocusedEditor();\r\n        if (!editor) {\r\n            return;\r\n        }\r\n        \r\n        editor._codeMirror.execCommand("indentMore");\r\n    }\r\n    \r\n    /**\r\n     * Unindent a line of text if no selection. Otherwise, unindent all lines in selection.\r\n     */\r\n    function unindentText() {\r\n        var editor = EditorManager.getFocusedEditor();\r\n        if (!editor) {\r\n            return;\r\n        }\r\n        \r\n        editor._codeMirror.execCommand("indentLess");\r\n    }\r\n\r\n    function selectLine(editor) {\r\n        editor = editor || EditorManager.getFocusedEditor();\r\n        if (editor) {\r\n            // We can just use `convertToLineSelections`, but throw away the original tracked selections and just use the\r\n            // coalesced selections.\r\n            editor.setSelections(_.pluck(editor.convertToLineSelections(editor.getSelections(), { expandEndAtStartOfLine: true }), "selectionForEdit"));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Takes the current selection and splits each range into separate selections, one per line.\r\n     * @param {!Editor} editor The editor to operate on.\r\n     */\r\n    function splitSelIntoLines(editor) {\r\n        editor = editor || EditorManager.getFocusedEditor();\r\n        if (editor) {\r\n            editor._codeMirror.execCommand("splitSelectionByLine");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Adds a cursor on the next/previous line after/before each selected range to the selection.\r\n     * @param {!Editor} editor The editor to operate on.\r\n     * @param {number} dir The direction to add - 1 is down, -1 is up.\r\n     */\r\n    function addCursorToSelection(editor, dir) {\r\n        editor = editor || EditorManager.getFocusedEditor();\r\n        if (editor) {\r\n            var origSels = editor.getSelections(),\r\n                newSels = [];\r\n            _.each(origSels, function (sel) {\r\n                var pos, colOffset;\r\n                if ((dir === -1 && sel.start.line > editor.getFirstVisibleLine()) || (dir === 1 && sel.end.line < editor.getLastVisibleLine())) {\r\n                    // Add a new cursor on the next line up/down. It\'s okay if it overlaps another selection, because CM\r\n                    // will take care of throwing it away in that case. It will also take care of clipping the char position\r\n                    // to the end of the new line if the line is shorter.\r\n                    pos = _.clone(dir === -1 ? sel.start : sel.end);\r\n\r\n                    // get sel column of current selection\r\n                    colOffset = editor.getColOffset(pos);\r\n\r\n                    pos.line += dir;\r\n\r\n                    // translate column to ch in line of new selection\r\n                    pos.ch = editor.getCharIndexForColumn(pos.line, colOffset);\r\n\r\n\r\n                    // If this is the primary selection, we want the new cursor we\'re adding to become the\r\n                    // primary selection.\r\n                    newSels.push({start: pos, end: pos, primary: sel.primary});\r\n                    sel.primary = false;\r\n                }\r\n            });\r\n            // CM will take care of sorting the selections.\r\n            editor.setSelections(origSels.concat(newSels));\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Adds a cursor on the previous line before each selected range to the selection.\r\n     * @param {!Editor} editor The editor to operate on.\r\n     */\r\n    function addCursorToPrevLine(editor) {\r\n        addCursorToSelection(editor, -1);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Adds a cursor on the next line after each selected range to the selection.\r\n     * @param {!Editor} editor The editor to operate on.\r\n     */\r\n    function addCursorToNextLine(editor) {\r\n        addCursorToSelection(editor, 1);\r\n    }\r\n\r\n    function handleUndoRedo(operation) {\r\n        var editor = EditorManager.getFocusedEditor();\r\n        var result = new $.Deferred();\r\n        \r\n        if (editor) {\r\n            editor[operation]();\r\n            result.resolve();\r\n        } else {\r\n            result.reject();\r\n        }\r\n        \r\n        return result.promise();\r\n    }\r\n\r\n    function handleUndo() {\r\n        return handleUndoRedo("undo");\r\n    }\r\n\r\n    function handleRedo() {\r\n        return handleUndoRedo("redo");\r\n    }\r\n\r\n    /**\r\n     * Special command handler that just ignores the command. This is used for Cut, Copy, and Paste.\r\n     * These menu items are handled natively, but need to be registered in our JavaScript code so the \r\n     * menu items can be created.\r\n     */\r\n    function ignoreCommand() {\r\n        // Do nothing. The shell will call the native handler for the command.\r\n        return (new $.Deferred()).reject().promise();\r\n    }\r\n	\r\n	function _handleSelectAll() {\r\n        var result = new $.Deferred(),\r\n            editor = EditorManager.getFocusedEditor();\r\n\r\n        if (editor) {\r\n            editor.selectAllNoScroll();\r\n            result.resolve();\r\n        } else {\r\n            result.reject();    // command not handled\r\n        }\r\n\r\n        return result.promise();\r\n    }\r\n        \r\n    // Register commands\r\n    CommandManager.register(Strings.CMD_INDENT,                 Commands.EDIT_INDENT,                 indentText);\r\n    CommandManager.register(Strings.CMD_UNINDENT,               Commands.EDIT_UNINDENT,               unindentText);\r\n    CommandManager.register(Strings.CMD_COMMENT,                Commands.EDIT_LINE_COMMENT,           lineComment);\r\n    CommandManager.register(Strings.CMD_BLOCK_COMMENT,          Commands.EDIT_BLOCK_COMMENT,          blockComment);\r\n    CommandManager.register(Strings.CMD_DUPLICATE,              Commands.EDIT_DUPLICATE,              duplicateText);\r\n    CommandManager.register(Strings.CMD_DELETE_LINES,           Commands.EDIT_DELETE_LINES,           deleteCurrentLines);\r\n    CommandManager.register(Strings.CMD_LINE_UP,                Commands.EDIT_LINE_UP,                moveLineUp);\r\n    CommandManager.register(Strings.CMD_LINE_DOWN,              Commands.EDIT_LINE_DOWN,              moveLineDown);\r\n    CommandManager.register(Strings.CMD_OPEN_LINE_ABOVE,        Commands.EDIT_OPEN_LINE_ABOVE,        openLineAbove);\r\n    CommandManager.register(Strings.CMD_OPEN_LINE_BELOW,        Commands.EDIT_OPEN_LINE_BELOW,        openLineBelow);\r\n    CommandManager.register(Strings.CMD_SELECT_LINE,            Commands.EDIT_SELECT_LINE,            selectLine);\r\n    CommandManager.register(Strings.CMD_SPLIT_SEL_INTO_LINES,   Commands.EDIT_SPLIT_SEL_INTO_LINES,   splitSelIntoLines);\r\n    CommandManager.register(Strings.CMD_ADD_CUR_TO_NEXT_LINE,   Commands.EDIT_ADD_CUR_TO_NEXT_LINE,   addCursorToNextLine);\r\n    CommandManager.register(Strings.CMD_ADD_CUR_TO_PREV_LINE,   Commands.EDIT_ADD_CUR_TO_PREV_LINE,   addCursorToPrevLine);\r\n\r\n    CommandManager.register(Strings.CMD_UNDO,                   Commands.EDIT_UNDO,                   handleUndo);\r\n    CommandManager.register(Strings.CMD_REDO,                   Commands.EDIT_REDO,                   handleRedo);\r\n    CommandManager.register(Strings.CMD_CUT,                    Commands.EDIT_CUT,                    ignoreCommand);\r\n    CommandManager.register(Strings.CMD_COPY,                   Commands.EDIT_COPY,                   ignoreCommand);\r\n    CommandManager.register(Strings.CMD_PASTE,                  Commands.EDIT_PASTE,                  ignoreCommand);\r\n    CommandManager.register(Strings.CMD_SELECT_ALL,             Commands.EDIT_SELECT_ALL,             _handleSelectAll);\r\n});\r\n\n//# sourceURL=/editor/EditorCommandHandlers.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\ndefine(\'editor/EditorOptionHandlers\',[\'require\',\'exports\',\'module\',\'utils/AppInit\',\'editor/Editor\',\'editor/EditorManager\',\'command/Commands\',\'command/CommandManager\',\'preferences/PreferencesManager\',\'strings\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var AppInit                 = require("utils/AppInit"),\r\n        Editor                  = require("editor/Editor").Editor,\r\n        EditorManager           = require("editor/EditorManager"),\r\n        Commands                = require("command/Commands"),\r\n        CommandManager          = require("command/CommandManager"),\r\n        PreferencesManager      = require("preferences/PreferencesManager"),\r\n        Strings                 = require("strings"),\r\n        _                       = require("thirdparty/lodash");\r\n    \r\n    // Constants for the preferences referred to in this file\r\n    var SHOW_LINE_NUMBERS = "showLineNumbers",\r\n        STYLE_ACTIVE_LINE = "styleActiveLine",\r\n        WORD_WRAP         = "wordWrap",\r\n        CLOSE_BRACKETS    = "closeBrackets";\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Maps from preference names to the command names needed to update the checked status.\r\n     */\r\n    var _optionMapping = {};\r\n    _optionMapping[SHOW_LINE_NUMBERS] = Commands.TOGGLE_LINE_NUMBERS;\r\n    _optionMapping[STYLE_ACTIVE_LINE] = Commands.TOGGLE_ACTIVE_LINE;\r\n    _optionMapping[WORD_WRAP] = Commands.TOGGLE_WORD_WRAP;\r\n    _optionMapping[CLOSE_BRACKETS] = Commands.TOGGLE_CLOSE_BRACKETS;\r\n    \r\n    /**\r\n     * @private\r\n     * \r\n     * Updates the command checked status based on the preference name given.\r\n     * \r\n     * @param {string} name Name of preference that has changed\r\n     */\r\n    function _updateCheckedState(name) {\r\n        var mapping = _optionMapping[name];\r\n        if (!mapping) {\r\n            return;\r\n        }\r\n        CommandManager.get(mapping).setChecked(PreferencesManager.get(name));\r\n    }\r\n    \r\n    // Listen to preference changes for the preferences we care about\r\n    Object.keys(_optionMapping).forEach(function (preference) {\r\n        PreferencesManager.on("change", preference, function () {\r\n            _updateCheckedState(preference);\r\n        });\r\n    });\r\n        \r\n    /**\r\n     * @private\r\n     * Creates a function that will toggle the named preference.\r\n     * \r\n     * @param {string} prefName Name of preference that should be toggled by the function\r\n     */\r\n    function _getToggler(prefName) {\r\n        return function () {\r\n            PreferencesManager.set(prefName, !PreferencesManager.get(prefName));\r\n        };\r\n    }\r\n    \r\n    function _init() {\r\n        _.each(_optionMapping, function (commandName, prefName) {\r\n            CommandManager.get(commandName).setChecked(PreferencesManager.get(prefName));\r\n        });\r\n        \r\n        if (!Editor.getShowLineNumbers()) {\r\n            Editor._toggleLinePadding(true);\r\n        }\r\n    }\r\n    \r\n    CommandManager.register(Strings.CMD_TOGGLE_LINE_NUMBERS, Commands.TOGGLE_LINE_NUMBERS, _getToggler(SHOW_LINE_NUMBERS));\r\n    CommandManager.register(Strings.CMD_TOGGLE_ACTIVE_LINE, Commands.TOGGLE_ACTIVE_LINE, _getToggler(STYLE_ACTIVE_LINE));\r\n    CommandManager.register(Strings.CMD_TOGGLE_WORD_WRAP, Commands.TOGGLE_WORD_WRAP, _getToggler(WORD_WRAP));\r\n    CommandManager.register(Strings.CMD_TOGGLE_CLOSE_BRACKETS, Commands.TOGGLE_CLOSE_BRACKETS, _getToggler(CLOSE_BRACKETS));\r\n\r\n    AppInit.htmlReady(_init);\r\n});\r\n\n//# sourceURL=/editor/EditorOptionHandlers.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets */\r\n\r\n/**\r\n * Utilities for determining the git SHA from an optional repository or from the\r\n * installed copy of Brackets.\r\n */\r\ndefine(\'utils/BuildInfoUtils\',[\'require\',\'exports\',\'module\',\'utils/Global\',\'filesystem/FileSystem\',\'file/FileUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var Global              = require("utils/Global"),\r\n        FileSystem          = require("filesystem/FileSystem"),\r\n        FileUtils           = require("file/FileUtils");\r\n            \r\n    var _bracketsSHA;\r\n    \r\n    /**\r\n     * Loads a SHA from Git metadata file. If the file contains a symbolic ref name, follows the ref\r\n     * and loads the SHA from that file in turn.\r\n     */\r\n    function _loadSHA(path, callback) {\r\n        var result = new $.Deferred();\r\n        \r\n        if (brackets.inBrowser) {\r\n            result.reject();\r\n        } else {\r\n            // HEAD contains a SHA in detached-head mode; otherwise it contains a relative path\r\n            // to a file in /refs which in turn contains the SHA\r\n            var file = FileSystem.getFileForPath(path);\r\n            FileUtils.readAsText(file).done(function (text) {\r\n                if (text.indexOf("ref: ") === 0) {\r\n                    // e.g. "ref: refs/heads/branchname"\r\n                    var basePath    = path.substr(0, path.lastIndexOf("/")),\r\n                        refRelPath  = text.substr(5).trim(),\r\n                        branch      = text.substr(16).trim();\r\n                    \r\n                    _loadSHA(basePath + "/" + refRelPath, callback).done(function (data) {\r\n                        result.resolve({ branch: branch, sha: data.sha.trim() });\r\n                    }).fail(function () {\r\n                        result.resolve({ branch: branch });\r\n                    });\r\n                } else {\r\n                    result.resolve({ sha: text });\r\n                }\r\n            }).fail(function () {\r\n                result.reject();\r\n            });\r\n        }\r\n\r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * @return {$.Promise} A promise resolved with the git branch and SHA\r\n     *     of a local copy of a repository or the branch and SHA\r\n     *     embedded at build-time in the package.json repository metadata.\r\n     */\r\n    function getBracketsSHA() {\r\n        var result = new $.Deferred();\r\n        \r\n        // Look for Git metadata on disk to load the SHAs for \'brackets\'. Done on\r\n        // startup instead of on demand because the version that\'s currently running is what was\r\n        // loaded at startup (the src on disk may be updated to a different version later).\r\n        // Git metadata may be missing (e.g. in the release builds) - silently ignore if so.\r\n        var bracketsSrc = FileUtils.getNativeBracketsDirectoryPath();\r\n        \r\n        // Assumes Brackets is a standalone repo and not a submodule (prior to brackets-shell,\r\n        // brackets-app was setup this way)\r\n        var bracketsGitRoot = bracketsSrc.substr(0, bracketsSrc.lastIndexOf("/")) + "/.git/HEAD";\r\n        \r\n        _loadSHA(bracketsGitRoot).done(function (data) {\r\n            // Found a repository\r\n            result.resolve(data.branch, data.sha, true);\r\n        }).fail(function () {\r\n            // If package.json has repository data, Brackets is running from the installed /www folder\r\n            result.resolve(brackets.metadata.repository.branch, brackets.metadata.repository.SHA, false);\r\n        });\r\n        \r\n        return result.promise();\r\n    }\r\n\r\n    exports.getBracketsSHA      = getBracketsSHA;\r\n    \r\n    // FIXME (jasonsanjose): Since the move to brackets-shell, can\'t reliably get SHA for shell.\r\n    // exports._getBracketsShellSHA = getBracketsShellSHA;\r\n});\r\n\n//# sourceURL=/utils/BuildInfoUtils.js'),eval('define(\'text!htmlContent/about-dialog.html\',[],function () { return \'<div class="about-dialog modal">\\r\\n    <div class="modal-header">\\r\\n        <h1 class="dialog-title">{{Strings.ABOUT}}</h1>\\r\\n    </div>\\r\\n    <div class="modal-body no-padding">\\r\\n        <img class="about-icon" src="{{ABOUT_ICON}}">\\r\\n        <div class="about-text">\\r\\n            <h2>{{APP_NAME_ABOUT_BOX}}</h2>\\r\\n            <div class="about-info">\\r\\n                <p class="dialog-message">{{Strings.ABOUT_TEXT_LINE1}} <span id="about-build-number">{{BUILD_INFO}}</span>\\r\\n                  {{#BUILD_TIMESTAMP}}\\r\\n                  <br><span class="dialog-message">{{Strings.ABOUT_TEXT_BUILD_TIMESTAMP}}{{BUILD_TIMESTAMP}}</span>\\r\\n                  {{/BUILD_TIMESTAMP}}\\r\\n                </p>\\r\\n\\r\\n                <p class="dialog-message"><!-- $NON-NLS$ -->Copyright 2012 - 2014 Adobe Systems Incorporated and its licensors. All rights reserved.</p>\\r\\n                <p class="dialog-message">{{{Strings.ABOUT_TEXT_WEB_PLATFORM_DOCS}}}</p>\\r\\n                <p class="dialog-message">{{{Strings.ABOUT_TEXT_LINE3}}}</p>\\r\\n                <p class="dialog-message">{{{Strings.ABOUT_TEXT_LINE4}}}</p>\\r\\n                <p class="dialog-message">\\r\\n                    {{Strings.ABOUT_TEXT_LINE5}}\\r\\n                    <span class="spinner inline"></span>\\r\\n                </p>\\r\\n                <div class="about-contributors">\\r\\n                </div>\\r\\n            </div>\\r\\n        </div>\\r\\n    </div>\\r\\n    <div class="modal-footer">\\r\\n        <button class="dialog-button btn primary" data-button-id="ok">{{Strings.CLOSE}}</button>\\r\\n    </div>\\r\\n</div>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/about-dialog.html'),eval('define(\'text!htmlContent/contributors-list.html\',[],function () { return \'{{#.}}<a href="{{html_url}}" title="{{login}} - {{html_url}}"><img src="{{avatar_url}}?size=30" alt="{{login}}" width="30" height="30" /></a>{{/.}}\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/contributors-list.html'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets, window, PathUtils, Mustache */\r\n\r\ndefine(\'help/HelpCommandHandlers\',[\'require\',\'exports\',\'module\',\'utils/AppInit\',\'utils/BuildInfoUtils\',\'command/CommandManager\',\'command/Commands\',\'widgets/Dialogs\',\'file/FileUtils\',\'utils/Global\',\'utils/NativeApp\',\'strings\',\'utils/StringUtils\',\'utils/UpdateNotification\',\'text!htmlContent/about-dialog.html\',\'text!htmlContent/contributors-list.html\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var AppInit                 = require("utils/AppInit"),\r\n        BuildInfoUtils          = require("utils/BuildInfoUtils"),\r\n        CommandManager          = require("command/CommandManager"),\r\n        Commands                = require("command/Commands"),\r\n        Dialogs                 = require("widgets/Dialogs"),\r\n        FileUtils               = require("file/FileUtils"),\r\n        Global                  = require("utils/Global"),\r\n        NativeApp               = require("utils/NativeApp"),\r\n        Strings                 = require("strings"),\r\n        StringUtils             = require("utils/StringUtils"),\r\n        UpdateNotification      = require("utils/UpdateNotification"),\r\n        AboutDialogTemplate     = require("text!htmlContent/about-dialog.html"),\r\n        ContributorsTemplate    = require("text!htmlContent/contributors-list.html");\r\n    \r\n    /**\r\n     * This is the thirdparty API\'s (GitHub) maximum contributors per page limit\r\n     * @const {number}\r\n     */\r\n    var CONTRIBUTORS_PER_PAGE   = 100;\r\n\r\n    var buildInfo;\r\n    \r\n	\r\n    function _handleCheckForUpdates() {\r\n        UpdateNotification.checkForUpdate(true);\r\n    }\r\n    \r\n    function _handleLinkMenuItem(url) {\r\n        return function () {\r\n            if (!url) {\r\n                return;\r\n            }\r\n            NativeApp.openURLInDefaultBrowser(url);\r\n        };\r\n    }\r\n    \r\n    function _handleShowExtensionsFolder() {\r\n        brackets.app.showExtensionsFolder(\r\n            FileUtils.convertToNativePath(decodeURI(window.location.href)),\r\n            function (err) {} /* Ignore errors */\r\n        );\r\n    }\r\n\r\n    function _handleAboutDialog() {\r\n        var templateVars = {\r\n            ABOUT_ICON          : brackets.config.about_icon,\r\n            APP_NAME_ABOUT_BOX  : brackets.config.app_name_about,\r\n            BUILD_TIMESTAMP     : brackets.config.build_timestamp,\r\n            BUILD_INFO          : buildInfo || "",\r\n            Strings             : Strings\r\n        };\r\n        \r\n        Dialogs.showModalDialogUsingTemplate(Mustache.render(AboutDialogTemplate, templateVars));\r\n        \r\n        // Get containers\r\n        var $dlg            = $(".about-dialog.instance"),\r\n            $contributors   = $dlg.find(".about-contributors"),\r\n            $spinner        = $dlg.find(".spinner"),\r\n            contributorsUrl = brackets.config.contributors_url,\r\n            page;\r\n\r\n        if (contributorsUrl.indexOf("{1}") !== -1) { // pagination enabled\r\n            page = 1;\r\n        }\r\n        \r\n        $spinner.addClass("spin");\r\n        \r\n        function loadContributors(rawUrl, page, contributors, deferred) {\r\n            deferred = deferred || new $.Deferred();\r\n            contributors = contributors || [];\r\n            var url = StringUtils.format(rawUrl, CONTRIBUTORS_PER_PAGE, page);\r\n\r\n            $.ajax({\r\n                url: url,\r\n                dataType: "json",\r\n                cache: false\r\n            })\r\n                .done(function (response) {\r\n                    contributors = contributors.concat(response || []);\r\n                    if (page && response.length === CONTRIBUTORS_PER_PAGE) {\r\n                        loadContributors(rawUrl, page + 1, contributors, deferred);\r\n                    } else {\r\n                        deferred.resolve(contributors);\r\n                    }\r\n                })\r\n                .fail(function () {\r\n                    if (contributors.length) { // we weren\'t able to fetch this page, but previous fetches were successful\r\n                        deferred.resolve(contributors);\r\n                    } else {\r\n                        deferred.reject();\r\n                    }\r\n                });\r\n            return deferred.promise();\r\n        }\r\n\r\n        loadContributors(contributorsUrl, page) // Load the contributors\r\n            .done(function (allContributors) {\r\n                // Populate the contributors data\r\n                var totalContributors = allContributors.length,\r\n                    contributorsCount = 0;\r\n\r\n                allContributors.forEach(function (contributor) {\r\n                    // remove any UrlParams delivered via the GitHub API\r\n                    contributor.avatar_url = contributor.avatar_url.split("?")[0];\r\n                });\r\n\r\n                $contributors.html(Mustache.render(ContributorsTemplate, allContributors));\r\n\r\n                // This is used to create an opacity transition when each image is loaded\r\n                $contributors.find("img").one("load", function () {\r\n                    $(this).css("opacity", 1);\r\n\r\n                    // Count the contributors loaded and hide the spinner once all are loaded\r\n                    contributorsCount++;\r\n                    if (contributorsCount >= totalContributors) {\r\n                        $spinner.removeClass("spin");\r\n                    }\r\n                }).each(function () {\r\n                    if (this.complete) {\r\n                        $(this).trigger("load");\r\n                    }\r\n                });\r\n            })\r\n            .fail(function () {\r\n                $spinner.removeClass("spin");\r\n                $contributors.html(Mustache.render("<p class=\'dialog-message\'>{{ABOUT_TEXT_LINE6}}</p>", Strings));\r\n            });\r\n    }\r\n\r\n    // Read "build number" SHAs off disk immediately at APP_READY, instead\r\n    // of later, when they may have been updated to a different version\r\n    AppInit.appReady(function () {\r\n        BuildInfoUtils.getBracketsSHA().done(function (branch, sha, isRepo) {\r\n            // If we\'ve successfully determined a "build number" via .git metadata, add it to dialog\r\n            sha = sha ? sha.substr(0, 9) : "";\r\n            if (branch || sha) {\r\n                buildInfo = StringUtils.format("({0} {1})", branch, sha).trim();\r\n            }\r\n        });\r\n    });\r\n\r\n    CommandManager.register(Strings.CMD_CHECK_FOR_UPDATE,       Commands.HELP_CHECK_FOR_UPDATE,     _handleCheckForUpdates);\r\n    CommandManager.register(Strings.CMD_HOW_TO_USE_BRACKETS,    Commands.HELP_HOW_TO_USE_BRACKETS,  _handleLinkMenuItem(brackets.config.how_to_use_url));\r\n    CommandManager.register(Strings.CMD_SUPPORT,                Commands.HELP_SUPPORT,              _handleLinkMenuItem(brackets.config.support_url));\r\n    CommandManager.register(Strings.CMD_SUGGEST,                Commands.HELP_SUGGEST,              _handleLinkMenuItem(brackets.config.suggest_feature_url));\r\n    CommandManager.register(Strings.CMD_RELEASE_NOTES,          Commands.HELP_RELEASE_NOTES,        _handleLinkMenuItem(brackets.config.release_notes_url));\r\n    CommandManager.register(Strings.CMD_GET_INVOLVED,           Commands.HELP_GET_INVOLVED,         _handleLinkMenuItem(brackets.config.get_involved_url));\r\n    CommandManager.register(Strings.CMD_SHOW_EXTENSIONS_FOLDER, Commands.HELP_SHOW_EXT_FOLDER,      _handleShowExtensionsFolder);\r\n    CommandManager.register(Strings.CMD_HOMEPAGE,               Commands.HELP_HOMEPAGE,             _handleLinkMenuItem(brackets.config.homepage_url));\r\n    CommandManager.register(Strings.CMD_TWITTER,                Commands.HELP_TWITTER,              _handleLinkMenuItem(brackets.config.twitter_url));\r\n    CommandManager.register(Strings.CMD_ABOUT,                  Commands.HELP_ABOUT,                _handleAboutDialog);\r\n});\r\n\n//# sourceURL=/help/HelpCommandHandlers.js'),eval('define(\'text!htmlContent/edit-filter-dialog.html\',[],function () { return \'<div class="file-filter-dialog modal">\\r\\n    <div class="modal-header">\\r\\n        <h1 class="dialog-title">{{Strings.FILE_FILTER_DIALOG}}</h1>\\r\\n    </div>\\r\\n    <div class="modal-body">\\r\\n        <div class="dialog-message">\\r\\n            {{{instruction}}}\\r\\n            <textarea class="exclusions-editor"></textarea>\\r\\n            <input type="text" class="exclusions-name" placeholder="{{Strings.FILTER_NAME_PLACEHOLDER}}">\\r\\n            <div class="exclusions-filecount">{{Strings.FILTER_COUNTING_FILES}}</div>\\r\\n        </div>\\r\\n    </div>\\r\\n    <div class="modal-footer">\\r\\n        <button class="dialog-button btn" data-button-id="cancel">{{Strings.CANCEL}}</button>\\r\\n        <button class="dialog-button btn primary" data-button-id="ok">{{Strings.OK}}</button>\\r\\n    </div>\\r\\n</div>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/edit-filter-dialog.html'),eval("define('text!htmlContent/filter-name.html',[],function () { return '<div class=\\'filter-trash-icon\\'>&times;</div><!-- \\r\\n--><span class=\\'recent-filter-name\\'>{{{filter-name}}}</span><!-- \\r\\n--><span class=\\'recent-filter-patterns\\'>{{{filter-patterns}}}</span><!-- \\r\\n--><span class=\\'filter-edit-icon\\'></span>';});\n\n//# sourceURL=/text!htmlContent/filter-name.html"),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets, window, Mustache */\r\n\r\n/**\r\n * Utilities for managing file-set filters, as used in Find in Files.\r\n * Includes both UI for selecting/editing filters, as well as the actual file-filtering implementation.\r\n */\r\ndefine(\'search/FileFilters\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'project/ProjectManager\',\'widgets/DefaultDialogs\',\'widgets/Dialogs\',\'widgets/DropdownButton\',\'utils/StringUtils\',\'strings\',\'preferences/PreferencesManager\',\'text!htmlContent/edit-filter-dialog.html\',\'text!htmlContent/filter-name.html\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _                  = require("thirdparty/lodash"),\r\n        ProjectManager     = require("project/ProjectManager"),\r\n        DefaultDialogs     = require("widgets/DefaultDialogs"),\r\n        Dialogs            = require("widgets/Dialogs"),\r\n        DropdownButton     = require("widgets/DropdownButton").DropdownButton,\r\n        StringUtils        = require("utils/StringUtils"),\r\n        Strings            = require("strings"),\r\n        PreferencesManager = require("preferences/PreferencesManager"),\r\n        EditFilterTemplate = require("text!htmlContent/edit-filter-dialog.html"),\r\n        FilterNameTemplate = require("text!htmlContent/filter-name.html");\r\n  \r\n    /**\r\n     * Constant: first filter index in the filter dropdown list\r\n     * @type {number}\r\n     */\r\n    var FIRST_FILTER_INDEX = 3;\r\n    \r\n    /**\r\n     * Context Info on which files the filter will be applied to. \r\n     * It will be initialized when createFilterPicker is called and if specified, editing UI will \r\n     * indicate how many files are excluded by the filter. Label should be of the form "in ..."\r\n     * @type {?{label:string, promise:$.Promise}}\r\n     */\r\n    var _context = null;\r\n    \r\n    /**\r\n     * @type {DropdownButton}\r\n     */\r\n    var _picker  = null;\r\n    \r\n    /**\r\n     * Get the condensed form of the filter set by joining the first two in the set with\r\n     * a comma separator and appending a short message with the number of filters being clipped.\r\n     * @param {Array.<string>} filter\r\n     * @return {string} Condensed form of filter set if `filter` is a valid array.\r\n     *                  Otherwise, return an empty string.\r\n     */\r\n    function _getCondensedForm(filter) {\r\n        if (!_.isArray(filter)) {\r\n            return "";\r\n        }\r\n        \r\n        // Format filter in condensed form\r\n        if (filter.length > 2) {\r\n            return filter.slice(0, 2).join(", ") + " " +\r\n                   StringUtils.format(Strings.FILE_FILTER_CLIPPED_SUFFIX, filter.length - 2);\r\n        }\r\n        return filter.join(", ");\r\n    }\r\n    \r\n    /**\r\n     * Populate the list of dropdown menu with two filter commands and\r\n     * the list of saved filter sets.\r\n     */\r\n    function _doPopulate() {\r\n        var dropdownItems = [Strings.NEW_FILE_FILTER, Strings.CLEAR_FILE_FILTER],\r\n            filterSets = PreferencesManager.get("fileFilters") || [];\r\n\r\n        if (filterSets.length) {\r\n            dropdownItems.push("---");\r\n\r\n            // Remove all the empty exclusion sets before concatenating to the dropdownItems.\r\n            filterSets = filterSets.filter(function (filter) {\r\n                return (_getCondensedForm(filter.patterns) !== "");\r\n            });\r\n\r\n            // FIRST_FILTER_INDEX needs to stay in sync with the number of static items (plus separator)\r\n            // ie. the number of items populated so far before we concatenate with the actual filter sets.\r\n            dropdownItems = dropdownItems.concat(filterSets);\r\n        }\r\n        _picker.items = dropdownItems;\r\n    }\r\n    \r\n    /**\r\n     * Find the index of a filter set in the list of saved filter sets.\r\n     * @param {Array.<{name: string, patterns: Array.<string>}>} filterSets\r\n     * @return {{name: string, patterns: Array.<string>}} filter\r\n     */\r\n    function _getFilterIndex(filterSets, filter) {\r\n        var index = -1,\r\n            found = false;\r\n        \r\n        if (!filter || !filterSets.length) {\r\n            return index;\r\n        }\r\n        \r\n        return _.findIndex(filterSets, _.partial(_.isEqual, filter));\r\n    }\r\n    \r\n    /**\r\n     * A search filter is an array of one or more glob strings. The filter must be \'compiled\' via compile()\r\n     * before passing to filterPath()/filterFileList().\r\n     * @return {?{name: string, patterns: Array.<string>}}\r\n     */\r\n    function getActiveFilter() {\r\n        var filterSets        = PreferencesManager.get("fileFilters") || [],\r\n            activeFilterIndex = PreferencesManager.getViewState("activeFileFilter"),\r\n            oldFilter         = PreferencesManager.getViewState("search.exclusions") || [],\r\n            activeFilter      = null;\r\n\r\n        if (activeFilterIndex === undefined && oldFilter.length) {\r\n            activeFilter = { name: "", patterns: oldFilter };\r\n            activeFilterIndex = _getFilterIndex(filterSets, activeFilter);\r\n            \r\n            // Migrate the old filter into the new filter storage\r\n            if (activeFilterIndex === -1) {\r\n                activeFilterIndex = filterSets.length;\r\n                filterSets.push(activeFilter);\r\n                PreferencesManager.set("fileFilters", filterSets);\r\n            }\r\n            PreferencesManager.setViewState("activeFileFilter", activeFilterIndex);\r\n        } else if (activeFilterIndex > -1 && activeFilterIndex < filterSets.length) {\r\n            activeFilter = filterSets[activeFilterIndex];\r\n        }\r\n        \r\n        return activeFilter;\r\n    }\r\n    \r\n    /**\r\n     * Update the picker button label with the name/patterns of the selected filter or \r\n     * No Files Excluded if no filter is selected.\r\n     */\r\n    function _updatePicker() {\r\n        var filter = getActiveFilter();\r\n        if (filter && filter.patterns.length) {\r\n            var label = filter.name || _getCondensedForm(filter.patterns);\r\n            _picker.setButtonLabel(StringUtils.format(Strings.EXCLUDE_FILE_FILTER, label));\r\n        } else {\r\n            _picker.setButtonLabel(Strings.NO_FILE_FILTER);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Sets and save the index of the active filter. Automatically set when editFilter() is completed.\r\n     * If no filter is passed in, then clear the last active filter index by setting it to -1.\r\n     *\r\n     * @param {{name: string, patterns: Array.<string>}=} filter\r\n     * @param {number=} index The index of the filter set in the list of saved filter sets or -1 if it is a new one\r\n     */\r\n    function setActiveFilter(filter, index) {\r\n        var filterSets = PreferencesManager.get("fileFilters") || [];\r\n        \r\n        if (filter) {\r\n            if (index === -1) {\r\n                // Add a new filter set\r\n                index = filterSets.length;\r\n                filterSets.push(filter);\r\n            } else if (index > -1 && index < filterSets.length) {\r\n                // Update an existing filter set only if the filter set has some changes\r\n                if (!_.isEqual(filterSets[index], filter)) {\r\n                    filterSets[index] = filter;\r\n                }\r\n            } else {\r\n                // Should not have been called with an invalid index to the available filter sets.\r\n                console.log("setActiveFilter is called with an invalid index: " + index);\r\n                return;\r\n            }\r\n\r\n            PreferencesManager.set("fileFilters", filterSets);\r\n            PreferencesManager.setViewState("activeFileFilter", index);\r\n        } else {\r\n            // Explicitly set to -1 to remove the active file filter\r\n            PreferencesManager.setViewState("activeFileFilter", -1);\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Converts a user-specified filter object (as chosen in picker or retrieved from getFilters()) to a \'compiled\' form\r\n     * that can be used with filterPath()/filterFileList().\r\n     * @param {!Array.<string>} userFilter\r\n     * @return {!string} \'compiled\' filter that can be passed to filterPath()/filterFileList().\r\n     */\r\n    function compile(userFilter) {\r\n        // Automatically apply ** prefix/suffix to make writing simple substring-match filters more intuitive\r\n        var wrappedGlobs = userFilter.map(function (glob) {\r\n            // Automatic "**" prefix if not explicitly present\r\n            if (glob.substr(0, 2) !== "**") {\r\n                glob = "**" + glob;\r\n            }\r\n            // Automatic "**" suffix if not explicitly present and no "." in last path segment of filter string\r\n            if (glob.substr(-2, 2) !== "**") {\r\n                var lastSeg = glob.lastIndexOf("/");\r\n                if (glob.indexOf(".", lastSeg + 1) === -1) {  // if no "/" present, this treats whole string as \'last segment\'\r\n                    glob += "**";\r\n                }\r\n            }\r\n            return glob;\r\n        });\r\n        \r\n        // Convert to regular expression for fast matching\r\n        var regexStrings = wrappedGlobs.map(function (glob) {\r\n            var reStr = "", i;\r\n            for (i = 0; i < glob.length; i++) {\r\n                var ch = glob[i];\r\n                if (ch === "*") {\r\n                    // Check for `**`\r\n                    if (glob[i + 1] === "*") {\r\n                        // Special case: `/**/` can collapse - that is, it shouldn\'t require matching both slashes\r\n                        if (glob[i + 2] === "/" && glob[i - 1] === "/") {\r\n                            reStr += "(.*/)?";\r\n                            i += 2; // skip 2nd * and / after it\r\n                        } else {\r\n                            reStr += ".*";\r\n                            i++;    // skip 2nd *\r\n                        }\r\n                    } else {\r\n                        // Single `*`\r\n                        reStr += "[^/]*";\r\n                    }\r\n                } else if (ch === "?") {\r\n                    reStr += "[^/]";  // unlike \'?\' in regexp, in globs this requires exactly 1 char\r\n                } else {\r\n                    // Regular char with no special meaning\r\n                    reStr += StringUtils.regexEscape(ch);\r\n                }\r\n            }\r\n            return "^" + reStr + "$";\r\n        });\r\n        return regexStrings.join("|");\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Returns false if the given path matches any of the exclusion globs in the given filter. Returns true\r\n     * if the path does not match any of the globs. If filtering many paths at once, use filterFileList()\r\n     * for much better performance.\r\n     * \r\n     * @param {?string} compiledFilter  \'Compiled\' filter object as returned by compile(), or null to no-op\r\n     * @param {!string} fullPath\r\n     * @return {boolean}\r\n     */\r\n    function filterPath(compiledFilter, fullPath) {\r\n        if (!compiledFilter) {\r\n            return true;\r\n        }\r\n        \r\n        var re = new RegExp(compiledFilter);\r\n        return !fullPath.match(re);\r\n    }\r\n    \r\n    /**\r\n     * Returns a copy of \'files\' filtered to just those that don\'t match any of the exclusion globs in the filter.\r\n     * \r\n     * @param {?string} compiledFilter  \'Compiled\' filter object as returned by compile(), or null to no-op\r\n     * @param {!Array.<File>} files\r\n     * @return {!Array.<File>}\r\n     */\r\n    function filterFileList(compiledFilter, files) {\r\n        if (!compiledFilter) {\r\n            return files;\r\n        }\r\n        \r\n        var re = new RegExp(compiledFilter);\r\n        return files.filter(function (f) {\r\n            return !f.fullPath.match(re);\r\n        });\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Opens a dialog box to edit the given filter. When editing is finished, the value of getActiveFilter() changes to\r\n     * reflect the edits. If the dialog was canceled, the preference is left unchanged.\r\n     * @param {!{name: string, patterns: Array.<string>}} filter\r\n     * @param {number} index The index of the filter set to be edited or created. The value is -1 if it is for a new one \r\n     *          to be created.\r\n     * @return {!$.Promise} Dialog box promise\r\n     */\r\n    function editFilter(filter, index) {\r\n        var lastFocus = window.document.activeElement;\r\n        \r\n        var templateVars = {\r\n                instruction: StringUtils.format(Strings.FILE_FILTER_INSTRUCTIONS, brackets.config.glob_help_url),\r\n                Strings: Strings\r\n            };\r\n        var dialog = Dialogs.showModalDialogUsingTemplate(Mustache.render(EditFilterTemplate, templateVars)),\r\n            $nameField = dialog.getElement().find(".exclusions-name"),\r\n            $editField = dialog.getElement().find(".exclusions-editor");\r\n        \r\n        $nameField.val(filter.name);\r\n        $editField.val(filter.patterns.join("\\n")).focus();\r\n        \r\n        function getValue() {\r\n            var newFilter = $editField.val().split("\\n");\r\n\r\n            // Remove blank lines\r\n            return newFilter.filter(function (glob) {\r\n                return glob.trim().length;\r\n            });\r\n        }\r\n        \r\n        dialog.done(function (buttonId) {\r\n            if (buttonId === Dialogs.DIALOG_BTN_OK) {\r\n                // Update saved filter preference\r\n                setActiveFilter({ name: $nameField.val(), patterns: getValue() }, index);\r\n                _updatePicker();\r\n                _doPopulate();\r\n            }\r\n            lastFocus.focus();  // restore focus to old pos\r\n        });\r\n        \r\n        // Code to update the file count readout at bottom of dialog (if context provided)\r\n        var $fileCount = dialog.getElement().find(".exclusions-filecount");\r\n        \r\n        function updateFileCount() {\r\n            _context.promise.done(function (files) {\r\n                var filter = getValue();\r\n                if (filter.length) {\r\n                    var filtered = filterFileList(compile(filter), files);\r\n                    $fileCount.html(StringUtils.format(Strings.FILTER_FILE_COUNT, filtered.length, files.length, _context.label));\r\n                } else {\r\n                    $fileCount.html(StringUtils.format(Strings.FILTER_FILE_COUNT_ALL, files.length, _context.label));\r\n                }\r\n            });\r\n        }\r\n        \r\n        // Code to enable/disable the OK button at the bottom of dialog (whether filter is empty or not)\r\n        var $primaryBtn = dialog.getElement().find(".primary");\r\n\r\n        function updatePrimaryButton() {\r\n            var trimmedValue = $editField.val().trim();\r\n\r\n            $primaryBtn.prop("disabled", !trimmedValue.length);\r\n        }\r\n\r\n        $editField.on("input", updatePrimaryButton);\r\n        updatePrimaryButton();\r\n\r\n        if (_context) {\r\n            $editField.on("input", _.debounce(updateFileCount, 400));\r\n            updateFileCount();\r\n        } else {\r\n            $fileCount.hide();\r\n        }\r\n        \r\n        return dialog.getPromise();\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Marks the filter picker\'s currently selected item as most-recently used, and returns the corresponding\r\n     * \'compiled\' filter object ready for use with filterPath().\r\n     * @param {!jQueryObject} picker UI returned from createFilterPicker()\r\n     * @return {!string} \'compiled\' filter that can be passed to filterPath()/filterFileList().\r\n     */\r\n    function commitPicker(picker) {\r\n        var filter = getActiveFilter();\r\n        return (filter && filter.patterns.length) ? compile(filter.patterns) : "";\r\n    }\r\n    \r\n    /**\r\n     * Remove the target item from the filter dropdown list and update dropdown button\r\n     * and dropdown list UI.\r\n     * @param {!Event} e Mouse events\r\n     */\r\n    function _handleDeleteFilter(e) {\r\n        // Remove the filter set from the preferences and \r\n        // clear the active filter set index from view state.\r\n        var filterSets        = PreferencesManager.get("fileFilters") || [],\r\n            activeFilterIndex = PreferencesManager.getViewState("activeFileFilter"),\r\n            filterIndex       = $(e.target).parent().data("index") - FIRST_FILTER_INDEX;\r\n\r\n        // Don\'t let the click bubble upward.\r\n        e.stopPropagation();\r\n\r\n        filterSets.splice(filterIndex, 1);\r\n        PreferencesManager.set("fileFilters", filterSets);\r\n\r\n        if (activeFilterIndex === filterIndex) {\r\n            // Removing the active filter, so clear the active filter \r\n            // both in the view state.\r\n            setActiveFilter(null);\r\n        } else if (activeFilterIndex > filterIndex) {\r\n            // Adjust the active filter index after the removal of a filter set before it.\r\n            --activeFilterIndex;\r\n            setActiveFilter(filterSets[activeFilterIndex], activeFilterIndex);\r\n        }\r\n\r\n        _updatePicker();\r\n        _doPopulate();\r\n        _picker.refresh();\r\n    }\r\n\r\n    /**\r\n     * Close filter dropdwon list and launch edit filter dialog.\r\n     * @param {!Event} e Mouse events\r\n     */\r\n    function _handleEditFilter(e) {\r\n        var filterSets  = PreferencesManager.get("fileFilters") || [],\r\n            filterIndex = $(e.target).parent().data("index") - FIRST_FILTER_INDEX;\r\n\r\n        // Don\'t let the click bubble upward.\r\n        e.stopPropagation();\r\n\r\n        // Close the dropdown first before opening the edit filter dialog \r\n        // so that it will restore focus to the DOM element that has focus\r\n        // prior to opening it.\r\n        _picker.closeDropdown();\r\n\r\n        editFilter(filterSets[filterIndex], filterIndex);\r\n    }\r\n\r\n    /**\r\n     * Set up mouse click event listeners for \'Delete\' and \'Edit\' buttons\r\n     * when the dropdown is open. Also set check mark on the active filter.\r\n     * @param {!Event>} event listRendered event triggered when the dropdown is open\r\n     * @param {!jQueryObject} $dropdown the jQuery DOM node of the dropdown list\r\n     */\r\n    function _handleListRendered(event, $dropdown) {\r\n        var activeFilterIndex = PreferencesManager.getViewState("activeFileFilter"),\r\n            checkedItemIndex = (activeFilterIndex > -1) ? (activeFilterIndex + FIRST_FILTER_INDEX) : -1;\r\n        _picker.setChecked(checkedItemIndex, true);\r\n\r\n        $dropdown.find(".filter-trash-icon")\r\n            .on("click", _handleDeleteFilter);\r\n        \r\n        $dropdown.find(".filter-edit-icon")\r\n            .on("click", _handleEditFilter);\r\n    }\r\n                      \r\n    /**\r\n     * Creates a UI element for selecting a filter, populated with a list of recently used filters, an option to\r\n     * edit the selected filter and another option to create a new filter. The client should call commitDropdown() \r\n     * when the UI containing the filter picker is confirmed (which updates the MRU order) and then use the \r\n     * returned filter object as needed.\r\n     * \r\n     * @param {?{label:string, promise:$.Promise}} context Info on files that filter will apply to. \r\n     *      This will be saved as _context for later use in creating a new filter or editing an\r\n     *      existing filter in Edit Filter dialog.\r\n     * @return {!jQueryObject} Picker UI. To retrieve the selected value, use commitPicker().\r\n     */\r\n    function createFilterPicker(context) {\r\n        \r\n        function itemRenderer(item, index) {\r\n            if (index < FIRST_FILTER_INDEX) {\r\n                // Prefix the two filter commands with \'recent-filter-name\' so that\r\n                // they also get the same margin-left as the actual filters.\r\n                return "<span class=\'recent-filter-name\'></span>" + _.escape(item);\r\n            }\r\n            \r\n            var condensedPatterns = _getCondensedForm(item.patterns),\r\n                templateVars = {\r\n                    "filter-name"    : _.escape(item.name || condensedPatterns),\r\n                    "filter-patterns": item.name ? " - " + _.escape(condensedPatterns) : ""\r\n                };\r\n                \r\n            return Mustache.render(FilterNameTemplate, templateVars);\r\n        }\r\n\r\n        _context = context;\r\n        _picker = new DropdownButton("", [], itemRenderer);\r\n\r\n        _updatePicker();\r\n        _doPopulate();\r\n        \r\n        // Add \'file-filter-picker\' to keep some margin space on the left of the button\r\n        _picker.$button.addClass("file-filter-picker no-focus");\r\n        \r\n        // Set up mouse click event listeners for \'Delete\' and \'Edit\' buttons\r\n        $(_picker).on("listRendered", _handleListRendered);\r\n        \r\n        $(_picker).on("select", function (event, item, itemIndex) {\r\n            if (itemIndex === 0) {\r\n                // Close the dropdown first before opening the edit filter dialog \r\n                // so that it will restore focus to the DOM element that has focus\r\n                // prior to opening it.\r\n                _picker.closeDropdown();\r\n\r\n                // Create a new filter set\r\n                editFilter({ name: "", patterns: [] }, -1);\r\n            } else if (itemIndex === 1) {\r\n                // Uncheck the prior active filter in the dropdown list.\r\n                _picker.setChecked(itemIndex, false);\r\n                \r\n                // Clear the active filter\r\n                setActiveFilter(null);\r\n                _updatePicker();\r\n            } else if (itemIndex >= FIRST_FILTER_INDEX && item) {\r\n                setActiveFilter(item, itemIndex - FIRST_FILTER_INDEX);\r\n                _picker.setChecked(itemIndex, true);\r\n                _updatePicker();\r\n            }\r\n        });\r\n        \r\n        return _picker.$button;\r\n    }\r\n    \r\n    /**\r\n     * Allows unit tests to open the file filter dropdown list.\r\n     */\r\n    function showDropdown() {\r\n        if (_picker) {\r\n            _picker.showDropdown();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Allows unit tests to close the file filter dropdown list.\r\n     */\r\n    function closeDropdown() {\r\n        if (_picker) {\r\n            _picker.closeDropdown();\r\n        }\r\n    }\r\n    \r\n    // For unit tests only\r\n    exports.showDropdown       = showDropdown;\r\n    exports.closeDropdown      = closeDropdown;\r\n\r\n    exports.createFilterPicker = createFilterPicker;\r\n    exports.commitPicker       = commitPicker;\r\n    exports.getActiveFilter      = getActiveFilter;\r\n    exports.setActiveFilter      = setActiveFilter;\r\n    exports.editFilter         = editFilter;\r\n    exports.compile            = compile;\r\n    exports.filterPath         = filterPath;\r\n    exports.filterFileList     = filterFileList;\r\n});\r\n\n//# sourceURL=/search/FileFilters.js'),eval('define(\'text!htmlContent/findreplace-bar.html\',[],function () { return \'<div class="find-input-group">\\r\\n    <div id="find-group"><!--\\r\\n        --><div class="search-input-container"><input type="text" id="find-what" placeholder="{{queryPlaceholder}}" value="{{initialQuery}}" /><div class="error"></div><span id="find-counter"></span></div><!--\\r\\n        --><button id="find-case-sensitive" class="btn no-focus" tabindex="-1" title="{{Strings.BUTTON_CASESENSITIVE_HINT}}"><div class="button-icon"></div></button><!--\\r\\n        --><button id="find-regexp" class="btn no-focus" tabindex="-1" title="{{Strings.BUTTON_REGEXP_HINT}}"><div class="button-icon"></div></button><!--\\r\\n        {{^multifile}}\\r\\n        --><div class="navigator"><!--\\r\\n            --><button id="find-prev" class="btn no-focus" tabindex="-1" title="{{Strings.BUTTON_PREV_HINT}}">{{Strings.BUTTON_PREV}}</button><!--\\r\\n            --><button id="find-next" class="btn no-focus" tabindex="-1" title="{{Strings.BUTTON_NEXT_HINT}}">{{Strings.BUTTON_NEXT}}</button><!--\\r\\n        --></div><!--\\r\\n        {{/multifile}}\\r\\n    --></div>\\r\\n\\r\\n    {{#replace}}\\r\\n    <div id="replace-group" {{#scope}}class="has-scope"{{/scope}}><!--\\r\\n        --><input type="text" id="replace-with" placeholder="{{Strings.REPLACE_PLACEHOLDER}}"/><!--\\r\\n        {{^multifile}}\\r\\n        --><button id="replace-yes" class="btn no-focus" tabindex="-1">{{Strings.BUTTON_REPLACE}}</button><!--\\r\\n        {{/multifile}}\\r\\n        --><button id="replace-all" class="btn no-focus {{#multifile}}solo{{/multifile}}" tabindex="-1">{{replaceAllLabel}}</button></div>\\r\\n    {{/replace}}\\r\\n</div>\\r\\n\\r\\n{{#multifile}}\\r\\n<div class="scope-group">\\r\\n    <div class="no-results-message">{{Strings.FIND_NO_RESULTS}}</div>\\r\\n    <div class="message">\\r\\n        <span id="searchlabel">{{{scopeLabel}}}</span>\\r\\n    </div>\\r\\n    <!-- For Find in Files, the filter picker will be added here programmatically. -->\\r\\n</div>\\r\\n{{/multifile}}\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/findreplace-bar.html'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, Mustache */\r\n\r\n/*\r\n * UI for the Find/Replace and Find in Files modal bar.\r\n */\r\ndefine(\'search/FindBar\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'command/Commands\',\'editor/EditorManager\',\'command/KeyBindingManager\',\'utils/KeyEvent\',\'widgets/ModalBar\',\'preferences/PreferencesManager\',\'view/MainViewManager\',\'strings\',\'utils/ViewUtils\',\'text!htmlContent/findreplace-bar.html\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _                  = require("thirdparty/lodash"),\r\n        Commands           = require("command/Commands"),\r\n        EditorManager      = require("editor/EditorManager"),\r\n        KeyBindingManager  = require("command/KeyBindingManager"),\r\n        KeyEvent           = require("utils/KeyEvent"),\r\n        ModalBar           = require("widgets/ModalBar").ModalBar,\r\n        PreferencesManager = require("preferences/PreferencesManager"),\r\n        MainViewManager    = require("view/MainViewManager"),\r\n        Strings            = require("strings"),\r\n        ViewUtils          = require("utils/ViewUtils");\r\n    \r\n    /**\r\n     * @private\r\n     * The template we use for all Find bars.\r\n     * @type {string}\r\n     */\r\n    var _searchBarTemplate = require("text!htmlContent/findreplace-bar.html");\r\n    \r\n    /**\r\n     * @constructor\r\n     * Find Bar UI component, used for both single- and multi-file find/replace. This doesn\'t actually\r\n     * create and add the FindBar to the DOM - for that, call open().\r\n     *\r\n     * Dispatches these events:\r\n     *\r\n     * - queryChange - when the user types in the input field or sets a query option. Use getQueryInfo()\r\n     *      to get the current query state.\r\n     * - doFind - when the user chooses to do a Find Previous or Find Next.\r\n     *      Parameters are:\r\n     *          shiftKey - boolean, false for Find Next, true for Find Previous\r\n     * - doReplace - when the user chooses to do a single replace. Use getReplaceText() to get the current replacement text.\r\n     * - doReplaceAll - when the user chooses to initiate a Replace All. Use getReplaceText() to get the current replacement text.\r\n     *-  close - when the find bar is closed\r\n     *\r\n     * @param {boolean=} options.multifile - true if this is a Find/Replace in Files (changes the behavior of Enter in\r\n     *      the fields, hides the navigator controls, shows the scope/filter controls, and if in replace mode, hides the\r\n     *      Replace button (so there\'s only Replace All)\r\n     * @param {boolean=} options.replace - true to show the Replace controls - default false\r\n     * @param {string=}  options.queryPlaceholder - label to show in the Find field - default empty string\r\n     * @param {string=}  options.initialQuery - query to populate in the Find field on open - default empty string\r\n     * @param {string=}  scopeLabel - HTML label to show for the scope of the search, expected to be already escaped - default empty string\r\n     */\r\n    function FindBar(options) {\r\n        var defaults = {\r\n            multifile: false,\r\n            replace: false,\r\n            queryPlaceholder: "",\r\n            initialQuery: "",\r\n            scopeLabel: ""\r\n        };\r\n        this._options = _.extend(defaults, options);\r\n        this._closed = false;\r\n        this._enabled = true;\r\n    }\r\n    \r\n    /*\r\n     * Global FindBar functions for making sure only one is open at a time.\r\n     */\r\n    \r\n    // TODO: this is temporary - we should do this at the ModalBar level, but can\'t do that until\r\n    // we land the simplified Quick Open UI (#7227) that eliminates some asynchronicity in closing\r\n    // its ModalBar.\r\n    \r\n    /**\r\n     * @private\r\n     * Register a find bar so we can close it later if another one tries to open.\r\n     * Note that this is a global function, not an instance function.\r\n     * @param {!FindBar} findBar The find bar to register.\r\n     */\r\n    FindBar._addFindBar = function (findBar) {\r\n        FindBar._bars = FindBar._bars || [];\r\n        FindBar._bars.push(findBar);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Remove a find bar from the list.\r\n     * Note that this is a global function, not an instance function.\r\n     * @param {FindBar} findBar The bar to remove.\r\n     */\r\n    FindBar._removeFindBar = function (findBar) {\r\n        if (FindBar._bars) {\r\n            _.pull(FindBar._bars, findBar);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Close all existing find bars. In theory there should be only one, but since there can be\r\n     * timing issues due to animation we maintain a list.\r\n     * Note that this is a global function, not an instance function.\r\n     */\r\n    FindBar._closeFindBars = function () {\r\n        var bars = FindBar._bars;\r\n        if (bars) {\r\n            bars.forEach(function (bar) {\r\n                bar.close(true, false);\r\n            });\r\n            bars = [];\r\n        }\r\n    };\r\n    \r\n    /*\r\n     * Instance properties/functions\r\n     */\r\n    \r\n    /**\r\n     * @private\r\n     * Options passed into the FindBar.\r\n     * @type {!{multifile: boolean, replace: boolean, queryPlaceholder: string, initialQuery: string, scopeLabel: string}}\r\n     */\r\n    FindBar.prototype._options = null;\r\n    \r\n    /**\r\n     * @private\r\n     * Whether the FindBar has been closed.\r\n     * @type {boolean}\r\n     */\r\n    FindBar.prototype._closed = false;\r\n    \r\n    /**\r\n     * @private\r\n     * Whether the FindBar is currently enabled.\r\n     * @type {boolean}\r\n     */\r\n    FindBar.prototype._enabled = true;\r\n    \r\n    /** \r\n     * @private\r\n     * @type {?ModalBar} Modal bar containing this find bar\'s UI\r\n     */\r\n    FindBar.prototype._modalBar = null;\r\n    \r\n    /**\r\n     * @private\r\n     * Returns the jQuery object for an element in this Find bar.\r\n     * @param {string} selector The selector for the element.\r\n     * @return {jQueryObject} The jQuery object for the element, or an empty object if the Find bar isn\'t yet\r\n     *      in the DOM or the element doesn\'t exist.\r\n     */\r\n    FindBar.prototype.$ = function (selector) {\r\n        if (this._modalBar) {\r\n            return $(selector, this._modalBar.getRoot());\r\n        } else {\r\n            return $();\r\n        }\r\n    };\r\n    \r\n    // TODO: change IDs to classes\r\n    \r\n    /**\r\n     * @private\r\n     * Set the state of the toggles in the Find bar to the saved prefs state.\r\n     */\r\n    FindBar.prototype._updateSearchBarFromPrefs = function () {\r\n        // Have to make sure we explicitly cast the second parameter to a boolean, because\r\n        // toggleClass expects literal true/false.\r\n        this.$("#find-case-sensitive").toggleClass("active", !!PreferencesManager.getViewState("caseSensitive"));\r\n        this.$("#find-regexp").toggleClass("active", !!PreferencesManager.getViewState("regexp"));\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Save the prefs state based on the state of the toggles.\r\n     */\r\n    FindBar.prototype._updatePrefsFromSearchBar = function () {\r\n        PreferencesManager.setViewState("caseSensitive", this.$("#find-case-sensitive").is(".active"));\r\n        PreferencesManager.setViewState("regexp",        this.$("#find-regexp").is(".active"));\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Shows the keyboard shortcut for the given command in the element\'s tooltip.\r\n     * @param {jQueryObject} $elem The element to add the shortcut to.\r\n     * @param {string} commandId The ID for the command whose keyboard shortcut to show.\r\n     */\r\n    FindBar.prototype._addShortcutToTooltip = function ($elem, commandId) {\r\n        var replaceShortcut = KeyBindingManager.getKeyBindings(commandId)[0];\r\n        if (replaceShortcut) {\r\n            var oldTitle = $elem.attr("title");\r\n            oldTitle = (oldTitle ? oldTitle + " " : "");\r\n            $elem.attr("title", oldTitle + "(" + KeyBindingManager.formatKeyDescriptor(replaceShortcut.displayKey) + ")");\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Opens the Find bar, closing any other existing Find bars.\r\n     */\r\n    FindBar.prototype.open = function () {\r\n        var self = this;\r\n        \r\n        // Normally, creating a new Find bar will simply cause the old one to close\r\n        // automatically. This can cause timing issues because the focus change might\r\n        // cause the new one to think it should close, too. So we simply explicitly\r\n        // close the old Find bar (with no animation) before creating a new one. \r\n        // TODO: see note above - this will move to ModalBar eventually.\r\n        FindBar._closeFindBars();\r\n        \r\n        var templateVars = _.clone(this._options);\r\n        templateVars.Strings = Strings;\r\n        templateVars.replaceAllLabel = (templateVars.multifile ? Strings.BUTTON_REPLACE_ALL_IN_FILES : Strings.BUTTON_REPLACE_ALL);\r\n        \r\n        this._modalBar = new ModalBar(Mustache.render(_searchBarTemplate, templateVars), true);  // 2nd arg = auto-close on Esc/blur\r\n        \r\n        // When the ModalBar closes, clean ourselves up.\r\n        $(this._modalBar).on("close", function (event) {\r\n            // Hide error popup, since it hangs down low enough to make the slide-out look awkward\r\n            self.showError(null);\r\n            self._modalBar = null;\r\n            self._closed = true;\r\n            FindBar._removeFindBar(self);\r\n            MainViewManager.focusActivePane();\r\n            $(self).trigger("close");\r\n        });\r\n        \r\n        FindBar._addFindBar(this);\r\n        \r\n        var $root = this._modalBar.getRoot();\r\n        $root\r\n            .on("input", "#find-what", function () {\r\n                $(self).triggerHandler("queryChange");\r\n            })\r\n            .on("click", "#find-case-sensitive, #find-regexp", function (e) {\r\n                $(e.currentTarget).toggleClass("active");\r\n                self._updatePrefsFromSearchBar();\r\n                $(self).triggerHandler("queryChange");\r\n            })\r\n            .on("keydown", "#find-what, #replace-with", function (e) {\r\n                if (e.keyCode === KeyEvent.DOM_VK_RETURN) {\r\n                    e.preventDefault();\r\n                    e.stopPropagation();\r\n                    if (self._options.multifile) {\r\n                        if ($(e.target).is("#find-what")) {\r\n                            if (self._options.replace) {\r\n                                // Just set focus to the Replace field.\r\n                                self.focusReplace();\r\n                            } else {\r\n                                // Trigger a Find (which really means "Find All" in this context).\r\n                                $(self).triggerHandler("doFind");\r\n                            }\r\n                        } else {\r\n                            $(self).triggerHandler("doReplaceAll");\r\n                        }\r\n                    } else {\r\n                        // In the single file case, we just want to trigger a Find Next (or Find Previous\r\n                        // if Shift is held down).\r\n                        $(self).triggerHandler("doFind", [e.shiftKey]);\r\n                    }\r\n                }\r\n            });\r\n        \r\n        if (!this._options.multifile) {\r\n            this._addShortcutToTooltip($("#find-next"), Commands.CMD_FIND_NEXT);\r\n            this._addShortcutToTooltip($("#find-prev"), Commands.CMD_FIND_PREVIOUS);\r\n            $root\r\n                .on("click", "#find-next", function (e) {\r\n                    $(self).triggerHandler("doFind", false);\r\n                })\r\n                .on("click", "#find-prev", function (e) {\r\n                    $(self).triggerHandler("doFind", true);\r\n                });\r\n        }\r\n        \r\n        if (this._options.replace) {\r\n            this._addShortcutToTooltip($("#replace-yes"), Commands.CMD_REPLACE);\r\n            $root\r\n                .on("click", "#replace-yes", function (e) {\r\n                    $(self).triggerHandler("doReplace");\r\n                })\r\n                .on("click", "#replace-all", function (e) {\r\n                    $(self).triggerHandler("doReplaceAll");\r\n                })\r\n                // One-off hack to make Find/Replace fields a self-contained tab cycle\r\n                // TODO: remove once https://trello.com/c/lTSJgOS2 implemented\r\n                .on("keydown", function (e) {\r\n                    if (e.keyCode === KeyEvent.DOM_VK_TAB && !e.ctrlKey && !e.metaKey && !e.altKey) {\r\n                        if (e.target.id === "replace-with" && !e.shiftKey) {\r\n                            self.$("#find-what").focus();\r\n                            e.preventDefault();\r\n                        } else if (e.target.id === "find-what" && e.shiftKey) {\r\n                            self.$("#replace-with").focus();\r\n                            e.preventDefault();\r\n                        }\r\n                    }\r\n                });\r\n        }\r\n        \r\n        // Set up the initial UI state.\r\n        this._updateSearchBarFromPrefs();\r\n        this.focusQuery();\r\n    };\r\n\r\n    /**\r\n     * Closes this Find bar. If already closed, does nothing.\r\n     * @param {boolean} suppressAnimation If true, don\'t do the standard closing animation. Default false.\r\n     */\r\n    FindBar.prototype.close = function (suppressAnimation) {\r\n        if (this._modalBar) {\r\n            // 1st arg = restore scroll pos; 2nd arg = no animation, since getting replaced immediately\r\n            this._modalBar.close(true, !suppressAnimation);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @return {boolean} true if this FindBar has been closed.\r\n     */\r\n    FindBar.prototype.isClosed = function () {\r\n        return this._closed;\r\n    };\r\n    \r\n    /**\r\n     * @return {Object} The options passed into the FindBar.\r\n     */\r\n    FindBar.prototype.getOptions = function () {\r\n        return this._options;\r\n    };\r\n    \r\n    /**\r\n     * Returns the current query and parameters.\r\n     * @return {{query: string, caseSensitive: boolean, isRegexp: boolean}}\r\n     */\r\n    FindBar.prototype.getQueryInfo = function () {\r\n        return {\r\n            query:           this.$("#find-what").val() || "",\r\n            isCaseSensitive: this.$("#find-case-sensitive").is(".active"),\r\n            isRegexp:        this.$("#find-regexp").is(".active")\r\n        };\r\n    };\r\n    \r\n    /**\r\n     * Show or clear an error message related to the query.\r\n     * @param {?string} error The error message to show, or null to hide the error display.\r\n     * @param {boolean=} isHTML Whether the error message is HTML that should remain unescaped.\r\n     */\r\n    FindBar.prototype.showError = function (error, isHTML) {\r\n        var $error = this.$(".error");\r\n        if (error) {\r\n            if (isHTML) {\r\n                $error.html(error);\r\n            } else {\r\n                $error.text(error);\r\n            }\r\n            $error.show();\r\n        } else {\r\n            $error.hide();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Set the find count.\r\n     * @param {string} count The find count message to show. Can be the empty string to hide it.\r\n     */\r\n    FindBar.prototype.showFindCount = function (count) {\r\n        this.$("#find-counter").text(count);\r\n    };\r\n    \r\n    /**\r\n     * Show or hide the no-results indicator and optional message. This is also used to\r\n     * indicate regular expression errors.\r\n     * @param {boolean} showIndicator\r\n     * @param {boolean} showMessage\r\n     */\r\n    FindBar.prototype.showNoResults = function (showIndicator, showMessage) {\r\n        ViewUtils.toggleClass(this.$("#find-what"), "no-results", showIndicator);\r\n        \r\n        var $msg = this.$(".no-results-message");\r\n        if (showMessage) {\r\n            $msg.show();\r\n        } else {\r\n            $msg.hide();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Returns the current replace text.\r\n     * @return {string}\r\n     */\r\n    FindBar.prototype.getReplaceText = function () {\r\n        return this.$("#replace-with").val() || "";\r\n    };\r\n    \r\n    /**\r\n     * Enables or disables the controls in the Find bar. Note that if enable is true, *all* controls will be\r\n     * re-enabled, even if some were previously disabled using enableNavigation() or enableReplace(), so you\r\n     * will need to refresh their enable state after calling this.\r\n     * @param {boolean} enable Whether to enable or disable the controls.\r\n     */\r\n    FindBar.prototype.enable = function (enable) {\r\n        var self = this;\r\n        this.$("#find-what, #replace-with, #find-prev, #find-next, #find-case-sensitive, #find-regexp").prop("disabled", !enable);\r\n        this._enabled = enable;\r\n    };\r\n    \r\n    /**\r\n     * @return {boolean} true if the FindBar is enabled.\r\n     */\r\n    FindBar.prototype.isEnabled = function () {\r\n        return this._enabled;\r\n    };\r\n    \r\n    /**\r\n     * @return {boolean} true if the Replace button is enabled.\r\n     */\r\n    FindBar.prototype.isReplaceEnabled = function () {\r\n        return this.$("#replace-yes").is(":enabled");\r\n    };\r\n    \r\n    /**\r\n     * Enable or disable the navigation controls if present. Note that if the Find bar is currently disabled\r\n     * (i.e. isEnabled() returns false), this will have no effect.\r\n     * @param {boolean} enable Whether to enable the controls.\r\n     */\r\n    FindBar.prototype.enableNavigation = function (enable) {\r\n        if (this.isEnabled()) {\r\n            this.$("#find-prev, #find-next").prop("disabled", !enable);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Enable or disable the replace controls if present. Note that if the Find bar is currently disabled\r\n     * (i.e. isEnabled() returns false), this will have no effect.\r\n     * @param {boolean} enable Whether to enable the controls.\r\n     */\r\n    FindBar.prototype.enableReplace = function (enable) {\r\n        if (this.isEnabled) {\r\n            this.$("#replace-yes, #replace-all").prop("disabled", !enable);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Focus and select the contents of the given field.\r\n     * @param {string} selector The selector for the field.\r\n     */\r\n    FindBar.prototype._focus = function (selector) {\r\n        this.$(selector)\r\n            .focus()\r\n            .get(0).select();\r\n    };\r\n    \r\n    /**\r\n     * Sets focus to the query field and selects its text.\r\n     */\r\n    FindBar.prototype.focusQuery = function () {\r\n        this._focus("#find-what");\r\n    };\r\n    \r\n    /**\r\n     * Sets focus to the replace field and selects its text.\r\n     */\r\n    FindBar.prototype.focusReplace = function () {\r\n        this._focus("#replace-with");\r\n    };\r\n    \r\n    PreferencesManager.stateManager.definePreference("caseSensitive", "boolean", false);\r\n    PreferencesManager.stateManager.definePreference("regexp", "boolean", false);\r\n    PreferencesManager.convertPreferences(module, {"caseSensitive": "user", "regexp": "user"}, true);\r\n    \r\n    exports.FindBar = FindBar;\r\n});\n//# sourceURL=/search/FindBar.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*global define, $ */\r\n\r\ndefine(\'search/SearchModel\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'file/FileUtils\',\'utils/StringUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _           = require("thirdparty/lodash"),\r\n        FileUtils   = require("file/FileUtils"),\r\n        StringUtils = require("utils/StringUtils");\r\n\r\n    /**\r\n     * @constructor\r\n     * Manages a set of search query and result data.\r\n     * Dispatches these events:\r\n     *      "change" - whenever the results have been updated. Note that it\'s up to people who\r\n     *      edit the model to call fireChange() when necessary - it doesn\'t automatically fire.\r\n     */\r\n    function SearchModel() {\r\n        this.clear();\r\n    }\r\n\r\n    /** @const Constant used to define the maximum results found. \r\n     *  Note that this is a soft limit - we\'ll likely go slightly over it since\r\n     *  we always add all the searches in a given file.\r\n     */\r\n    SearchModel.MAX_TOTAL_RESULTS = 100000;\r\n        \r\n    /** \r\n     * The current set of results.\r\n     * @type {Object.<fullPath: string, {matches: Array.<Object>, collapsed: boolean, timestamp: Date}>}\r\n     */\r\n    SearchModel.prototype.results = null;\r\n\r\n    /**\r\n     * The query that generated these results.\r\n     * @type {{query: string, caseSensitive: boolean, isRegexp: boolean}}\r\n     */\r\n    SearchModel.prototype.queryInfo = null;\r\n    \r\n    /**\r\n     * The compiled query, expressed as a regexp.\r\n     * @type {RegExp}\r\n     */\r\n    SearchModel.prototype.queryExpr = null;\r\n\r\n    /**\r\n     * Whether this is a find/replace query.\r\n     * @type {boolean}\r\n     */\r\n    SearchModel.prototype.isReplace = false;\r\n\r\n    /**\r\n     * The replacement text specified for this query, if any.\r\n     * @type {string}\r\n     */\r\n    SearchModel.prototype.replaceText = null;\r\n\r\n    /**\r\n     * The file/folder path representing the scope that this query was performed in.\r\n     * @type {FileSystemEntry}\r\n     */\r\n    SearchModel.prototype.scope = null;\r\n    \r\n    /**\r\n     * A file filter (as returned from FileFilters) to apply within the main scope.\r\n     * @type {string}\r\n     */\r\n    SearchModel.prototype.filter = null;\r\n\r\n    /** \r\n     * The total number of matches in the model.\r\n     * @type {number}\r\n     */\r\n    SearchModel.prototype.numMatches = 0;\r\n    \r\n    /**\r\n     * Whether or not we hit the maximum number of results for the type of search we did.\r\n     * @type {boolean}\r\n     */\r\n    SearchModel.prototype.foundMaximum = false;\r\n\r\n    /**\r\n     * Clears out the model to an empty state.\r\n     */\r\n    SearchModel.prototype.clear = function () {\r\n        this.results = {};\r\n        this.queryInfo = null;\r\n        this.queryExpr = null;\r\n        this.isReplace = false;\r\n        this.replaceText = null;\r\n        this.scope = null;\r\n        this.numMatches = 0;\r\n        this.foundMaximum = false;\r\n    };\r\n    \r\n    /**\r\n     * Sets the given query info and stores a compiled RegExp query in this.queryExpr. Returns info on whether the\r\n     * query was valid or not. If the query is invalid, then this.queryExpr will be null.\r\n     * @param {{query: string, caseSensitive: boolean, isRegexp: boolean}} queryInfo\r\n     * @return {{valid: boolean, empty: boolean, error: string}}\r\n     *      valid - set to true if query is a nonempty string or a valid regexp.\r\n     *      empty - set to true if query was empty.\r\n     *      error - set to an error string if valid is false and query is nonempty.\r\n     */\r\n    SearchModel.prototype.setQueryInfo = function (queryInfo) {\r\n        this.queryInfo = queryInfo;\r\n        this.queryExpr = null;\r\n        \r\n        // TODO: only major difference between this one and the one in FindReplace is that \r\n        // this always returns a regexp even for simple strings. Reconcile.\r\n        if (!queryInfo || !queryInfo.query) {\r\n            return {empty: true};\r\n        }\r\n\r\n        // For now, treat all matches as multiline (i.e. ^/$ match on every line, not the whole\r\n        // document). This is consistent with how single-file find works. Eventually we should add\r\n        // an option for this.\r\n        var flags = "gm";\r\n        if (!queryInfo.isCaseSensitive) {\r\n            flags += "i";\r\n        }\r\n        \r\n        // Is it a (non-blank) regex?\r\n        if (queryInfo.isRegexp) {\r\n            try {\r\n                this.queryExpr = new RegExp(queryInfo.query, flags);\r\n            } catch (e) {\r\n                return {valid: false, error: e.message};\r\n            }\r\n        } else {\r\n            // Query is a plain string. Turn it into a regexp\r\n            this.queryExpr = new RegExp(StringUtils.regexEscape(queryInfo.query), flags);\r\n        }\r\n        return {valid: true};\r\n    };\r\n\r\n    /**\r\n     * Sets the list of matches for the given path, removing the previous match info, if any, and updating\r\n     * the total match count. Note that for the count to remain accurate, the previous match info must not have\r\n     * been mutated since it was set.\r\n     * @param {string} fullpath Full path to the file containing the matches.\r\n     * @param {!{matches: Object, timestamp: Date, collapsed: boolean=}} resultInfo Info for the matches to set:\r\n     *      matches - Array of matches, in the format returned by FindInFiles._getSearchMatches()\r\n     *      timestamp - The timestamp of the document at the time we searched it.\r\n     *      collapsed - Optional: whether the results should be collapsed in the UI (default false).\r\n     */\r\n    SearchModel.prototype.setResults = function (fullpath, resultInfo) {\r\n        this.removeResults(fullpath);\r\n        \r\n        if (this.foundMaximum || !resultInfo.matches.length) {\r\n            return;\r\n        }\r\n        \r\n        // Make sure that the optional `collapsed` property is explicitly set to either true or false,\r\n        // to avoid logic issues later with comparing values.\r\n        resultInfo.collapsed = !!resultInfo.collapsed;\r\n        \r\n        this.results[fullpath] = resultInfo;\r\n        this.numMatches += resultInfo.matches.length;\r\n        if (this.numMatches >= SearchModel.MAX_TOTAL_RESULTS) {\r\n            this.foundMaximum = true;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Removes the given result\'s matches from the search results and updates the total match count.\r\n     * @param {string} fullpath Full path to the file containing the matches.\r\n     */\r\n    SearchModel.prototype.removeResults = function (fullpath) {\r\n        if (this.results[fullpath]) {\r\n            this.numMatches -= this.results[fullpath].matches.length;\r\n            delete this.results[fullpath];\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @return {boolean} true if there are any results in this model.\r\n     */\r\n    SearchModel.prototype.hasResults = function () {\r\n        return Object.keys(this.results).length > 0;\r\n    };\r\n\r\n    /**\r\n     * Counts the total number of matches and files\r\n     * @return {{files: number, matches: number}}\r\n     */\r\n    SearchModel.prototype.countFilesMatches = function () {\r\n        return {files: Object.keys(this.results).length, matches: this.numMatches};\r\n    };\r\n\r\n    /**\r\n     * Sorts the file keys to show the results from the selected file first and the rest sorted by path\r\n     * @param {?string} firstFile If specified, the path to the file that should be sorted to the top.\r\n     * @return {Array.<string>}\r\n     */\r\n    SearchModel.prototype.getSortedFiles = function (firstFile) {\r\n        return Object.keys(this.results).sort(function (key1, key2) {\r\n            if (firstFile === key1) {\r\n                return -1;\r\n            } else if (firstFile === key2) {\r\n                return 1;\r\n            }\r\n            return FileUtils.comparePaths(key1, key2);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Notifies listeners that the set of results has changed. Must be called after the\r\n     * model is changed.\r\n     * @param {boolean} quickChange Whether this type of change is one that might occur\r\n     *      often, meaning that the view should buffer updates.\r\n     */\r\n    SearchModel.prototype.fireChanged = function (quickChange) {\r\n        $(this).triggerHandler("change", quickChange);\r\n    };\r\n\r\n    // Public API\r\n    exports.SearchModel = SearchModel;\r\n});\r\n\n//# sourceURL=/search/SearchModel.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $ */\r\n\r\ndefine(\'search/FindUtils\',[\'require\',\'exports\',\'module\',\'utils/Async\',\'document/DocumentManager\',\'view/MainViewManager\',\'filesystem/FileSystem\',\'file/FileUtils\',\'project/ProjectManager\',\'strings\',\'utils/StringUtils\',\'thirdparty/CodeMirror2/lib/codemirror\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var Async           = require("utils/Async"),\r\n        DocumentManager = require("document/DocumentManager"),\r\n        MainViewManager = require("view/MainViewManager"),\r\n        FileSystem      = require("filesystem/FileSystem"),\r\n        FileUtils       = require("file/FileUtils"),\r\n        ProjectManager  = require("project/ProjectManager"),\r\n        Strings         = require("strings"),\r\n        StringUtils     = require("utils/StringUtils"),\r\n        CodeMirror      = require("thirdparty/CodeMirror2/lib/codemirror"),\r\n        _               = require("thirdparty/lodash");\r\n    \r\n    /**\r\n     * Given a replace string that contains $-expressions, replace them with data from the given\r\n     * regexp match info.\r\n     * NOTE: we can\'t just use the ordinary replace() function here because the string has been\r\n     * extracted from the original text and so might be missing some context that the regexp matched.\r\n     * @param {string} replaceWith The string containing the $-expressions.\r\n     * @param {Object} match The match data from the regexp.\r\n     * @return {string} The replace text with the $-expressions substituted.\r\n     */\r\n    function parseDollars(replaceWith, match) {\r\n        replaceWith = replaceWith.replace(/(\\$+)(\\d{1,2}|&)/g, function (whole, dollars, index) {\r\n            if (dollars.length % 2 === 1) { // make sure dollar signs don\'t escape themselves (like $$1, $$$$&)\r\n                if (index === "&") { // handle $&\r\n                    // slice the first dollar (but leave any others to get unescaped below) and return the\r\n                    // whole match\r\n                    return dollars.substr(1) + (match[0] || "");\r\n                } else {\r\n                    // now we\'re sure index is an integer, so we can parse it\r\n                    var parsedIndex = parseInt(index, 10);\r\n                    if (parsedIndex !== 0) { // handle $n or $nn, but don\'t handle $0 or $00\r\n                        // slice the first dollar (but leave any others to get unescaped below) and return the\r\n                        // the corresponding match\r\n                        return dollars.substr(1) + (match[parsedIndex] || "");\r\n                    }\r\n                }\r\n            }\r\n            // this code gets called if the dollar signs escape themselves or if $0/$00 (not handled) was present\r\n            return whole; // return everything to get handled below\r\n        });\r\n        // replace escaped dollar signs (i.e. $$, $$$$, ...) with single ones (unescaping)\r\n        replaceWith = replaceWith.replace(/\\$\\$/g, "$");\r\n        return replaceWith;\r\n    }\r\n    \r\n    /*\r\n     * Returns the string used to prepopulate the find bar\r\n     * @param {!Editor} editor\r\n     * @return {string} first line of primary selection to populate the find bar\r\n     */\r\n    function getInitialQueryFromSelection(editor) {\r\n        var selectionText = editor.getSelectedText();\r\n        if (selectionText) {\r\n            return selectionText\r\n                .replace(/^\\n*/, "") // Trim possible newlines at the very beginning of the selection\r\n                .split("\\n")[0];\r\n        }\r\n        return "";\r\n    }\r\n\r\n    /**\r\n     * Does a set of replacements in a single document in memory.\r\n     * @param {!Document} doc The document to do the replacements in.\r\n     * @param {Object} matchInfo The match info for this file, as returned by `_addSearchMatches()`. Might be mutated.\r\n     * @param {string} replaceText The text to replace each result with.\r\n     * @param {boolean=} isRegexp Whether the original query was a regexp.\r\n     * @return {$.Promise} A promise that\'s resolved when the replacement is finished or rejected with an error if there were one or more errors.\r\n     */\r\n    function _doReplaceInDocument(doc, matchInfo, replaceText, isRegexp) {\r\n        // Double-check that the open document\'s timestamp matches the one we recorded. This\r\n        // should normally never go out of sync, because if it did we wouldn\'t start the\r\n        // replace in the first place (due to the fact that we immediately close the search\r\n        // results panel whenever we detect a filesystem change that affects the results),\r\n        // but we want to double-check in case we don\'t happen to get the change in time.\r\n        // This will *not* handle cases where the document has been edited in memory since \r\n        // the matchInfo was generated.\r\n        if (doc.diskTimestamp.getTime() !== matchInfo.timestamp.getTime()) {\r\n            return new $.Deferred().reject(exports.ERROR_FILE_CHANGED).promise();\r\n        }\r\n\r\n        // Do the replacements in reverse document order so the offsets continue to be correct.\r\n        doc.batchOperation(function () {\r\n            matchInfo.matches.reverse().forEach(function (match) {\r\n                if (match.isChecked) {\r\n                    doc.replaceRange(isRegexp ? parseDollars(replaceText, match.result) : replaceText, match.start, match.end);\r\n                }\r\n            });\r\n        });\r\n        \r\n        return new $.Deferred().resolve().promise();\r\n    }\r\n    \r\n    /**\r\n     * Does a set of replacements in a single file on disk.\r\n     * @param {string} fullPath The full path to the file.\r\n     * @param {Object} matchInfo The match info for this file, as returned by `_addSearchMatches()`.\r\n     * @param {string} replaceText The text to replace each result with.\r\n     * @param {boolean=} isRegexp Whether the original query was a regexp.\r\n     * @return {$.Promise} A promise that\'s resolved when the replacement is finished or rejected with an error if there were one or more errors.\r\n     */\r\n    function _doReplaceOnDisk(fullPath, matchInfo, replaceText, isRegexp) {\r\n        var file = FileSystem.getFileForPath(fullPath);\r\n        return DocumentManager.getDocumentText(file, true).then(function (contents, timestamp, lineEndings) {\r\n            if (timestamp.getTime() !== matchInfo.timestamp.getTime()) {\r\n                // Return a promise that we\'ll reject immediately. (We can\'t just return the\r\n                // error since this is the success handler.)\r\n                return new $.Deferred().reject(exports.ERROR_FILE_CHANGED).promise();\r\n            }\r\n\r\n            // Note that this assumes that the matches are sorted.\r\n            // TODO: is there a more efficient way to do this in a large string?\r\n            var result = [],\r\n                lastIndex = 0;\r\n            matchInfo.matches.forEach(function (match) {\r\n                if (match.isChecked) {\r\n                    result.push(contents.slice(lastIndex, match.startOffset));\r\n                    result.push(isRegexp ? parseDollars(replaceText, match.result) : replaceText);\r\n                    lastIndex = match.endOffset;\r\n                }\r\n            });\r\n            result.push(contents.slice(lastIndex));\r\n\r\n            var newContents = result.join("");\r\n            // TODO: duplicated logic from Document - should refactor this?\r\n            if (lineEndings === FileUtils.LINE_ENDINGS_CRLF) {\r\n                newContents = newContents.replace(/\\n/g, "\\r\\n");\r\n            }\r\n\r\n            return Async.promisify(file, "write", newContents);\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Does a set of replacements in a single file. If the file is already open in a Document in memory,\r\n     * will do the replacement there, otherwise does it directly on disk.\r\n     * @param {string} fullPath The full path to the file.\r\n     * @param {Object} matchInfo The match info for this file, as returned by `_addSearchMatches()`.\r\n     * @param {string} replaceText The text to replace each result with.\r\n     * @param {Object=} options An options object:\r\n     *      forceFilesOpen: boolean - Whether to open the file in an editor and do replacements there rather than doing the \r\n     *          replacements on disk. Note that even if this is false, files that are already open in editors will have replacements\r\n     *          done in memory.\r\n     *      isRegexp: boolean - Whether the original query was a regexp. If true, $-substitution is performed on the replaceText.\r\n     * @return {$.Promise} A promise that\'s resolved when the replacement is finished or rejected with an error if there were one or more errors.\r\n     */\r\n    function _doReplaceInOneFile(fullPath, matchInfo, replaceText, options) {\r\n        var doc = DocumentManager.getOpenDocumentForPath(fullPath);\r\n        options = options || {};\r\n        // If we\'re forcing files open, or if the document is in the working set but not actually open\r\n        // yet, we want to open the file and do the replacement in memory.\r\n        if (!doc && (options.forceFilesOpen || MainViewManager.findInWorkingSet(MainViewManager.ALL_PANES, fullPath) !== -1)) {\r\n            return DocumentManager.getDocumentForPath(fullPath).then(function (newDoc) {\r\n                return _doReplaceInDocument(newDoc, matchInfo, replaceText, options.isRegexp);\r\n            });\r\n        } else if (doc) {\r\n            return _doReplaceInDocument(doc, matchInfo, replaceText, options.isRegexp);\r\n        } else {\r\n            return _doReplaceOnDisk(fullPath, matchInfo, replaceText, options.isRegexp);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Returns true if a search result has any checked matches.\r\n     */\r\n    function hasCheckedMatches(result) {\r\n        return result.matches.some(function (match) { return match.isChecked; });\r\n    }\r\n        \r\n    /**\r\n     * Given a set of search results, replaces them with the given replaceText, either on disk or in memory.\r\n     * Checks timestamps to ensure replacements are not performed in files that have changed on disk since\r\n     * the original search results were generated. However, does *not* check whether edits have been performed\r\n     * in in-memory documents since the search; it\'s up to the caller to guarantee this hasn\'t happened.\r\n     * (When called from the standard Find in Files UI, SearchResultsView guarantees this. If called headlessly,\r\n     * the caller needs to track changes.)\r\n     * \r\n     * Replacements in documents that are already open in memory at the start of the replacement are guaranteed to\r\n     * happen synchronously; replacements in files on disk will return an error if the on-disk file changes between\r\n     * the time performReplacements() is called and the time the replacement actually happens.\r\n     *\r\n     * @param {Object.<fullPath: string, {matches: Array.<{start: {line:number,ch:number}, end: {line:number,ch:number}, startOffset: number, endOffset: number, line: string}>, collapsed: boolean}>} results\r\n     *      The list of results to replace, as returned from _doSearch..\r\n     * @param {string} replaceText The text to replace each result with.\r\n     * @param {?Object} options An options object:\r\n     *      forceFilesOpen: boolean - Whether to open all files in editors and do replacements there rather than doing the \r\n     *          replacements on disk. Note that even if this is false, files that are already open in editors will have replacements\r\n     *          done in memory.\r\n     *      isRegexp: boolean - Whether the original query was a regexp. If true, $-substitution is performed on the replaceText.\r\n     * @return {$.Promise} A promise that\'s resolved when the replacement is finished or rejected with an array of errors\r\n     *      if there were one or more errors. Each individual item in the array will be a {item: string, error: string} object,\r\n     *      where item is the full path to the file that could not be updated, and error is either a FileSystem error or one \r\n     *      of the `FindUtils.ERROR_*` constants.\r\n     */\r\n    function performReplacements(results, replaceText, options) {\r\n        return Async.doInParallel_aggregateErrors(Object.keys(results), function (fullPath) {\r\n            return _doReplaceInOneFile(fullPath, results[fullPath], replaceText, options);\r\n        }).done(function () {\r\n            if (options && options.forceFilesOpen) {\r\n                // If the currently selected document wasn\'t modified by the search, or there is no open document,\r\n                // then open the first modified document.\r\n                var doc = DocumentManager.getCurrentDocument();\r\n                if (!doc ||\r\n                        !results[doc.file.fullPath] ||\r\n                        !hasCheckedMatches(results[doc.file.fullPath])) {\r\n                    // Figure out the first modified document. This logic is slightly different from\r\n                    // SearchResultsView._getSortedFiles() because it doesn\'t sort the currently open file to\r\n                    // the top. But if the currently open file were in the search results, we wouldn\'t be\r\n                    // doing this anyway.\r\n                    var sortedPaths = Object.keys(results).sort(FileUtils.comparePaths),\r\n                        firstPath = _.find(sortedPaths, function (path) {\r\n                            return hasCheckedMatches(results[path]);\r\n                        });\r\n                    \r\n                    if (firstPath) {\r\n                        var newDoc = DocumentManager.getOpenDocumentForPath(firstPath);\r\n                        // newDoc might be null if the replacement failed.\r\n                        if (newDoc) {\r\n                            MainViewManager._edit(MainViewManager.ACTIVE_PANE, newDoc);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Returns label text to indicate the search scope. Already HTML-escaped.\r\n     * @param {?Entry} scope\r\n     * @return {string}\r\n     */\r\n    function labelForScope(scope) {\r\n        if (scope) {\r\n            return StringUtils.format(\r\n                Strings.FIND_IN_FILES_SCOPED,\r\n                StringUtils.breakableUrl(\r\n                    ProjectManager.makeProjectRelativeIfPossible(scope.fullPath)\r\n                )\r\n            );\r\n        } else {\r\n            return Strings.FIND_IN_FILES_NO_SCOPE;\r\n        }\r\n    }\r\n\r\n    exports.parseDollars                    = parseDollars;\r\n    exports.getInitialQueryFromSelection    = getInitialQueryFromSelection;\r\n    exports.hasCheckedMatches               = hasCheckedMatches;\r\n    exports.performReplacements             = performReplacements;\r\n    exports.labelForScope                   = labelForScope;\r\n    exports.ERROR_FILE_CHANGED              = "fileChanged";\r\n});\r\n\n//# sourceURL=/search/FindUtils.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, Mustache */\r\n\r\n/*\r\n * The core search functionality used by Find in Files and single-file Replace Batch.\r\n */\r\ndefine(\'search/FindInFiles\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'search/FileFilters\',\'utils/Async\',\'utils/StringUtils\',\'project/ProjectManager\',\'document/Document\',\'document/DocumentManager\',\'view/MainViewManager\',\'filesystem/FileSystem\',\'language/LanguageManager\',\'search/SearchModel\',\'utils/PerfUtils\',\'search/FindUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _                     = require("thirdparty/lodash"),\r\n        FileFilters           = require("search/FileFilters"),\r\n        Async                 = require("utils/Async"),\r\n        StringUtils           = require("utils/StringUtils"),\r\n        ProjectManager        = require("project/ProjectManager"),\r\n        DocumentModule        = require("document/Document"),\r\n        DocumentManager       = require("document/DocumentManager"),\r\n        MainViewManager       = require("view/MainViewManager"),\r\n        FileSystem            = require("filesystem/FileSystem"),\r\n        LanguageManager       = require("language/LanguageManager"),\r\n        SearchModel           = require("search/SearchModel").SearchModel,\r\n        PerfUtils             = require("utils/PerfUtils"),\r\n        FindUtils             = require("search/FindUtils");\r\n    \r\n    /**\r\n     * Token used to indicate a specific reason for zero search results\r\n     * @const @type {!Object}\r\n     */\r\n    var ZERO_FILES_TO_SEARCH = {};\r\n    \r\n    /**\r\n     * The search query and results model.\r\n     * @type {SearchModel} \r\n     */\r\n    var searchModel = new SearchModel();\r\n    \r\n    /* Forward declarations */\r\n    var _documentChangeHandler, _fileSystemChangeHandler, _fileNameChangeHandler;\r\n    \r\n    /** Remove the listeners that were tracking potential search result changes */\r\n    function _removeListeners() {\r\n        $(DocumentModule).off("documentChange", _documentChangeHandler);\r\n        FileSystem.off("change", _fileSystemChangeHandler);\r\n        $(DocumentManager).off("fileNameChange", _fileNameChangeHandler);\r\n    }\r\n    \r\n    /** Add listeners to track events that might change the search result set */\r\n    function _addListeners() {\r\n        if (searchModel.hasResults()) {\r\n            // Avoid adding duplicate listeners - e.g. if a 2nd search is run without closing the old results panel first\r\n            _removeListeners();\r\n        \r\n            $(DocumentModule).on("documentChange", _documentChangeHandler);\r\n            FileSystem.on("change", _fileSystemChangeHandler);\r\n            $(DocumentManager).on("fileNameChange",  _fileNameChangeHandler);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Searches through the contents and returns an array of matches\r\n     * @param {string} contents\r\n     * @param {RegExp} queryExpr\r\n     * @return {!Array.<{start: {line:number,ch:number}, end: {line:number,ch:number}, line: string}>}\r\n     */\r\n    function _getSearchMatches(contents, queryExpr) {\r\n        // Quick exit if not found or if we hit the limit\r\n        if (searchModel.foundMaximum || contents.search(queryExpr) === -1) {\r\n            return [];\r\n        }\r\n        \r\n        var match, lineNum, line, ch, totalMatchLength, matchedLines, numMatchedLines, lastLineLength,\r\n            lines   = StringUtils.getLines(contents),\r\n            matches = [];\r\n        \r\n        while ((match = queryExpr.exec(contents)) !== null) {\r\n            lineNum          = StringUtils.offsetToLineNum(lines, match.index);\r\n            line             = lines[lineNum];\r\n            ch               = match.index - contents.lastIndexOf("\\n", match.index) - 1;  // 0-based index\r\n            matchedLines     = match[0].split("\\n");\r\n            numMatchedLines  = matchedLines.length;\r\n            totalMatchLength = match[0].length;\r\n            lastLineLength   = matchedLines[matchedLines.length - 1].length;\r\n            \r\n            // Don\'t store more than 200 chars per line\r\n            line = line.substr(0, Math.min(200, line.length));\r\n            \r\n            matches.push({\r\n                start:       {line: lineNum, ch: ch},\r\n                end:         {line: lineNum + numMatchedLines - 1, ch: (numMatchedLines === 1 ? ch + totalMatchLength : lastLineLength)},\r\n                \r\n                // Note that the following offsets from the beginning of the file are *not* updated if the search\r\n                // results change. These are currently only used for multi-file replacement, and we always\r\n                // abort the replace (by shutting the results panel) if we detect any result changes, so we don\'t\r\n                // need to keep them up to date. Eventually, we should either get rid of the need for these (by\r\n                // doing everything in terms of line/ch offsets, though that will require re-splitting files when\r\n                // doing a replace) or properly update them.\r\n                startOffset: match.index,\r\n                endOffset:   match.index + totalMatchLength,\r\n                \r\n                line:        line,\r\n                result:      match,\r\n                isChecked:   true\r\n            });\r\n\r\n            // We have the max hits in just this 1 file. Stop searching this file.\r\n            // This fixed issue #1829 where code hangs on too many hits.\r\n            if (matches.length >= SearchModel.MAX_TOTAL_RESULTS) {\r\n                queryExpr.lastIndex = 0;\r\n                break;\r\n            }\r\n            \r\n            // Pathological regexps like /^/ return 0-length matches. Ensure we make progress anyway\r\n            if (totalMatchLength === 0) {\r\n                queryExpr.lastIndex++;\r\n            }\r\n        }\r\n\r\n        return matches;\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Update the search results using the given list of changes for the given document\r\n     * @param {Document} doc  The Document that changed, should be the current one\r\n     * @param {Array.<{from: {line:number,ch:number}, to: {line:number,ch:number}, text: !Array.<string>}>} changeList\r\n     *      An array of changes as described in the Document constructor\r\n     */\r\n    function _updateResults(doc, changeList) {\r\n        var i, diff, matches, lines, start, howMany,\r\n            resultsChanged = false,\r\n            fullPath       = doc.file.fullPath,\r\n            resultInfo     = searchModel.results[fullPath];\r\n        \r\n        // Remove the results before we make any changes, so the SearchModel can accurately update its count.\r\n        searchModel.removeResults(fullPath);\r\n        \r\n        changeList.forEach(function (change) {\r\n            lines = [];\r\n            start = 0;\r\n            howMany = 0;\r\n\r\n            // There is no from or to positions, so the entire file changed, we must search all over again\r\n            if (!change.from || !change.to) {\r\n                // TODO: add unit test exercising timestamp logic in this case\r\n                // We don\'t just call _updateSearchMatches() here because we want to continue iterating through changes in\r\n                // the list and update at the end.\r\n                resultInfo = {matches: _getSearchMatches(doc.getText(), searchModel.queryExpr), timestamp: doc.diskTimestamp};\r\n                resultsChanged = true;\r\n\r\n            } else {\r\n                // Get only the lines that changed\r\n                for (i = 0; i < change.text.length; i++) {\r\n                    lines.push(doc.getLine(change.from.line + i));\r\n                }\r\n\r\n                // We need to know how many newlines were inserted/deleted in order to update the rest of the line indices;\r\n                // this is the total number of newlines inserted (which is the length of the lines array minus\r\n                // 1, since the last line in the array is inserted without a newline after it) minus the\r\n                // number of original newlines being removed.\r\n                diff = lines.length - 1 - (change.to.line - change.from.line);\r\n\r\n                if (resultInfo) {\r\n                    // Search the last match before a replacement, the amount of matches deleted and update\r\n                    // the lines values for all the matches after the change\r\n                    resultInfo.matches.forEach(function (item) {\r\n                        if (item.end.line < change.from.line) {\r\n                            start++;\r\n                        } else if (item.end.line <= change.to.line) {\r\n                            howMany++;\r\n                        } else {\r\n                            item.start.line += diff;\r\n                            item.end.line   += diff;\r\n                        }\r\n                    });\r\n\r\n                    // Delete the lines that where deleted or replaced\r\n                    if (howMany > 0) {\r\n                        resultInfo.matches.splice(start, howMany);\r\n                    }\r\n                    resultsChanged = true;\r\n                }\r\n\r\n                // Searches only over the lines that changed\r\n                matches = _getSearchMatches(lines.join("\\r\\n"), searchModel.queryExpr);\r\n                if (matches.length) {\r\n                    // Updates the line numbers, since we only searched part of the file\r\n                    matches.forEach(function (value, key) {\r\n                        matches[key].start.line += change.from.line;\r\n                        matches[key].end.line   += change.from.line;\r\n                    });\r\n\r\n                    // If the file index exists, add the new matches to the file at the start index found before\r\n                    if (resultInfo) {\r\n                        Array.prototype.splice.apply(resultInfo.matches, [start, 0].concat(matches));\r\n                    // If not, add the matches to a new file index\r\n                    } else {\r\n                        // TODO: add unit test exercising timestamp logic in self case\r\n                        resultInfo = {\r\n                            matches:   matches,\r\n                            collapsed: false,\r\n                            timestamp: doc.diskTimestamp\r\n                        };\r\n                    }\r\n                    resultsChanged = true;\r\n                }\r\n            }\r\n        });\r\n        \r\n        // Always re-add the results, even if nothing changed.\r\n        if (resultInfo && resultInfo.matches.length) {\r\n            searchModel.setResults(fullPath, resultInfo);\r\n        }\r\n\r\n        if (resultsChanged) {\r\n            // Pass `true` for quickChange here. This will make listeners debounce the change event,\r\n            // avoiding lots of updates if the user types quickly.\r\n            searchModel.fireChanged(true);\r\n        }\r\n    }\r\n        \r\n\r\n    /**\r\n     * Checks that the file matches the given subtree scope. To fully check whether the file\r\n     * should be in the search set, use _inSearchScope() instead - a supserset of this.\r\n     * \r\n     * @param {!File} file\r\n     * @param {?FileSystemEntry} scope Search scope, or null if whole project\r\n     * @return {boolean}\r\n     */\r\n    function _subtreeFilter(file, scope) {\r\n        if (scope) {\r\n            if (scope.isDirectory) {\r\n                // Dirs always have trailing slash, so we don\'t have to worry about being\r\n                // a substring of another dir name\r\n                return file.fullPath.indexOf(scope.fullPath) === 0;\r\n            } else {\r\n                return file.fullPath === scope.fullPath;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n     * Filters out files that are known binary types.\r\n     * @param {string} fullPath\r\n     * @return {boolean} True if the file\'s contents can be read as text\r\n     */\r\n    function _isReadableText(fullPath) {\r\n        return !LanguageManager.getLanguageForPath(fullPath).isBinary();\r\n    }\r\n    \r\n    /**\r\n     * Finds all candidate files to search in the given scope\'s subtree that are not binary content. Does NOT apply\r\n     * the current filter yet.\r\n     * @param {?FileSystemEntry} scope Search scope, or null if whole project\r\n     * @return {$.Promise} A promise that will be resolved with the list of files in the scope. Never rejected.\r\n     */\r\n    function getCandidateFiles(scope) {\r\n        function filter(file) {\r\n            return _subtreeFilter(file, scope) && _isReadableText(file.fullPath);\r\n        }\r\n        \r\n        // If the scope is a single file, just check if the file passes the filter directly rather than\r\n        // trying to use ProjectManager.getAllFiles(), both for performance and because an individual\r\n        // in-memory file might be an untitled document that doesn\'t show up in getAllFiles().\r\n        if (scope && scope.isFile) {\r\n            return new $.Deferred().resolve(filter(scope) ? [scope] : []).promise();\r\n        } else {\r\n            return ProjectManager.getAllFiles(filter, true);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Checks that the file is eligible for inclusion in the search (matches the user\'s subtree scope and\r\n     * file exclusion filters, and isn\'t binary). Used when updating results incrementally - during the\r\n     * initial search, these checks are done in bulk via getCandidateFiles() and the filterFileList() call\r\n     * after it.\r\n     * @param {!File} file\r\n     * @return {boolean}\r\n     */\r\n    function _inSearchScope(file) {\r\n        // Replicate the checks getCandidateFiles() does\r\n        if (searchModel && searchModel.scope) {\r\n            if (!_subtreeFilter(file, searchModel.scope)) {\r\n                return false;\r\n            }\r\n        } else {\r\n            // Still need to make sure it\'s within project or working set\r\n            // In getCandidateFiles(), this is covered by the baseline getAllFiles() itself\r\n            if (file.fullPath.indexOf(ProjectManager.getProjectRoot().fullPath) !== 0) {\r\n                if (MainViewManager.findInWorkingSet(MainViewManager.ALL_PANES, file.fullPath) === -1) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!_isReadableText(file.fullPath)) {\r\n            return false;\r\n        }\r\n        \r\n        // Replicate the filtering filterFileList() does\r\n        return FileFilters.filterPath(searchModel.filter, file.fullPath);\r\n    }\r\n\r\n    \r\n    /**\r\n     * @private\r\n     * Tries to update the search result on document changes\r\n     * @param {$.Event} event\r\n     * @param {Document} document\r\n     * @param {<{from: {line:number,ch:number}, to: {line:number,ch:number}, text: !Array.<string>}>} change\r\n     *      A change list as described in the Document constructor\r\n     */\r\n    _documentChangeHandler = function (event, document, change) {\r\n        if (_inSearchScope(document.file)) {\r\n            _updateResults(document, change);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Finds search results in the given file and adds them to \'searchResults.\' Resolves with\r\n     * true if any matches found, false if none found. Errors reading the file are treated the\r\n     * same as if no results found.\r\n     * \r\n     * Does not perform any filtering - assumes caller has already vetted this file as a search\r\n     * candidate.\r\n     * \r\n     * @param {!File} file\r\n     * @return {$.Promise}\r\n     */\r\n    function _doSearchInOneFile(file) {\r\n        var result = new $.Deferred();\r\n        \r\n        DocumentManager.getDocumentText(file)\r\n            .done(function (text, timestamp) {\r\n                // Note that we don\'t fire a model change here, since this is always called by some outer batch\r\n                // operation that will fire it once it\'s done.\r\n                var matches = _getSearchMatches(text, searchModel.queryExpr);\r\n                searchModel.setResults(file.fullPath, {matches: matches, timestamp: timestamp});\r\n                result.resolve(!!matches.length);\r\n            })\r\n            .fail(function () {\r\n                // Always resolve. If there is an error, this file\r\n                // is skipped and we move on to the next file.\r\n                result.resolve(false);\r\n            });\r\n        \r\n        return result.promise();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Executes the Find in Files search inside the current scope.\r\n     * @param {{query: string, caseSensitive: boolean, isRegexp: boolean}} queryInfo Query info object\r\n     * @param {!$.Promise} candidateFilesPromise Promise from getCandidateFiles(), which was called earlier\r\n     * @param {?string} filter A "compiled" filter as returned by FileFilters.compile(), or null for no filter\r\n     * @return {?$.Promise} A promise that\'s resolved with the search results (or ZERO_FILES_TO_SEARCH) or rejected when the find competes. \r\n     *      Will be null if the query is invalid.\r\n     */\r\n    function _doSearch(queryInfo, candidateFilesPromise, filter) {\r\n        searchModel.filter = filter;\r\n        \r\n        var queryResult = searchModel.setQueryInfo(queryInfo);\r\n        if (!queryResult.valid) {\r\n            return null;\r\n        }\r\n        \r\n        var scopeName = searchModel.scope ? searchModel.scope.fullPath : ProjectManager.getProjectRoot().fullPath,\r\n            perfTimer = PerfUtils.markStart("FindIn: " + scopeName + " - " + queryInfo.query);\r\n        \r\n        return candidateFilesPromise\r\n            .then(function (fileListResult) {\r\n                // Filter out files/folders that match user\'s current exclusion filter\r\n                fileListResult = FileFilters.filterFileList(filter, fileListResult);\r\n                \r\n                if (fileListResult.length) {\r\n                    return Async.doInParallel(fileListResult, _doSearchInOneFile);\r\n                } else {\r\n                    return ZERO_FILES_TO_SEARCH;\r\n                }\r\n            })\r\n            .then(function (zeroFilesToken) {\r\n                exports._searchDone = true; // for unit tests\r\n                PerfUtils.addMeasurement(perfTimer);\r\n                \r\n                // Listen for FS & Document changes to keep results up to date\r\n                _addListeners();\r\n                \r\n                if (zeroFilesToken === ZERO_FILES_TO_SEARCH) {\r\n                    return zeroFilesToken;\r\n                } else {\r\n                    return searchModel.results;\r\n                }\r\n            }, function (err) {\r\n                console.log("find in files failed: ", err);\r\n                PerfUtils.finalizeMeasurement(perfTimer);\r\n                \r\n                // In jQuery promises, returning the error here propagates the rejection,\r\n                // unlike in Promises/A, where we would need to re-throw it to do so.\r\n                return err;\r\n            });\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Clears any previous search information, removing update listeners and clearing the model.\r\n     * @param {?Entry} scope Project file/subfolder to search within; else searches whole project.\r\n     */\r\n    function clearSearch() {\r\n        _removeListeners();\r\n        searchModel.clear();\r\n    }\r\n\r\n    /**\r\n     * Does a search in the given scope with the given filter. Used when you want to start a search\r\n     * programmatically.\r\n     * @param {{query: string, caseSensitive: boolean, isRegexp: boolean}} queryInfo Query info object\r\n     * @param {?Entry} scope Project file/subfolder to search within; else searches whole project.\r\n     * @param {?string} filter A "compiled" filter as returned by FileFilters.compile(), or null for no filter\r\n     * @param {?string} replaceText If this is a replacement, the text to replace matches with. This is just\r\n     *      stored in the model for later use - the replacement is not actually performed right now.\r\n     * @param {?$.Promise} candidateFilesPromise If specified, a promise that should resolve with the same set of files that\r\n     *      getCandidateFiles(scope) would return.\r\n     * @return {$.Promise} A promise that\'s resolved with the search results or rejected when the find competes.\r\n     */\r\n    function doSearchInScope(queryInfo, scope, filter, replaceText, candidateFilesPromise) {\r\n        clearSearch();\r\n        searchModel.scope = scope;\r\n        if (replaceText !== undefined) {\r\n            searchModel.isReplace = true;\r\n            searchModel.replaceText = replaceText;\r\n        }\r\n        candidateFilesPromise = candidateFilesPromise || getCandidateFiles(scope);\r\n        return _doSearch(queryInfo, candidateFilesPromise, filter);\r\n    }\r\n        \r\n    /**\r\n     * Given a set of search results, replaces them with the given replaceText, either on disk or in memory.\r\n     * @param {Object.<fullPath: string, {matches: Array.<{start: {line:number,ch:number}, end: {line:number,ch:number}, startOffset: number, endOffset: number, line: string}>, collapsed: boolean}>} results\r\n     *      The list of results to replace, as returned from _doSearch..\r\n     * @param {string} replaceText The text to replace each result with.\r\n     * @param {?Object} options An options object:\r\n     *      forceFilesOpen: boolean - Whether to open all files in editors and do replacements there rather than doing the \r\n     *          replacements on disk. Note that even if this is false, files that are already open in editors will have replacements\r\n     *          done in memory.\r\n     *      isRegexp: boolean - Whether the original query was a regexp. If true, $-substitution is performed on the replaceText.\r\n     * @return {$.Promise} A promise that\'s resolved when the replacement is finished or rejected with an array of errors\r\n     *      if there were one or more errors. Each individual item in the array will be a {item: string, error: string} object,\r\n     *      where item is the full path to the file that could not be updated, and error is either a FileSystem error or one \r\n     *      of the `FindInFiles.ERROR_*` constants.\r\n     */\r\n    function doReplace(results, replaceText, options) {\r\n        return FindUtils.performReplacements(results, replaceText, options).always(function () {\r\n            // For UI integration testing only\r\n            exports._replaceDone = true;\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Moves the search results from the previous path to the new one and updates the results list, if required\r\n     * @param {$.Event} event\r\n     * @param {string} oldName\r\n     * @param {string} newName\r\n     */\r\n    _fileNameChangeHandler = function (event, oldName, newName) {\r\n        var resultsChanged = false;\r\n        \r\n            // Update the search results\r\n        _.forEach(searchModel.results, function (item, fullPath) {\r\n            if (fullPath.indexOf(oldName) === 0) {\r\n                searchModel.removeResults(fullPath);\r\n                searchModel.setResults(fullPath.replace(oldName, newName), item);\r\n                resultsChanged = true;\r\n            }\r\n        });\r\n\r\n        if (resultsChanged) {\r\n            searchModel.fireChanged();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Updates search results in response to FileSystem "change" event\r\n     * @param {$.Event} event\r\n     * @param {FileSystemEntry} entry\r\n     * @param {Array.<FileSystemEntry>=} added Added children\r\n     * @param {Array.<FileSystemEntry>=} removed Removed children\r\n     */\r\n    _fileSystemChangeHandler = function (event, entry, added, removed) {\r\n        var resultsChanged = false;\r\n\r\n        /*\r\n         * Remove existing search results that match the given entry\'s path\r\n         * @param {(File|Directory)} entry\r\n         */\r\n        function _removeSearchResultsForEntry(entry) {\r\n            Object.keys(searchModel.results).forEach(function (fullPath) {\r\n                if (fullPath.indexOf(entry.fullPath) === 0) {\r\n                    searchModel.removeResults(fullPath);\r\n                    resultsChanged = true;\r\n                }\r\n            });\r\n        }\r\n    \r\n        /*\r\n         * Add new search results for this entry and all of its children\r\n         * @param {(File|Directory)} entry\r\n         * @return {jQuery.Promise} Resolves when the results have been added\r\n         */\r\n        function _addSearchResultsForEntry(entry) {\r\n            var addedFiles = [],\r\n                deferred = new $.Deferred();\r\n            \r\n            // gather up added files\r\n            var visitor = function (child) {\r\n                // Replicate filtering that getAllFiles() does\r\n                if (ProjectManager.shouldShow(child)) {\r\n                    if (child.isFile && _isReadableText(child.name)) {\r\n                        // Re-check the filtering that the initial search applied\r\n                        if (_inSearchScope(child)) {\r\n                            addedFiles.push(child);\r\n                        }\r\n                    }\r\n                    return true;\r\n                }\r\n                return false;\r\n            };\r\n    \r\n            entry.visit(visitor, function (err) {\r\n                if (err) {\r\n                    deferred.reject(err);\r\n                    return;\r\n                }\r\n                \r\n                // find additional matches in all added files\r\n                Async.doInParallel(addedFiles, function (file) {\r\n                    return _doSearchInOneFile(file)\r\n                        .done(function (foundMatches) {\r\n                            resultsChanged = resultsChanged || foundMatches;\r\n                        });\r\n                }).always(deferred.resolve);\r\n            });\r\n    \r\n            return deferred.promise();\r\n        }\r\n        \r\n        if (!entry) {\r\n            // TODO: re-execute the search completely?\r\n            return;\r\n        }\r\n        \r\n        var addPromise;\r\n        if (entry.isDirectory) {\r\n            if (!added || !removed) {\r\n                // If the added or removed sets are null, must redo the search for the entire subtree - we\r\n                // don\'t know which child files/folders may have been added or removed.\r\n                _removeSearchResultsForEntry(entry);\r\n                \r\n                var deferred = $.Deferred();\r\n                addPromise = deferred.promise();\r\n                entry.getContents(function (err, entries) {\r\n                    Async.doInParallel(entries, _addSearchResultsForEntry).always(deferred.resolve);\r\n                });\r\n            } else {\r\n                removed.forEach(_removeSearchResultsForEntry);\r\n                addPromise = Async.doInParallel(added, _addSearchResultsForEntry);\r\n            }\r\n        } else { // entry.isFile\r\n            _removeSearchResultsForEntry(entry);\r\n            addPromise = _addSearchResultsForEntry(entry);\r\n        }\r\n        \r\n        addPromise.always(function () {\r\n            // Restore the results if needed\r\n            if (resultsChanged) {\r\n                searchModel.fireChanged();\r\n            }\r\n        });\r\n    };\r\n    \r\n    // Public exports\r\n    exports.searchModel          = searchModel;\r\n    exports.doSearchInScope      = doSearchInScope;\r\n    exports.doReplace            = doReplace;\r\n    exports.getCandidateFiles    = getCandidateFiles;\r\n    exports.clearSearch          = clearSearch;\r\n    exports.ZERO_FILES_TO_SEARCH = ZERO_FILES_TO_SEARCH;\r\n    \r\n    // For unit tests only\r\n    exports._documentChangeHandler = _documentChangeHandler;\r\n    exports._fileNameChangeHandler = _fileNameChangeHandler;\r\n    exports._fileSystemChangeHandler = _fileSystemChangeHandler;\r\n});\r\n\n//# sourceURL=/search/FindInFiles.js'),eval('define(\'text!htmlContent/search-panel.html\',[],function () { return \'<div id="{{panelID}}" class="search-results bottom-panel vert-resizable top-resizer no-focus">\\r\\n    <div class="toolbar simple-toolbar-layout">\\r\\n        <div class="title"></div>\\r\\n        <a href="#" class="close">&times;</a>\\r\\n    </div>\\r\\n    <div class="table-container resizable-content"></div>\\r\\n</div>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/search-panel.html'),eval('define(\'text!htmlContent/search-results.html\',[],function () { return \'<table class="bottom-panel-table table table-striped table-condensed row-highlight">\\r\\n    <tbody>\\r\\n        {{#searchList}}\\r\\n        <tr class="file-section" data-file-index="{{fileIndex}}">\\r\\n            {{#replace}}<td class="checkbox-column"><input type="checkbox" class="check-one-file" {{#isChecked}}checked="true"{{/isChecked}} /></td>{{/replace}}\\r\\n            <td colspan="2">\\r\\n                <span class="disclosure-triangle expanded" title="{{Strings.FIND_IN_FILES_EXPAND_COLLAPSE}}"></span>\\r\\n                {{{filename}}}\\r\\n            </td>\\r\\n        </tr>\\r\\n        {{#items}}\\r\\n        <tr data-file-index="{{fileIndex}}" data-item-index="{{itemIndex}}" data-match-index="{{matchIndex}}">\\r\\n            {{#replace}}<td class="checkbox-column"><input type="checkbox" class="check-one" {{#isChecked}}checked="true"{{/isChecked}} /></td>{{/replace}}\\r\\n            <td class="line-number">{{line}}</td>\\r\\n            <td class="line-text">{{pre}}<span class="highlight">{{highlight}}</span>{{post}}</td>\\r\\n        </tr>\\r\\n        {{/items}}\\r\\n        {{/searchList}}\\r\\n    </tbody>\\r\\n</table>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/search-results.html'),eval('define(\'text!htmlContent/search-summary.html\',[],function () { return \'{{#replace}}\\r\\n<div class="fixed-col"><input type="checkbox" class="check-all" {{#allChecked}}checked="checked"{{/allChecked}} /></div>\\r\\n{{/replace}}\\r\\n<div class="fixed-col">{{titleLabel}} &quot;</div>\\r\\n<div class="contracting-col">{{query}}</div>\\r\\n<div class="fixed-col">&quot;</div>\\r\\n{{#replace}}\\r\\n<div class="fixed-col">&nbsp;{{Strings.FIND_REPLACE_TITLE_WITH}} &quot;</div>\\r\\n<div class="contracting-col">{{replaceWith}}</div>\\r\\n<div class="fixed-col">&quot;</div>\\r\\n{{/replace}}\\r\\n{{#scope}}\\r\\n<div class="contracting-col">{{{scope}}}</div>\\r\\n{{/scope}}\\r\\n<div class="fixed-col">&nbsp;{{{summary}}}</div>\\r\\n{{#hasPages}}\\r\\n<div class="pagination-col">\\r\\n    <span class="first-page {{^hasPrev}}disabled{{/hasPrev}}"></span>\\r\\n    <span class="prev-page {{^hasPrev}}disabled{{/hasPrev}}"></span>\\r\\n    {{{results}}}\\r\\n    <span class="next-page {{^hasNext}}disabled{{/hasNext}}"></span>\\r\\n    <span class="last-page {{^hasNext}}disabled{{/hasNext}}"></span>\\r\\n</div>\\r\\n{{/hasPages}}\\r\\n{{#replace}}\\r\\n<div class="replace-col">\\r\\n    <button class="btn small replace-checked">{{Strings.BUTTON_REPLACE}}</button>\\r\\n</div>\\r\\n{{/replace}}\';});\n\n//# sourceURL=/text!htmlContent/search-summary.html'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*global define, $, window, Mustache */\r\n\r\n/*\r\n * Panel showing search results for a Find/Replace in Files operation.\r\n */\r\ndefine(\'search/SearchResultsView\',[\'require\',\'exports\',\'module\',\'command/CommandManager\',\'command/Commands\',\'document/DocumentManager\',\'editor/EditorManager\',\'project/ProjectManager\',\'project/FileViewController\',\'file/FileUtils\',\'search/FindUtils\',\'view/WorkspaceManager\',\'utils/StringUtils\',\'strings\',\'thirdparty/lodash\',\'text!htmlContent/search-panel.html\',\'text!htmlContent/search-results.html\',\'text!htmlContent/search-summary.html\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var CommandManager        = require("command/CommandManager"),\r\n        Commands              = require("command/Commands"),\r\n        DocumentManager       = require("document/DocumentManager"),\r\n        EditorManager         = require("editor/EditorManager"),\r\n        ProjectManager        = require("project/ProjectManager"),\r\n        FileViewController    = require("project/FileViewController"),\r\n        FileUtils             = require("file/FileUtils"),\r\n        FindUtils             = require("search/FindUtils"),\r\n        WorkspaceManager      = require("view/WorkspaceManager"),\r\n        StringUtils           = require("utils/StringUtils"),\r\n        Strings               = require("strings"),\r\n        _                     = require("thirdparty/lodash"),\r\n        \r\n        searchPanelTemplate   = require("text!htmlContent/search-panel.html"),\r\n        searchResultsTemplate = require("text!htmlContent/search-results.html"),\r\n        searchSummaryTemplate = require("text!htmlContent/search-summary.html");\r\n    \r\n    \r\n    /** \r\n     * @const \r\n     * The maximum results to show per page.\r\n     * @type {number}\r\n     */\r\n    var RESULTS_PER_PAGE = 100;\r\n    \r\n    /**\r\n     * @const\r\n     * Debounce time for document changes updating the search results view.\r\n     * @type {number}\r\n     */\r\n    var UPDATE_TIMEOUT   = 400;\r\n    \r\n    /**\r\n     * @constructor\r\n     * Handles the search results panel.\r\n     * Dispatches the following events:\r\n     *      replaceAll - when the "Replace" button is clicked.\r\n     *      close - when the panel is closed.\r\n     *\r\n     * @param {SearchModel} model The model that this view is showing.\r\n     * @param {string} panelID The CSS ID to use for the panel.\r\n     * @param {string} panelName The name to use for the panel, as passed to PanelManager.createBottomPanel().\r\n     */\r\n    function SearchResultsView(model, panelID, panelName) {\r\n        var panelHtml  = Mustache.render(searchPanelTemplate, {panelID: panelID});\r\n\r\n        this._panel    = WorkspaceManager.createBottomPanel(panelName, $(panelHtml), 100);\r\n        this._$summary = this._panel.$panel.find(".title");\r\n        this._$table   = this._panel.$panel.find(".table-container");\r\n        this._model    = model;\r\n    }\r\n    \r\n    /** @type {SearchModel} The search results model we\'re viewing. */\r\n    SearchResultsView.prototype._model = null;\r\n    \r\n    /**\r\n     * Array with content used in the Results Panel\r\n     * @type {Array.<{fileIndex: number, filename: string, fullPath: string, items: Array.<Object>}>}\r\n     */\r\n    SearchResultsView.prototype._searchList = [];\r\n    \r\n    /** @type {Panel} Bottom panel holding the search results */\r\n    SearchResultsView.prototype._panel = null;\r\n    \r\n    /** @type {?string} The full path of the file that was open in the main editor on the initial search */\r\n    SearchResultsView.prototype._initialFilePath = null;\r\n    \r\n    /** @type {number} The index of the first result that is displayed */\r\n    SearchResultsView.prototype._currentStart = 0;\r\n        \r\n    /** @type {boolean} Used to remake the replace all summary after it is changed */\r\n    SearchResultsView.prototype._allChecked = false;\r\n    \r\n    /** @type {$.Element} The currently selected row */\r\n    SearchResultsView.prototype._$selectedRow = null;\r\n    \r\n    /** @type {$.Element} The element where the title is placed */\r\n    SearchResultsView.prototype._$summary = null;\r\n    \r\n    /** @type {$.Element} The table that holds the results */\r\n    SearchResultsView.prototype._$table = null;\r\n    \r\n    /** @type {number} The ID we use for timeouts when handling model changes. */\r\n    SearchResultsView.prototype._timeoutID = null;\r\n        \r\n    /**\r\n     * @private\r\n     * Handles when model changes. Updates the view, buffering changes if necessary so as not to churn too much.\r\n     */\r\n    SearchResultsView.prototype._handleModelChange = function (quickChange) {\r\n        // If this is a replace, to avoid complications with updating, just close ourselves if we hear about\r\n        // a results model change after we\'ve already shown the results initially.\r\n        // TODO: notify user, re-do search in file\r\n        if (this._model.isReplace) {\r\n            this.close();\r\n            return;\r\n        }\r\n        \r\n        var self = this;\r\n        if (this._timeoutID) {\r\n            window.clearTimeout(this._timeoutID);\r\n        }\r\n        if (quickChange) {\r\n            this._timeoutID = window.setTimeout(function () {\r\n                self._updateResults();\r\n                self._timeoutID = null;\r\n            }, UPDATE_TIMEOUT);\r\n        } else {\r\n            this._updateResults();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Adds the listeners for close, prev, next, first, last and check all\r\n     */\r\n    SearchResultsView.prototype._addPanelListeners = function () {\r\n        var self = this;\r\n        this._panel.$panel\r\n            .off(".searchResults")  // Remove the old events\r\n            .on("click.searchResults", ".close", function () {\r\n                self.close();\r\n            })\r\n            // The link to go the first page\r\n            .on("click.searchResults", ".first-page:not(.disabled)", function () {\r\n                self._currentStart = 0;\r\n                self._render();\r\n            })\r\n            // The link to go the previous page\r\n            .on("click.searchResults", ".prev-page:not(.disabled)", function () {\r\n                self._currentStart -= RESULTS_PER_PAGE;\r\n                self._render();\r\n            })\r\n            // The link to go to the next page\r\n            .on("click.searchResults", ".next-page:not(.disabled)", function () {\r\n                self._currentStart += RESULTS_PER_PAGE;\r\n                self._render();\r\n            })\r\n            // The link to go to the last page\r\n            .on("click.searchResults", ".last-page:not(.disabled)", function () {\r\n                self._currentStart = self._getLastCurrentStart();\r\n                self._render();\r\n            })\r\n            \r\n            // Add the file to the working set on double click\r\n            .on("dblclick.searchResults", ".table-container tr:not(.file-section)", function (e) {\r\n                var item = self._searchList[$(this).data("file-index")];\r\n                FileViewController.openFileAndAddToWorkingSet(item.fullPath);\r\n            })\r\n        \r\n            // Add the click event listener directly on the table parent\r\n            .on("click.searchResults .table-container", function (e) {\r\n                var $row = $(e.target).closest("tr");\r\n\r\n                if ($row.length) {\r\n                    if (self._$selectedRow) {\r\n                        self._$selectedRow.removeClass("selected");\r\n                    }\r\n                    $row.addClass("selected");\r\n                    self._$selectedRow = $row;\r\n\r\n                    var searchItem = self._searchList[$row.data("file-index")],\r\n                        fullPath   = searchItem.fullPath;\r\n\r\n                    // This is a file title row, expand/collapse on click\r\n                    if ($row.hasClass("file-section")) {\r\n                        var $titleRows,\r\n                            collapsed = !self._model.results[fullPath].collapsed;\r\n\r\n                        if (e.metaKey || e.ctrlKey) { //Expand all / Collapse all\r\n                            $titleRows = $(e.target).closest("table").find(".file-section");\r\n                        } else {\r\n                            // Clicking the file section header collapses/expands result rows for that file\r\n                            $titleRows = $row;\r\n                        }\r\n\r\n                        $titleRows.each(function () {\r\n                            fullPath   = self._searchList[$(this).data("file-index")].fullPath;\r\n                            searchItem = self._model.results[fullPath];\r\n\r\n                            if (searchItem.collapsed !== collapsed) {\r\n                                searchItem.collapsed = collapsed;\r\n                                $(this).nextUntil(".file-section").toggle();\r\n                                $(this).find(".disclosure-triangle").toggleClass("expanded").toggleClass("collapsed");\r\n                            }\r\n                        });\r\n\r\n                        //In Expand/Collapse all, reset all search results \'collapsed\' flag to same value(true/false).\r\n                        if (e.metaKey || e.ctrlKey) {\r\n                            _.forEach(self._model.results, function (item) {\r\n                                item.collapsed = collapsed;\r\n                            });\r\n                        }\r\n                    \r\n                    // This is a file row, show the result on click\r\n                    } else {\r\n                        // Grab the required item data\r\n                        var item = searchItem.items[$row.data("item-index")];\r\n\r\n                        CommandManager.execute(Commands.FILE_OPEN, {fullPath: fullPath})\r\n                            .done(function (doc) {\r\n                                // Opened document is now the current main editor\r\n                                EditorManager.getCurrentFullEditor().setSelection(item.start, item.end, true);\r\n                            });\r\n                    }\r\n                }\r\n            });\r\n        \r\n        function updateHeaderCheckbox($checkAll) {\r\n            var $allFileRows     = self._panel.$panel.find(".file-section"),\r\n                $checkedFileRows = $allFileRows.filter(function (index) {\r\n                    return $(this).find(".check-one-file").is(":checked");\r\n                });\r\n            if ($checkedFileRows.length === $allFileRows.length) {\r\n                $checkAll.prop("checked", true);\r\n            }\r\n        }\r\n        \r\n        function updateFileAndHeaderCheckboxes($clickedRow, isChecked) {\r\n            var $firstMatch = ($clickedRow.data("item-index") === 0) ? $clickedRow :\r\n                    $clickedRow.prevUntil(".file-section").last(),\r\n                $fileRow = $firstMatch.prev(),\r\n                $siblingRows = $fileRow.nextUntil(".file-section"),\r\n                $fileCheckbox = $fileRow.find(".check-one-file"),\r\n                $checkAll = self._panel.$panel.find(".check-all");\r\n        \r\n            if (isChecked) {\r\n                if (!$fileCheckbox.is(":checked")) {\r\n                    var $checkedSibilings = $siblingRows.filter(function (index) {\r\n                            return $(this).find(".check-one").is(":checked");\r\n                        });\r\n                    if ($checkedSibilings.length === $siblingRows.length) {\r\n                        $fileCheckbox.prop("checked", true);\r\n                        if (!$checkAll.is(":checked")) {\r\n                            updateHeaderCheckbox($checkAll);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                if ($checkAll.is(":checked")) {\r\n                    $checkAll.prop("checked", false);\r\n                }\r\n                if ($fileCheckbox.is(":checked")) {\r\n                    $fileCheckbox.prop("checked", false);\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Add the Click handlers for replace functionality if required\r\n        if (this._model.isReplace) {\r\n            this._panel.$panel\r\n                .on("click.searchResults", ".check-all", function (e) {\r\n                    var isChecked = $(this).is(":checked");\r\n                    _.forEach(self._model.results, function (results) {\r\n                        results.matches.forEach(function (match) {\r\n                            match.isChecked = isChecked;\r\n                        });\r\n                    });\r\n                    self._$table.find(".check-one").prop("checked", isChecked);\r\n                    self._$table.find(".check-one-file").prop("checked", isChecked);\r\n                    self._allChecked = isChecked;\r\n                })\r\n                .on("click.searchResults", ".check-one-file", function (e) {\r\n                    var isChecked = $(this).is(":checked"),\r\n                        $row = $(e.target).closest("tr"),\r\n                        item = self._searchList[$row.data("file-index")],\r\n                        $matchRows = $row.nextUntil(".file-section"),\r\n                        $checkAll = self._panel.$panel.find(".check-all");\r\n                    \r\n                    if (item) {\r\n                        self._model.results[item.fullPath].matches.forEach(function (match) {\r\n                            match.isChecked = isChecked;\r\n                        });\r\n                    }\r\n                    $matchRows.find(".check-one").prop("checked", isChecked);\r\n                    if (!isChecked) {\r\n                        if ($checkAll.is(":checked")) {\r\n                            $checkAll.prop("checked", false);\r\n                        }\r\n                    } else if (!$checkAll.is(":checked")) {\r\n                        updateHeaderCheckbox($checkAll);\r\n                    }\r\n                    e.stopPropagation();\r\n                })\r\n                .on("click.searchResults", ".check-one", function (e) {\r\n                    var $row = $(e.target).closest("tr"),\r\n                        item = self._searchList[$row.data("file-index")],\r\n                        match = self._model.results[item.fullPath].matches[$row.data("match-index")];\r\n\r\n                    match.isChecked = $(this).is(":checked");\r\n                    updateFileAndHeaderCheckboxes($row, match.isChecked);\r\n                    e.stopPropagation();\r\n                })\r\n                .on("click.searchResults", ".replace-checked", function (e) {\r\n                    $(self).triggerHandler("replaceAll");\r\n                });\r\n        }\r\n    };\r\n    \r\n    \r\n    /**\r\n     * @private\r\n     * Shows the Results Summary\r\n     */\r\n    SearchResultsView.prototype._showSummary = function () {\r\n        var count     = this._model.countFilesMatches(),\r\n            lastIndex = this._getLastIndex(count.matches),\r\n            fileList  = Object.keys(this._model.results),\r\n            filesStr,\r\n            summary;\r\n        \r\n        filesStr = StringUtils.format(\r\n            Strings.FIND_NUM_FILES,\r\n            count.files,\r\n            (count.files > 1 ? Strings.FIND_IN_FILES_FILES : Strings.FIND_IN_FILES_FILE)\r\n        );\r\n        \r\n        // This text contains some formatting, so all the strings are assumed to be already escaped\r\n        summary = StringUtils.format(\r\n            Strings.FIND_TITLE_SUMMARY,\r\n            this._model.foundMaximum ? Strings.FIND_IN_FILES_MORE_THAN : "",\r\n            String(count.matches),\r\n            (count.matches > 1) ? Strings.FIND_IN_FILES_MATCHES : Strings.FIND_IN_FILES_MATCH,\r\n            filesStr\r\n        );\r\n\r\n        this._$summary.html(Mustache.render(searchSummaryTemplate, {\r\n            query:       (this._model.queryInfo.query && this._model.queryInfo.query.toString()) || "",\r\n            replaceWith: this._model.replaceText,\r\n            titleLabel:  this._model.isReplace ? Strings.FIND_REPLACE_TITLE_LABEL : Strings.FIND_TITLE_LABEL,\r\n            scope:       this._model.scope ? "&nbsp;" + FindUtils.labelForScope(this._model.scope) + "&nbsp;" : "",\r\n            summary:     summary,\r\n            allChecked:  this._allChecked,\r\n            hasPages:    count.matches > RESULTS_PER_PAGE,\r\n            results:     StringUtils.format(Strings.FIND_IN_FILES_PAGING, this._currentStart + 1, lastIndex),\r\n            hasPrev:     this._currentStart > 0,\r\n            hasNext:     lastIndex < count.matches,\r\n            replace:     this._model.isReplace,\r\n            Strings:     Strings\r\n        }));\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Shows the current set of results.\r\n     */\r\n    SearchResultsView.prototype._render = function () {\r\n        var searchItems, match, i, item, multiLine,\r\n            count            = this._model.countFilesMatches(),\r\n            searchFiles      = this._model.getSortedFiles(this._initialFilePath),\r\n            lastIndex        = this._getLastIndex(count.matches),\r\n            matchesCounter   = 0,\r\n            showMatches      = false,\r\n            allInFileChecked = true,\r\n            self             = this;\r\n        \r\n        this._showSummary();\r\n        this._searchList   = [];\r\n        \r\n        // Iterates throuh the files to display the results sorted by filenamess. The loop ends as soon as\r\n        // we filled the results for one page\r\n        searchFiles.some(function (fullPath) {\r\n            showMatches = true;\r\n            item = self._model.results[fullPath];\r\n\r\n            // Since the amount of matches on this item plus the amount of matches we skipped until\r\n            // now is still smaller than the first match that we want to display, skip these.\r\n            if (matchesCounter + item.matches.length < self._currentStart) {\r\n                matchesCounter += item.matches.length;\r\n                showMatches = false;\r\n\r\n            // If we still haven\'t skipped enough items to get to the first match, but adding the\r\n            // item matches to the skipped ones is greater the the first match we want to display,\r\n            // then we can display the matches from this item skipping the first ones\r\n            } else if (matchesCounter < self._currentStart) {\r\n                i = self._currentStart - matchesCounter;\r\n                matchesCounter = self._currentStart;\r\n\r\n            // If we already skipped enough matches to get to the first match to display, we can start\r\n            // displaying from the first match of this item\r\n            } else if (matchesCounter < lastIndex) {\r\n                i = 0;\r\n\r\n            // We can\'t display more items by now. Break the loop\r\n            } else {\r\n                return true;\r\n            }\r\n\r\n            if (showMatches && i < item.matches.length) {\r\n                // Add a row for each match in the file\r\n                searchItems = [];\r\n\r\n                allInFileChecked = true;\r\n                // Add matches until we get to the last match of this item, or filling the page\r\n                while (i < item.matches.length && matchesCounter < lastIndex) {\r\n                    match     = item.matches[i];\r\n                    multiLine = match.start.line !== match.end.line;\r\n                    \r\n                    searchItems.push({\r\n                        fileIndex:  self._searchList.length,\r\n                        itemIndex:  searchItems.length,\r\n                        matchIndex: i,\r\n                        line:       match.start.line + 1,\r\n                        pre:        match.line.substr(0, match.start.ch),\r\n                        highlight:  match.line.substring(match.start.ch, multiLine ? undefined : match.end.ch),\r\n                        post:       multiLine ? "\\u2026" : match.line.substr(match.end.ch),\r\n                        start:      match.start,\r\n                        end:        match.end,\r\n                        isChecked:  match.isChecked\r\n                    });\r\n                    if (!match.isChecked) {\r\n                        allInFileChecked = false;\r\n                    }\r\n                    matchesCounter++;\r\n                    i++;\r\n                }\r\n\r\n                // Add a row for each file\r\n                var relativePath    = FileUtils.getDirectoryPath(ProjectManager.makeProjectRelativeIfPossible(fullPath)),\r\n                    directoryPath   = FileUtils.getDirectoryPath(relativePath),\r\n                    displayFileName = StringUtils.format(\r\n                        Strings.FIND_IN_FILES_FILE_PATH,\r\n                        StringUtils.breakableUrl(FileUtils.getBaseName(fullPath)),\r\n                        StringUtils.breakableUrl(directoryPath),\r\n                        directoryPath ? "&mdash;" : ""\r\n                    );\r\n\r\n                self._searchList.push({\r\n                    fileIndex: self._searchList.length,\r\n                    filename:  displayFileName,\r\n                    fullPath:  fullPath,\r\n                    isChecked: allInFileChecked,\r\n                    items:     searchItems\r\n                });\r\n            }\r\n        });\r\n\r\n        \r\n        // Insert the search results\r\n        this._$table\r\n            .empty()\r\n            .append(Mustache.render(searchResultsTemplate, {\r\n                replace:       this._model.isReplace,\r\n                searchList:    this._searchList,\r\n                Strings:       Strings\r\n            }))\r\n            // Restore the collapsed files\r\n            .find(".file-section").each(function () {\r\n                var fullPath = self._searchList[$(this).data("file-index")].fullPath;\r\n\r\n                if (self._model.results[fullPath].collapsed) {\r\n                    self._model.results[fullPath].collapsed = false;\r\n                    $(this).trigger("click");\r\n                }\r\n            });\r\n        \r\n        if (this._$selectedRow) {\r\n            this._$selectedRow.removeClass("selected");\r\n            this._$selectedRow = null;\r\n        }\r\n        \r\n        this._panel.show();\r\n        this._$table.scrollTop(0); // Otherwise scroll pos from previous contents is remembered\r\n    };\r\n    \r\n    /**\r\n     * Updates the results view after a model change, preserving scroll position and selection.\r\n     */\r\n    SearchResultsView.prototype._updateResults = function () {\r\n        // In general this shouldn\'t get called if the panel is closed, but in case some\r\n        // asynchronous process kicks this (e.g. a debounced model change), we double-check.\r\n        if (this._panel.isVisible()) {\r\n            var scrollTop  = this._$table.scrollTop(),\r\n                index      = this._$selectedRow ? this._$selectedRow.index() : null,\r\n                numMatches = this._model.countFilesMatches().matches;\r\n\r\n            if (this._currentStart > numMatches) {\r\n                this._currentStart = this._getLastCurrentStart(numMatches);\r\n            }\r\n            \r\n            this._render();\r\n\r\n            this._$table.scrollTop(scrollTop);\r\n            if (index) {\r\n                this._$selectedRow = this._$table.find("tr:eq(" + index + ")");\r\n                this._$selectedRow.addClass("selected");\r\n            }\r\n        }\r\n    };\r\n        \r\n    /**\r\n     * @private\r\n     * Returns one past the last result index displayed for the current page.\r\n     * @param {number} numMatches\r\n     * @return {number}\r\n     */\r\n    SearchResultsView.prototype._getLastIndex = function (numMatches) {\r\n        return Math.min(this._currentStart + RESULTS_PER_PAGE, numMatches);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Returns the last possible current start based on the given number of matches\r\n     * @param {number=} numMatches\r\n     * @return {number}\r\n     */\r\n    SearchResultsView.prototype._getLastCurrentStart = function (numMatches) {\r\n        numMatches = numMatches || this._model.countFilesMatches().matches;\r\n        return Math.floor((numMatches - 1) / RESULTS_PER_PAGE) * RESULTS_PER_PAGE;\r\n    };\r\n    \r\n    /**\r\n     * Opens the results panel and displays the current set of results from the model.\r\n     */\r\n    SearchResultsView.prototype.open = function () {\r\n        // Clear out any paging/selection state.\r\n        this._currentStart  = 0;\r\n        this._$selectedRow  = null;\r\n        this._allChecked    = true;\r\n        \r\n        // Save the currently open document\'s fullpath, if any, so we can sort it to the top of the result list.\r\n        var currentDoc = DocumentManager.getCurrentDocument();\r\n        this._initialFilePath = currentDoc ? currentDoc.file.fullPath : null;\r\n\r\n        this._render();\r\n        \r\n        // Listen for user interaction events with the panel and change events from the model.\r\n        this._addPanelListeners();\r\n        $(this._model).on("change.SearchResultsView", this._handleModelChange.bind(this));\r\n    };\r\n    \r\n    /**\r\n     * Hides the Search Results Panel and unregisters listeners.\r\n     */\r\n    SearchResultsView.prototype.close = function () {\r\n        if (this._panel && this._panel.isVisible()) {\r\n            this._$table.empty();\r\n            this._panel.hide();\r\n            this._panel.$panel.off(".searchResults");\r\n            $(this._model).off("change.SearchResultsView");\r\n            $(this).triggerHandler("close");\r\n        }\r\n    };\r\n    \r\n    // Public API\r\n    exports.SearchResultsView = SearchResultsView;\r\n});\r\n\n//# sourceURL=/search/SearchResultsView.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, Mustache */\r\n\r\n/*\r\n * UI and controller logic for find/replace across multiple files within the project.\r\n *\r\n * FUTURE:\r\n *  - Handle matches that span multiple lines\r\n */\r\ndefine(\'search/FindInFilesUI\',[\'require\',\'exports\',\'module\',\'utils/AppInit\',\'command/CommandManager\',\'command/Commands\',\'widgets/Dialogs\',\'widgets/DefaultDialogs\',\'editor/EditorManager\',\'view/WorkspaceManager\',\'search/FileFilters\',\'file/FileUtils\',\'search/FindBar\',\'search/FindInFiles\',\'search/FindUtils\',\'document/InMemoryFile\',\'project/ProjectManager\',\'search/SearchResultsView\',\'widgets/StatusBar\',\'strings\',\'utils/StringUtils\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var AppInit           = require("utils/AppInit"),\r\n        CommandManager    = require("command/CommandManager"),\r\n        Commands          = require("command/Commands"),\r\n        Dialogs           = require("widgets/Dialogs"),\r\n        DefaultDialogs    = require("widgets/DefaultDialogs"),\r\n        EditorManager     = require("editor/EditorManager"),\r\n        WorkspaceManager  = require("view/WorkspaceManager"),\r\n        FileFilters       = require("search/FileFilters"),\r\n        FileUtils         = require("file/FileUtils"),\r\n        FindBar           = require("search/FindBar").FindBar,\r\n        FindInFiles       = require("search/FindInFiles"),\r\n        FindUtils         = require("search/FindUtils"),\r\n        InMemoryFile      = require("document/InMemoryFile"),\r\n        ProjectManager    = require("project/ProjectManager"),\r\n        SearchResultsView = require("search/SearchResultsView").SearchResultsView,\r\n        StatusBar         = require("widgets/StatusBar"),\r\n        Strings           = require("strings"),\r\n        StringUtils       = require("utils/StringUtils"),\r\n        _                 = require("thirdparty/lodash");\r\n\r\n\r\n    /** @const Maximum number of files to do replacements in-memory instead of on disk. */\r\n    var MAX_IN_MEMORY = 20;\r\n    \r\n    /** @type {SearchResultsView} The results view. Initialized in htmlReady() */\r\n    var _resultsView = null;\r\n    \r\n    /** @type {FindBar} Find bar containing the search UI. */\r\n    var _findBar = null;\r\n\r\n    /**\r\n     * Does a search in the given scope with the given filter. Shows the result list once the search is complete.\r\n     * @param {{query: string, caseSensitive: boolean, isRegexp: boolean}} queryInfo Query info object\r\n     * @param {?Entry} scope Project file/subfolder to search within; else searches whole project.\r\n     * @param {?string} filter A "compiled" filter as returned by FileFilters.compile(), or null for no filter\r\n     * @param {?string} replaceText If this is a replacement, the text to replace matches with.\r\n     * @param {?$.Promise} candidateFilesPromise If specified, a promise that should resolve with the same set of files that\r\n     *      getCandidateFiles(scope) would return.\r\n     * @return {$.Promise} A promise that\'s resolved with the search results or rejected when the find competes.\r\n     */\r\n    function searchAndShowResults(queryInfo, scope, filter, replaceText, candidateFilesPromise) {\r\n        return FindInFiles.doSearchInScope(queryInfo, scope, filter, replaceText, candidateFilesPromise)\r\n            .done(function (zeroFilesToken) {\r\n                // Done searching all files: show results\r\n                if (FindInFiles.searchModel.hasResults()) {\r\n                    _resultsView.open();\r\n\r\n                    if (_findBar) {\r\n                        _findBar.close();\r\n                    }\r\n\r\n                } else {\r\n                    _resultsView.close();\r\n\r\n                    if (_findBar) {\r\n                        var showMessage = false;\r\n                        _findBar.enable(true);\r\n                        _findBar.focusQuery();\r\n                        if (zeroFilesToken === FindInFiles.ZERO_FILES_TO_SEARCH) {\r\n                            _findBar.showError(StringUtils.format(Strings.FIND_IN_FILES_ZERO_FILES, FindUtils.labelForScope(FindInFiles.searchModel.scope)), true);\r\n                        } else {\r\n                            showMessage = true;\r\n                        }\r\n                        _findBar.showNoResults(true, showMessage);\r\n                    }\r\n                }\r\n\r\n                StatusBar.hideBusyIndicator();\r\n            })\r\n            .fail(function (err) {\r\n                console.log("find in files failed: ", err);\r\n                StatusBar.hideBusyIndicator();\r\n            });\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Displays a non-modal embedded dialog above the code mirror editor that allows the user to do\r\n     * a find operation across all files in the project.\r\n     * @param {?Entry} scope  Project file/subfolder to search within; else searches whole project.\r\n     * @param {boolean=} showReplace If true, show the Replace controls.\r\n     */\r\n    function _showFindBar(scope, showReplace) {\r\n        // If the scope is a file with a custom viewer, then we\r\n        // don\'t show find in files dialog.\r\n        if (scope && !EditorManager.canOpenPath(scope.fullPath)) {\r\n            return;\r\n        }\r\n        \r\n        if (scope instanceof InMemoryFile) {\r\n            CommandManager.execute(Commands.FILE_OPEN, { fullPath: scope.fullPath }).done(function () {\r\n                CommandManager.execute(Commands.CMD_FIND);\r\n            });\r\n            return;\r\n        }\r\n        \r\n        // Default to searching for the current selection\r\n        var currentEditor = EditorManager.getActiveEditor(),\r\n            initialQuery  = "";\r\n\r\n        if (_findBar && !_findBar.isClosed()) {\r\n            // The modalBar was already up. When creating the new modalBar, copy the\r\n            // current query instead of using the passed-in selected text.\r\n            initialQuery = _findBar.getQueryInfo().query;\r\n        } else if (currentEditor) {\r\n            initialQuery = FindUtils.getInitialQueryFromSelection(currentEditor);\r\n        }\r\n        \r\n        FindInFiles.clearSearch();\r\n        \r\n        // Close our previous find bar, if any. (The open() of the new _findBar will\r\n        // take care of closing any other find bar instances.)\r\n        if (_findBar) {\r\n            _findBar.close();\r\n        }\r\n\r\n        _findBar = new FindBar({\r\n            multifile: true,\r\n            replace: showReplace,\r\n            initialQuery: initialQuery,\r\n            queryPlaceholder: Strings.FIND_QUERY_PLACEHOLDER,\r\n            scopeLabel: FindUtils.labelForScope(scope)\r\n        });\r\n        _findBar.open();\r\n\r\n        // TODO Should push this state into ModalBar (via a FindBar API) instead of installing a callback like this.\r\n        // Custom closing behavior: if in the middle of executing search, blur shouldn\'t close ModalBar yet. And\r\n        // don\'t close bar when opening Edit Filter dialog either.\r\n        _findBar._modalBar.isLockedOpen = function () {\r\n            // TODO: should have state for whether the search is executing instead of looking at find bar state\r\n            // TODO: should have API on filterPicker to figure out if dialog is open\r\n            return !_findBar.isEnabled() || $(".modal.instance .exclusions-editor").length > 0;\r\n        };\r\n        \r\n        var candidateFilesPromise = FindInFiles.getCandidateFiles(scope),  // used for eventual search, and in exclusions editor UI\r\n            filterPicker;\r\n        \r\n        function handleQueryChange() {\r\n            // Check the query expression on every input event. This way the user is alerted\r\n            // to any RegEx syntax errors immediately.\r\n            var queryInfo = _findBar.getQueryInfo(),\r\n                queryResult = FindInFiles.searchModel.setQueryInfo(queryInfo);\r\n\r\n            // Enable the replace button appropriately.\r\n            _findBar.enableReplace(queryResult.valid);\r\n\r\n            if (queryResult.valid || queryResult.empty) {\r\n                _findBar.showNoResults(false);\r\n                _findBar.showError(null);\r\n            } else {\r\n                _findBar.showNoResults(true, false);\r\n                _findBar.showError(queryResult.error);\r\n            }\r\n        }\r\n        \r\n        function startSearch(replaceText) {\r\n            var queryInfo = _findBar.getQueryInfo();\r\n            if (queryInfo && queryInfo.query) {\r\n                _findBar.enable(false);\r\n                StatusBar.showBusyIndicator(true);\r\n\r\n                var filter;\r\n                if (filterPicker) {\r\n                    filter = FileFilters.commitPicker(filterPicker);\r\n                } else {\r\n                    // Single-file scope: don\'t use any file filters\r\n                    filter = null;\r\n                }\r\n                searchAndShowResults(queryInfo, scope, filter, replaceText, candidateFilesPromise);\r\n            }\r\n            return null;\r\n        }\r\n        \r\n        function startReplace() {\r\n            startSearch(_findBar.getReplaceText());\r\n        }\r\n        \r\n        $(_findBar)\r\n            .on("doFind.FindInFiles", function () {\r\n                // Subtle issue: we can\'t just pass startSearch directly as the handler, because\r\n                // we don\'t want it to get the event object as an argument.\r\n                startSearch();\r\n            })\r\n            .on("queryChange.FindInFiles", handleQueryChange)\r\n            .on("close.FindInFiles", function (e) {\r\n                $(_findBar).off(".FindInFiles");\r\n                _findBar = null;\r\n            });\r\n        \r\n        if (showReplace) {\r\n            // We shouldn\'t get a "doReplace" in this case, since the Replace button\r\n            // is hidden when we set options.multifile.\r\n            $(_findBar).on("doReplaceAll.FindInFiles", startReplace);\r\n        }\r\n        \r\n        var oldModalBarHeight = _findBar._modalBar.height();\r\n        \r\n        // Show file-exclusion UI *unless* search scope is just a single file\r\n        if (!scope || scope.isDirectory) {\r\n            var exclusionsContext = {\r\n                label: FindUtils.labelForScope(scope),\r\n                promise: candidateFilesPromise\r\n            };\r\n\r\n            filterPicker = FileFilters.createFilterPicker(exclusionsContext);\r\n            // TODO: include in FindBar? (and disable it when FindBar is disabled)\r\n            _findBar._modalBar.getRoot().find(".scope-group").append(filterPicker);\r\n        }\r\n        \r\n        handleQueryChange();\r\n        \r\n        // Appending FilterPicker and query text can change height of modal bar, so resize editor.\r\n        // Preserve scroll position of the current full editor across the editor refresh, adjusting\r\n        // for the height of the modal bar so the code doesn\'t appear to shift if possible.\r\n        var fullEditor = EditorManager.getCurrentFullEditor(),\r\n            scrollPos;\r\n        if (fullEditor) {\r\n            scrollPos = fullEditor.getScrollPos();\r\n            scrollPos.y -= oldModalBarHeight;   // modalbar already showing, adjust for old height\r\n        }\r\n        WorkspaceManager.recomputeLayout();\r\n        if (fullEditor) {\r\n            fullEditor._codeMirror.scrollTo(scrollPos.x, scrollPos.y + _findBar._modalBar.height());\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Finish a replace across files operation when the user clicks "Replace" on the results panel.\r\n     * @param {SearchModel} model The model for the search associated with ths replace.\r\n     */\r\n    function _finishReplaceAll(model) {\r\n        var replaceText = model.replaceText;\r\n        if (replaceText === null) {\r\n            return;\r\n        }\r\n        \r\n        // Clone the search results so that they don\'t get updated in the middle of the replacement.\r\n        var resultsClone = _.cloneDeep(model.results),\r\n            replacedFiles = Object.keys(resultsClone).filter(function (path) {\r\n                return FindUtils.hasCheckedMatches(resultsClone[path]);\r\n            }),\r\n            isRegexp = model.queryInfo.isRegexp,\r\n            replacePromise;\r\n        \r\n        function processReplace(forceFilesOpen) {\r\n            StatusBar.showBusyIndicator(true);\r\n            FindInFiles.doReplace(resultsClone, replaceText, { forceFilesOpen: forceFilesOpen, isRegexp: isRegexp })\r\n                .fail(function (errors) {\r\n                    var message = Strings.REPLACE_IN_FILES_ERRORS + FileUtils.makeDialogFileList(\r\n                            errors.map(function (errorInfo) {\r\n                                return ProjectManager.makeProjectRelativeIfPossible(errorInfo.item);\r\n                            })\r\n                        );\r\n                    \r\n                    Dialogs.showModalDialog(\r\n                        DefaultDialogs.DIALOG_ID_ERROR,\r\n                        Strings.REPLACE_IN_FILES_ERRORS_TITLE,\r\n                        message,\r\n                        [\r\n                            {\r\n                                className : Dialogs.DIALOG_BTN_CLASS_PRIMARY,\r\n                                id        : Dialogs.DIALOG_BTN_OK,\r\n                                text      : Strings.BUTTON_REPLACE_WITHOUT_UNDO\r\n                            }\r\n                        ]\r\n                    );\r\n                })\r\n                .always(function () {\r\n                    StatusBar.hideBusyIndicator();\r\n                });\r\n        }\r\n                \r\n        if (replacedFiles.length <= MAX_IN_MEMORY) {\r\n            // Just do the replacements in memory.\r\n            _resultsView.close();\r\n            processReplace(true);\r\n        } else {\r\n            Dialogs.showModalDialog(\r\n                DefaultDialogs.DIALOG_ID_INFO,\r\n                Strings.REPLACE_WITHOUT_UNDO_WARNING_TITLE,\r\n                StringUtils.format(Strings.REPLACE_WITHOUT_UNDO_WARNING, MAX_IN_MEMORY),\r\n                [\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_NORMAL,\r\n                        id        : Dialogs.DIALOG_BTN_CANCEL,\r\n                        text      : Strings.CANCEL\r\n                    },\r\n                    {\r\n                        className : Dialogs.DIALOG_BTN_CLASS_PRIMARY,\r\n                        id        : Dialogs.DIALOG_BTN_OK,\r\n                        text      : Strings.BUTTON_REPLACE_WITHOUT_UNDO\r\n                    }\r\n                ]\r\n            )\r\n                .done(function (id) {\r\n                    if (id === Dialogs.DIALOG_BTN_OK) {\r\n                        _resultsView.close();\r\n                        processReplace(false);\r\n                    }\r\n                });\r\n        }\r\n    }\r\n\r\n    // Command handlers\r\n    \r\n    /**\r\n     * @private\r\n     * Bring up the Find in Files UI with the replace options.\r\n     */\r\n    function _showReplaceBar() {\r\n        _showFindBar(null, true);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Search within the file/subtree defined by the sidebar selection\r\n     */\r\n    function _showFindBarForSubtree() {\r\n        var selectedEntry = ProjectManager.getSelectedItem();\r\n        _showFindBar(selectedEntry);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Search within the file/subtree defined by the sidebar selection\r\n     */\r\n    function _showReplaceBarForSubtree() {\r\n        var selectedEntry = ProjectManager.getSelectedItem();\r\n        _showFindBar(selectedEntry, true);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Close the open search bar, if any. For unit tests.\r\n     */\r\n    function _closeFindBar() {\r\n        if (_findBar) {\r\n            _findBar.close();\r\n        }\r\n    }\r\n    \r\n    // Initialize items dependent on HTML DOM\r\n    AppInit.htmlReady(function () {\r\n        var model = FindInFiles.searchModel;\r\n        _resultsView = new SearchResultsView(model, "find-in-files-results", "find-in-files.results");\r\n        $(_resultsView)\r\n            .on("replaceAll", function () {\r\n                _finishReplaceAll(model);\r\n            })\r\n            .on("close", function () {\r\n                FindInFiles.clearSearch();\r\n            });\r\n    });\r\n    \r\n    // Initialize: register listeners\r\n    $(ProjectManager).on("beforeProjectClose", function () { _resultsView.close(); });\r\n    \r\n    // Initialize: command handlers\r\n    CommandManager.register(Strings.CMD_FIND_IN_FILES,       Commands.CMD_FIND_IN_FILES,       _showFindBar);\r\n    CommandManager.register(Strings.CMD_FIND_IN_SELECTED,    Commands.CMD_FIND_IN_SELECTED,    _showFindBarForSubtree);\r\n    CommandManager.register(Strings.CMD_FIND_IN_SUBTREE,     Commands.CMD_FIND_IN_SUBTREE,     _showFindBarForSubtree);\r\n    \r\n    CommandManager.register(Strings.CMD_REPLACE_IN_FILES,    Commands.CMD_REPLACE_IN_FILES,    _showReplaceBar);\r\n    CommandManager.register(Strings.CMD_REPLACE_IN_SELECTED, Commands.CMD_REPLACE_IN_SELECTED, _showReplaceBarForSubtree);\r\n    CommandManager.register(Strings.CMD_REPLACE_IN_SUBTREE,  Commands.CMD_REPLACE_IN_SUBTREE,  _showReplaceBarForSubtree);\r\n    \r\n    // Public exports\r\n    exports.searchAndShowResults = searchAndShowResults;\r\n    \r\n    // For unit testing\r\n    exports._showFindBar  = _showFindBar;\r\n    exports._closeFindBar = _closeFindBar;\r\n});\r\n\n//# sourceURL=/search/FindInFilesUI.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets, window */\r\n\r\n\r\n/**\r\n * Manages tickmarks shown along the scrollbar track.\r\n * NOT yet intended for use by anyone other than the FindReplace module.\r\n * It is assumed that markers are always clear()ed when switching editors.\r\n */\r\ndefine(\'search/ScrollTrackMarkers\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'editor/Editor\',\'editor/EditorManager\',\'view/WorkspaceManager\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n    \r\n    var Editor              = require("editor/Editor"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        WorkspaceManager    = require("view/WorkspaceManager");\r\n    \r\n    \r\n    /**\r\n     * Editor the markers are currently shown for, or null if not shown\r\n     * @type {?Editor}\r\n     */\r\n    var editor;\r\n    \r\n    /**\r\n     * Top of scrollbar track area, relative to top of scrollbar\r\n     * @type {number}\r\n     */\r\n    var trackOffset;\r\n    \r\n    /**\r\n     * Height of scrollbar track area\r\n     * @type {number}\r\n     */\r\n    var trackHt;\r\n    \r\n    /**\r\n     * Text positions of markers\r\n     * @type {!Array.<{line: number, ch: number}>}\r\n     */\r\n    var marks = [];\r\n    \r\n    \r\n    function _getScrollbar(editor) {\r\n        // Be sure to select only the direct descendant, not also elements within nested inline editors\r\n        return $(editor.getRootElement()).children(".CodeMirror-vscrollbar");\r\n    }\r\n    \r\n    /** Measure scrollbar track */\r\n    function _calcScaling() {\r\n        var $sb = _getScrollbar(editor);\r\n        \r\n        trackHt = $sb[0].offsetHeight;\r\n        \r\n        if (trackHt > 0) {\r\n            // Scrollbar visible: determine offset of track from top of scrollbar\r\n            if (brackets.platform === "win") {\r\n                trackOffset = 0;  // Custom scrollbar CSS has no gap around the track\r\n            } else if (brackets.platform === "mac") {\r\n                trackOffset = 4;  // Native scrollbar has padding around the track\r\n            } else { //(Linux)\r\n                trackOffset = 2;  // Custom scrollbar CSS has assymmetrical gap; this approximates it\r\n            }\r\n            trackHt -= trackOffset * 2;\r\n            \r\n        } else {\r\n            // No scrollbar: use the height of the entire code content\r\n            var codeContainer = $(editor.getRootElement()).find("> .CodeMirror-scroll > .CodeMirror-sizer > div > .CodeMirror-lines > div")[0];\r\n            trackHt = codeContainer.offsetHeight;\r\n            trackOffset = codeContainer.offsetTop;\r\n        }\r\n    }\r\n\r\n    /** Add all the given tickmarks to the DOM in a batch */\r\n    function _renderMarks(posArray) {\r\n        var html = "";\r\n        posArray.forEach(function (pos) {\r\n            var top = Math.round(pos.line / editor.lineCount() * trackHt) + trackOffset;\r\n            top--;  // subtract ~1/2 the ht of a tickmark to center it on ideal pos\r\n            \r\n            html += "<div class=\'tickmark\' style=\'top:" + top + "px\'></div>";\r\n        });\r\n        $(".tickmark-track", editor.getRootElement()).append($(html));\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Clear any markers in the editor\'s tickmark track, but leave it visible. Safe to call when\r\n     * tickmark track is not visible also.\r\n     */\r\n    function clear() {\r\n        if (editor) {\r\n            $(".tickmark-track", editor.getRootElement()).empty();\r\n            marks = [];\r\n        }\r\n    }\r\n    \r\n    /** Add or remove the tickmark track from the editor\'s UI */\r\n    function setVisible(curEditor, visible) {\r\n        // short-circuit no-ops\r\n        if ((visible && curEditor === editor) || (!visible && !editor)) {\r\n            return;\r\n        }\r\n        \r\n        if (visible) {\r\n            console.assert(!editor);\r\n            editor = curEditor;\r\n            \r\n            // Don\'t support inline editors yet - search inside them is pretty screwy anyway (#2110)\r\n            if (editor.isTextSubset()) {\r\n                return;\r\n            }\r\n            \r\n            var $sb = _getScrollbar(editor);\r\n            var $overlay = $("<div class=\'tickmark-track\'></div>");\r\n            $sb.parent().append($overlay);\r\n            \r\n            _calcScaling();\r\n            \r\n            // Update tickmarks during editor resize (whenever resizing has paused/stopped for > 1/3 sec)\r\n            $(WorkspaceManager).on("workspaceUpdateLayout.ScrollTrackMarkers", _.debounce(function () {\r\n                if (marks.length) {\r\n                    _calcScaling();\r\n                    $(".tickmark-track", editor.getRootElement()).empty();\r\n                    _renderMarks(marks);\r\n                }\r\n            }, 300));\r\n            \r\n        } else {\r\n            console.assert(editor === curEditor);\r\n            $(".tickmark-track", curEditor.getRootElement()).remove();\r\n            editor = null;\r\n            marks = [];\r\n            $(WorkspaceManager).off("workspaceUpdateLayout.ScrollTrackMarkers");\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Add tickmarks to the editor\'s tickmark track, if it\'s visible\r\n     * @param curEditor {!Editor}\r\n     * @param posArray {!Array.<{line:Number, ch:Number}>}\r\n     */\r\n    function addTickmarks(curEditor, posArray) {\r\n        console.assert(editor === curEditor);\r\n        \r\n        marks = marks.concat(posArray);\r\n        _renderMarks(posArray);\r\n    }\r\n\r\n    // Private helper for unit tests\r\n    function _getTickmarks() {\r\n        return marks;\r\n    }\r\n\r\n\r\n    // For unit tests\r\n    exports._getTickmarks   = _getTickmarks;\r\n\r\n    exports.clear           = clear;\r\n    exports.setVisible      = setVisible;\r\n    exports.addTickmarks    = addTickmarks;\r\n});\r\n\n//# sourceURL=/search/ScrollTrackMarkers.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define, $, Mustache */\r\n/*unittests: FindReplace*/\r\n\r\n\r\n/**\r\n * Adds Find and Replace commands\r\n *\r\n * Originally based on the code in CodeMirror2/lib/util/search.js.\r\n */\r\ndefine(\'search/FindReplace\',[\'require\',\'exports\',\'module\',\'command/CommandManager\',\'utils/AppInit\',\'command/Commands\',\'document/DocumentManager\',\'view/MainViewManager\',\'project/ProjectManager\',\'strings\',\'utils/StringUtils\',\'editor/Editor\',\'editor/EditorManager\',\'search/FindBar\',\'search/FindUtils\',\'search/FindInFilesUI\',\'search/ScrollTrackMarkers\',\'widgets/StatusBar\',\'preferences/PreferencesManager\',\'thirdparty/lodash\',\'thirdparty/CodeMirror2/lib/codemirror\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var CommandManager      = require("command/CommandManager"),\r\n        AppInit             = require("utils/AppInit"),\r\n        Commands            = require("command/Commands"),\r\n        DocumentManager     = require("document/DocumentManager"),\r\n        MainViewManager     = require("view/MainViewManager"),\r\n        ProjectManager      = require("project/ProjectManager"),\r\n        Strings             = require("strings"),\r\n        StringUtils         = require("utils/StringUtils"),\r\n        Editor              = require("editor/Editor"),\r\n        EditorManager       = require("editor/EditorManager"),\r\n        FindBar             = require("search/FindBar").FindBar,\r\n        FindUtils           = require("search/FindUtils"),\r\n        FindInFilesUI       = require("search/FindInFilesUI"),\r\n        ScrollTrackMarkers  = require("search/ScrollTrackMarkers"),\r\n        StatusBar           = require("widgets/StatusBar"),\r\n        PreferencesManager  = require("preferences/PreferencesManager"),\r\n        _                   = require("thirdparty/lodash"),\r\n        CodeMirror          = require("thirdparty/CodeMirror2/lib/codemirror");\r\n    \r\n    /**\r\n     * Maximum file size to search within (in chars)\r\n     * @const {number}\r\n     */\r\n    var FIND_MAX_FILE_SIZE  = 500000;\r\n\r\n    /**\r\n     * If the number of matches exceeds this limit, inline text highlighting and scroll-track tickmarks are disabled\r\n     * @const {number}\r\n     */\r\n    var FIND_HIGHLIGHT_MAX  = 2000;\r\n\r\n    /**\r\n     * Instance of the currently opened document when replaceAllPanel is visible\r\n     * @type {?Document}\r\n     */\r\n    var currentDocument = null;\r\n\r\n    /**\r\n     * Currently open Find or Find/Replace bar, if any\r\n     * @type {?FindBar} \r\n     */\r\n    var findBar;\r\n    \r\n    function SearchState() {\r\n        this.searchStartPos = null;\r\n        this.parsedQuery = null;\r\n        this.queryInfo = null;\r\n        this.foundAny = false;\r\n        this.marked = [];\r\n        this.resultSet = [];\r\n        this.matchIndex = -1;\r\n        this.markedCurrent = null;\r\n    }\r\n\r\n    function getSearchState(cm) {\r\n        if (!cm._searchState) {\r\n            cm._searchState = new SearchState();\r\n        }\r\n        return cm._searchState;\r\n    }\r\n\r\n    function getSearchCursor(cm, state, pos) {\r\n        // Heuristic: if the query string is all lowercase, do a case insensitive search.\r\n        return cm.getSearchCursor(state.parsedQuery, pos, !state.queryInfo.isCaseSensitive);\r\n    }\r\n    \r\n    function parseQuery(queryInfo) {\r\n        if (findBar) {\r\n            findBar.showError(null);\r\n        }\r\n        \r\n        if (!queryInfo || !queryInfo.query) {\r\n            return "";\r\n        }\r\n    \r\n        // Is it a (non-blank) regex?\r\n        if (queryInfo.isRegexp) {\r\n            try {\r\n                return new RegExp(queryInfo.query, queryInfo.isCaseSensitive ? "" : "i");\r\n            } catch (e) {\r\n                if (findBar) {\r\n                    findBar.showError(e.message);\r\n                }\r\n                return "";\r\n            }\r\n        \r\n        } else {\r\n            return queryInfo.query;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Determine the query from the given info and store it in the state.\r\n     * @param {SearchState} state The state to store the parsed query in\r\n     * @param {{query: string, caseSensitive: boolean, isRegexp: boolean}} queryInfo \r\n     *      The query info object as returned by FindBar.getQueryInfo()\r\n     */\r\n    function setQueryInfo(state, queryInfo) {\r\n        state.queryInfo = queryInfo;\r\n        if (!queryInfo) {\r\n            state.parsedQuery = null;\r\n        } else {\r\n            state.parsedQuery = parseQuery(queryInfo);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Show the current match index by finding matchRange in the resultSet stored \r\n     * in the search state if this is the first call for a new search query. For\r\n     * subsequent calls, just compare matchRange with the next match in the resultSet\r\n     * based on the search direction and show the next match if they are the same. \r\n     * If not, then find the match index by searching matchRange in the entire resultSet.\r\n     *\r\n     * @param {!SearchState} state The search state that has the array of search result\r\n     * @param {!{from: {line: number, ch: number}, to: {line: number, ch: number}}} matchRange - the range of current match\r\n     * @param {!boolean} searchBackwards true if searching backwards\r\n     */\r\n    function _updateFindBarWithMatchInfo(state, matchRange, searchBackwards) {\r\n        // Bail if there is no result set.\r\n        if (!state.foundAny) {\r\n            return;\r\n        }\r\n        \r\n        if (findBar) {\r\n            if (state.matchIndex === -1) {\r\n                state.matchIndex = _.findIndex(state.resultSet, matchRange);\r\n            } else {\r\n                state.matchIndex = searchBackwards ? state.matchIndex - 1 : state.matchIndex + 1;\r\n                // Adjust matchIndex for modulo wraparound\r\n                state.matchIndex = (state.matchIndex + state.resultSet.length) % state.resultSet.length;\r\n                \r\n                // Confirm that we find the right matchIndex. If not, then search \r\n                // matchRange in the entire resultSet.\r\n                if (!_.isEqual(state.resultSet[state.matchIndex], matchRange)) {\r\n                    state.matchIndex = _.findIndex(state.resultSet, matchRange);\r\n                }\r\n            }\r\n        \r\n            if (state.matchIndex !== -1) {\r\n                // Convert to 1-based by adding one before showing the index.\r\n                findBar.showFindCount(StringUtils.format(Strings.FIND_MATCH_INDEX,\r\n                                                        state.matchIndex + 1, state.resultSet.length));\r\n            }\r\n        }\r\n    }\r\n       \r\n    /**\r\n     * @private\r\n     * Returns the next match for the current query (from the search state) before/after the given position. Wraps around\r\n     * the end of the document if no match is found before the end.\r\n     *\r\n     * @param {!Editor} editor The editor to search in\r\n     * @param {boolean} searchBackwards true to search backwards\r\n     * @param {{line: number, ch: number}=} pos The position to start from. Defaults to the current primary selection\'s\r\n     *      head cursor position.\r\n     * @param {boolean=} wrap Whether to wrap the search around if we hit the end of the document. Default true.\r\n     * @return {?{start: {line: number, ch: number}, end: {line: number, ch: number}}} The range for the next match, or\r\n     *      null if there is no match.\r\n     */\r\n    function _getNextMatch(editor, searchBackwards, pos, wrap) {\r\n        var cm = editor._codeMirror;\r\n        var state = getSearchState(cm);\r\n        var cursor = getSearchCursor(cm, state, pos || editor.getCursorPos(false, searchBackwards ? "start" : "end"));\r\n\r\n        state.lastMatch = cursor.find(searchBackwards);\r\n        if (!state.lastMatch && wrap !== false) {\r\n            // If no result found before hitting edge of file, try wrapping around\r\n            cursor = getSearchCursor(cm, state, searchBackwards ? {line: cm.lineCount() - 1} : {line: 0, ch: 0});\r\n            state.lastMatch = cursor.find(searchBackwards);\r\n        }\r\n        if (!state.lastMatch) {\r\n            // No result found, period: clear selection & bail\r\n            cm.setCursor(editor.getCursorPos());  // collapses selection, keeping cursor in place to avoid scrolling\r\n            return null;\r\n        }\r\n\r\n        return {start: cursor.from(), end: cursor.to()};\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Sets the given selections in the editor and applies some heuristics to determine whether and how we should\r\n     * center the primary selection.\r\n     *\r\n     * @param {!Editor} editor The editor to search in\r\n     * @param {!Array<{start:{line:number, ch:number}, end:{line:number, ch:number}, primary:boolean, reversed: boolean}>} selections\r\n     *      The selections to set. Must not be empty.\r\n     * @param {boolean} center Whether to try to center the primary selection vertically on the screen. If false, the selection will still be scrolled\r\n     *      into view if it\'s offscreen, but will not be centered.\r\n     * @param {boolean=} preferNoScroll If center is true, whether to avoid scrolling if the hit is in the top half of the screen. Default false.\r\n     */\r\n    function _selectAndScrollTo(editor, selections, center, preferNoScroll) {\r\n        var primarySelection = _.find(selections, function (sel) { return sel.primary; }) || _.last(selections),\r\n            resultVisible = editor.isLineVisible(primarySelection.start.line),\r\n            centerOptions = Editor.BOUNDARY_CHECK_NORMAL;\r\n\r\n        if (preferNoScroll && resultVisible) {\r\n            // no need to scroll if the line with the match is in view\r\n            centerOptions = Editor.BOUNDARY_IGNORE_TOP;\r\n        }\r\n        \r\n        // Make sure the primary selection is fully visible on screen.\r\n        var primary = _.find(selections, function (sel) {\r\n            return sel.primary;\r\n        });\r\n        if (!primary) {\r\n            primary = _.last(selections);\r\n        }\r\n        editor._codeMirror.scrollIntoView({from: primary.start, to: primary.end});\r\n        editor.setSelections(selections, center, centerOptions);\r\n    }\r\n    \r\n    /**\r\n     * Returns the range of the word surrounding the given editor position. Similar to getWordAt() from CodeMirror.\r\n     *\r\n     * @param {!Editor} editor The editor to search in\r\n     * @param {!{line: number, ch: number}} pos The position to find a word at.\r\n     * @return {{start:{line: number, ch: number}, end:{line:number, ch:number}, text:string}} The range and content of the found word. If\r\n     *     there is no word, start will equal end and the text will be the empty string.\r\n     */\r\n    function _getWordAt(editor, pos) {\r\n        var cm = editor._codeMirror,\r\n            start = pos.ch,\r\n            end = start,\r\n            line = cm.getLine(pos.line);\r\n        while (start && CodeMirror.isWordChar(line.charAt(start - 1))) {\r\n            --start;\r\n        }\r\n        while (end < line.length && CodeMirror.isWordChar(line.charAt(end))) {\r\n            ++end;\r\n        }\r\n        return {start: {line: pos.line, ch: start}, end: {line: pos.line, ch: end}, text: line.slice(start, end)};\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Helper function. Returns true if two selections are equal.\r\n     * @param {!{start: {line: number, ch: number}, end: {line: number, ch: number}}} sel1 The first selection to compare\r\n     * @param {!{start: {line: number, ch: number}, end: {line: number, ch: number}}} sel2 The second selection to compare\r\n     * @return {boolean} true if the selections are equal\r\n     */\r\n    function _selEq(sel1, sel2) {\r\n        return (CodeMirror.cmpPos(sel1.start, sel2.start) === 0 && CodeMirror.cmpPos(sel1.end, sel2.end) === 0);\r\n    }\r\n\r\n    /**\r\n     * Expands each empty range in the selection to the nearest word boundaries. Then, if the primary selection \r\n     * was already a range (even a non-word range), adds the next instance of the contents of that range as a selection.\r\n     *\r\n     * @param {!Editor} editor The editor to search in\r\n     * @param {boolean=} removePrimary Whether to remove the current primary selection in addition to adding the\r\n     * next one. If true, we add the next match even if the current primary selection is a cursor (we expand it\r\n     * first to determine what to match).\r\n     */\r\n    function _expandWordAndAddNextToSelection(editor, removePrimary) {\r\n        editor = editor || EditorManager.getActiveEditor();\r\n        if (!editor) {\r\n            return;\r\n        }\r\n        \r\n        var selections = editor.getSelections(),\r\n            primarySel,\r\n            primaryIndex,\r\n            searchText,\r\n            added = false;\r\n        \r\n        _.each(selections, function (sel, index) {\r\n            var isEmpty = (CodeMirror.cmpPos(sel.start, sel.end) === 0);\r\n            if (sel.primary) {\r\n                primarySel = sel;\r\n                primaryIndex = index;\r\n                if (!isEmpty) {\r\n                    searchText = editor.document.getRange(primarySel.start, primarySel.end);\r\n                }\r\n            }\r\n            if (isEmpty) {\r\n                var wordInfo = _getWordAt(editor, sel.start);\r\n                sel.start = wordInfo.start;\r\n                sel.end = wordInfo.end;\r\n                if (sel.primary && removePrimary) {\r\n                    // Get the expanded text, even though we\'re going to remove this selection,\r\n                    // since in this case we still want to select the next match.\r\n                    searchText = wordInfo.text;\r\n                }\r\n            }\r\n        });\r\n        \r\n        if (searchText && searchText.length) {\r\n            // We store this as a query in the state so that if the user next does a "Find Next",\r\n            // it will use the same query (but throw away the existing selection).\r\n            var state = getSearchState(editor._codeMirror);\r\n            setQueryInfo(state, { query: searchText, isCaseSensitive: false, isRegexp: false });\r\n            \r\n            // Skip over matches that are already in the selection.\r\n            var searchStart = primarySel.end,\r\n                nextMatch,\r\n                isInSelection;\r\n            do {\r\n                nextMatch = _getNextMatch(editor, false, searchStart);\r\n                if (nextMatch) {\r\n                    // This is a little silly, but if we just stick the equivalence test function in here\r\n                    // JSLint complains about creating a function in a loop, even though it\'s safe in this case.\r\n                    isInSelection = _.find(selections, _.partial(_selEq, nextMatch));\r\n                    searchStart = nextMatch.end;\r\n                    \r\n                    // If we\'ve gone all the way around, then all instances must have been selected already.\r\n                    if (CodeMirror.cmpPos(searchStart, primarySel.end) === 0) {\r\n                        nextMatch = null;\r\n                        break;\r\n                    }\r\n                }\r\n            } while (nextMatch && isInSelection);\r\n            \r\n            if (nextMatch) {\r\n                nextMatch.primary = true;\r\n                selections.push(nextMatch);\r\n                added = true;\r\n            }\r\n        }\r\n        \r\n        if (removePrimary) {\r\n            selections.splice(primaryIndex, 1);\r\n        }\r\n        \r\n        if (added) {\r\n            // Center the new match, but avoid scrolling to matches that are already on screen.\r\n            _selectAndScrollTo(editor, selections, true, true);\r\n        } else {\r\n            // If all we did was expand some selections, don\'t center anything.\r\n            _selectAndScrollTo(editor, selections, false);\r\n        }\r\n    }\r\n    \r\n    function _skipCurrentMatch(editor) {\r\n        return _expandWordAndAddNextToSelection(editor, true);\r\n    }\r\n    \r\n    /**\r\n     * Takes the primary selection, expands it to a word range if necessary, then sets the selection to\r\n     * include all instances of that range. Removes all other selections. Does nothing if the selection\r\n     * is not a range after expansion.\r\n     */\r\n    function _findAllAndSelect(editor) {\r\n        editor = editor || EditorManager.getActiveEditor();\r\n        if (!editor) {\r\n            return;\r\n        }\r\n        \r\n        var sel = editor.getSelection(),\r\n            newSelections = [];\r\n        if (CodeMirror.cmpPos(sel.start, sel.end) === 0) {\r\n            sel = _getWordAt(editor, sel.start);\r\n        }\r\n        if (CodeMirror.cmpPos(sel.start, sel.end) !== 0) {\r\n            var searchStart = {line: 0, ch: 0},\r\n                state = getSearchState(editor._codeMirror),\r\n                nextMatch;\r\n            setQueryInfo(state, { query: editor.document.getRange(sel.start, sel.end), isCaseSensitive: false, isRegexp: false });\r\n            \r\n            while ((nextMatch = _getNextMatch(editor, false, searchStart, false)) !== null) {\r\n                if (_selEq(sel, nextMatch)) {\r\n                    nextMatch.primary = true;\r\n                }\r\n                newSelections.push(nextMatch);\r\n                searchStart = nextMatch.end;\r\n            }\r\n            \r\n            // This should find at least the original selection, but just in case...\r\n            if (newSelections.length) {\r\n                // Don\'t change the scroll position.\r\n                editor.setSelections(newSelections, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Removes the current-match highlight, leaving all matches marked in the generic highlight style */\r\n    function clearCurrentMatchHighlight(cm, state) {\r\n        if (state.markedCurrent) {\r\n            state.markedCurrent.clear();\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Selects the next match (or prev match, if searchBackwards==true) starting from either the current position\r\n     * (if pos unspecified) or the given position (if pos specified explicitly). The starting position\r\n     * need not be an existing match. If a new match is found, sets to state.lastMatch either the regex\r\n     * match result, or simply true for a plain-string match. If no match found, sets state.lastMatch\r\n     * to false.\r\n     * @param {!Editor} editor\r\n     * @param {?boolean} searchBackwards\r\n     * @param {?boolean} preferNoScroll\r\n     * @param {?Pos} pos\r\n     */\r\n    function findNext(editor, searchBackwards, preferNoScroll, pos) {\r\n        var cm = editor._codeMirror;\r\n        cm.operation(function () {\r\n            var state = getSearchState(cm);\r\n            clearCurrentMatchHighlight(cm, state);\r\n            \r\n            var nextMatch = _getNextMatch(editor, searchBackwards, pos);\r\n            if (nextMatch) {\r\n                _updateFindBarWithMatchInfo(getSearchState(editor._codeMirror),\r\n                                            {from: nextMatch.start, to: nextMatch.end}, searchBackwards);\r\n                _selectAndScrollTo(editor, [nextMatch], true, preferNoScroll);\r\n                state.markedCurrent = cm.markText(nextMatch.start, nextMatch.end,\r\n                     { className: "searching-current-match", startStyle: "searching-first", endStyle: "searching-last" });\r\n            } else {\r\n                cm.setCursor(editor.getCursorPos());  // collapses selection, keeping cursor in place to avoid scrolling\r\n            }\r\n        });\r\n    }\r\n\r\n    /** Clears all match highlights, including the current match */\r\n    function clearHighlights(cm, state) {\r\n        cm.operation(function () {\r\n            state.marked.forEach(function (markedRange) {\r\n                markedRange.clear();\r\n            });\r\n            clearCurrentMatchHighlight(cm, state);\r\n        });\r\n        state.marked.length = 0;\r\n        state.markedCurrent = null;\r\n        \r\n        ScrollTrackMarkers.clear();\r\n\r\n        state.resultSet = [];\r\n        state.matchIndex = -1;\r\n    }\r\n\r\n    function clearSearch(cm) {\r\n        cm.operation(function () {\r\n            var state = getSearchState(cm);\r\n            if (!state.parsedQuery) {\r\n                return;\r\n            }\r\n            setQueryInfo(state, null);\r\n\r\n            clearHighlights(cm, state);\r\n        });\r\n    }\r\n    \r\n    function toggleHighlighting(editor, enabled) {\r\n        // Temporarily change selection color to improve highlighting - see LESS code for details\r\n        if (enabled) {\r\n            $(editor.getRootElement()).addClass("find-highlighting");\r\n        } else {\r\n            $(editor.getRootElement()).removeClass("find-highlighting");\r\n        }\r\n        \r\n        ScrollTrackMarkers.setVisible(editor, enabled);\r\n    }\r\n\r\n    /**\r\n     * Called each time the search query changes or document is modified (via Replace). Updates\r\n     * the match count, match highlights and scrollbar tickmarks. Does not change the cursor pos.\r\n     */\r\n    function updateResultSet(editor) {\r\n        var cm = editor._codeMirror,\r\n            state = getSearchState(cm);\r\n        \r\n        function indicateHasMatches(numResults) {\r\n            // Make the field red if it\'s not blank and it has no matches (which also covers invalid regexes)\r\n            findBar.showNoResults(!state.foundAny && findBar.getQueryInfo().query);\r\n            \r\n            // Navigation buttons enabled if we have a query and more than one match\r\n            findBar.enableNavigation(state.foundAny && numResults > 1);\r\n            findBar.enableReplace(state.foundAny);\r\n        }\r\n        \r\n        cm.operation(function () {\r\n            // Clear old highlights\r\n            if (state.marked) {\r\n                clearHighlights(cm, state);\r\n            }\r\n            \r\n            if (!state.parsedQuery) {\r\n                // Search field is empty - no results\r\n                findBar.showFindCount("");\r\n                state.foundAny = false;\r\n                indicateHasMatches();\r\n                return;\r\n            }\r\n            \r\n            // Find *all* matches, searching from start of document\r\n            // (Except on huge documents, where this is too expensive)\r\n            var cursor = getSearchCursor(cm, state);\r\n            if (cm.getValue().length <= FIND_MAX_FILE_SIZE) {\r\n                // FUTURE: if last query was prefix of this one, could optimize by filtering last result set\r\n                state.resultSet = [];\r\n                while (cursor.findNext()) {\r\n                    state.resultSet.push(cursor.pos);  // pos is unique obj per search result\r\n                }\r\n                \r\n                // Highlight all matches if there aren\'t too many\r\n                if (state.resultSet.length <= FIND_HIGHLIGHT_MAX) {\r\n                    toggleHighlighting(editor, true);\r\n                    \r\n                    state.resultSet.forEach(function (result) {\r\n                        state.marked.push(cm.markText(result.from, result.to,\r\n                             { className: "CodeMirror-searching", startStyle: "searching-first", endStyle: "searching-last" }));\r\n                    });\r\n                    var scrollTrackPositions = state.resultSet.map(function (result) {\r\n                        return result.from;\r\n                    });\r\n                    \r\n                    ScrollTrackMarkers.addTickmarks(editor, scrollTrackPositions);\r\n                }\r\n                \r\n                // Here we only update find bar with no result. In the case of a match \r\n                // a findNext() call is guaranteed to be followed by this function call,\r\n                // and findNext() in turn calls _updateFindBarWithMatchInfo() to show the \r\n                // match index.\r\n                if (state.resultSet.length === 0) {\r\n                    findBar.showFindCount(Strings.FIND_NO_RESULTS);\r\n                }\r\n\r\n                state.foundAny = (state.resultSet.length > 0);\r\n                indicateHasMatches(state.resultSet.length);\r\n                \r\n            } else {\r\n                // On huge documents, just look for first match & then stop\r\n                findBar.showFindCount("");\r\n                state.foundAny = cursor.findNext();\r\n                indicateHasMatches();\r\n            }\r\n        });\r\n    }\r\n    \r\n    /**\r\n     * Called each time the search query field changes. Updates state.parsedQuery (parsedQuery will be falsy if the field\r\n     * was blank OR contained a regexp with invalid syntax). Then calls updateResultSet(), and then jumps to\r\n     * the first matching result, starting from the original cursor position.\r\n     * @param {!Editor} editor The editor we\'re searching in.\r\n     * @param {Object} state The current query state.\r\n     * @param {boolean} initial Whether this is the initial population of the query when the search bar opens.\r\n     *     In that case, we don\'t want to change the selection unnecessarily.\r\n     */\r\n    function handleQueryChange(editor, state, initial) {\r\n        setQueryInfo(state, findBar.getQueryInfo());\r\n        updateResultSet(editor);\r\n        \r\n        if (state.parsedQuery) {\r\n            // 3rd arg: prefer to avoid scrolling if result is anywhere within view, since in this case user\r\n            // is in the middle of typing, not navigating explicitly; viewport jumping would be distracting.\r\n            findNext(editor, false, true, state.searchStartPos);\r\n        } else if (!initial) {\r\n            // Blank or invalid query: just jump back to initial pos\r\n            editor._codeMirror.setCursor(state.searchStartPos);\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Creates a Find bar for the current search session.\r\n     * @param {!Editor} editor\r\n     * @param {boolean} replace Whether to show the Replace UI; default false\r\n     */\r\n    function openSearchBar(editor, replace) {\r\n        var cm = editor._codeMirror,\r\n            state = getSearchState(cm);\r\n        \r\n        // Use the selection start as the searchStartPos. This way if you\r\n        // start with a pre-populated search and enter an additional character,\r\n        // it will extend the initial selection instead of jumping to the next\r\n        // occurrence.\r\n        state.searchStartPos = editor.getCursorPos(false, "start");\r\n        \r\n        // Prepopulate the search field\r\n        var initialQuery;\r\n        if (findBar) {\r\n            // Use the previous query. This can happen if the user switches from Find to Replace.\r\n            initialQuery = findBar.getQueryInfo().query;\r\n        } else {\r\n            initialQuery = FindUtils.getInitialQueryFromSelection(editor);\r\n        }\r\n        \r\n        // Close our previous find bar, if any. (The open() of the new findBar will\r\n        // take care of closing any other find bar instances.)\r\n        if (findBar) {\r\n            findBar.close();\r\n        }\r\n        \r\n        // Create the search bar UI (closing any previous find bar in the process)\r\n        findBar = new FindBar({\r\n            multifile: false,\r\n            replace: replace,\r\n            initialQuery: initialQuery,\r\n            queryPlaceholder: Strings.FIND_QUERY_PLACEHOLDER\r\n        });\r\n        findBar.open();\r\n\r\n        $(findBar)\r\n            .on("queryChange.FindReplace", function (e) {\r\n                handleQueryChange(editor, state);\r\n            })\r\n            .on("doFind.FindReplace", function (e, searchBackwards) {\r\n                findNext(editor, searchBackwards);\r\n            })\r\n            .on("close.FindReplace", function (e) {\r\n                // Clear highlights but leave search state in place so Find Next/Previous work after closing\r\n                clearHighlights(cm, state);\r\n\r\n                // Dispose highlighting UI (important to restore normal selection color as soon as focus goes back to the editor)\r\n                toggleHighlighting(editor, false);\r\n\r\n                $(findBar).off(".FindReplace");\r\n                findBar = null;\r\n            });\r\n        \r\n        handleQueryChange(editor, state, true);\r\n    }\r\n    \r\n    /**\r\n     * If no search pending, opens the Find dialog. If search bar already open, moves to\r\n     * next/prev result (depending on \'searchBackwards\')\r\n     */\r\n    function doSearch(editor, searchBackwards) {\r\n        var state = getSearchState(editor._codeMirror);\r\n        if (state.parsedQuery) {\r\n            findNext(editor, searchBackwards);\r\n            return;\r\n        }\r\n        \r\n        openSearchBar(editor, false);\r\n    }\r\n\r\n    \r\n    /**\r\n     * @private\r\n     * When the user switches documents (or closes the last document), ensure that the find bar\r\n     * closes, and also close the Replace All panel.\r\n     */\r\n    function _handleFileChanged() {\r\n        if (findBar) {\r\n            findBar.close();\r\n        }\r\n    }\r\n\r\n    function doReplace(editor, all) {\r\n        var cm = editor._codeMirror,\r\n            state = getSearchState(cm),\r\n            replaceText = findBar.getReplaceText();\r\n\r\n        if (all) {\r\n            findBar.close();\r\n            // Delegate to Replace in Files.\r\n            FindInFilesUI.searchAndShowResults(state.queryInfo, editor.document.file, null, replaceText);\r\n        } else {\r\n            cm.replaceSelection(state.queryInfo.isRegexp ? FindUtils.parseDollars(replaceText, state.lastMatch) : replaceText);\r\n\r\n            updateResultSet(editor);  // we updated the text, so result count & tickmarks must be refreshed\r\n\r\n            findNext(editor);\r\n            if (!state.lastMatch) {\r\n                // No more matches, so destroy find bar\r\n                findBar.close();\r\n            }\r\n        }\r\n    }\r\n\r\n    function replace(editor) {\r\n        // If Replace bar already open, treat the shortcut as a hotkey for the Replace button\r\n        if (findBar && findBar.getOptions().replace && findBar.isReplaceEnabled()) {\r\n            doReplace(editor, false);\r\n            return;\r\n        }\r\n        \r\n        openSearchBar(editor, true);\r\n        \r\n        $(findBar)\r\n            .on("doReplace.FindReplace", function (e) {\r\n                doReplace(editor, false);\r\n            })\r\n            .on("doReplaceAll.FindReplace", function (e) {\r\n                doReplace(editor, true);\r\n            });\r\n    }\r\n\r\n    function _launchFind() {\r\n        var editor = EditorManager.getActiveEditor();\r\n        if (editor) {\r\n            // Create a new instance of the search bar UI\r\n            clearSearch(editor._codeMirror);\r\n            doSearch(editor, false);\r\n        }\r\n    }\r\n\r\n    function _findNext() {\r\n        var editor = EditorManager.getActiveEditor();\r\n        if (editor) {\r\n            doSearch(editor);\r\n        }\r\n    }\r\n\r\n    function _findPrevious() {\r\n        var editor = EditorManager.getActiveEditor();\r\n        if (editor) {\r\n            doSearch(editor, true);\r\n        }\r\n    }\r\n\r\n    function _replace() {\r\n        var editor = EditorManager.getActiveEditor();\r\n        if (editor) {\r\n            replace(editor);\r\n        }\r\n    }\r\n\r\n    $(MainViewManager).on("currentFileChange", _handleFileChanged);\r\n\r\n    CommandManager.register(Strings.CMD_FIND,                   Commands.CMD_FIND,                  _launchFind);\r\n    CommandManager.register(Strings.CMD_FIND_NEXT,              Commands.CMD_FIND_NEXT,             _findNext);\r\n    CommandManager.register(Strings.CMD_REPLACE,                Commands.CMD_REPLACE,               _replace);\r\n    CommandManager.register(Strings.CMD_FIND_PREVIOUS,          Commands.CMD_FIND_PREVIOUS,         _findPrevious);\r\n    CommandManager.register(Strings.CMD_FIND_ALL_AND_SELECT,    Commands.CMD_FIND_ALL_AND_SELECT,   _findAllAndSelect);\r\n    CommandManager.register(Strings.CMD_ADD_NEXT_MATCH,         Commands.CMD_ADD_NEXT_MATCH,        _expandWordAndAddNextToSelection);\r\n    CommandManager.register(Strings.CMD_SKIP_CURRENT_MATCH,     Commands.CMD_SKIP_CURRENT_MATCH,    _skipCurrentMatch);\r\n    \r\n    // For unit testing\r\n    exports._getWordAt                       = _getWordAt;\r\n    exports._expandWordAndAddNextToSelection = _expandWordAndAddNextToSelection;\r\n    exports._findAllAndSelect                = _findAllAndSelect;\r\n});\r\n\n//# sourceURL=/search/FindReplace.js'),eval('define(\'text!htmlContent/install-extension-dialog.html\',[],function () { return \'<div class="install-extension-dialog modal">\\r\\n    <div class="modal-header">\\r\\n        <h1 class="dialog-title">\\r\\n            {{#isUpdate}}{{Strings.UPDATE_EXTENSION_TITLE}}{{/isUpdate}}\\r\\n            {{^isUpdate}}{{Strings.INSTALL_EXTENSION_TITLE}}{{/isUpdate}}\\r\\n        </h1>\\r\\n    </div>\\r\\n    <div class="modal-body">\\r\\n        <div class="field-container input-field">\\r\\n            <input type="text" placeholder="{{INSTALL_EXTENSION_HINT}}" class="url" />\\r\\n        </div>\\r\\n        <div class="field-container message-field">\\r\\n            <div class="message"></div>\\r\\n        </div>\\r\\n    </div>\\r\\n    <div class="modal-footer">\\r\\n        {{#includeBrowseExtensions}}<button class="btn left browse-extensions">{{Strings.BROWSE_EXTENSIONS}}</button>{{/includeBrowseExtensions}}\\r\\n        <button class="dialog-button btn" data-button-id="cancel">{{Strings.CANCEL}}</button>\\r\\n        <button class="dialog-button btn primary" data-button-id="ok" disabled>{{Strings.INSTALL}}</button>\\r\\n    </div>\\r\\n</div>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/install-extension-dialog.html'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, window, $, brackets, Mustache, document */\r\n/*unittests: Install Extension Dialog*/\r\n\r\ndefine(\'extensibility/InstallExtensionDialog\',[\'require\',\'exports\',\'module\',\'widgets/Dialogs\',\'filesystem/File\',\'utils/StringUtils\',\'strings\',\'command/Commands\',\'command/CommandManager\',\'filesystem/FileSystem\',\'utils/KeyEvent\',\'extensibility/Package\',\'utils/NativeApp\',\'text!htmlContent/install-extension-dialog.html\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var Dialogs                = require("widgets/Dialogs"),\r\n        File                   = require("filesystem/File"),\r\n        StringUtils            = require("utils/StringUtils"),\r\n        Strings                = require("strings"),\r\n        Commands               = require("command/Commands"),\r\n        CommandManager         = require("command/CommandManager"),\r\n        FileSystem             = require("filesystem/FileSystem"),\r\n        KeyEvent               = require("utils/KeyEvent"),\r\n        Package                = require("extensibility/Package"),\r\n        NativeApp              = require("utils/NativeApp"),\r\n        InstallDialogTemplate  = require("text!htmlContent/install-extension-dialog.html");\r\n\r\n    var STATE_CLOSED              = 0,\r\n        STATE_START               = 1,\r\n        STATE_VALID_URL           = 2,\r\n        STATE_INSTALLING          = 3,\r\n        STATE_INSTALLED           = 4,\r\n        STATE_INSTALL_FAILED      = 5,\r\n        STATE_CANCELING_INSTALL   = 6,\r\n        STATE_CANCELING_HUNG      = 7,\r\n        STATE_INSTALL_CANCELED    = 8,\r\n        STATE_ALREADY_INSTALLED   = 9,\r\n        STATE_OVERWRITE_CONFIRMED = 10,\r\n        STATE_NEEDS_UPDATE        = 11;\r\n    \r\n    /** \r\n     * Creates a new extension installer dialog.\r\n     * @constructor\r\n     * @param {{install: function(url), cancel: function()}} installer The installer backend to use.\r\n     */\r\n    function InstallExtensionDialog(installer, _isUpdate) {\r\n        this._installer = installer;\r\n        this._state = STATE_CLOSED;\r\n        this._installResult = null;\r\n        this._isUpdate = _isUpdate;\r\n\r\n        // Timeout before we allow user to leave STATE_INSTALL_CANCELING without waiting for a resolution\r\n        // (per-instance so we can poke it for unit testing)\r\n        this._cancelTimeout = 10 * 1000;\r\n    }\r\n    \r\n    /**\r\n     * The dialog root.\r\n     * @type {jQuery}\r\n     */\r\n    InstallExtensionDialog.prototype.$dlg = null;\r\n    \r\n    /**\r\n     * The url input field.\r\n     * @type {jQuery}\r\n     */\r\n    InstallExtensionDialog.prototype.$url = null;\r\n    \r\n    /**\r\n     * The ok button.\r\n     * @type {jQuery}\r\n     */\r\n    InstallExtensionDialog.prototype.$okButton = null;\r\n    \r\n    /**\r\n     * The cancel button.\r\n     * @type {jQuery}\r\n     */\r\n    InstallExtensionDialog.prototype.$cancelButton = null;\r\n    \r\n    /**\r\n     * The area containing the url input label and field.\r\n     * @type {jQuery}\r\n     */\r\n    InstallExtensionDialog.prototype.$inputArea = null;\r\n    \r\n    /**\r\n     * The area containing the installation message and spinner.\r\n     * @type {jQuery}\r\n     */\r\n    InstallExtensionDialog.prototype.$msgArea = null;\r\n    \r\n    /**\r\n     * The span containing the installation message.\r\n     * @type {jQuery}\r\n     */\r\n    InstallExtensionDialog.prototype.$msg = null;\r\n    \r\n    /**\r\n     * The "Browse Extensions" button.\r\n     * @type {jQuery}\r\n     */\r\n    InstallExtensionDialog.prototype.$browseExtensionsButton = null;\r\n    \r\n    /**\r\n     * A deferred that\'s resolved/rejected when the dialog is closed and\r\n     * something has/hasn\'t been installed successfully.\r\n     * @type {$.Deferred}\r\n     */\r\n    InstallExtensionDialog.prototype._dialogDeferred = null;\r\n    \r\n    \r\n    /**\r\n     * installer The installer backend for this dialog.\r\n     * @type {{install: function(url), cancel: function()}}\r\n     */\r\n    InstallExtensionDialog.prototype._installer = null;\r\n    \r\n    /**\r\n     * The current state of the dialog; one of the STATE_* constants above.\r\n     * @type {number}\r\n     */\r\n    InstallExtensionDialog.prototype._state = null;\r\n    \r\n    /**\r\n     * @private\r\n     * Transitions the dialog into a new state as the installation proceeds.\r\n     * @param {number} newState The state to transition into; one of the STATE_* variables.\r\n     */\r\n    InstallExtensionDialog.prototype._enterState = function (newState) {\r\n        var url,\r\n            msg,\r\n            self = this,\r\n            prevState = this._state;\r\n        \r\n        // Store the new state up front in case some of the processing below ends up changing\r\n        // the state again immediately.\r\n        this._state = newState;\r\n        \r\n        switch (newState) {\r\n        case STATE_START:\r\n            // This should match the default appearance of the dialog when it first opens.\r\n            this.$msg.find(".spinner").remove();\r\n            this.$msgArea.hide();\r\n            this.$inputArea.show();\r\n            this.$okButton\r\n                .prop("disabled", true)\r\n                .text(Strings.INSTALL);\r\n            break;\r\n                \r\n        case STATE_VALID_URL:\r\n            this.$okButton.prop("disabled", false);\r\n            break;\r\n            \r\n        case STATE_INSTALLING:\r\n            url = this.$url.val().trim();\r\n            this.$inputArea.hide();\r\n            this.$browseExtensionsButton.hide();\r\n            this.$msg.text(StringUtils.format(Strings.INSTALLING_FROM, url))\r\n                .append("<span class=\'spinner inline spin\'/>");\r\n            this.$msgArea.show();\r\n            this.$okButton.prop("disabled", true);\r\n            this._installer.install(url)\r\n                .done(function (result) {\r\n                    self._installResult = result;\r\n                    if (result.installationStatus === Package.InstallationStatuses.ALREADY_INSTALLED ||\r\n                            result.installationStatus === Package.InstallationStatuses.OLDER_VERSION ||\r\n                            result.installationStatus === Package.InstallationStatuses.SAME_VERSION) {\r\n                        self._enterState(STATE_ALREADY_INSTALLED);\r\n                    } else if (result.installationStatus === Package.InstallationStatuses.NEEDS_UPDATE) {\r\n                        self._enterState(STATE_NEEDS_UPDATE);\r\n                    } else {\r\n                        self._enterState(STATE_INSTALLED);\r\n                    }\r\n                })\r\n                .fail(function (err) {\r\n                    // If the "failure" is actually a user-requested cancel, don\'t show an error UI\r\n                    if (err === "CANCELED") {\r\n                        console.assert(self._state === STATE_CANCELING_INSTALL || self._state === STATE_CANCELING_HUNG);\r\n                        self._enterState(STATE_INSTALL_CANCELED);\r\n                    } else {\r\n                        self._errorMessage = Package.formatError(err);\r\n                        self._enterState(STATE_INSTALL_FAILED);\r\n                    }\r\n                });\r\n            break;\r\n            \r\n        case STATE_CANCELING_INSTALL:\r\n            // This should call back the STATE_INSTALLING fail() handler above, unless it\'s too late to cancel\r\n            // in which case we\'ll still jump to STATE_INSTALLED after this\r\n            this.$cancelButton.prop("disabled", true);\r\n            this.$msg.text(Strings.CANCELING_INSTALL);\r\n            this._installer.cancel();\r\n            window.setTimeout(function () {\r\n                if (self._state === STATE_CANCELING_INSTALL) {\r\n                    self._enterState(STATE_CANCELING_HUNG);\r\n                }\r\n            }, this._cancelTimeout);\r\n            break;\r\n            \r\n        case STATE_CANCELING_HUNG:\r\n            this.$msg.text(Strings.CANCELING_HUNG);\r\n            this.$okButton\r\n                .removeAttr("disabled")\r\n                .text(Strings.CLOSE);\r\n            break;\r\n            \r\n        case STATE_INSTALLED:\r\n        case STATE_INSTALL_FAILED:\r\n        case STATE_INSTALL_CANCELED:\r\n        case STATE_NEEDS_UPDATE:\r\n            if (newState === STATE_INSTALLED) {\r\n                msg = Strings.INSTALL_SUCCEEDED;\r\n            } else if (newState === STATE_INSTALL_FAILED) {\r\n                msg = Strings.INSTALL_FAILED;\r\n            } else if (newState === STATE_NEEDS_UPDATE) {\r\n                msg = Strings.EXTENSION_UPDATE_INSTALLED;\r\n            } else {\r\n                msg = Strings.INSTALL_CANCELED;\r\n            }\r\n            this.$msg.html($("<strong/>").text(msg));\r\n            if (this._errorMessage) {\r\n                this.$msg.append($("<p/>").text(this._errorMessage));\r\n            }\r\n            this.$okButton\r\n                .removeAttr("disabled")\r\n                .text(Strings.CLOSE);\r\n            this.$cancelButton.hide();\r\n            break;\r\n        \r\n        case STATE_ALREADY_INSTALLED:\r\n            var installResult = this._installResult;\r\n            var status = installResult.installationStatus;\r\n            var msgText = Strings["EXTENSION_" + status];\r\n            if (status === Package.InstallationStatuses.OLDER_VERSION) {\r\n                msgText = StringUtils.format(msgText, installResult.metadata.version, installResult.installedVersion);\r\n            }\r\n            this.$msg.text(msgText);\r\n            this.$okButton\r\n                .prop("disabled", false)\r\n                .text(Strings.OVERWRITE);\r\n            break;\r\n        \r\n        case STATE_OVERWRITE_CONFIRMED:\r\n            this._enterState(STATE_CLOSED);\r\n            break;\r\n        \r\n        case STATE_CLOSED:\r\n            $(document.body).off(".installDialog");\r\n            \r\n           // Only resolve as successful if we actually installed something.\r\n            Dialogs.cancelModalDialogIfOpen("install-extension-dialog");\r\n            if (prevState === STATE_INSTALLED || prevState === STATE_NEEDS_UPDATE ||\r\n                    prevState === STATE_OVERWRITE_CONFIRMED) {\r\n                this._dialogDeferred.resolve(this._installResult);\r\n            } else {\r\n                this._dialogDeferred.reject();\r\n            }\r\n            break;\r\n        }\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Handle a click on the Cancel button, which either cancels an ongoing installation (leaving\r\n     * the dialog open), or closes the dialog if no installation is in progress.\r\n     */\r\n    InstallExtensionDialog.prototype._handleCancel = function () {\r\n        if (this._state === STATE_INSTALLING) {\r\n            this._enterState(STATE_CANCELING_INSTALL);\r\n        } else if (this._state === STATE_ALREADY_INSTALLED) {\r\n            // If we were prompting the user about overwriting a previous installation,\r\n            // and the user cancels, we can delete the downloaded file.\r\n            if (this._installResult && this._installResult.localPath && !this._installResult.keepFile) {\r\n                var filename = this._installResult.localPath;\r\n                FileSystem.getFileForPath(filename).unlink();\r\n            }\r\n            this._enterState(STATE_CLOSED);\r\n        } else if (this._state !== STATE_CANCELING_INSTALL) {\r\n            this._enterState(STATE_CLOSED);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Handle a click on the default button, which is "Install" while we\'re waiting for the\r\n     * user to enter a URL, and "Close" once we\'ve successfully finished installation.\r\n     */\r\n    InstallExtensionDialog.prototype._handleOk = function () {\r\n        if (this._state === STATE_INSTALLED ||\r\n                this._state === STATE_INSTALL_FAILED ||\r\n                this._state === STATE_INSTALL_CANCELED ||\r\n                this._state === STATE_CANCELING_HUNG ||\r\n                this._state === STATE_NEEDS_UPDATE) {\r\n            // In these end states, this is a "Close" button: just close the dialog and indicate\r\n            // success.\r\n            this._enterState(STATE_CLOSED);\r\n        } else if (this._state === STATE_VALID_URL) {\r\n            this._enterState(STATE_INSTALLING);\r\n        } else if (this._state === STATE_ALREADY_INSTALLED) {\r\n            this._enterState(STATE_OVERWRITE_CONFIRMED);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Handle key up events on the document. We use this to detect the Esc key.\r\n     */\r\n    InstallExtensionDialog.prototype._handleKeyUp = function (e) {\r\n        if (e.keyCode === KeyEvent.DOM_VK_ESCAPE) {\r\n            this._handleCancel();\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Handle typing in the URL field.\r\n     */\r\n    InstallExtensionDialog.prototype._handleUrlInput = function (e) {\r\n        var url     = this.$url.val().trim(),\r\n            valid   = (url !== "");\r\n        if (!valid && this._state === STATE_VALID_URL) {\r\n            this._enterState(STATE_START);\r\n        } else if (valid && this._state === STATE_START) {\r\n            this._enterState(STATE_VALID_URL);\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Closes the dialog if it\'s not already closed. For unit testing only.\r\n     */\r\n    InstallExtensionDialog.prototype._close = function () {\r\n        if (this._state !== STATE_CLOSED) {\r\n            this._enterState(STATE_CLOSED);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Initialize and show the dialog.\r\n     * @param {string=} urlToInstall If specified, immediately starts installing the given file as if the user had\r\n     *     specified it.\r\n     * @return {$.Promise} A promise object that will be resolved when the selected extension\r\n     *     has finished installing, or rejected if the dialog is cancelled.\r\n     */\r\n    InstallExtensionDialog.prototype.show = function (urlToInstall) {\r\n        if (this._state !== STATE_CLOSED) {\r\n            // Somehow the dialog got invoked twice. Just ignore this.\r\n            return this._dialogDeferred.promise();\r\n        }\r\n\r\n        var context = {\r\n            Strings: Strings,\r\n            isUpdate: this._isUpdate,\r\n            includeBrowseExtensions: !!brackets.config.extension_listing_url\r\n        };\r\n        \r\n        // We ignore the promise returned by showModalDialogUsingTemplate, since we\'re managing the \r\n        // lifecycle of the dialog ourselves.\r\n        Dialogs.showModalDialogUsingTemplate(Mustache.render(InstallDialogTemplate, context), false);\r\n        \r\n        this.$dlg          = $(".install-extension-dialog.instance");\r\n        this.$url          = this.$dlg.find(".url").focus();\r\n        this.$okButton     = this.$dlg.find(".dialog-button[data-button-id=\'ok\']");\r\n        this.$cancelButton = this.$dlg.find(".dialog-button[data-button-id=\'cancel\']");\r\n        this.$inputArea    = this.$dlg.find(".input-field");\r\n        this.$msgArea      = this.$dlg.find(".message-field");\r\n        this.$msg          = this.$msgArea.find(".message");\r\n        this.$browseExtensionsButton = this.$dlg.find(".browse-extensions");\r\n\r\n        this.$okButton.on("click", this._handleOk.bind(this));\r\n        this.$cancelButton.on("click", this._handleCancel.bind(this));\r\n        this.$url.on("input", this._handleUrlInput.bind(this));\r\n        this.$browseExtensionsButton.on("click", function () {\r\n            NativeApp.openURLInDefaultBrowser(brackets.config.extension_listing_url);\r\n        });\r\n        $(document.body).on("keyup.installDialog", this._handleKeyUp.bind(this));\r\n        \r\n        this._enterState(STATE_START);\r\n        if (urlToInstall) {\r\n            // Act as if the user had manually entered the URL.\r\n            this.$url.val(urlToInstall);\r\n            this._enterState(STATE_VALID_URL);\r\n            this._enterState(STATE_INSTALLING);\r\n        }\r\n\r\n        this._dialogDeferred = new $.Deferred();\r\n        return this._dialogDeferred.promise();\r\n    };\r\n    \r\n    \r\n    /** Mediates between this module and the Package extension-installation utils. Mockable for unit-testing. */\r\n    function InstallerFacade(isLocalFile) {\r\n        this._isLocalFile = isLocalFile;\r\n    }\r\n\r\n    InstallerFacade.prototype.install = function (url) {\r\n        if (this.pendingInstall) {\r\n            console.error("Extension installation already pending");\r\n            return new $.Deferred().reject("DOWNLOAD_ID_IN_USE").promise();\r\n        }\r\n\r\n        if (this._isLocalFile) {\r\n            var deferred = new $.Deferred();\r\n\r\n            this.pendingInstall = {\r\n                promise: deferred.promise(),\r\n                cancel: function () {\r\n                    // Can\'t cancel local zip installs\r\n                }\r\n            };\r\n\r\n            Package.installFromPath(url).then(function (installationResult) {\r\n                // Flag to keep zip files for local file installation\r\n                installationResult.keepFile = true;\r\n                deferred.resolve(installationResult);\r\n            }, deferred.reject);\r\n        } else {\r\n            this.pendingInstall = Package.installFromURL(url);\r\n        }\r\n        \r\n        // Store now since we\'ll null pendingInstall immediately if the promise was resolved synchronously\r\n        var promise = this.pendingInstall.promise;\r\n        \r\n        var self = this;\r\n        this.pendingInstall.promise.always(function () {\r\n            self.pendingInstall = null;\r\n        });\r\n        \r\n        return promise;\r\n    };\r\n    InstallerFacade.prototype.cancel = function () {\r\n        this.pendingInstall.cancel();\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Show a dialog that allows the user to enter the URL of an extension ZIP file to install.\r\n     * @return {$.Promise} A promise object that will be resolved when the selected extension\r\n     *     has finished installing, or rejected if the dialog is cancelled.\r\n     */\r\n    function showDialog() {\r\n        var dlg = new InstallExtensionDialog(new InstallerFacade());\r\n        return dlg.show();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Show the installation dialog and automatically begin installing the given URL.\r\n     * @param {(string|File)=} urlOrFileToInstall If specified, immediately starts installing the given file as if the user had\r\n     *     specified it.\r\n     * @return {$.Promise} A promise object that will be resolved when the selected extension\r\n     *     has finished installing, or rejected if the dialog is cancelled.\r\n     */\r\n    function installUsingDialog(urlOrFileToInstall, _isUpdate) {\r\n        var isLocalFile = (urlOrFileToInstall instanceof File),\r\n            dlg = new InstallExtensionDialog(new InstallerFacade(isLocalFile), _isUpdate);\r\n\r\n        return dlg.show(urlOrFileToInstall.fullPath || urlOrFileToInstall);\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Show the update dialog and automatically begin downloading the update from the given URL.\r\n     * @param {string} urlToUpdate URL to download\r\n     * @return {$.Promise} A promise object that will be resolved when the selected extension\r\n     *     has finished downloading, or rejected if the dialog is cancelled.\r\n     */\r\n    function updateUsingDialog(urlToUpdate) {\r\n        return installUsingDialog(urlToUpdate, true);\r\n    }\r\n    \r\n    exports.showDialog          = showDialog;\r\n    exports.installUsingDialog  = installUsingDialog;\r\n    exports.updateUsingDialog   = updateUsingDialog;\r\n\r\n    // Exposed for unit testing only\r\n    exports._Dialog = InstallExtensionDialog;\r\n});\r\n\n//# sourceURL=/extensibility/InstallExtensionDialog.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*\r\n * N.B.: This file was copied from `lib/registry_utils.js` in `https://github.com/adobe/brackets-registry`.\r\n * We can\'t use the exact same file currently because Brackets uses AMD-style modules, so this version has\r\n * the AMD wrapper added (and is reindented to avoid JSLint complaints).. If changes are made here, the \r\n * version in the registry app should be kept in sync.\r\n * In the future, we should have a better mechanism for sharing code between the two.\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global brackets, define*/\r\n\r\ndefine(\'extensibility/registry_utils\',[\'require\',\'exports\',\'module\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    // From Brackets StringUtils\r\n    function htmlEscape(str) {\r\n        return String(str)\r\n            .replace(/&/g, "&amp;")\r\n            .replace(/"/g, "&quot;")\r\n            .replace(/\'/g, "&#39;")\r\n            .replace(/</g, "&lt;")\r\n            .replace(/>/g, "&gt;");\r\n    }\r\n    \r\n    /**\r\n     * Gets the last version from the given object and returns the short form of its date.\r\n     * Assumes "this" is the current template context.\r\n     * @return {string} The formatted date.\r\n     */\r\n    exports.lastVersionDate = function () {\r\n        var result;\r\n        if (this.versions && this.versions.length) {\r\n            result = this.versions[this.versions.length - 1].published;\r\n            if (result) {\r\n                result = new Date(result);\r\n                result = result.toLocaleDateString(brackets.getLocale(), {\r\n                    "year": "numeric",\r\n                    "month": "2-digit",\r\n                    "day": "2-digit"\r\n                });\r\n            }\r\n        }\r\n        return result || "";\r\n    };\r\n    \r\n    /**\r\n     * Returns a more friendly display form of the owner\'s internal user id.\r\n     * Assumes "this" is the current template context.\r\n     * @return {string} A display version in the form "id (service)".\r\n     */\r\n    exports.formatUserId = function () {\r\n        var friendlyName;\r\n        if (this.owner) {\r\n            var nameComponents = this.owner.split(":");\r\n            friendlyName = nameComponents[1];\r\n        }\r\n        return friendlyName;\r\n    };\r\n    \r\n    /**\r\n     * Given a registry item, returns a URL that represents its owner\'s page on the auth service.\r\n     * Currently only handles GitHub.\r\n     * Assumes "this" is the current template context.\r\n     * @return {string} A link to that user\'s page on the service.\r\n     */\r\n    exports.ownerLink = function () {\r\n        var url;\r\n        if (this.owner) {\r\n            var nameComponents = this.owner.split(":");\r\n            if (nameComponents[0] === "github") {\r\n                url = "https://github.com/" + nameComponents[1];\r\n            }\r\n        }\r\n        return url;\r\n    };\r\n\r\n    /**\r\n     * Given a registry item, formats the author information, including a link to the owner\'s\r\n     * github page (if available) and the author\'s name from the metadata.\r\n     */\r\n    exports.authorInfo = function () {\r\n        var result = "",\r\n            ownerLink = exports.ownerLink.call(this),\r\n            userId = exports.formatUserId.call(this);\r\n        if (this.metadata && this.metadata.author) {\r\n            result = htmlEscape(this.metadata.author.name || this.metadata.author);\r\n        } else if (userId) {\r\n            result = htmlEscape(userId);\r\n        }\r\n        if (ownerLink) {\r\n            result = "<a href=\'" + htmlEscape(ownerLink) + "\' title=\'" + htmlEscape(ownerLink) + "\'>" + result + "</a>";\r\n        }\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Returns an array of current registry entries, sorted by the publish date of the latest version of each entry.\r\n     * @param {object} registry The unsorted registry.\r\n     * @param {string} subkey The subkey to look for the registry metadata in. If unspecified, assumes\r\n     *     we should look at the top level of the object.\r\n     * @return {Array} Sorted array of registry entries.\r\n     */\r\n    exports.sortRegistry = function (registry, subkey) {\r\n        function getPublishTime(entry) {\r\n            if (entry.versions) {\r\n                return new Date(entry.versions[entry.versions.length - 1].published).getTime();\r\n            }\r\n            \r\n            return Number.NEGATIVE_INFINITY;\r\n        }\r\n        \r\n        var sortedEntries = [];\r\n    \r\n        // Sort the registry by last published date (newest first).\r\n        Object.keys(registry).forEach(function (key) {\r\n            sortedEntries.push(registry[key]);\r\n        });\r\n        sortedEntries.sort(function (entry1, entry2) {\r\n            return getPublishTime((subkey && entry2[subkey]) || entry2) -\r\n                getPublishTime((subkey && entry1[subkey]) || entry1);\r\n        });\r\n        \r\n        return sortedEntries;\r\n    };\r\n});\r\n\n//# sourceURL=/extensibility/registry_utils.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"),\r\n * to deal in the Software without restriction, including without limitation\r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\r\n * and/or sell copies of the Software, and to permit persons to whom the\r\n * Software is furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\r\n * DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, regexp: true, indent: 4, maxerr: 50 */\r\n/*global define */\r\n\r\n/**\r\n *  Utilities functions related to localization/i18n\r\n *\r\n */\r\ndefine(\'utils/LocalizationUtils\',[\'require\',\'exports\',\'module\',\'strings\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var Strings = require("strings");\r\n\r\n    /*\r\n     * Converts a language code to its written name, if possible.\r\n     * If not possible, the language code is simply returned.\r\n     *\r\n     * @param {string} locale   The two-char language code\r\n     * @return {string} The language\'s name or the given language code\r\n     */\r\n    function getLocalizedLabel(locale) {\r\n        var key  = "LOCALE_" + locale.toUpperCase().replace("-", "_"),\r\n            i18n = Strings[key];\r\n\r\n        return i18n === undefined ? locale : i18n;\r\n    }\r\n\r\n\r\n    // Define public API\r\n    exports.getLocalizedLabel = getLocalizedLabel;\r\n});\r\n\n//# sourceURL=/utils/LocalizationUtils.js'),eval('define(\'text!htmlContent/extension-manager-view-item.html\',[],function () { return \'<tr>\\r\\n    <td class="ext-info">\\r\\n        <span class="ext-name">{{#metadata.title}}{{metadata.title}}{{/metadata.title}}{{^metadata.title}}{{metadata.name}}{{/metadata.title}}</span>\\r\\n        {{#authorInfo}}\\r\\n            <span class="muted ext-author">{{{authorInfo}}}</span>\\r\\n        {{/authorInfo}}\\r\\n        <span class="muted ext-version">{{metadata.version}}</span>\\r\\n        {{#hasVersionInfo}}\\r\\n            <span class="muted ext-date"> &mdash; {{lastVersionDate}}</span>\\r\\n        {{/hasVersionInfo}}\\r\\n    </td>\\r\\n    <td class="ext-desc">\\r\\n        {{#showInstallButton}}\\r\\n            <!-- Warnings when trying to install extension where latest/all versions not compatible -->\\r\\n            {{^isCompatible}}\\r\\n                <div class="alert warning">\\r\\n                    {{#requiresNewer}}{{Strings.EXTENSION_INCOMPATIBLE_NEWER}}{{/requiresNewer}}\\r\\n                    {{^requiresNewer}}{{Strings.EXTENSION_INCOMPATIBLE_OLDER}}{{/requiresNewer}}\\r\\n                </div>\\r\\n            {{/isCompatible}}\\r\\n            {{#isCompatible}}\\r\\n                {{^isCompatibleLatest}}\\r\\n                    <div class="alert warning">\\r\\n                        {{installWarning}}\\r\\n                    </div>\\r\\n                {{/isCompatibleLatest}}\\r\\n            {{/isCompatible}}\\r\\n        {{/showInstallButton}}\\r\\n        <span class="ext-full-description">\\r\\n            {{#metadata.shortdescription}}\\r\\n                {{metadata.shortdescription}}\\r\\n            {{/metadata.shortdescription}}\\r\\n            {{^metadata.shortdescription}}\\r\\n                {{#metadata.description}}\\r\\n                    {{metadata.description}}\\r\\n                {{/metadata.description}}\\r\\n                {{^metadata.description}}\\r\\n                    <p class="muted"><em>{{Strings.EXTENSION_NO_DESCRIPTION}}</em></p>\\r\\n                {{/metadata.description}}\\r\\n            {{/metadata.shortdescription}}\\r\\n        </span>\\r\\n        {{#metadata.shortdescription}}\\r\\n        <a data-extension-id="{{metadata.name}}" data-toggle-desc="expand-desc" title="{{Strings.VIEW_COMPLETE_DESCRIPTION}}" href="#">...</a>\\r\\n        {{/metadata.shortdescription}}\\r\\n        {{#metadata.homepage}}\\r\\n            <p><a title="{{metadata.homepage}}" href="{{metadata.homepage}}">{{Strings.EXTENSION_MORE_INFO}}</a></p>\\r\\n        {{/metadata.homepage}}\\r\\n        {{#translated}}\\r\\n            <br/>\\r\\n            <span class="ext-translated" title="{{translatedLangs}}">{{extensionTranslated}}</span>\\r\\n        {{/translated}}\\r\\n    </td>\\r\\n    <td class="ext-action">\\r\\n        {{#showInstallButton}}\\r\\n            <button class="btn btn-mini install" data-extension-id="{{metadata.name}}" {{^allowInstall}}disabled{{/allowInstall}}>\\r\\n                {{^isInstalled}}{{Strings.INSTALL}}{{/isInstalled}}\\r\\n                {{#isInstalled}}{{Strings.EXTENSION_INSTALLED}}{{/isInstalled}}\\r\\n            </button>\\r\\n        {{/showInstallButton}}\\r\\n        {{#isInstalled}}\\r\\n            {{#showUpdateButton}}\\r\\n                <button class="btn btn-mini update" data-extension-id="{{metadata.name}}" {{^allowUpdate}}disabled title="{{updateNotAllowedReason}}"{{/allowUpdate}}>\\r\\n                    {{Strings.UPDATE}}\\r\\n                </button>\\r\\n            {{/showUpdateButton}}\\r\\n            {{#removalAllowed}}\\r\\n                <button class="btn btn-mini remove" data-extension-id="{{metadata.name}}" {{^allowRemove}}disabled title="{{Strings.CANT_REMOVE_DEV}}"{{/allowRemove}}>\\r\\n                    {{Strings.REMOVE}}\\r\\n                </button>\\r\\n            {{/removalAllowed}}\\r\\n            {{#failedToStart}}\\r\\n                {{^isMarkedForRemoval}}\\r\\n                    {{Strings.EXTENSION_ERROR}} {{#allowRemove}}(<a class="remove" data-extension-id="{{metadata.name}}">{{Strings.REMOVE}}</a>){{/allowRemove}}\\r\\n                {{/isMarkedForRemoval}}\\r\\n            {{/failedToStart}}\\r\\n            {{#isMarkedForRemoval}}\\r\\n                {{Strings.MARKED_FOR_REMOVAL}} (<a class="undo-remove" data-extension-id="{{metadata.name}}" href="#">{{Strings.UNDO_REMOVE}}</a>)\\r\\n            {{/isMarkedForRemoval}}\\r\\n            {{#isMarkedForUpdate}}\\r\\n                {{Strings.MARKED_FOR_UPDATE}} (<a class="undo-update" data-extension-id="{{metadata.name}}" href="#">{{Strings.UNDO_UPDATE}}</a>)\\r\\n            {{/isMarkedForUpdate}}\\r\\n        {{/isInstalled}}\\r\\n    </td>\\r\\n</tr>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/extension-manager-view-item.html'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, regexp: true */\r\n/*global define, window, $, brackets, Mustache */\r\n/*unittests: ExtensionManager*/\r\n\r\ndefine(\'extensibility/ExtensionManagerView\',[\'require\',\'exports\',\'module\',\'strings\',\'utils/StringUtils\',\'extensibility/ExtensionManager\',\'extensibility/registry_utils\',\'extensibility/InstallExtensionDialog\',\'utils/LocalizationUtils\',\'text!htmlContent/extension-manager-view-item.html\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var Strings                   = require("strings"),\r\n        StringUtils               = require("utils/StringUtils"),\r\n        ExtensionManager          = require("extensibility/ExtensionManager"),\r\n        registry_utils            = require("extensibility/registry_utils"),\r\n        InstallExtensionDialog    = require("extensibility/InstallExtensionDialog"),\r\n        LocalizationUtils         = require("utils/LocalizationUtils"),\r\n        itemTemplate              = require("text!htmlContent/extension-manager-view-item.html");\r\n\r\n    /**\r\n     * Creates a view enabling the user to install and manage extensions. Must be initialized\r\n     * with initialize(). When the view is closed, dispose() must be called.\r\n     * @constructor\r\n     */\r\n    function ExtensionManagerView() {\r\n    }\r\n    \r\n    /**\r\n     * Initializes the view to show a set of extensions.\r\n     * @param {ExtensionManagerViewModel} model Model object containing extension data to view\r\n     * @return {$.Promise} a promise that\'s resolved once the view has been initialized. Never\r\n     *     rejected.\r\n     */\r\n    ExtensionManagerView.prototype.initialize = function (model) {\r\n        var self = this,\r\n            result = new $.Deferred();\r\n        this.model = model;\r\n        this._itemTemplate = Mustache.compile(itemTemplate);\r\n        this._itemViews = {};\r\n        this.$el = $("<div class=\'extension-list tab-pane\' id=\'" + this.model.source + "\'/>");\r\n        this._$emptyMessage = $("<div class=\'empty-message\'/>")\r\n            .appendTo(this.$el);\r\n        this._$infoMessage = $("<div class=\'info-message\'/>")\r\n            .appendTo(this.$el).html(this.model.infoMessage);\r\n        this._$table = $("<table class=\'table\'/>").appendTo(this.$el);\r\n        \r\n        this.model.initialize().done(function () {\r\n            self._setupEventHandlers();\r\n        }).always(function () {\r\n            self._render();\r\n            result.resolve();\r\n        });\r\n        \r\n        return result.promise();\r\n    };\r\n    \r\n    /**\r\n     * @type {jQueryObject}\r\n     * The root of the view\'s DOM tree.\r\n     */\r\n    ExtensionManagerView.prototype.$el = null;\r\n    \r\n    /**\r\n     * @type {Model}\r\n     * The view\'s model. Handles sorting and filtering of items in the view.\r\n     */\r\n    ExtensionManagerView.prototype.model = null;\r\n    \r\n    /**\r\n     * @type {jQueryObject}\r\n     * Element showing a message when there are no extensions.\r\n     */\r\n    ExtensionManagerView.prototype._$emptyMessage = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {jQueryObject}\r\n     * The root of the table inside the view.\r\n     */\r\n    ExtensionManagerView.prototype._$table = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {function} The compiled template we use for rendering items in the extension list.\r\n     */\r\n    ExtensionManagerView.prototype._itemTemplate = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {Object.<string, jQueryObject>}\r\n     * The individual views for each item, keyed by the extension ID.\r\n     */\r\n    ExtensionManagerView.prototype._itemViews = null;\r\n\r\n    /**\r\n     * Toggles between truncated and full length extension descriptions\r\n     * @param {string} id The id of the extension clicked\r\n     * @param {JQueryElement} $element The DOM element of the extension clicked\r\n     * @param {boolean} showFull true if full length description should be shown, false for shortened version.\r\n     */\r\n    ExtensionManagerView.prototype._toggleDescription = function (id, $element, showFull) {\r\n        var description, linkTitle,\r\n            info = this.model._getEntry(id);\r\n\r\n        // Toggle between appropriate descriptions and link title,\r\n        // depending on if extension is installed or not\r\n        if (showFull) {\r\n            description = info.metadata.description;\r\n            linkTitle = Strings.VIEW_TRUNCATED_DESCRIPTION;\r\n        } else {\r\n            description = info.metadata.shortdescription;\r\n            linkTitle = Strings.VIEW_COMPLETE_DESCRIPTION;\r\n        }\r\n\r\n        $element.data("toggle-desc", showFull ? "trunc-desc" : "expand-desc")\r\n                .attr("title", linkTitle)\r\n                .prev(".ext-full-description").text(description);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Attaches our event handlers. We wait to do this until we\'ve fully fetched the extension list.\r\n     */\r\n    ExtensionManagerView.prototype._setupEventHandlers = function () {\r\n        var self = this;\r\n\r\n        // Listen for model data and filter changes.\r\n        $(this.model)\r\n            .on("filter", function () {\r\n                self._render();\r\n            })\r\n            .on("change", function (e, id) {\r\n                var extensions = self.model.extensions,\r\n                    $oldItem = self._itemViews[id];\r\n                self._updateMessage();\r\n                if (self.model.filterSet.indexOf(id) === -1) {\r\n                    // This extension is not in the filter set. Remove it from the view if we\r\n                    // were rendering it previously.\r\n                    if ($oldItem) {\r\n                        $oldItem.remove();\r\n                        delete self._itemViews[id];\r\n                    }\r\n                } else {\r\n                    // Render the item, replacing the old item if we had previously rendered it.\r\n                    var $newItem = self._renderItem(extensions[id], self.model._getEntry(id));\r\n                    if ($oldItem) {\r\n                        $oldItem.replaceWith($newItem);\r\n                        self._itemViews[id] = $newItem;\r\n                    }\r\n                }\r\n            });\r\n        \r\n        // UI event handlers\r\n        this.$el\r\n            .on("click", "a", function (e) {\r\n                var $target = $(e.target);\r\n                if ($target.hasClass("undo-remove")) {\r\n                    ExtensionManager.markForRemoval($target.attr("data-extension-id"), false);\r\n                } else if ($target.hasClass("remove")) {\r\n                    ExtensionManager.markForRemoval($target.attr("data-extension-id"), true);\r\n                } else if ($target.hasClass("undo-update")) {\r\n                    ExtensionManager.removeUpdate($target.attr("data-extension-id"));\r\n                } else if ($target.data("toggle-desc") === "expand-desc") {\r\n                    this._toggleDescription($target.attr("data-extension-id"), $target, true);\r\n                } else if ($target.data("toggle-desc") === "trunc-desc") {\r\n                    this._toggleDescription($target.attr("data-extension-id"), $target, false);\r\n                }\r\n            }.bind(this))\r\n            .on("click", "button.install", function (e) {\r\n                self._installUsingDialog($(e.target).attr("data-extension-id"));\r\n            })\r\n            .on("click", "button.update", function (e) {\r\n                self._installUsingDialog($(e.target).attr("data-extension-id"), true);\r\n            })\r\n            .on("click", "button.remove", function (e) {\r\n                ExtensionManager.markForRemoval($(e.target).attr("data-extension-id"), true);\r\n            });\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Renders the view for a single extension entry.\r\n     * @param {Object} entry The extension entry to render.\r\n     * @param {Object} info The extension\'s metadata.\r\n     * @return {jQueryObject} The rendered node as a jQuery object.\r\n     */\r\n    ExtensionManagerView.prototype._renderItem = function (entry, info) {\r\n        // Create a Mustache context object containing the entry data and our helper functions.\r\n        \r\n        // Start with the basic info from the given entry, either the installation info or the\r\n        // registry info depending on what we\'re listing.\r\n        var context = $.extend({}, info);\r\n        \r\n        // Normally we would merge the strings into the context we\'re passing into the template,\r\n        // but since we\'re instantiating the template for every item, it seems wrong to take the hit\r\n        // of copying all the strings into the context, so we just make it a subfield.\r\n        context.Strings = Strings;\r\n        \r\n        // Calculate various bools, since Mustache doesn\'t let you use expressions and interprets\r\n        // arrays as iteration contexts.\r\n        context.isInstalled = !!entry.installInfo;\r\n        context.failedToStart = (entry.installInfo && entry.installInfo.status === ExtensionManager.START_FAILED);\r\n        context.hasVersionInfo = !!info.versions;\r\n                \r\n        if (entry.registryInfo) {\r\n            var latestVerCompatInfo = ExtensionManager.getCompatibilityInfo(entry.registryInfo, brackets.metadata.apiVersion);\r\n            context.isCompatible = latestVerCompatInfo.isCompatible;\r\n            context.requiresNewer = latestVerCompatInfo.requiresNewer;\r\n            context.isCompatibleLatest = latestVerCompatInfo.isLatestVersion;\r\n            if (!context.isCompatibleLatest) {\r\n                var installWarningBase = context.requiresNewer ? Strings.EXTENSION_LATEST_INCOMPATIBLE_NEWER : Strings.EXTENSION_LATEST_INCOMPATIBLE_OLDER;\r\n                context.installWarning = StringUtils.format(installWarningBase, entry.registryInfo.versions[entry.registryInfo.versions.length - 1].version, latestVerCompatInfo.compatibleVersion);\r\n            }\r\n        } else {\r\n            // We should only get here when viewing the Installed tab and some extensions don\'t exist in the registry\r\n            // (or registry is offline). These flags *should* always be ignored in that scenario, but just in case...\r\n            context.isCompatible = context.isCompatibleLatest = true;\r\n        }\r\n\r\n        if (info.metadata.description !== undefined) {\r\n            info.metadata.shortdescription = StringUtils.truncate(info.metadata.description, 200);\r\n        }\r\n\r\n        context.isMarkedForRemoval = ExtensionManager.isMarkedForRemoval(info.metadata.name);\r\n        context.isMarkedForUpdate = ExtensionManager.isMarkedForUpdate(info.metadata.name);\r\n        \r\n        context.showInstallButton = (this.model.source === this.model.SOURCE_REGISTRY || this.model.source === this.model.SOURCE_THEMES) && !context.updateAvailable;\r\n        context.showUpdateButton = context.updateAvailable && !context.isMarkedForUpdate && !context.isMarkedForRemoval;\r\n\r\n        context.allowInstall = context.isCompatible && !context.isInstalled;\r\n\r\n        if (Array.isArray(info.metadata.i18n) && info.metadata.i18n.length > 0) {\r\n            var lang      = brackets.getLocale(),\r\n                shortLang = lang.split("-")[0];\r\n\r\n            context.translated = true;\r\n            context.translatedLangs =\r\n                info.metadata.i18n.map(function (value) {\r\n                    return { name: LocalizationUtils.getLocalizedLabel(value), locale: value };\r\n                })\r\n                .sort(function (lang1, lang2) {\r\n                    // List users language first\r\n                    var locales         = [lang1.locale, lang2.locale],\r\n                        userLangIndex   = locales.indexOf(lang);\r\n                    if (userLangIndex > -1) {\r\n                        return userLangIndex;\r\n                    }\r\n                    userLangIndex = locales.indexOf(shortLang);\r\n                    if (userLangIndex > -1) {\r\n                        return userLangIndex;\r\n                    }\r\n\r\n                    return lang1.name.localeCompare(lang2.name);\r\n                })\r\n                .map(function (value) {\r\n                    return value.name;\r\n                })\r\n                .join(", ");\r\n            context.translatedLangs = StringUtils.format(Strings.EXTENSION_TRANSLATED_LANGS, context.translatedLangs);\r\n\r\n            // If the selected language is System Default, match both the short (2-char) language code\r\n            // and the long one\r\n            var translatedIntoUserLang =\r\n                (brackets.isLocaleDefault() && info.metadata.i18n.indexOf(shortLang) > -1) ||\r\n                info.metadata.i18n.indexOf(lang) > -1;\r\n            context.extensionTranslated = StringUtils.format(\r\n                translatedIntoUserLang ? Strings.EXTENSION_TRANSLATED_USER_LANG : Strings.EXTENSION_TRANSLATED_GENERAL,\r\n                info.metadata.i18n.length\r\n            );\r\n        }\r\n\r\n        var isInstalledInUserFolder = (entry.installInfo && entry.installInfo.locationType === ExtensionManager.LOCATION_USER);\r\n        context.allowRemove = isInstalledInUserFolder;\r\n        context.allowUpdate = context.showUpdateButton && context.isCompatible && context.updateCompatible && isInstalledInUserFolder;\r\n        if (!context.allowUpdate) {\r\n            context.updateNotAllowedReason = isInstalledInUserFolder ? Strings.CANT_UPDATE : Strings.CANT_UPDATE_DEV;\r\n        }\r\n\r\n        context.removalAllowed = this.model.source === "installed" &&\r\n            !context.failedToStart && !context.isMarkedForUpdate && !context.isMarkedForRemoval;\r\n        \r\n        // Copy over helper functions that we share with the registry app.\r\n        ["lastVersionDate", "authorInfo"].forEach(function (helper) {\r\n            context[helper] = registry_utils[helper];\r\n        });\r\n        \r\n        return $(this._itemTemplate(context));\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Display an optional message (hiding the extension list if displayed)\r\n     * @return {boolean} Returns true if a message is displayed\r\n     */\r\n    ExtensionManagerView.prototype._updateMessage = function () {\r\n        if (this.model.message) {\r\n            this._$emptyMessage.css("display", "block");\r\n            this._$emptyMessage.html(this.model.message);\r\n            this._$infoMessage.css("display", "none");\r\n            this._$table.css("display", "none");\r\n            \r\n            return true;\r\n        } else {\r\n            this._$emptyMessage.css("display", "none");\r\n            this._$infoMessage.css("display", this.model.infoMessage ? "block" : "none");\r\n            this._$table.css("display", "");\r\n            \r\n            return false;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Renders the extension entry table based on the model\'s current filter set. Will create\r\n     * new items for entries that haven\'t yet been rendered, but will not re-render existing items.\r\n     */\r\n    ExtensionManagerView.prototype._render = function () {\r\n        var self = this,\r\n            $item;\r\n        \r\n        this._$table.empty();\r\n        this._updateMessage();\r\n        \r\n        this.model.filterSet.forEach(function (id) {\r\n            var $item = self._itemViews[id];\r\n            if (!$item) {\r\n                $item = self._renderItem(self.model.extensions[id], self.model._getEntry(id));\r\n                self._itemViews[id] = $item;\r\n            }\r\n            $item.appendTo(self._$table);\r\n        });\r\n        \r\n        $(this).triggerHandler("render");\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Install the extension with the given ID using the install dialog.\r\n     * @param {string} id ID of the extension to install.\r\n     */\r\n    ExtensionManagerView.prototype._installUsingDialog = function (id, _isUpdate) {\r\n        var entry = this.model.extensions[id];\r\n        if (entry && entry.registryInfo) {\r\n            var compatInfo = ExtensionManager.getCompatibilityInfo(entry.registryInfo, brackets.metadata.apiVersion),\r\n                url = ExtensionManager.getExtensionURL(id, compatInfo.compatibleVersion);\r\n            \r\n            // TODO: this should set .done on the returned promise\r\n            if (_isUpdate) {\r\n                InstallExtensionDialog.updateUsingDialog(url).done(ExtensionManager.updateFromDownload);\r\n            } else {\r\n                InstallExtensionDialog.installUsingDialog(url);\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Filters the contents of the view.\r\n     * @param {string} query The query to filter by.\r\n     */\r\n    ExtensionManagerView.prototype.filter = function (query) {\r\n        this.model.filter(query);\r\n    };\r\n        \r\n    exports.ExtensionManagerView = ExtensionManagerView;\r\n});\r\n\n//# sourceURL=/extensibility/ExtensionManagerView.js'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50, regexp: true */\r\n/*global define, window, $, brackets, Mustache */\r\n/*unittests: ExtensionManager*/\r\n\r\ndefine(\'extensibility/ExtensionManagerViewModel\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'extensibility/ExtensionManager\',\'extensibility/Package\',\'extensibility/registry_utils\',\'strings\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _ = require("thirdparty/lodash");\r\n    \r\n    var ExtensionManager = require("extensibility/ExtensionManager"),\r\n        Package          = require("extensibility/Package"),\r\n        registry_utils   = require("extensibility/registry_utils"),\r\n        Strings          = require("strings");\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array}\r\n     * A list of fields to search when trying to search for a query string in an object. Each field is \r\n     * represented as an array of keys to recurse downward through the object. We store this here to avoid \r\n     * doing it for each search call.\r\n     */\r\n    var _searchFields = [["metadata", "name"], ["metadata", "title"], ["metadata", "description"],\r\n                         ["metadata", "author", "name"], ["metadata", "keywords"], ["owner"]];\r\n    /**\r\n     * The base model for the ExtensionManagerView. Keeps track of the extensions that are currently visible\r\n     * and manages sorting/filtering them. Must be disposed with dispose() when done.\r\n     * Events:\r\n     * - change - triggered when the data for a given extension changes. Second parameter is the extension id.\r\n     * - filter - triggered whenever the filtered set changes (including on initialize).\r\n     *\r\n     * @constructor\r\n     */\r\n    function ExtensionManagerViewModel() {\r\n        this._handleStatusChange = this._handleStatusChange.bind(this);\r\n        \r\n        // Listen for extension status changes.\r\n        $(ExtensionManager)\r\n            .on("statusChange." + this.source, this._handleStatusChange)\r\n            .on("registryUpdate." + this.source, this._handleStatusChange);\r\n    }\r\n    \r\n    /**\r\n     * @type {string}\r\n     * Constant indicating that this model/view should initialize from the main extension registry.\r\n     */\r\n    ExtensionManagerViewModel.prototype.SOURCE_REGISTRY = "registry";\r\n    \r\n    /**\r\n     * @type {string}\r\n     * Constant indicating that this model/view should initialize from the main extension registry with only themes.\r\n     */\r\n    ExtensionManagerViewModel.prototype.SOURCE_THEMES = "themes";\r\n\r\n    /**\r\n     * @type {string}\r\n     * Constant indicating that this model/view should initialize from the list of locally installed extensions.\r\n     */\r\n    ExtensionManagerViewModel.prototype.SOURCE_INSTALLED = "installed";\r\n    \r\n    /**\r\n     * @type {Object}\r\n     * The current set of extensions managed by this model. Same as ExtensionManager.extensions.\r\n     */\r\n    ExtensionManagerViewModel.prototype.extensions = null;\r\n    \r\n    /**\r\n     * @type {string}\r\n     * The current source for the model; one of the SOURCE_* keys above.\r\n     */\r\n    ExtensionManagerViewModel.prototype.source = null;\r\n    \r\n    /**\r\n     * @type {Array.<Object>}\r\n     * The list of IDs of items matching the current query and sorted with the current sort.\r\n     */\r\n    ExtensionManagerViewModel.prototype.filterSet = null;\r\n    \r\n    /**\r\n     * @type {Object}\r\n     * The list of all ids from the extension list, sorted with the current sort.\r\n     */\r\n    ExtensionManagerViewModel.prototype.sortedFullSet = null;\r\n    \r\n    /**\r\n     * @private\r\n     * @type {string}\r\n     * The last query we filtered by. Used to optimize future searches.\r\n     */\r\n    ExtensionManagerViewModel.prototype._lastQuery = null;\r\n    \r\n    /**\r\n     * @type {string}\r\n     * Info message to display to the user when listing extensions\r\n     */\r\n    ExtensionManagerViewModel.prototype.infoMessage = null;\r\n    \r\n    /**\r\n     * @type {string}\r\n     * An optional message to display to the user\r\n     */\r\n    ExtensionManagerViewModel.prototype.message = null;\r\n    \r\n    /**\r\n     * @type {number}\r\n     * Number to show in tab\'s notification icon. No icon shown if 0.\r\n     */\r\n    ExtensionManagerViewModel.prototype.notifyCount = 0;\r\n    \r\n    /**\r\n     * @private {$.Promise}\r\n     * Internal use only to track when initialization fails, see usage in _updateMessage.\r\n     */\r\n    ExtensionManagerViewModel.prototype._initializeFromSourcePromise = null;\r\n    \r\n    /**\r\n     * Unregisters listeners when we\'re done.\r\n     */\r\n    ExtensionManagerViewModel.prototype.dispose = function () {\r\n        $(ExtensionManager).off("." + this.source);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Sets up the initial filtered set based on the sorted full set.\r\n     */\r\n    ExtensionManagerViewModel.prototype._setInitialFilter = function () {\r\n        // Initial filtered list is the same as the sorted list.\r\n        this.filterSet = _.clone(this.sortedFullSet);\r\n        $(this).triggerHandler("filter");\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Re-sorts the current full set based on the source we\'re viewing.\r\n     * The base implementation does nothing.\r\n     */\r\n    ExtensionManagerViewModel.prototype._sortFullSet = function () { };\r\n\r\n    /**\r\n     * Initializes the model from the source.\r\n     */\r\n    ExtensionManagerViewModel.prototype.initialize = function () {\r\n        var self = this;\r\n        \r\n        this._initializeFromSourcePromise = this._initializeFromSource().always(function () {\r\n            self._updateMessage();\r\n        });\r\n        \r\n        return this._initializeFromSourcePromise;\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Updates the initial set and filter as necessary when the status of an extension changes,\r\n     * and notifies listeners of the change.\r\n     * @param {$.Event} e The jQuery event object.\r\n     * @param {string} id The id of the extension whose status changed.\r\n     */\r\n    ExtensionManagerViewModel.prototype._handleStatusChange = function (e, id) {\r\n        $(this).triggerHandler("change", id);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Searches for the given query in the current extension list and updates the filter set,\r\n     * dispatching a filter event.\r\n     * @param {string} query The string to search for.\r\n     * @param {boolean} force If true, always filter starting with the full set, not the last\r\n     *     query\'s filter.\r\n     */\r\n    ExtensionManagerViewModel.prototype.filter = function (query, force) {\r\n        var self = this, initialList;\r\n        if (!force && this._lastQuery && query.indexOf(this._lastQuery) === 0) {\r\n            // This is the old query with some new letters added, so we know we can just\r\n            // search in the current filter set. (This is true even if query has spaces).\r\n            initialList = this.filterSet;\r\n        } else {\r\n            // This is a new query, so start with the full list.\r\n            initialList = this.sortedFullSet;\r\n        }\r\n        \r\n        var keywords = query.toLowerCase().split(/\\s+/);\r\n        \r\n        // Takes \'extensionList\' and returns a version filtered to only those that match \'keyword\'\r\n        function filterForKeyword(extensionList, word) {\r\n            var filteredList = [];\r\n            extensionList.forEach(function (id) {\r\n                var entry = self._getEntry(id);\r\n                if (entry && self._entryMatchesQuery(entry, word)) {\r\n                    filteredList.push(id);\r\n                }\r\n            });\r\n            return filteredList;\r\n        }\r\n        \r\n        // "AND" the keywords together: successively filter down the result set by each keyword in turn\r\n        var i, currentList = initialList;\r\n        for (i = 0; i < keywords.length; i++) {\r\n            currentList = filterForKeyword(currentList, keywords[i]);\r\n        }\r\n        \r\n        this._lastQuery = query;\r\n        this.filterSet = currentList;\r\n\r\n        this._updateMessage();\r\n\r\n        $(this).triggerHandler("filter");\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Updates an optional message displayed to the user along with the extension list.\r\n     */\r\n    ExtensionManagerViewModel.prototype._updateMessage = function () {\r\n        if (this._initializeFromSourcePromise && this._initializeFromSourcePromise.state() === "rejected") {\r\n            this.message = Strings.EXTENSION_MANAGER_ERROR_LOAD;\r\n        } else if (this.filterSet && this.filterSet.length === 0) {\r\n            this.message = this.sortedFullSet && this.sortedFullSet.length ? Strings.NO_EXTENSION_MATCHES : Strings.NO_EXTENSIONS;\r\n        } else {\r\n            this.message = null;\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * This is to be overridden by subclasses to provide the metadata for the extension\r\n     * with the provided `id`.\r\n     *\r\n     * @param {string} id of the extension\r\n     * @return {Object?} extension metadata or null if there\'s no matching extension\r\n     */\r\n    ExtensionManagerViewModel.prototype._getEntry = function (id) {\r\n        return null;\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Tests if the given entry matches the query.\r\n     * @param {Object} entry The extension entry to test.\r\n     * @param {string} query The query to match against.\r\n     * @return {boolean} Whether the query matches.\r\n     */\r\n    ExtensionManagerViewModel.prototype._entryMatchesQuery = function (entry, query) {\r\n        return query === "" ||\r\n            _searchFields.some(function (fieldSpec) {\r\n                var i, cur = entry;\r\n                for (i = 0; i < fieldSpec.length; i++) {\r\n                    // Recurse downward through the specified fields to the leaf value.\r\n                    cur = cur[fieldSpec[i]];\r\n                    if (!cur) {\r\n                        return false;\r\n                    }\r\n                }\r\n                // If the leaf value is an array (like keywords), search each item, otherwise\r\n                // just search in the string.\r\n                if (Array.isArray(cur)) {\r\n                    return cur.some(function (keyword) {\r\n                        return keyword.toLowerCase().indexOf(query) !== -1;\r\n                    });\r\n                } else if (fieldSpec[fieldSpec.length - 1] === "owner") {\r\n                    // Special handling: ignore the authentication source when querying,\r\n                    // since it\'s not useful to search on\r\n                    var components = cur.split(":");\r\n                    if (components[1].toLowerCase().indexOf(query) !== -1) {\r\n                        return true;\r\n                    }\r\n                } else if (cur.toLowerCase().indexOf(query) !== -1) {\r\n                    return true;\r\n                }\r\n            });\r\n    };\r\n    \r\n    /**\r\n     * The model for the ExtensionManagerView that is responsible for handling registry-based extensions. \r\n     * This extends ExtensionManagerViewModel.\r\n     * Must be disposed with dispose() when done.\r\n     *\r\n     * Events:\r\n     * - change - triggered when the data for a given extension changes. Second parameter is the extension id.\r\n     * - filter - triggered whenever the filtered set changes (including on initialize).\r\n     *\r\n     * @constructor\r\n     */\r\n    function RegistryViewModel() {\r\n        ExtensionManagerViewModel.call(this);\r\n        this.infoMessage = Strings.REGISTRY_SANITY_CHECK_WARNING;\r\n    }\r\n    \r\n    RegistryViewModel.prototype = Object.create(ExtensionManagerViewModel.prototype);\r\n    RegistryViewModel.prototype.constructor = RegistryViewModel;\r\n    \r\n    /**\r\n     * @type {string}\r\n     * RegistryViewModels always have a source of SOURCE_REGISTRY.\r\n     */\r\n    RegistryViewModel.prototype.source = ExtensionManagerViewModel.prototype.SOURCE_REGISTRY;\r\n    \r\n    /**\r\n     * Initializes the model from the remote extension registry.\r\n     * @return {$.Promise} a promise that\'s resolved with the registry JSON data\r\n     * or rejected if the server can\'t be reached.\r\n     */\r\n    RegistryViewModel.prototype._initializeFromSource = function () {\r\n        var self = this;\r\n        return ExtensionManager.downloadRegistry()\r\n            .done(function () {\r\n                self.extensions = ExtensionManager.extensions;\r\n                \r\n                // Sort the registry by last published date and store the sorted list of IDs.\r\n                self.sortedFullSet = registry_utils.sortRegistry(self.extensions, "registryInfo")\r\n                    .filter(function (entry) {\r\n                        return entry.registryInfo !== undefined && entry.registryInfo.metadata.theme === undefined;\r\n                    })\r\n                    .map(function (entry) {\r\n                        return entry.registryInfo.metadata.name;\r\n                    });\r\n                self._setInitialFilter();\r\n            })\r\n            .fail(function () {\r\n                self.extensions = [];\r\n                self.sortedFullSet = [];\r\n                self.filterSet = [];\r\n            });\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Finds the extension metadata by id. If there is no extension matching the given id,\r\n     * this returns `null`.\r\n     * @param {string} id of the extension\r\n     * @return {Object?} extension metadata or null if there\'s no matching extension\r\n     */\r\n    RegistryViewModel.prototype._getEntry = function (id) {\r\n        var entry = this.extensions[id];\r\n        if (entry) {\r\n            return entry.registryInfo;\r\n        }\r\n        return entry;\r\n    };\r\n    \r\n    /**\r\n     * The model for the ExtensionManagerView that is responsible for handling previously-installed extensions. \r\n     * This extends ExtensionManagerViewModel.\r\n     * Must be disposed with dispose() when done.\r\n     *\r\n     * Events:\r\n     * - change - triggered when the data for a given extension changes. Second parameter is the extension id.\r\n     * - filter - triggered whenever the filtered set changes (including on initialize).\r\n     *\r\n     * @constructor\r\n     */\r\n    function InstalledViewModel() {\r\n        ExtensionManagerViewModel.call(this);\r\n\r\n        // when registry is downloaded, sort extensions again - those with updates will be before others\r\n        var self = this;\r\n        $(ExtensionManager).on("registryDownload", function () {\r\n            self._sortFullSet();\r\n            self._setInitialFilter();\r\n        });\r\n    }\r\n    \r\n    InstalledViewModel.prototype = Object.create(ExtensionManagerViewModel.prototype);\r\n    InstalledViewModel.prototype.constructor = InstalledViewModel;\r\n    \r\n    /**\r\n     * @type {string}\r\n     * InstalledViewModels always have a source of SOURCE_INSTALLED.\r\n     */\r\n    InstalledViewModel.prototype.source = ExtensionManagerViewModel.prototype.SOURCE_INSTALLED;\r\n    \r\n    /**\r\n     * Initializes the model from the set of locally installed extensions, sorted\r\n     * alphabetically by id (or name of the extension folder for legacy extensions).\r\n     * @return {$.Promise} a promise that\'s resolved when we\'re done initializing.\r\n     */\r\n    InstalledViewModel.prototype._initializeFromSource = function () {\r\n        var self = this;\r\n        this.extensions = ExtensionManager.extensions;\r\n        this.sortedFullSet = Object.keys(this.extensions)\r\n            .filter(function (key) {\r\n                return self.extensions[key].installInfo &&\r\n                    self.extensions[key].installInfo.locationType !== ExtensionManager.LOCATION_DEFAULT;\r\n            });\r\n        this._sortFullSet();\r\n        this._setInitialFilter();\r\n        this._countUpdates();\r\n        \r\n        return new $.Deferred().resolve().promise();\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Re-sorts the current full set\r\n     */\r\n    InstalledViewModel.prototype._sortFullSet = function () {\r\n        var self = this;\r\n        \r\n        this.sortedFullSet = this.sortedFullSet.sort(function (key1, key2) {\r\n            // before sorting by name, put first extensions that have updates\r\n            var ua1 = self.extensions[key1].installInfo.updateAvailable,\r\n                ua2 = self.extensions[key2].installInfo.updateAvailable;\r\n\r\n            if (ua1 && !ua2) {\r\n                return -1;\r\n            } else if (!ua1 && ua2) {\r\n                return 1;\r\n            }\r\n\r\n            var metadata1 = self.extensions[key1].installInfo.metadata,\r\n                metadata2 = self.extensions[key2].installInfo.metadata,\r\n                id1 = (metadata1.title || metadata1.name).toLocaleLowerCase(),\r\n                id2 = (metadata2.title || metadata2.name).toLocaleLowerCase();\r\n\r\n            return id1.localeCompare(id2);\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Updates notifyCount based on number of extensions with an update available\r\n     */\r\n    InstalledViewModel.prototype._countUpdates = function () {\r\n        var self = this;\r\n        this.notifyCount = 0;\r\n        this.sortedFullSet.forEach(function (key) {\r\n            if (self.extensions[key].installInfo.updateCompatible && !ExtensionManager.isMarkedForUpdate(key)) {\r\n                self.notifyCount++;\r\n            }\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Updates the initial set and filter as necessary when the status of an extension changes,\r\n     * and notifies listeners of the change.\r\n     * @param {$.Event} e The jQuery event object.\r\n     * @param {string} id The id of the extension whose status changed.\r\n     */\r\n    InstalledViewModel.prototype._handleStatusChange = function (e, id) {\r\n        var index = this.sortedFullSet.indexOf(id),\r\n            refilter = false;\r\n        if (index !== -1 && !this.extensions[id].installInfo) {\r\n            // This was in our set, but was uninstalled. Remove it.\r\n            this.sortedFullSet.splice(index, 1);\r\n            this._countUpdates();  // may also affect update count\r\n            refilter = true;\r\n        } else if (index === -1 && this.extensions[id].installInfo) {\r\n            // This was not in our set, but is now installed. Add it and resort.\r\n            this.sortedFullSet.push(id);\r\n            this._sortFullSet();\r\n            refilter = true;\r\n        }\r\n        if (refilter) {\r\n            this.filter(this._lastQuery || "", true);\r\n        }\r\n        \r\n        if (this.extensions[id].installInfo) {\r\n            // If our count of available updates may have been affected, re-count\r\n            this._countUpdates();\r\n        }\r\n        \r\n        ExtensionManagerViewModel.prototype._handleStatusChange.call(this, e, id);\r\n    };\r\n    \r\n    /**\r\n     * @private\r\n     * Finds the extension metadata by id. If there is no extension matching the given id,\r\n     * this returns `null`.\r\n     * @param {string} id of the extension\r\n     * @return {Object?} extension metadata or null if there\'s no matching extension\r\n     */\r\n    InstalledViewModel.prototype._getEntry = function (id) {\r\n        var entry = this.extensions[id];\r\n        if (entry) {\r\n            return entry.installInfo;\r\n        }\r\n        return entry;\r\n    };\r\n\r\n    /**\r\n     * The model for the ExtensionManagerView that is responsible for handling registry-based theme extensions. \r\n     * This extends ExtensionManagerViewModel.\r\n     * Must be disposed with dispose() when done.\r\n     *\r\n     * Events:\r\n     * - change - triggered when the data for a given extension changes. Second parameter is the extension id.\r\n     * - filter - triggered whenever the filtered set changes (including on initialize).\r\n     *\r\n     * @constructor\r\n     */\r\n    function ThemesViewModel() {\r\n        ExtensionManagerViewModel.call(this);\r\n    }\r\n\r\n    // Inheritance setup\r\n    ThemesViewModel.prototype = Object.create(ExtensionManagerViewModel.prototype);\r\n    ThemesViewModel.prototype.constructor = ThemesViewModel;\r\n\r\n    /**\r\n     * @type {string}\r\n     * ThemeViewModels always have a source of SOURCE_THEMES.\r\n     */\r\n    ThemesViewModel.prototype.source = ExtensionManagerViewModel.prototype.SOURCE_THEMES;\r\n\r\n    /**\r\n     * Initializes the model from the remote extension registry.\r\n     * @return {$.Promise} a promise that\'s resolved with the registry JSON data.\r\n     */\r\n    ThemesViewModel.prototype._initializeFromSource = function () {\r\n        var self = this;\r\n        return ExtensionManager.downloadRegistry()\r\n            .done(function () {\r\n                self.extensions = ExtensionManager.extensions;\r\n\r\n                // Sort the registry by last published date and store the sorted list of IDs.\r\n                self.sortedFullSet = registry_utils.sortRegistry(self.extensions, "registryInfo")\r\n                    .filter(function (entry) {\r\n                        return entry.registryInfo !== undefined && entry.registryInfo.metadata.theme;\r\n                    })\r\n                    .map(function (entry) {\r\n                        return entry.registryInfo.metadata.name;\r\n                    });\r\n                self._setInitialFilter();\r\n            })\r\n            .fail(function () {\r\n                self.extensions = [];\r\n                self.sortedFullSet = [];\r\n                self.filterSet = [];\r\n            });\r\n    };\r\n\r\n    /**\r\n     * @private\r\n     * Finds the theme extension metadata by id. If there is no theme extension matching the given id,\r\n     * this returns `null`.\r\n     * @param {string} id of the theme extension\r\n     * @return {Object?} extension metadata or null if there\'s no matching extension\r\n     */\r\n    ThemesViewModel.prototype._getEntry = function (id) {\r\n        var entry = this.extensions[id];\r\n        if (entry) {\r\n            return entry.registryInfo;\r\n        }\r\n        return entry;\r\n    };\r\n\r\n    exports.RegistryViewModel = RegistryViewModel;\r\n    exports.ThemesViewModel = ThemesViewModel;\r\n    exports.InstalledViewModel = InstalledViewModel;\r\n});\r\n\n//# sourceURL=/extensibility/ExtensionManagerViewModel.js'),eval('define(\'text!htmlContent/extension-manager-dialog.html\',[],function () { return \'<div class="extension-manager-dialog modal" tabindex="-1">\\r\\n    <div class="modal-header">\\r\\n        <ul class="nav nav-tabs">\\r\\n            {{#showRegistry}}\\r\\n                <li><a href="#registry" class="registry" data-toggle="tab"><img src="styles/images/extension-manager-registry.svg"/><br/>{{Strings.EXTENSIONS_AVAILABLE_TITLE}}</a></li>\\r\\n                <li><a href="#themes" class="themes" data-toggle="tab"><img src="styles/images/themes-icon.svg"/><br/>{{Strings.EXTENSIONS_THEMES_TITLE}}</a></li>\\r\\n                <!--<li><a href="#updates" class="updates" data-toggle="tab"><img src="styles/images/extension-manager-updates.svg"/><br/>{{Strings.EXTENSIONS_UPDATES_TITLE}}</a></li>-->\\r\\n            {{/showRegistry}}\\r\\n            <li><a href="#installed" class="installed" data-toggle="tab"><span class="notification"></span><img src="styles/images/extension-manager-installed.svg"/><br/>{{Strings.EXTENSIONS_INSTALLED_TITLE}}</a></li>\\r\\n        </ul>\\r\\n        <div>\\r\\n            <button class="search-clear">&times;</button>\\r\\n            <input class="search" type="text" placeholder="{{EXTENSION_SEARCH_PLACEHOLDER}}">\\r\\n        </div>\\r\\n    </div>\\r\\n    <div class="modal-body no-padding table-striped tab-content">\\r\\n        <div class=\\\'spinner large spin\\\'/>\\r\\n    </div>\\r\\n    <div class="modal-footer">\\r\\n        <span id="install-drop-zone" class="btn left drag">\\r\\n            <span class="install-drag-message">{{Strings.INSTALL_EXTENSION_DRAG}} <a class="install-from-url">{{Strings.INSTALL_FROM_URL}}</a></span>\\r\\n            <span class="install-drop-message">{{Strings.INSTALL_EXTENSION_DROP}}</span>\\r\\n            <span class="install-validating-message">{{Strings.INSTALL_EXTENSION_VALIDATING}}</span>\\r\\n            <div id="install-drop-zone-mask"></div>\\r\\n        </span>\\r\\n        <button class="dialog-button btn primary" data-button-id="close">{{Strings.CLOSE}}</button>\\r\\n    </div>\\r\\n</div>\\r\\n\';});\n\n//# sourceURL=/text!htmlContent/extension-manager-dialog.html'),eval("/* ========================================================\r\n * bootstrap-tab.js v2.3.1\r\n * http://twitter.github.com/bootstrap/javascript.html#tabs\r\n * ========================================================\r\n * Copyright 2012 Twitter, Inc.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n * ======================================================== */\r\n\r\n\r\n!function ($) {\r\n\r\n  \"use strict\"; // jshint ;_;\r\n\r\n\r\n /* TAB CLASS DEFINITION\r\n  * ==================== */\r\n\r\n  var Tab = function (element) {\r\n    this.element = $(element)\r\n  }\r\n\r\n  Tab.prototype = {\r\n\r\n    constructor: Tab\r\n\r\n  , show: function () {\r\n      var $this = this.element\r\n        , $ul = $this.closest('ul:not(.dropdown-menu)')\r\n        , selector = $this.attr('data-target')\r\n        , previous\r\n        , $target\r\n        , e\r\n\r\n      if (!selector) {\r\n        selector = $this.attr('href')\r\n        selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') //strip for ie7\r\n      }\r\n\r\n      if ( $this.parent('li').hasClass('active') ) return\r\n\r\n      previous = $ul.find('.active:last a')[0]\r\n\r\n      e = $.Event('show', {\r\n        relatedTarget: previous\r\n      })\r\n\r\n      $this.trigger(e)\r\n\r\n      if (e.isDefaultPrevented()) return\r\n\r\n      $target = $(selector)\r\n\r\n      this.activate($this.parent('li'), $ul)\r\n      this.activate($target, $target.parent(), function () {\r\n        $this.trigger({\r\n          type: 'shown'\r\n        , relatedTarget: previous\r\n        })\r\n      })\r\n    }\r\n\r\n  , activate: function ( element, container, callback) {\r\n      var $active = container.find('> .active')\r\n        , transition = callback\r\n            && $.support.transition\r\n            && $active.hasClass('fade')\r\n\r\n      function next() {\r\n        $active\r\n          .removeClass('active')\r\n          .find('> .dropdown-menu > .active')\r\n          .removeClass('active')\r\n\r\n        element.addClass('active')\r\n\r\n        if (transition) {\r\n          element[0].offsetWidth // reflow for transition\r\n          element.addClass('in')\r\n        } else {\r\n          element.removeClass('fade')\r\n        }\r\n\r\n        if ( element.parent('.dropdown-menu') ) {\r\n          element.closest('li.dropdown').addClass('active')\r\n        }\r\n\r\n        callback && callback()\r\n      }\r\n\r\n      transition ?\r\n        $active.one($.support.transition.end, next) :\r\n        next()\r\n\r\n      $active.removeClass('in')\r\n    }\r\n  }\r\n\r\n\r\n /* TAB PLUGIN DEFINITION\r\n  * ===================== */\r\n\r\n  var old = $.fn.tab\r\n\r\n  $.fn.tab = function ( option ) {\r\n    return this.each(function () {\r\n      var $this = $(this)\r\n        , data = $this.data('tab')\r\n      if (!data) $this.data('tab', (data = new Tab(this)))\r\n      if (typeof option == 'string') data[option]()\r\n    })\r\n  }\r\n\r\n  $.fn.tab.Constructor = Tab\r\n\r\n\r\n /* TAB NO CONFLICT\r\n  * =============== */\r\n\r\n  $.fn.tab.noConflict = function () {\r\n    $.fn.tab = old\r\n    return this\r\n  }\r\n\r\n\r\n /* TAB DATA-API\r\n  * ============ */\r\n\r\n  $(document).on('click.tab.data-api', '[data-toggle=\"tab\"], [data-toggle=\"pill\"]', function (e) {\r\n    e.preventDefault()\r\n    $(this).tab('show')\r\n  })\r\n\r\n}(window.jQuery);\n//# sourceURL=/widgets/bootstrap-tab.js"),define("widgets/bootstrap-tab",function(){}),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global brackets, define, $, Mustache, window */\r\n\r\ndefine(\'extensibility/ExtensionManagerDialog\',[\'require\',\'exports\',\'module\',\'thirdparty/lodash\',\'widgets/Dialogs\',\'widgets/DefaultDialogs\',\'filesystem/FileSystem\',\'file/FileUtils\',\'extensibility/Package\',\'strings\',\'utils/StringUtils\',\'command/Commands\',\'command/CommandManager\',\'extensibility/InstallExtensionDialog\',\'utils/AppInit\',\'utils/Async\',\'utils/KeyEvent\',\'extensibility/ExtensionManager\',\'extensibility/ExtensionManagerView\',\'extensibility/ExtensionManagerViewModel\',\'text!htmlContent/extension-manager-dialog.html\',\'widgets/bootstrap-tab\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var _                           = require("thirdparty/lodash"),\r\n        Dialogs                     = require("widgets/Dialogs"),\r\n        DefaultDialogs              = require("widgets/DefaultDialogs"),\r\n        FileSystem                  = require("filesystem/FileSystem"),\r\n        FileUtils                   = require("file/FileUtils"),\r\n        Package                     = require("extensibility/Package"),\r\n        Strings                     = require("strings"),\r\n        StringUtils                 = require("utils/StringUtils"),\r\n        Commands                    = require("command/Commands"),\r\n        CommandManager              = require("command/CommandManager"),\r\n        InstallExtensionDialog      = require("extensibility/InstallExtensionDialog"),\r\n        AppInit                     = require("utils/AppInit"),\r\n        Async                       = require("utils/Async"),\r\n        KeyEvent                    = require("utils/KeyEvent"),\r\n        ExtensionManager            = require("extensibility/ExtensionManager"),\r\n        ExtensionManagerView        = require("extensibility/ExtensionManagerView").ExtensionManagerView,\r\n        ExtensionManagerViewModel   = require("extensibility/ExtensionManagerViewModel");\r\n    \r\n    var dialogTemplate    = require("text!htmlContent/extension-manager-dialog.html");\r\n    \r\n    // bootstrap tabs component\r\n    require("widgets/bootstrap-tab");\r\n    \r\n    var _activeTabIndex;\r\n\r\n    function _stopEvent(event) {\r\n        event.stopPropagation();\r\n        event.preventDefault();\r\n    }\r\n\r\n    /**\r\n     * @private\r\n     * Triggers changes requested by the dialog UI.\r\n     */\r\n    function _performChanges() {\r\n        // If an extension was removed or updated, prompt the user to quit Brackets.\r\n        var hasRemovedExtensions = ExtensionManager.hasExtensionsToRemove(),\r\n            hasUpdatedExtensions = ExtensionManager.hasExtensionsToUpdate();\r\n        if (!hasRemovedExtensions && !hasUpdatedExtensions) {\r\n            return;\r\n        }\r\n        \r\n        var buttonLabel = Strings.CHANGE_AND_RELOAD;\r\n        if (hasRemovedExtensions && !hasUpdatedExtensions) {\r\n            buttonLabel = Strings.REMOVE_AND_RELOAD;\r\n        } else if (hasUpdatedExtensions && !hasRemovedExtensions) {\r\n            buttonLabel = Strings.UPDATE_AND_RELOAD;\r\n        }\r\n        \r\n        var dlg = Dialogs.showModalDialog(\r\n            DefaultDialogs.DIALOG_ID_CHANGE_EXTENSIONS,\r\n            Strings.CHANGE_AND_RELOAD_TITLE,\r\n            Strings.CHANGE_AND_RELOAD_MESSAGE,\r\n            [\r\n                {\r\n                    className : Dialogs.DIALOG_BTN_CLASS_NORMAL,\r\n                    id        : Dialogs.DIALOG_BTN_CANCEL,\r\n                    text      : Strings.CANCEL\r\n                },\r\n                {\r\n                    className : Dialogs.DIALOG_BTN_CLASS_PRIMARY,\r\n                    id        : Dialogs.DIALOG_BTN_OK,\r\n                    text      : buttonLabel\r\n                }\r\n            ],\r\n            false\r\n        ),\r\n            $dlg = dlg.getElement();\r\n        \r\n        $dlg.one("buttonClick", function (e, buttonId) {\r\n            if (buttonId === Dialogs.DIALOG_BTN_OK) {\r\n                // Disable the dialog buttons so the user can\'t dismiss it,\r\n                // and show a message indicating that we\'re doing the updates,\r\n                // in case it takes a long time.\r\n                $dlg.find(".dialog-button").prop("disabled", true);\r\n                $dlg.find(".close").hide();\r\n                $dlg.find(".dialog-message")\r\n                    .text(Strings.PROCESSING_EXTENSIONS)\r\n                    .append("<span class=\'spinner inline spin\'/>");\r\n                \r\n                ExtensionManager.removeMarkedExtensions()\r\n                    .done(function () {\r\n                        ExtensionManager.updateExtensions()\r\n                            .done(function () {\r\n                                dlg.close();\r\n                                CommandManager.execute(Commands.APP_RELOAD);\r\n                            })\r\n                            .fail(function (errorArray) {\r\n                                dlg.close();\r\n                                \r\n                                // This error case should be very uncommon.\r\n                                // Just let the user know that we couldn\'t update\r\n                                // this extension and log the errors to the console.\r\n                                var ids = [];\r\n                                errorArray.forEach(function (errorObj) {\r\n                                    ids.push(errorObj.item);\r\n                                    if (errorObj.error && errorObj.error.forEach) {\r\n                                        console.error("Errors for ", errorObj.item);\r\n                                        errorObj.error.forEach(function (error) {\r\n                                            console.error(Package.formatError(error));\r\n                                        });\r\n                                    }\r\n                                });\r\n                                Dialogs.showModalDialog(\r\n                                    DefaultDialogs.DIALOG_ID_ERROR,\r\n                                    Strings.EXTENSION_MANAGER_UPDATE,\r\n                                    StringUtils.format(Strings.EXTENSION_MANAGER_UPDATE_ERROR, ids.join(", "))\r\n                                ).done(function () {\r\n                                    // We still have to reload even if some of the removals failed.\r\n                                    CommandManager.execute(Commands.APP_RELOAD);\r\n                                });\r\n                            });\r\n                    })\r\n                    .fail(function (errorArray) {\r\n                        dlg.close();\r\n                        ExtensionManager.cleanupUpdates();\r\n                        \r\n                        var ids = [];\r\n                        errorArray.forEach(function (errorObj) {\r\n                            ids.push(errorObj.item);\r\n                        });\r\n                        Dialogs.showModalDialog(\r\n                            DefaultDialogs.DIALOG_ID_ERROR,\r\n                            Strings.EXTENSION_MANAGER_REMOVE,\r\n                            StringUtils.format(Strings.EXTENSION_MANAGER_REMOVE_ERROR, ids.join(", "))\r\n                        ).done(function () {\r\n                            // We still have to reload even if some of the removals failed.\r\n                            CommandManager.execute(Commands.APP_RELOAD);\r\n                        });\r\n                    });\r\n            } else {\r\n                dlg.close();\r\n                ExtensionManager.cleanupUpdates();\r\n                ExtensionManager.unmarkAllForRemoval();\r\n            }\r\n        });\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @private\r\n     * Install extensions from the local file system using the install dialog.\r\n     * @return {$.Promise}\r\n     */\r\n    function _installUsingDragAndDrop() {\r\n        var installZips = [],\r\n            updateZips = [],\r\n            deferred = new $.Deferred(),\r\n            validatePromise;\r\n\r\n        brackets.app.getDroppedFiles(function (err, paths) {\r\n            if (err) {\r\n                // Only possible error is invalid params, silently ignore\r\n                console.error(err);\r\n                deferred.resolve();\r\n                return;\r\n            }\r\n\r\n            // Parse zip files and separate new installs vs. updates\r\n            validatePromise = Async.doInParallel_aggregateErrors(paths, function (path) {\r\n                var result = new $.Deferred();\r\n                \r\n                FileSystem.resolve(path, function (err, file) {\r\n                    var extension = FileUtils.getFileExtension(path),\r\n                        isZip = file.isFile && (extension === "zip"),\r\n                        errStr;\r\n                    \r\n                    if (err) {\r\n                        errStr = FileUtils.getFileErrorString(err);\r\n                    } else if (!isZip) {\r\n                        errStr = Strings.INVALID_ZIP_FILE;\r\n                    }\r\n\r\n                    if (errStr) {\r\n                        result.reject(errStr);\r\n                        return;\r\n                    }\r\n                    \r\n                    // Call validate() so that we open the local zip file and parse the\r\n                    // package.json. We need the name to detect if this zip will be a\r\n                    // new install or an update.\r\n                    Package.validate(path, { requirePackageJSON: true }).done(function (info) {\r\n                        if (info.errors.length) {\r\n                            result.reject(Package.formatError(info.errors));\r\n                            return;\r\n                        }\r\n\r\n                        var extensionName = info.metadata.name,\r\n                            extensionInfo = ExtensionManager.extensions[extensionName],\r\n                            isUpdate = extensionInfo && !!extensionInfo.installInfo;\r\n\r\n                        if (isUpdate) {\r\n                            updateZips.push(file);\r\n                        } else {\r\n                            installZips.push(file);\r\n                        }\r\n\r\n                        result.resolve();\r\n                    }).fail(function (err) {\r\n                        result.reject(Package.formatError(err));\r\n                    });\r\n                });\r\n                \r\n                return result.promise();\r\n            });\r\n\r\n            validatePromise.done(function () {\r\n                var installPromise = Async.doSequentially(installZips, function (file) {\r\n                    return InstallExtensionDialog.installUsingDialog(file);\r\n                });\r\n\r\n                var updatePromise = installPromise.then(function () {\r\n                    return Async.doSequentially(updateZips, function (file) {\r\n                        return InstallExtensionDialog.updateUsingDialog(file).done(function (result) {\r\n                            ExtensionManager.updateFromDownload(result);\r\n                        });\r\n                    });\r\n                });\r\n                \r\n                // InstallExtensionDialog displays it\'s own errors, always\r\n                // resolve the outer promise\r\n                updatePromise.always(deferred.resolve);\r\n            }).fail(function (errorArray) {\r\n                deferred.reject(errorArray);\r\n            });\r\n        });\r\n        \r\n        return deferred.promise();\r\n    }\r\n    \r\n    /**\r\n     * @private\r\n     * Show a dialog that allows the user to browse and manage extensions.\r\n     */\r\n    function _showDialog() {\r\n        var dialog,\r\n            $dlg,\r\n            views   = [],\r\n            $search,\r\n            $searchClear,\r\n            context = { Strings: Strings, showRegistry: !!brackets.config.extension_registry },\r\n            models  = [];\r\n        \r\n        // Load registry only if the registry URL exists\r\n        if (context.showRegistry) {\r\n            models.push(new ExtensionManagerViewModel.RegistryViewModel());\r\n            models.push(new ExtensionManagerViewModel.ThemesViewModel());\r\n        }\r\n        \r\n        models.push(new ExtensionManagerViewModel.InstalledViewModel());\r\n        \r\n        function updateSearchDisabled() {\r\n            var model           = models[_activeTabIndex],\r\n                searchDisabled  = ($search.val() === "") &&\r\n                                  (!model.filterSet || model.filterSet.length === 0);\r\n            \r\n            $search.prop("disabled", searchDisabled);\r\n            $searchClear.prop("disabled", searchDisabled);\r\n            \r\n            return searchDisabled;\r\n        }\r\n        \r\n        // Open the dialog\r\n        dialog = Dialogs.showModalDialogUsingTemplate(Mustache.render(dialogTemplate, context));\r\n        \r\n        // When dialog closes, dismiss models and commit changes\r\n        dialog.done(function () {\r\n            models.forEach(function (model) {\r\n                model.dispose();\r\n            });\r\n            \r\n            _performChanges();\r\n        });\r\n        \r\n        // Create the view.\r\n        $dlg = dialog.getElement();\r\n        $search = $(".search", $dlg);\r\n        $searchClear = $(".search-clear", $dlg);\r\n\r\n        function setActiveTab($tab) {\r\n            models[_activeTabIndex].scrollPos = $(".modal-body", $dlg).scrollTop();\r\n            $tab.tab("show");\r\n            $(".modal-body", $dlg).scrollTop(models[_activeTabIndex].scrollPos || 0);\r\n            $searchClear.click();\r\n        }\r\n\r\n        // Dialog tabs\r\n        $dlg.find(".nav-tabs a")\r\n            .on("click", function (event) {\r\n                setActiveTab($(this));\r\n            });\r\n\r\n        // navigate through tabs via Ctrl-(Shift)-Tab\r\n        $dlg.on("keyup", function (event) {\r\n            if (event.keyCode === KeyEvent.DOM_VK_TAB && event.ctrlKey) {\r\n                var $tabs = $(".nav-tabs a", $dlg),\r\n                    tabIndex = _activeTabIndex;\r\n\r\n                if (event.shiftKey) {\r\n                    tabIndex--;\r\n                } else {\r\n                    tabIndex++;\r\n                }\r\n                tabIndex %= $tabs.length;\r\n                setActiveTab($tabs.eq(tabIndex));\r\n            }\r\n        });\r\n\r\n        // Update & hide/show the notification overlay on a tab\'s icon, based on its model\'s notifyCount\r\n        function updateNotificationIcon(index) {\r\n            var model = models[index],\r\n                $notificationIcon = $dlg.find(".nav-tabs li").eq(index).find(".notification");\r\n            if (model.notifyCount) {\r\n                $notificationIcon.text(model.notifyCount);\r\n                $notificationIcon.show();\r\n            } else {\r\n                $notificationIcon.hide();\r\n            }\r\n        }\r\n        \r\n        // Initialize models and create a view for each model\r\n        var modelInitPromise = Async.doInParallel(models, function (model, index) {\r\n            var view    = new ExtensionManagerView(),\r\n                promise = view.initialize(model),\r\n                lastNotifyCount;\r\n            \r\n            promise.always(function () {\r\n                views[index] = view;\r\n                \r\n                lastNotifyCount = model.notifyCount;\r\n                updateNotificationIcon(index);\r\n            });\r\n            \r\n            $(model).on("change", function () {\r\n                if (lastNotifyCount !== model.notifyCount) {\r\n                    lastNotifyCount = model.notifyCount;\r\n                    updateNotificationIcon(index);\r\n                }\r\n            });\r\n            \r\n            return promise;\r\n        }, true);\r\n        \r\n        modelInitPromise.always(function () {\r\n            $(".spinner", $dlg).remove();\r\n            \r\n            views.forEach(function (view) {\r\n                view.$el.appendTo($(".modal-body", $dlg));\r\n            });\r\n            \r\n            // Update search UI before new tab is shown\r\n            $("a[data-toggle=\'tab\']", $dlg).each(function (index, tabElement) {\r\n                $(tabElement).on("show", function (event) {\r\n                    _activeTabIndex = index;\r\n                    \r\n                    // Focus the search input\r\n                    if (!updateSearchDisabled()) {\r\n                        $dlg.find(".search").focus();\r\n                    }\r\n                });\r\n            });\r\n            \r\n            // Filter the views when the user types in the search field.\r\n            $dlg.on("input", ".search", function (e) {\r\n                var query = $(this).val();\r\n                views.forEach(function (view) {\r\n                    view.filter(query);\r\n                });\r\n            }).on("click", ".search-clear", function (e) {\r\n                $search.val("");\r\n                views.forEach(function (view, index) {\r\n                    view.filter("");\r\n                });\r\n                \r\n                if (!updateSearchDisabled()) {\r\n                    $search.focus();\r\n                }\r\n            });\r\n            \r\n            // Disable the search field when there are no items in the model\r\n            models.forEach(function (model, index) {\r\n                $(model).on("change", function () {\r\n                    if (_activeTabIndex === index) {\r\n                        updateSearchDisabled();\r\n                    }\r\n                });\r\n            });\r\n            \r\n            // Open dialog to Installed tab if extension updates are available\r\n            if ($("#toolbar-extension-manager").hasClass(\'updatesAvailable\')) {\r\n                $dlg.find(".nav-tabs a.installed").tab("show");\r\n            } else { // Otherwise show the first tab\r\n                $dlg.find(".nav-tabs a:first").tab("show");\r\n            }\r\n        });\r\n    \r\n        // Handle the install button.\r\n        $(".extension-manager-dialog .install-from-url")\r\n            .click(function () {\r\n                InstallExtensionDialog.showDialog().done(ExtensionManager.updateFromDownload);\r\n            });\r\n        \r\n        // Handle the drag/drop zone\r\n        var $dropzone = $("#install-drop-zone"),\r\n            $dropmask = $("#install-drop-zone-mask");\r\n        \r\n        $dropzone\r\n            .on("dragover", function (event) {\r\n                _stopEvent(event);\r\n\r\n                if (!event.originalEvent.dataTransfer.files) {\r\n                    return;\r\n                }\r\n\r\n                var items = event.originalEvent.dataTransfer.items,\r\n                    isValidDrop = false;\r\n\r\n                isValidDrop = _.every(items, function (item) {\r\n                    if (item.kind === "file") {\r\n                        var entry = item.webkitGetAsEntry(),\r\n                            extension = FileUtils.getFileExtension(entry.fullPath);\r\n\r\n                        return entry.isFile && extension === "zip";\r\n                    }\r\n\r\n                    return false;\r\n                });\r\n\r\n                if (isValidDrop) {\r\n                    // Set an absolute width to stabilize the button size\r\n                    $dropzone.width($dropzone.width());\r\n\r\n                    // Show drop styling and message\r\n                    $dropzone.removeClass("drag");\r\n                    $dropzone.addClass("drop");\r\n                } else {\r\n                    event.originalEvent.dataTransfer.dropEffect = "none";\r\n                }\r\n            })\r\n            .on("drop", _stopEvent);\r\n        \r\n        $dropmask\r\n            .on("dragover", function (event) {\r\n                _stopEvent(event);\r\n                event.originalEvent.dataTransfer.dropEffect = "copy";\r\n            })\r\n            .on("dragleave", function () {\r\n                $dropzone.removeClass("drop");\r\n                $dropzone.addClass("drag");\r\n            })\r\n            .on("drop", function (event) {\r\n                _stopEvent(event);\r\n                \r\n                if (event.originalEvent.dataTransfer.files) {\r\n                    // Attempt install\r\n                    _installUsingDragAndDrop().fail(function (errorArray) {\r\n                        var message = Strings.INSTALL_EXTENSION_DROP_ERROR;\r\n\r\n                        message += "<ul class=\'dialog-list\'>";\r\n                        errorArray.forEach(function (info) {\r\n                            message += "<li><span class=\'dialog-filename\'>";\r\n                            message += StringUtils.breakableUrl(info.item);\r\n                            message += "</span>: " + info.error + "</li>";\r\n                        });\r\n                        message += "</ul>";\r\n\r\n                        Dialogs.showModalDialog(\r\n                            DefaultDialogs.DIALOG_ID_ERROR,\r\n                            Strings.EXTENSION_MANAGER_TITLE,\r\n                            message\r\n                        );\r\n                    }).always(function () {\r\n                        $dropzone.removeClass("validating");\r\n                        $dropzone.addClass("drag");\r\n                    });\r\n                    \r\n                    // While installing, show validating message\r\n                    $dropzone.removeClass("drop");\r\n                    $dropzone.addClass("validating");\r\n                }\r\n            });\r\n        \r\n        return new $.Deferred().resolve(dialog).promise();\r\n    }\r\n    \r\n    CommandManager.register(Strings.CMD_EXTENSION_MANAGER, Commands.FILE_EXTENSION_MANAGER, _showDialog);\r\n\r\n    AppInit.appReady(function () {\r\n        $("#toolbar-extension-manager").click(_showDialog);\r\n    });\r\n    \r\n    // Unit tests\r\n    exports._performChanges = _performChanges;\r\n});\r\n\n//# sourceURL=/extensibility/ExtensionManagerDialog.js'),eval('define(\'text!htmlContent/image-view.html\',[],function () { return \'<div class="image-view">\\r\\n    <div class="image-centering">\\r\\n        <div class="image-header">\\r\\n            <div class="image-data"></div>\\r\\n            <div class="image-path"></div>\\t\\r\\n        </div>\\r\\n        <div class="image">\\r\\n            <div class="image-scale"></div>\\r\\n            <img class="image-preview" src="file:///{{fullPath}}?ver={{now}}">\\r\\n            <div class="image-tip">\\r\\n                <table class="tip-container">\\r\\n                    <tr>\\r\\n                        <td class="variable">x: </td>\\r\\n                        <td class="x-value"></td>\\r\\n                    </tr>\\r\\n                    <tr>\\r\\n                        <td class="variable">y: </td>\\r\\n                        <td class="y-value"></td>\\r\\n                    </tr>\\r\\n                </table>\\r\\n            </div>\\r\\n            <div class="horz-guide image-guide"></div>\\r\\n            <div class="vert-guide image-guide"></div>\\r\\n        </div>\\r\\n    </div>\\r\\n</div>\';});\n\n//# sourceURL=/text!htmlContent/image-view.html'),eval('/*\r\n * Copyright (c) 2013 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, window, Mustache */\r\n\r\ndefine(\'editor/ImageViewer\',[\'require\',\'exports\',\'module\',\'document/DocumentManager\',\'text!htmlContent/image-view.html\',\'project/ProjectManager\',\'language/LanguageManager\',\'view/MainViewFactory\',\'strings\',\'utils/StringUtils\',\'filesystem/FileSystem\',\'file/FileUtils\',\'thirdparty/lodash\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var DocumentManager     = require("document/DocumentManager"),\r\n        ImageViewTemplate   = require("text!htmlContent/image-view.html"),\r\n        ProjectManager      = require("project/ProjectManager"),\r\n        LanguageManager     = require("language/LanguageManager"),\r\n        MainViewFactory     = require("view/MainViewFactory"),\r\n        Strings             = require("strings"),\r\n        StringUtils         = require("utils/StringUtils"),\r\n        FileSystem          = require("filesystem/FileSystem"),\r\n        FileUtils           = require("file/FileUtils"),\r\n        _                   = require("thirdparty/lodash");\r\n    \r\n    \r\n    var _viewers = {};\r\n        \r\n    /**\r\n     * ImageView objects are constructed when an image is opened \r\n     * @see {@link Pane} for more information about where ImageViews are rendered\r\n     * \r\n     * @constructor\r\n     * @param {!File} file - The image file object to render\r\n     * @param {!jQuery} container - The container to render the image view in\r\n     */\r\n    function ImageView(file, $container) {\r\n        this.file = file;\r\n        this.$el = $(Mustache.render(ImageViewTemplate, {fullPath: file.fullPath,\r\n                                                         now: new Date().valueOf()}));\r\n        \r\n        $container.append(this.$el);\r\n\r\n        this._naturalWidth = 0;\r\n        this._naturalHeight = 0;\r\n        this._scale = 100;           // 100%\r\n        this._scaleDivInfo = null;   // coordinates of hidden scale sticker\r\n        \r\n        this.relPath = ProjectManager.makeProjectRelativeIfPossible(this.file.fullPath);\r\n\r\n        this.$imagePath = this.$el.find(".image-path");\r\n        this.$imagePreview = this.$el.find(".image-preview");\r\n        this.$imageData = this.$el.find(".image-data");\r\n\r\n        this.$image = this.$el.find(".image");\r\n        this.$imageTip = this.$el.find(".image-tip");\r\n        this.$imageGuides = this.$el.find(".image-guide");\r\n        this.$imageScale = this.$el.find(".image-scale");\r\n        this.$x_value = this.$el.find(".x-value");\r\n        this.$y_value = this.$el.find(".y-value");\r\n        this.$horzGuide = this.$el.find(".horz-guide");\r\n        this.$vertGuide = this.$el.find(".vert-guide");\r\n        \r\n        this.$imagePath.text(this.relPath).attr("title", this.relPath);\r\n        this.$imagePreview.on("load", _.bind(this._onImageLoaded, this));\r\n        \r\n        _viewers[file.fullPath] = this;\r\n    }\r\n\r\n    /**\r\n     * DocumentManger.fileNameChange handler - when an image is renamed, we must \r\n     * update the view\r\n     * \r\n     * @param {jQuery.Event} e - event\r\n     * @param {!string} oldPath - the name of the file that\'s changing changing \r\n     * @param {!string} newPath - the name of the file that\'s changing changing \r\n     * @private\r\n     */\r\n    ImageView.prototype._onFilenameChange = function (e, oldPath, newPath) {\r\n        /* \r\n         * File objects are already updated when the event is triggered\r\n         * so we just need to see if the file has the same path as our image\r\n         */\r\n        if (this.file.fullPath === newPath) {\r\n            this.relPath = ProjectManager.makeProjectRelativeIfPossible(newPath);\r\n            this.$imagePath.text(this.relPath).attr("title", this.relPath);\r\n        }\r\n    };\r\n\r\n    /**\r\n     * <img>.on("load") handler - updates content of the image view \r\n     *                            initializes computed values \r\n     *                            installs event handlers\r\n     * @param {Event} e - event\r\n     * @private\r\n     */\r\n    ImageView.prototype._onImageLoaded = function (e) {\r\n        // add dimensions and size\r\n        this._naturalWidth = e.currentTarget.naturalWidth;\r\n        this._naturalHeight = e.currentTarget.naturalHeight;\r\n        \r\n        var extension = FileUtils.getFileExtension(this.file.fullPath);\r\n        var dimensionString = this._naturalWidth + " &times; " + this._naturalHeight + " " + Strings.UNIT_PIXELS;\r\n        \r\n        if (extension === "ico") {\r\n            dimensionString += " (" + Strings.IMAGE_VIEWER_LARGEST_ICON + ")";\r\n        }\r\n        \r\n        // get image size\r\n        var self = this;\r\n        \r\n        this.file.stat(function (err, stat) {\r\n            if (err) {\r\n                self.$imageData.html(dimensionString);\r\n            } else {\r\n                var sizeString = "";\r\n                if (stat.size) {\r\n                    sizeString = " &mdash; " + StringUtils.prettyPrintBytes(stat.size, 2);\r\n                }\r\n                var dimensionAndSize = dimensionString + sizeString;\r\n                self.$imageData.html(dimensionAndSize)\r\n                        .attr("title", dimensionAndSize\r\n                                    .replace("&times;", "x")\r\n                                    .replace("&mdash;", "-"));\r\n            }\r\n        });\r\n        \r\n        // make sure we always show the right file name\r\n        $(DocumentManager).on("fileNameChange", _.bind(this._onFilenameChange, this));\r\n       \r\n        this.$imageTip.hide();\r\n        this.$imageGuides.hide();\r\n        \r\n        this.$image.on("mousemove.ImageView", ".image-preview", _.bind(this._showImageTip, this))\r\n                   .on("mouseleave.ImageView", ".image-preview", _.bind(this._hideImageTip, this));\r\n\r\n        this._updateScale();\r\n    };\r\n    \r\n    /**\r\n     * Update the scale element\r\n     * @private\r\n     */\r\n    ImageView.prototype._updateScale = function () {\r\n        var currentWidth = this.$imagePreview.width();\r\n        \r\n        if (currentWidth && currentWidth < this._naturalWidth) {\r\n            this._scale = currentWidth / this._naturalWidth * 100;\r\n            this.$imageScale.text(Math.floor(this._scale) + "%")\r\n                // Keep the position of the image scale div relative to the image.\r\n                .css("left", this.$imagePreview.position().left + 5)\r\n                .show();\r\n        } else {\r\n            // Reset everything related to the image scale sticker before hiding it.\r\n            this._scale = 100;\r\n            this._scaleDivInfo = null;\r\n            this.$imageScale.text("").hide();\r\n        }\r\n    };\r\n        \r\n        \r\n    /**\r\n     * Show image coordinates under the mouse cursor\r\n     * @param {Event} e - event\r\n     * @private\r\n     */\r\n    ImageView.prototype._showImageTip = function (e) {\r\n        // Don\'t show image tip if this._scale is close to zero.\r\n        // since we won\'t have enough room to show tip anyway.\r\n        if (Math.floor(this._scale) === 0) {\r\n            return;\r\n        }\r\n        \r\n        var x                   = Math.round(e.offsetX * 100 / this._scale),\r\n            y                   = Math.round(e.offsetY * 100 / this._scale),\r\n            $target             = $(e.target),\r\n            imagePos            = this.$imagePreview.position(),\r\n            left                = e.offsetX + imagePos.left,\r\n            top                 = e.offsetY + imagePos.top,\r\n            width               = this.$imagePreview.width(),\r\n            height              = this.$imagePreview.height(),\r\n            windowWidth         = $(window).width(),\r\n            fourDigitImageWidth = this._naturalWidth.toString().length === 4,\r\n            \r\n            // @todo -- seems a bit strange that we\'re computing sizes\r\n            //          using magic numbers\r\n            \r\n            infoWidth1          = 112,    // info div width 96px + vertical toolbar width 16px\r\n            infoWidth2          = 120,    // info div width 104px (for 4-digit image width) + vertical toolbar width 16px\r\n            tipOffsetX          = 10,     // adjustment for info div left from x coordinate of cursor\r\n            tipOffsetY          = -54,    // adjustment for info div top from y coordinate of cursor\r\n            tipMinusOffsetX1    = -82,    // for less than 4-digit image width\r\n            tipMinusOffsetX2    = -90;    // for 4-digit image width \r\n        \r\n        // Check whether we\'re getting mousemove events beyond the image boundaries due to a browser bug \r\n        // or the rounding calculation above for a scaled image. For example, if an image is 120 px wide,\r\n        // we should get mousemove events in the range of 0 <= x < 120, but not 120 or more. If we get \r\n        // a value beyond the range, then simply handle the event as if it were a mouseleave.\r\n        if (x < 0 || x >= this._naturalWidth || y < 0 || y >= this._naturalHeight) {\r\n            this._hideImageTip(e);\r\n            this.$imagePreview.css("cursor", "auto");\r\n            return;\r\n        }\r\n        \r\n        this.$imagePreview.css("cursor", "none");\r\n        \r\n        this._handleMouseEnterOrExitScaleSticker(left, top);\r\n        \r\n        // Check whether to show the image tip on the left.\r\n        if ((e.pageX + infoWidth1) > windowWidth ||\r\n                (fourDigitImageWidth && (e.pageX + infoWidth2) > windowWidth)) {\r\n            tipOffsetX = fourDigitImageWidth ? tipMinusOffsetX2 : tipMinusOffsetX1;\r\n        }\r\n        \r\n        this.$x_value.text(x + "px");\r\n        this.$y_value.text(y + "px");\r\n\r\n        this.$imageTip.css({\r\n            left: left + tipOffsetX,\r\n            top: top + tipOffsetY\r\n        }).show();\r\n        \r\n        this.$horzGuide.css({\r\n            left: imagePos.left,\r\n            top: top,\r\n            width: width - 1\r\n        }).show();\r\n        \r\n        this.$vertGuide.css({\r\n            left: left,\r\n            top: imagePos.top,\r\n            height: height - 1\r\n        }).show();\r\n    };\r\n    \r\n    /**\r\n     * Hide image coordinates info tip\r\n     * @param {Event} e - event \r\n     * @private\r\n     */\r\n    ImageView.prototype._hideImageTip = function (e) {\r\n        var $target   = $(e.target),\r\n            targetPos = $target.position(),\r\n            imagePos  = this.$imagePreview.position(),\r\n            right     = imagePos.left + this.$imagePreview.width(),\r\n            bottom    = imagePos.top + this.$imagePreview.height(),\r\n            x         = targetPos.left + e.offsetX,\r\n            y         = targetPos.top + e.offsetY;\r\n        \r\n        // Hide image tip and guides only if the cursor is outside of the image.\r\n        if (x < imagePos.left || x >= right ||\r\n                y < imagePos.top || y >= bottom) {\r\n            this._hideGuidesAndTip();\r\n            if (this._scaleDivInfo) {\r\n                this._scaleDivInfo = null;\r\n                this.$imageScale.show();\r\n            }\r\n        }\r\n    };\r\n    \r\n    /**\r\n     * Hides both guides and the tip\r\n     * @private\r\n     */\r\n    ImageView.prototype._hideGuidesAndTip = function () {\r\n        this.$imageTip.hide();\r\n        this.$imageGuides.hide();\r\n    };\r\n    \r\n    /**\r\n     * Check mouse entering/exiting the scale sticker. \r\n     * Hide it when entering and show it again when exiting.\r\n     *\r\n     * @param {number} offsetX mouse offset from the left of the previewing image\r\n     * @param {number} offsetY mouseoffset from the top of the previewing image\r\n     * @private\r\n     */\r\n    ImageView.prototype._handleMouseEnterOrExitScaleSticker = function (offsetX, offsetY) {\r\n        var imagePos       = this.$imagePreview.position(),\r\n            scaleDivPos    = this.$imageScale.position(),\r\n            imgWidth       = this.$imagePreview.width(),\r\n            imgHeight      = this.$imagePreview.height(),\r\n            scaleDivLeft,\r\n            scaleDivTop,\r\n            scaleDivRight,\r\n            scaleDivBottom;\r\n        \r\n        if (this._scaleDivInfo) {\r\n            scaleDivLeft   = this._scaleDivInfo.left;\r\n            scaleDivTop    = this._scaleDivInfo.top;\r\n            scaleDivRight  = this._scaleDivInfo.right;\r\n            scaleDivBottom = this._scaleDivInfo.bottom;\r\n            \r\n            if ((imgWidth + imagePos.left) < scaleDivRight) {\r\n                scaleDivRight = imgWidth + imagePos.left;\r\n            }\r\n            \r\n            if ((imgHeight + imagePos.top) < scaleDivBottom) {\r\n                scaleDivBottom = imgHeight + imagePos.top;\r\n            }\r\n            \r\n        } else {\r\n            scaleDivLeft   = scaleDivPos.left;\r\n            scaleDivTop    = scaleDivPos.top;\r\n            scaleDivRight  = this.$imageScale.width() + scaleDivLeft;\r\n            scaleDivBottom = this.$imageScale.height() + scaleDivTop;\r\n        }\r\n        \r\n        if (this._scaleDivInfo) {\r\n            // See whether the cursor is no longer inside the hidden scale div.\r\n            // If so, show it again.\r\n            if ((offsetX < scaleDivLeft || offsetX > scaleDivRight) ||\r\n                    (offsetY < scaleDivTop || offsetY > scaleDivBottom)) {\r\n                this._scaleDivInfo = null;\r\n                this.$imageScale.show();\r\n            }\r\n        } else if ((offsetX >= scaleDivLeft && offsetX <= scaleDivRight) &&\r\n                (offsetY >= scaleDivTop && offsetY <= scaleDivBottom)) {\r\n            // Handle mouse inside image scale div.\r\n            // But hide it only if the pixel under mouse is also in the image.\r\n            if (offsetX < (imagePos.left + imgWidth) &&\r\n                    offsetY < (imagePos.top + imgHeight)) {\r\n                // Remember image scale div coordinates before hiding it.\r\n                this._scaleDivInfo = {left: scaleDivPos.left,\r\n                                 top: scaleDivPos.top,\r\n                                 right: scaleDivRight,\r\n                                 bottom: scaleDivBottom};\r\n                this.$imageScale.hide();\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * View Interface functions\r\n     */\r\n\r\n    /* \r\n     * Retrieves the file object for this view\r\n     * return {!File} the file object for this view\r\n     */\r\n    ImageView.prototype.getFile = function () {\r\n        return this.file;\r\n    };\r\n    \r\n    /* \r\n     * Updates the layout of the view\r\n     */\r\n    ImageView.prototype.updateLayout = function () {\r\n        this._hideGuidesAndTip();\r\n        \r\n        var $container = this.$el.parent();\r\n        \r\n        var pos = $container.position(),\r\n            iWidth = $container.innerWidth(),\r\n            iHeight = $container.innerHeight(),\r\n            oWidth = $container.outerWidth(),\r\n            oHeight = $container.outerHeight();\r\n            \r\n        // $view is "position:absolute" so \r\n        //  we have to update the height, width and position\r\n        this.$el.css({top: pos.top + ((oHeight - iHeight) / 2),\r\n                        left: pos.left + ((oWidth - iWidth) / 2),\r\n                        width: iWidth,\r\n                        height: iHeight});\r\n        this._updateScale();\r\n    };\r\n\r\n    /* \r\n     * Destroys the view\r\n     */\r\n    ImageView.prototype.destroy = function () {\r\n        delete _viewers[this.file.fullPath];\r\n        $(DocumentManager).off("fileNameChange", _.bind(this._onFilenameChange, this));\r\n        this.$image.off(".ImageView");\r\n        this.$el.remove();\r\n    };\r\n    \r\n    /* \r\n     * Refreshes the image preview with what\'s on disk\r\n     */\r\n    ImageView.prototype.refresh = function () {\r\n        var noCacheUrl = this.$imagePreview.attr("src"),\r\n            now = new Date().valueOf(),\r\n            index = noCacheUrl.indexOf("?");\r\n\r\n        // strip the old param off \r\n        if (index > 0) {\r\n            noCacheUrl = noCacheUrl.slice(0, index);\r\n        }\r\n        \r\n        // add a new param which will force chrome to \r\n        //  re-read the image from disk \r\n        noCacheUrl = noCacheUrl + "?ver=" + now;\r\n        \r\n\r\n        // Update the DOM node with the src URL \r\n        this.$imagePreview.attr("src", noCacheUrl);\r\n    };\r\n    \r\n    /* \r\n     * Creates an image view object and adds it to the specified pane\r\n     * @param {!File} file - the file to create an image of\r\n     * @param {!Pane} pane - the pane in which to host the view\r\n     * @return {jQuery.Promise} \r\n     */\r\n    function _createImageView(file, pane) {\r\n        var view = pane.getViewForPath(file.fullPath);\r\n        \r\n        if (view) {\r\n            pane.showView(view);\r\n        } else {\r\n            view = new ImageView(file, pane.$content);\r\n            pane.addView(view, true);\r\n        }\r\n        return new $.Deferred().resolve().promise();\r\n    }\r\n    \r\n    /**\r\n     * Handles file system change events so we can refresh \r\n     *  image viewers for the files that changed on disk due to external editors\r\n     * @param {jQuery.event} event - event object\r\n     * @param {?File} file - file object that changed\r\n     * @param {Array.<FileSystemEntry>=} added If entry is a Directory, contains zero or more added children\r\n     * @param {Array.<FileSystemEntry>=} removed If entry is a Directory, contains zero or more removed children\r\n     */\r\n    function _handleFileSystemChange(event, entry, added, removed) {\r\n        // this may have been called because files were added \r\n        //  or removed to the file system.  We don\'t care about those\r\n        if (!entry || entry.isDirectory) {\r\n            return;\r\n        }\r\n        \r\n        // Look for a viewer for the changed file\r\n        var viewer = _viewers[entry.fullPath];\r\n\r\n        // viewer found, call its refresh method\r\n        if (viewer) {\r\n            viewer.refresh();\r\n        }\r\n    }\r\n    \r\n    /*\r\n     * Install an event listener to receive all file system change events\r\n     * so we can refresh the view when changes are made to the image in an external editor\r\n     */\r\n    FileSystem.on("change", _handleFileSystemChange);\r\n\r\n    /* \r\n     * Initialization, register our view factory\r\n     */\r\n    MainViewFactory.registerViewFactory({\r\n        canOpenFile: function (fullPath) {\r\n            var lang = LanguageManager.getLanguageForPath(fullPath);\r\n            return (lang.getId() === "image");\r\n        },\r\n        openFile: function (file, pane) {\r\n            return _createImageView(file, pane);\r\n        }\r\n    });\r\n    \r\n    /* \r\n     * This is for extensions that want to create a \r\n     * view factory based on ImageViewer\r\n     */\r\n    exports.ImageView = ImageView;\r\n});\r\n\n//# sourceURL=/editor/ImageViewer.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, $, brackets */\r\n\r\n/**\r\n * This is a compatibility shim for legacy Brackets APIs that will be removed soon.\r\n * Use ProjectManager.getAllFiles() instead.\r\n * @deprecated\r\n */\r\ndefine(\'project/FileIndexManager\',[\'require\',\'exports\',\'module\',\'project/ProjectManager\',\'file/FileUtils\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var ProjectManager      = require("project/ProjectManager"),\r\n        FileUtils           = require("file/FileUtils");\r\n    \r\n    function _warn() {\r\n        console.error("Warning: FileIndexManager is deprecated. Use ProjectManager.getAllFiles() instead");\r\n    }\r\n\r\n\r\n    function _getFilter(indexName) {\r\n        if (indexName === "css") {\r\n            return ProjectManager.getLanguageFilter("css");\r\n        } else if (indexName === "all") {\r\n            return null;\r\n        } else {\r\n            throw new Error("Invalid index name:", indexName);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @deprecated\r\n     * @param {!string} indexname\r\n     * @return {$.Promise} a promise that is resolved with an Array of File objects\r\n     */\r\n    function getFileInfoList(indexName) {\r\n        _warn();\r\n        return ProjectManager.getAllFiles(_getFilter(indexName));\r\n    }\r\n    \r\n    /**\r\n     * @deprecated\r\n     * @param {!string} indexName\r\n     * @param {!string} filename\r\n     * @return {$.Promise} a promise that is resolved with an Array of File objects\r\n     */\r\n    function getFilenameMatches(indexName, filename) {\r\n        _warn();\r\n        \r\n        var indexFilter = _getFilter(indexName);\r\n        \r\n        return ProjectManager.getAllFiles(function (file) {\r\n            if (indexFilter && !indexFilter(file)) {\r\n                return false;\r\n            }\r\n            return file.name === filename;\r\n        });\r\n    }\r\n    \r\n    exports.getFileInfoList = getFileInfoList;\r\n    exports.getFilenameMatches = getFilenameMatches;\r\n});\r\n\n//# sourceURL=/project/FileIndexManager.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50*/\r\n/*global define */\r\n\r\n/**\r\n * @deprecated\r\n * This is a compatibility shim for legacy Brackets APIs that will be removed soon. These\r\n * error codes are *never* returned anymore. Use error codes in FileSystemError instead.\r\n */\r\ndefine(\'file/NativeFileError\',[],function () {\r\n    "use strict";\r\n   \r\n    /**\r\n     * @deprecated\r\n     */\r\n    var NativeFileError = {};\r\n    \r\n    NativeFileError.NOT_FOUND_ERR = "NotFoundError";\r\n    NativeFileError.SECURITY_ERR = "SecurityError";\r\n    NativeFileError.ABORT_ERR = "AbortError";\r\n    NativeFileError.NOT_READABLE_ERR = "NotReadableError";\r\n    NativeFileError.NO_MODIFICATION_ALLOWED_ERR = "NoModificationAllowedError";\r\n    NativeFileError.INVALID_STATE_ERR = "InvalidStateError";\r\n    NativeFileError.SYNTAX_ERR = "SyntaxError";\r\n    NativeFileError.INVALID_MODIFICATION_ERR = "InvalidModificationError";\r\n    NativeFileError.QUOTA_EXCEEDED_ERR = "QuotaExceededError";\r\n    NativeFileError.TYPE_MISMATCH_ERR = "TypeMismatchError";\r\n    NativeFileError.PATH_EXISTS_ERR = "PathExistsError";\r\n    \r\n    return NativeFileError;\r\n});\n//# sourceURL=/file/NativeFileError.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50*/\r\n/*global $, define, brackets, InvalidateStateError, window */\r\n\r\n/**\r\n * @deprecated\r\n * This is a compatibility shim for legacy Brackets APIs that will be removed soon.\r\n * Use APIs in the FileSystem module instead.\r\n */\r\ndefine(\'file/NativeFileSystem\',[\'require\',\'exports\',\'module\',\'filesystem/FileSystem\',\'filesystem/File\',\'filesystem/Directory\',\'file/NativeFileError\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    var FileSystem      = require("filesystem/FileSystem"),\r\n        File            = require("filesystem/File"),\r\n        Directory       = require("filesystem/Directory"),\r\n        NativeFileError = require("file/NativeFileError");\r\n    \r\n    \r\n    function _warn(oldAPI, newAPI) {\r\n        console.error("Warning: \'" + oldAPI + "\' is deprecated. Use \'" + newAPI + "\' instead");\r\n    }\r\n    \r\n    \r\n    // Shims for static APIs on NativeFileSystem itself\r\n    \r\n    var NativeFileSystem = {\r\n        /**\r\n         * @deprecated\r\n         * @param {boolean} allowMultipleSelection\r\n         * @param {boolean} chooseDirectories\r\n         * @param {string} title\r\n         * @param {string} initialPath\r\n         * @param {Array.<string>} fileTypes\r\n         * @param {!function(Array.<string>)} successCallback\r\n         * @param {!function(string)} errorCallback\r\n         */\r\n        showOpenDialog: function (allowMultipleSelection,\r\n                                  chooseDirectories,\r\n                                  title,\r\n                                  initialPath,\r\n                                  fileTypes,\r\n                                  successCallback,\r\n                                  errorCallback) {\r\n            _warn("NativeFileSystem.showOpenDialog()", "FileSystem.showOpenDialog()");\r\n            \r\n            FileSystem.showOpenDialog(\r\n                allowMultipleSelection,\r\n                chooseDirectories,\r\n                title,\r\n                initialPath,\r\n                fileTypes,\r\n                function (err, data) {\r\n                    if (!err) {\r\n                        successCallback(data);\r\n                    } else if (errorCallback) {\r\n                        errorCallback(err);\r\n                    }\r\n                }\r\n            );\r\n        },\r\n\r\n        /**\r\n         * @deprecated\r\n         * @param {string} title\r\n         * @param {string} initialPath\r\n         * @param {string} proposedNewFilename\r\n         * @param {!function(string)} successCallback\r\n         * @param {!function(string)} errorCallback\r\n         */\r\n        showSaveDialog: function (title,\r\n                                    initialPath,\r\n                                    proposedNewFilename,\r\n                                    successCallback,\r\n                                    errorCallback) {\r\n            _warn("NativeFileSystem.showSaveDialog()", "FileSystem.showSaveDialog()");\r\n            \r\n            FileSystem.showSaveDialog(\r\n                title,\r\n                initialPath,\r\n                proposedNewFilename,\r\n                function (err, data) {\r\n                    if (!err) {\r\n                        successCallback(data);\r\n                    } else if (errorCallback) {\r\n                        errorCallback(err);\r\n                    }\r\n                }\r\n            );\r\n        },\r\n\r\n        /**\r\n         * @deprecated\r\n         * @param {string} path\r\n         * @param {!function(!{ root: !Directory })} successCallback\r\n         * @param {!function(string)} errorCallback\r\n         */\r\n        requestNativeFileSystem: function (path, successCallback, errorCallback) {\r\n            _warn("NativeFileSystem.requestNativeFileSystem()", "FileSystem.resolve()");\r\n            \r\n            FileSystem.resolve(path, function (err, entry) {\r\n                if (err) {\r\n                    errorCallback(err);\r\n                } else {\r\n                    var fakeNativeFileSystem = { root: entry };\r\n                    successCallback(fakeNativeFileSystem);\r\n                }\r\n            });\r\n        },\r\n        \r\n        /**\r\n         * @deprecated\r\n         * @param {string} path\r\n         * @param {!function(!FileSystemEntry)} successCallback\r\n         * @param {!function(string)} errorCallback\r\n         */\r\n        resolveNativeFileSystemPath: function (path, successCallback, errorCallback) {\r\n            _warn("NativeFileSystem.resolveNativeFileSystemPath()", "FileSystem.resolve()");\r\n            \r\n            FileSystem.resolve(path, function (err, entry) {\r\n                if (err) {\r\n                    errorCallback(err);\r\n                } else {\r\n                    successCallback(entry);\r\n                }\r\n            });\r\n        }\r\n        \r\n    };\r\n    \r\n    \r\n    // Shims for constructors - return new File/Directory object instead\r\n    \r\n    /**\r\n     * @deprecated\r\n     * @param {string} fullPath\r\n     * @return {!File}\r\n     */\r\n    NativeFileSystem.FileEntry = function (fullPath) {\r\n        _warn("new NativeFileSystem.FileEntry()", "FileSystem.getFileForPath()");\r\n        return FileSystem.getFileForPath(fullPath);\r\n    };\r\n    \r\n    /**\r\n     * @deprecated\r\n     * @param {string} fullPath\r\n     * @return {!Directory}\r\n     */\r\n    NativeFileSystem.DirectoryEntry = function (fullPath) {\r\n        _warn("new NativeFileSystem.DirectoryEntry()", "FileSystem.getDirectoryForPath()");\r\n        return FileSystem.getDirectoryForPath(fullPath);\r\n    };\r\n    \r\n    \r\n    // Shims for members of File/Directory - monkey-patch the prototype to make them available\r\n    // without polluting the new filesystem code\r\n    \r\n    /**\r\n     * @deprecated\r\n     * @param {!function()} callback\r\n     */\r\n    File.prototype.createWriter = function (callback) {\r\n        _warn("File.createWriter()", "File.write()");\r\n        \r\n        var file = this;\r\n        \r\n        // Return fake FileWriter object\r\n        // (Unlike the original impl, we don\'t read the file\'s old contents first)\r\n        callback({\r\n            write: function (data) {\r\n                var fileWriter = this;\r\n                \r\n                if (fileWriter.onwritestart) {\r\n                    fileWriter.onwritestart();\r\n                }\r\n                \r\n                file.write(data, function (err) {\r\n                    if (err) {\r\n                        if (fileWriter.onerror) {\r\n                            fileWriter.onerror(err);\r\n                        }\r\n                    } else {\r\n                        if (fileWriter.onwrite) {\r\n                            fileWriter.onwrite();\r\n                        }\r\n                        if (fileWriter.onwriteend) {\r\n                            fileWriter.onwriteend();\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    };\r\n    \r\n    /**\r\n     * @deprecated\r\n     * @return {!{readEntries: !function()}}\r\n     */\r\n    Directory.prototype.createReader = function () {\r\n        _warn("Directory.createReader()", "Directory.getContents()");\r\n        \r\n        var dir = this;\r\n        \r\n        // Return fake DirectoryReader object\r\n        return {\r\n            readEntries: function (successCallback, errorCallback) {\r\n                dir.getContents(function (err, entries) {\r\n                    if (err) {\r\n                        errorCallback(err);\r\n                    } else {\r\n                        successCallback(entries);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n    };\r\n    \r\n    /**\r\n     * @deprecated\r\n     * @param {string} path\r\n     * @param {?Object} options\r\n     * @param {!function(!FileSystemEntry)} successCallback\r\n     * @param {!function(string)} errorCallback\r\n     */\r\n    Directory.prototype.getFile = function (path, options, successCallback, errorCallback) {\r\n        if (options && options.create) {\r\n            throw new Error("Directory.getFile() is deprecated and no longer supports \'create: true\'. Use File.write(\\"\\") instead.");\r\n        } else {\r\n            _warn("Directory.getFile()", "FileSystem.resolve()");\r\n        }\r\n        \r\n        // Is it a relative path?\r\n        if (path[0] !== "/" && path[1] !== ":") {\r\n            path = this.fullPath + path;\r\n        }\r\n        \r\n        FileSystem.resolve(path, function (err, entry) {\r\n            if (err) {\r\n                errorCallback(err);\r\n            } else {\r\n                if (entry.isDirectory) {\r\n                    errorCallback(NativeFileError.TYPE_MISMATCH_ERR);\r\n                } else {\r\n                    successCallback(entry);\r\n                }\r\n            }\r\n        });\r\n    };\r\n    \r\n    \r\n    // Fail-fast stubs for key methods that are not shimmed -- callers will break but with clear guidance in the exception message\r\n    \r\n    /**\r\n     * @deprecated\r\n     */\r\n    Directory.prototype.getDirectory = function () {\r\n        throw new Error("Directory.getDirectory() has been removed. Use FileSystem.getDirectoryForPath() and/or Directory.create() instead.");\r\n    };\r\n    \r\n    \r\n    // Define public API\r\n    exports.NativeFileSystem    = NativeFileSystem;\r\n});\r\n\n//# sourceURL=/file/NativeFileSystem.js'),eval('/*\r\n * Copyright (c) 2014 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global define, window, $, brackets */\r\n\r\n/**\r\n * @deprecated This module provided for backwards compatibility.  Use WorkspaceManager instead.  \r\n */\r\ndefine(\'view/PanelManager\',[\'require\',\'exports\',\'module\',\'view/WorkspaceManager\',\'utils/DeprecationWarning\'],function (require, exports, module) {\r\n    "use strict";\r\n    \r\n    var WorkspaceManager        = require("view/WorkspaceManager"),\r\n        DeprecationWarning      = require("utils/DeprecationWarning");\r\n    \r\n    /**\r\n     * Creates a deprecation warning event handler\r\n     * @param {!string} the event being deprecated\r\n     * @param {!string} the new event to use\r\n     */\r\n    function _deprecateEvent(oldEventName, newEventName) {\r\n        DeprecationWarning.deprecateEvent(exports,\r\n                                          WorkspaceManager,\r\n                                          oldEventName,\r\n                                          newEventName,\r\n                                          "PanelManager." + oldEventName,\r\n                                          "MainViewManager." + newEventName);\r\n    }\r\n    \r\n    // Define public API\r\n    exports.createBottomPanel   = function (id, $panel, minSize) {\r\n        DeprecationWarning.deprecationWarning("Use WorkspaceManager.createBottomPanel() instead of PanelManager.createBottomPanel().", true);\r\n        return WorkspaceManager.createBottomPanel(id, $panel, minSize);\r\n    };\r\n    \r\n    // Deprecated PanelManager events\r\n    _deprecateEvent("editorAreaResize", "workspaceUpdateLayout");\r\n});\r\n\n//# sourceURL=/view/PanelManager.js'),eval('/*\r\n * Copyright (c) 2012 Adobe Systems Incorporated. All rights reserved.\r\n *  \r\n * Permission is hereby granted, free of charge, to any person obtaining a\r\n * copy of this software and associated documentation files (the "Software"), \r\n * to deal in the Software without restriction, including without limitation \r\n * the rights to use, copy, modify, merge, publish, distribute, sublicense, \r\n * and/or sell copies of the Software, and to permit persons to whom the \r\n * Software is furnished to do so, subject to the following conditions:\r\n *  \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *  \r\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, \r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER \r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \r\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER \r\n * DEALINGS IN THE SOFTWARE.\r\n * \r\n */\r\n\r\n\r\n/*jslint vars: true, plusplus: true, devel: true, nomen: true, indent: 4, maxerr: 50 */\r\n/*global require, define, brackets: true, $, window, navigator, Mustache */\r\n\r\n// TODO: (issue #264) break out the definition of brackets into a separate module from the application controller logic\r\n\r\n/**\r\n * brackets is the root of the Brackets codebase. This file pulls in all other modules as\r\n * dependencies (or dependencies thereof), initializes the UI, and binds global menus & keyboard\r\n * shortcuts to their Commands.\r\n *\r\n * Unlike other modules, this one can be accessed without an explicit require() because it exposes\r\n * a global object, window.brackets.\r\n */\r\ndefine(\'brackets\',[\'require\',\'exports\',\'module\',\'widgets/bootstrap-dropdown\',\'widgets/bootstrap-modal\',\'widgets/bootstrap-twipsy-mod\',\'thirdparty/path-utils/path-utils.min\',\'thirdparty/smart-auto-complete-local/jquery.smart_autocomplete\',\'thirdparty/CodeMirror2/addon/fold/xml-fold\',\'thirdparty/CodeMirror2/addon/edit/matchtags\',\'thirdparty/CodeMirror2/addon/edit/matchbrackets\',\'thirdparty/CodeMirror2/addon/edit/closebrackets\',\'thirdparty/CodeMirror2/addon/edit/closetag\',\'thirdparty/CodeMirror2/addon/scroll/scrollpastend\',\'thirdparty/CodeMirror2/addon/selection/active-line\',\'thirdparty/CodeMirror2/addon/selection/mark-selection\',\'thirdparty/CodeMirror2/addon/mode/multiplex\',\'thirdparty/CodeMirror2/addon/mode/overlay\',\'thirdparty/CodeMirror2/addon/search/match-highlighter\',\'thirdparty/CodeMirror2/addon/search/searchcursor\',\'thirdparty/CodeMirror2/keymap/sublime\',\'utils/Global\',\'utils/AppInit\',\'language/LanguageManager\',\'project/ProjectManager\',\'document/DocumentManager\',\'editor/EditorManager\',\'editor/CSSInlineEditor\',\'language/JSUtils\',\'project/WorkingSetView\',\'project/WorkingSetSort\',\'document/DocumentCommandHandlers\',\'project/FileViewController\',\'project/FileSyncManager\',\'command/KeyBindingManager\',\'command/Commands\',\'command/CommandManager\',\'editor/CodeHintManager\',\'utils/PerfUtils\',\'filesystem/FileSystem\',\'search/QuickOpen\',\'command/Menus\',\'file/FileUtils\',\'text!htmlContent/main-view.html\',\'strings\',\'widgets/Dialogs\',\'widgets/DefaultDialogs\',\'utils/ExtensionLoader\',\'project/SidebarView\',\'utils/Async\',\'utils/UpdateNotification\',\'utils/UrlParams\',\'preferences/PreferencesManager\',\'utils/Resizer\',\'LiveDevelopment/main\',\'utils/NodeConnection\',\'utils/NodeDomain\',\'utils/ExtensionUtils\',\'utils/DragAndDrop\',\'utils/ColorUtils\',\'language/CodeInspection\',\'utils/NativeApp\',\'utils/DeprecationWarning\',\'view/ViewCommandHandlers\',\'view/ThemeManager\',\'view/MainViewManager\',\'thirdparty/lodash\',\'thirdparty/CodeMirror2/lib/codemirror\',\'command/DefaultMenus\',\'document/ChangedDocumentTracker\',\'editor/EditorStatusBar\',\'editor/EditorCommandHandlers\',\'editor/EditorOptionHandlers\',\'help/HelpCommandHandlers\',\'search/FindInFilesUI\',\'search/FindReplace\',\'extensibility/InstallExtensionDialog\',\'extensibility/ExtensionManagerDialog\',\'editor/ImageViewer\',\'utils/CollectionUtils\',\'project/FileIndexManager\',\'file/NativeFileSystem\',\'file/NativeFileError\',\'view/PanelManager\',\'language/CSSUtils\',\'document/Document\',\'LiveDevelopment/Agents/DOMAgent\',\'filesystem/File\',\'search/FileFilters\',\'file/FileUtils\',\'search/FindInFiles\',\'search/FindInFilesUI\',\'language/HTMLInstrumentation\',\'LiveDevelopment/Inspector/Inspector\',\'extensibility/InstallExtensionDialog\',\'LiveDevelopment/LiveDevelopment\',\'LiveDevelopment/LiveDevServerManager\',\'view/MainViewFactory\',\'editor/MultiRangeInlineEditor\',\'LiveDevelopment/Agents/RemoteAgent\',\'search/ScrollTrackMarkers\',\'utils/UpdateNotification\'],function (require, exports, module) {\r\n    "use strict";\r\n\r\n    // Load dependent non-module scripts\r\n    require("widgets/bootstrap-dropdown");\r\n    require("widgets/bootstrap-modal");\r\n    require("widgets/bootstrap-twipsy-mod");\r\n    require("thirdparty/path-utils/path-utils.min");\r\n    require("thirdparty/smart-auto-complete-local/jquery.smart_autocomplete");\r\n\r\n    // Load CodeMirror add-ons--these attach themselves to the CodeMirror module    \r\n    require("thirdparty/CodeMirror2/addon/fold/xml-fold");\r\n    require("thirdparty/CodeMirror2/addon/edit/matchtags");\r\n    require("thirdparty/CodeMirror2/addon/edit/matchbrackets");\r\n    require("thirdparty/CodeMirror2/addon/edit/closebrackets");\r\n    require("thirdparty/CodeMirror2/addon/edit/closetag");\r\n    require("thirdparty/CodeMirror2/addon/scroll/scrollpastend");\r\n    require("thirdparty/CodeMirror2/addon/selection/active-line");\r\n    require("thirdparty/CodeMirror2/addon/selection/mark-selection");\r\n    require("thirdparty/CodeMirror2/addon/mode/multiplex");\r\n    require("thirdparty/CodeMirror2/addon/mode/overlay");\r\n    require("thirdparty/CodeMirror2/addon/search/match-highlighter");\r\n    require("thirdparty/CodeMirror2/addon/search/searchcursor");\r\n    require("thirdparty/CodeMirror2/keymap/sublime");\r\n\r\n    // Load dependent modules\r\n    var Global                  = require("utils/Global"),\r\n        AppInit                 = require("utils/AppInit"),\r\n        LanguageManager         = require("language/LanguageManager"),\r\n        ProjectManager          = require("project/ProjectManager"),\r\n        DocumentManager         = require("document/DocumentManager"),\r\n        EditorManager           = require("editor/EditorManager"),\r\n        CSSInlineEditor         = require("editor/CSSInlineEditor"),\r\n        JSUtils                 = require("language/JSUtils"),\r\n        WorkingSetView        = require("project/WorkingSetView"),\r\n        WorkingSetSort        = require("project/WorkingSetSort"),\r\n        DocumentCommandHandlers = require("document/DocumentCommandHandlers"),\r\n        FileViewController      = require("project/FileViewController"),\r\n        FileSyncManager         = require("project/FileSyncManager"),\r\n        KeyBindingManager       = require("command/KeyBindingManager"),\r\n        Commands                = require("command/Commands"),\r\n        CommandManager          = require("command/CommandManager"),\r\n        CodeHintManager         = require("editor/CodeHintManager"),\r\n        PerfUtils               = require("utils/PerfUtils"),\r\n        FileSystem              = require("filesystem/FileSystem"),\r\n        QuickOpen               = require("search/QuickOpen"),\r\n        Menus                   = require("command/Menus"),\r\n        FileUtils               = require("file/FileUtils"),\r\n        MainViewHTML            = require("text!htmlContent/main-view.html"),\r\n        Strings                 = require("strings"),\r\n        Dialogs                 = require("widgets/Dialogs"),\r\n        DefaultDialogs          = require("widgets/DefaultDialogs"),\r\n        ExtensionLoader         = require("utils/ExtensionLoader"),\r\n        SidebarView             = require("project/SidebarView"),\r\n        Async                   = require("utils/Async"),\r\n        UpdateNotification      = require("utils/UpdateNotification"),\r\n        UrlParams               = require("utils/UrlParams").UrlParams,\r\n        PreferencesManager      = require("preferences/PreferencesManager"),\r\n        Resizer                 = require("utils/Resizer"),\r\n        LiveDevelopmentMain     = require("LiveDevelopment/main"),\r\n        NodeConnection          = require("utils/NodeConnection"),\r\n        NodeDomain              = require("utils/NodeDomain"),\r\n        ExtensionUtils          = require("utils/ExtensionUtils"),\r\n        DragAndDrop             = require("utils/DragAndDrop"),\r\n        ColorUtils              = require("utils/ColorUtils"),\r\n        CodeInspection          = require("language/CodeInspection"),\r\n        NativeApp               = require("utils/NativeApp"),\r\n        DeprecationWarning      = require("utils/DeprecationWarning"),\r\n        ViewCommandHandlers     = require("view/ViewCommandHandlers"),\r\n        ThemeManager            = require("view/ThemeManager"),\r\n        MainViewManager         = require("view/MainViewManager"),\r\n        _                       = require("thirdparty/lodash");\r\n    \r\n    // DEPRECATED: In future we want to remove the global CodeMirror, but for now we\r\n    // expose our required CodeMirror globally so as to avoid breaking extensions in the\r\n    // interim.\r\n    var CodeMirror = require("thirdparty/CodeMirror2/lib/codemirror");\r\n\r\n    Object.defineProperty(window, "CodeMirror", {\r\n        get: function () {\r\n            DeprecationWarning.deprecationWarning(\'Use brackets.getModule("thirdparty/CodeMirror2/lib/codemirror") instead of global CodeMirror.\', true);\r\n            return CodeMirror;\r\n        }\r\n    });\r\n  \r\n    // Load modules that self-register and just need to get included in the main project\r\n    require("command/DefaultMenus");\r\n    require("document/ChangedDocumentTracker");\r\n    require("editor/EditorStatusBar");\r\n    require("editor/EditorCommandHandlers");\r\n    require("editor/EditorOptionHandlers");\r\n    require("help/HelpCommandHandlers");\r\n    require("search/FindInFilesUI");\r\n    require("search/FindReplace");\r\n    require("extensibility/InstallExtensionDialog");\r\n    require("extensibility/ExtensionManagerDialog");\r\n    require("editor/ImageViewer");\r\n    \r\n    // Deprecated modules loaded just so extensions can still use them for now\r\n    require("utils/CollectionUtils");\r\n    // Compatibility shims for filesystem API migration\r\n    require("project/FileIndexManager");\r\n    require("file/NativeFileSystem");\r\n    require("file/NativeFileError");\r\n    \r\n    // Compatibility shim for PanelManager to WorkspaceManager migration\r\n    require("view/PanelManager");\r\n    \r\n    PerfUtils.addMeasurement("brackets module dependencies resolved");\r\n    \r\n    // Local variables\r\n    var params = new UrlParams();\r\n    \r\n    // read URL params\r\n    params.parse();\r\n    \r\n    /**\r\n     * Setup test object\r\n     */\r\n    function _initTest() {\r\n        // TODO: (issue #265) Make sure the "test" object is not included in final builds\r\n        // All modules that need to be tested from the context of the application\r\n        // must to be added to this object. The unit tests cannot just pull\r\n        // in the modules since they would run in context of the unit test window,\r\n        // and would not have access to the app html/css.\r\n        brackets.test = {\r\n            CodeHintManager         : CodeHintManager,\r\n            CodeInspection          : CodeInspection,\r\n            CommandManager          : CommandManager,\r\n            Commands                : Commands,\r\n            CSSUtils                : require("language/CSSUtils"),\r\n            DefaultDialogs          : DefaultDialogs,\r\n            Dialogs                 : Dialogs,\r\n            DocumentCommandHandlers : DocumentCommandHandlers,\r\n            DocumentManager         : DocumentManager,\r\n            DocumentModule          : require("document/Document"),\r\n            DOMAgent                : require("LiveDevelopment/Agents/DOMAgent"),\r\n            DragAndDrop             : DragAndDrop,\r\n            EditorManager           : EditorManager,\r\n            ExtensionLoader         : ExtensionLoader,\r\n            ExtensionUtils          : ExtensionUtils,\r\n            File                    : require("filesystem/File"),\r\n            FileFilters             : require("search/FileFilters"),\r\n            FileSyncManager         : FileSyncManager,\r\n            FileSystem              : FileSystem,\r\n            FileViewController      : FileViewController,\r\n            FileUtils               : require("file/FileUtils"),\r\n            FindInFiles             : require("search/FindInFiles"),\r\n            FindInFilesUI           : require("search/FindInFilesUI"),\r\n            HTMLInstrumentation     : require("language/HTMLInstrumentation"),\r\n            Inspector               : require("LiveDevelopment/Inspector/Inspector"),\r\n            InstallExtensionDialog  : require("extensibility/InstallExtensionDialog"),\r\n            JSUtils                 : JSUtils,\r\n            KeyBindingManager       : KeyBindingManager,\r\n            LanguageManager         : LanguageManager,\r\n            LiveDevelopment         : require("LiveDevelopment/LiveDevelopment"),\r\n            LiveDevServerManager    : require("LiveDevelopment/LiveDevServerManager"),\r\n            MainViewManager         : MainViewManager,\r\n            MainViewFactory         : require("view/MainViewFactory"),\r\n            Menus                   : Menus,\r\n            MultiRangeInlineEditor  : require("editor/MultiRangeInlineEditor").MultiRangeInlineEditor,\r\n            NativeApp               : NativeApp,\r\n            PerfUtils               : PerfUtils,\r\n            PreferencesManager      : PreferencesManager,\r\n            ProjectManager          : ProjectManager,\r\n            RemoteAgent             : require("LiveDevelopment/Agents/RemoteAgent"),\r\n            ScrollTrackMarkers      : require("search/ScrollTrackMarkers"),\r\n            UpdateNotification      : require("utils/UpdateNotification"),\r\n            WorkingSetView          : WorkingSetView,\r\n            doneLoading             : false\r\n        };\r\n\r\n        AppInit.appReady(function () {\r\n            brackets.test.doneLoading = true;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Setup Brackets\r\n     */\r\n    function _onReady() {\r\n        PerfUtils.addMeasurement("window.document Ready");\r\n\r\n        // Use quiet scrollbars if we aren\'t on Lion. If we\'re on Lion, only\r\n        // use native scroll bars when the mouse is not plugged in or when\r\n        // using the "Always" scroll bar setting. \r\n        var osxMatch = /Mac OS X 10\\D([\\d+])\\D/.exec(navigator.userAgent);\r\n        if (osxMatch && osxMatch[1] && Number(osxMatch[1]) >= 7) {\r\n            // test a scrolling div for scrollbars\r\n            var $testDiv = $("<div style=\'position:fixed;left:-50px;width:50px;height:50px;overflow:auto;\'><div style=\'width:100px;height:100px;\'/></div>").appendTo(window.document.body);\r\n            \r\n            if ($testDiv.outerWidth() === $testDiv.get(0).clientWidth) {\r\n                $(".sidebar").removeClass("quiet-scrollbars");\r\n            }\r\n            \r\n            $testDiv.remove();\r\n        }\r\n\r\n        // Load default languages and preferences\r\n        Async.waitForAll([LanguageManager.ready, PreferencesManager.ready]).always(function () {\r\n            // Load all extensions. This promise will complete even if one or more\r\n            // extensions fail to load.\r\n            var extensionPathOverride = params.get("extensions");  // used by unit tests\r\n            var extensionLoaderPromise = ExtensionLoader.init(extensionPathOverride ? extensionPathOverride.split(",") : null);\r\n            \r\n            // Load the initial project after extensions have loaded\r\n            extensionLoaderPromise.always(function () {\r\n               // Signal that extensions are loaded\r\n                AppInit._dispatchReady(AppInit.EXTENSIONS_LOADED);\r\n\r\n                // Finish UI initialization\r\n                ViewCommandHandlers.restoreFontSize();\r\n                var initialProjectPath = ProjectManager.getInitialProjectPath();\r\n                ProjectManager.openProject(initialProjectPath).always(function () {\r\n                    _initTest();\r\n                    \r\n                    // If this is the first launch, and we have an index.html file in the project folder (which should be\r\n                    // the samples folder on first launch), open it automatically. (We explicitly check for the\r\n                    // samples folder in case this is the first time we\'re launching Brackets after upgrading from\r\n                    // an old version that might not have set the "afterFirstLaunch" pref.)\r\n                    var deferred = new $.Deferred();\r\n                    \r\n                    if (!params.get("skipSampleProjectLoad") && !PreferencesManager.getViewState("afterFirstLaunch")) {\r\n                        PreferencesManager.setViewState("afterFirstLaunch", "true");\r\n                        if (ProjectManager.isWelcomeProjectPath(initialProjectPath)) {\r\n                            FileSystem.resolve(initialProjectPath + "index.html", function (err, file) {\r\n                                if (!err) {\r\n                                    var promise = CommandManager.execute(Commands.CMD_ADD_TO_WORKINGSET_AND_OPEN, { fullPath: file.fullPath });\r\n                                    promise.then(deferred.resolve, deferred.reject);\r\n                                } else {\r\n                                    deferred.reject();\r\n                                }\r\n                            });\r\n                        } else {\r\n                            deferred.resolve();\r\n                        }\r\n                    } else {\r\n                        deferred.resolve();\r\n                    }\r\n                    \r\n                    deferred.always(function () {\r\n                        // Signal that Brackets is loaded\r\n                        AppInit._dispatchReady(AppInit.APP_READY);\r\n                        \r\n                        PerfUtils.addMeasurement("Application Startup");\r\n                        \r\n                        if (PreferencesManager._isUserScopeCorrupt()) {\r\n                            Dialogs.showModalDialog(\r\n                                DefaultDialogs.DIALOG_ID_ERROR,\r\n                                Strings.ERROR_PREFS_CORRUPT_TITLE,\r\n                                Strings.ERROR_PREFS_CORRUPT\r\n                            )\r\n                                .done(function () {\r\n                                    CommandManager.execute(Commands.FILE_OPEN_PREFERENCES);\r\n                                });\r\n                        }\r\n                        \r\n                    });\r\n                    \r\n                    // See if any startup files were passed to the application\r\n                    if (brackets.app.getPendingFilesToOpen) {\r\n                        brackets.app.getPendingFilesToOpen(function (err, files) {\r\n                            DragAndDrop.openDroppedFiles(files);\r\n                        });\r\n                    }\r\n                });\r\n            });\r\n        });\r\n        \r\n        // Check for updates\r\n        if (!params.get("skipUpdateCheck") && !brackets.inBrowser) {\r\n            AppInit.appReady(function () {\r\n                // launches periodic checks for updates cca every 24 hours\r\n                UpdateNotification.launchAutomaticUpdate();\r\n            });\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Setup event handlers prior to dispatching AppInit.HTML_READY\r\n     */\r\n    function _beforeHTMLReady() {\r\n        // Add the platform (mac or win) to the body tag so we can have platform-specific CSS rules\r\n        $("body").addClass("platform-" + brackets.platform);\r\n        \r\n        // Browser-hosted version may also have different CSS (e.g. since \'#titlebar\' is shown)\r\n        if (brackets.inBrowser) {\r\n            $("body").addClass("in-browser");\r\n        } else {\r\n            $("body").addClass("in-appshell");\r\n        }\r\n\r\n        // Enable/Disable HTML Menus\r\n        if (brackets.nativeMenus) {\r\n            $("body").addClass("has-appshell-menus");\r\n        } else {\r\n            // (issue #5310) workaround for bootstrap dropdown: prevent the menu item to grab\r\n            // the focus -- override jquery focus implementation for top-level menu items\r\n            (function () {\r\n                var defaultFocus = $.fn.focus;\r\n                $.fn.focus = function () {\r\n                    if (!this.hasClass("dropdown-toggle")) {\r\n                        return defaultFocus.apply(this, arguments);\r\n                    }\r\n                };\r\n            }());\r\n        }\r\n        \r\n        // Localize MainViewHTML and inject into <BODY> tag\r\n        $("body").html(Mustache.render(MainViewHTML, Strings));\r\n        \r\n        // Update title\r\n        $("title").text(brackets.config.app_title);\r\n            \r\n        // Prevent unhandled drag and drop of files into the browser from replacing \r\n        // the entire Brackets app. This doesn\'t prevent children from choosing to\r\n        // handle drops.\r\n        $(window.document.body)\r\n            .on("dragover", function (event) {\r\n                var dropEffect = "none";\r\n                if (event.originalEvent.dataTransfer.files) {\r\n                    event.stopPropagation();\r\n                    event.preventDefault();\r\n                    // Don\'t allow drag-and-drop of files/folders when a modal dialog is showing.\r\n                    if ($(".modal.instance").length === 0 &&\r\n                            DragAndDrop.isValidDrop(event.originalEvent.dataTransfer.items)) {\r\n                        dropEffect = "copy";\r\n                    }\r\n                    event.originalEvent.dataTransfer.dropEffect = dropEffect;\r\n                }\r\n            })\r\n            .on("drop", function (event) {\r\n                if (event.originalEvent.dataTransfer.files) {\r\n                    event.stopPropagation();\r\n                    event.preventDefault();\r\n                    brackets.app.getDroppedFiles(function (err, files) {\r\n                        if (!err) {\r\n                            DragAndDrop.openDroppedFiles(files);\r\n                        }\r\n                    });\r\n                }\r\n            });\r\n        \r\n        // TODO: (issue 269) to support IE, need to listen to document instead (and even then it may not work when focus is in an input field?)\r\n        $(window).focus(function () {\r\n            // This call to syncOpenDocuments() *should* be a no-op now that we have\r\n            // file watchers, but is still here as a safety net.\r\n            FileSyncManager.syncOpenDocuments();\r\n        });\r\n        \r\n        // Prevent unhandled middle button clicks from triggering native behavior\r\n        // Example: activating AutoScroll (see #510)\r\n        $("html").on("mousedown", ".inline-widget", function (e) {\r\n            if (e.button === 1) {\r\n                e.preventDefault();\r\n            }\r\n        });\r\n        \r\n        // The .no-focus style is added to clickable elements that should\r\n        // not steal focus. Calling preventDefault() on mousedown prevents\r\n        // focus from going to the click target.\r\n        $("html").on("mousedown", ".no-focus", function (e) {\r\n            // Text fields should always be focusable.\r\n            var $target = $(e.target),\r\n                isFormElement =\r\n                    $target.is("input[type=text]") ||\r\n                    $target.is("input[type=number]") ||\r\n                    $target.is("input[type=password]") ||\r\n                    $target.is("input:not([type])") || // input with no type attribute defaults to text\r\n                    $target.is("textarea") ||\r\n                    $target.is("select");\r\n\r\n            if (!isFormElement) {\r\n                e.preventDefault();\r\n            }\r\n        });\r\n        \r\n        // Prevent clicks on any link from navigating to a different page (which could lose unsaved\r\n        // changes). We can\'t use a simple .on("click", "a") because of http://bugs.jquery.com/ticket/3861:\r\n        // jQuery hides non-left clicks from such event handlers, yet middle-clicks still cause CEF to\r\n        // navigate. Also, a capture handler is more reliable than bubble.\r\n        window.document.body.addEventListener("click", function (e) {\r\n            // Check parents too, in case link has inline formatting tags\r\n            var node = e.target, url;\r\n            while (node) {\r\n                if (node.tagName === "A") {\r\n                    url = node.getAttribute("href");\r\n                    if (url && !url.match(/^#/)) {\r\n                        NativeApp.openURLInDefaultBrowser(url);\r\n                    }\r\n                    e.preventDefault();\r\n                    break;\r\n                }\r\n                node = node.parentElement;\r\n            }\r\n        }, true);\r\n        \r\n        // Prevent extensions from using window.open() to insecurely load untrusted web content\r\n        var real_windowOpen = window.open;\r\n        window.open = function (url) {\r\n            // Allow file:// URLs, relative URLs (implicitly file: also), and about:blank\r\n            if (!url.match(/^file:\\/\\//) && url !== "about:blank" && url.indexOf(":") !== -1) {\r\n                throw new Error("Brackets-shell is not a secure general purpose web browser. Use NativeApp.openURLInDefaultBrowser() to open URLs in the user\'s main browser");\r\n            }\r\n            return real_windowOpen.apply(window, arguments);\r\n        };\r\n    }\r\n    \r\n    // Wait for view state to load.\r\n    var viewStateTimer = PerfUtils.markStart("User viewstate loading");\r\n    PreferencesManager._smUserScopeLoading.always(function () {\r\n        PerfUtils.addMeasurement(viewStateTimer);\r\n        // Dispatch htmlReady event\r\n        _beforeHTMLReady();\r\n        AppInit._dispatchReady(AppInit.HTML_READY);\r\n        $(window.document).ready(_onReady);\r\n    });\r\n});\r\n\n//# sourceURL=/brackets.js');

//# sourceMappingURL=main.js.map